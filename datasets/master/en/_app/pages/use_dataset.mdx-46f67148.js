import{S as Zt,i as sn,s as an,e as t,k as h,w as A,t as r,M as en,c as n,d as e,m,a as l,x as F,h as o,b as u,F as a,g as c,y as C,q as O,o as N,B as I,v as tn}from"../chunks/vendor-aa873a46.js";import{T as Xt}from"../chunks/Tip-f7f252ab.js";import{I as pa}from"../chunks/IconCopyLink-d0ca3106.js";import{C as ca}from"../chunks/CodeBlock-1f14baf3.js";function nn(bs){let i,w,d,j,v,f,S,k;return{c(){i=t("p"),w=r("Often times you may want to modify the structure and content of your dataset before you use it to train a model. For example, you may want to remove a column or cast it as a different type. \u{1F917} Datasets provides the necessary tools to do this, but since each dataset is so different, the processing approach will vary individually. For more detailed information about preprocessing data, take a look at our "),d=t("a"),j=r("guide"),v=r(" from the \u{1F917} Transformers library. Then come back and read our "),f=t("a"),S=r("How-to Process"),k=r(" guide to see all the different methods for processing your dataset."),this.h()},l($){i=n($,"P",{});var b=l(i);w=o(b,"Often times you may want to modify the structure and content of your dataset before you use it to train a model. For example, you may want to remove a column or cast it as a different type. \u{1F917} Datasets provides the necessary tools to do this, but since each dataset is so different, the processing approach will vary individually. For more detailed information about preprocessing data, take a look at our "),d=n(b,"A",{href:!0,rel:!0});var _=l(d);j=o(_,"guide"),_.forEach(e),v=o(b," from the \u{1F917} Transformers library. Then come back and read our "),f=n(b,"A",{href:!0});var L=l(f);S=o(L,"How-to Process"),L.forEach(e),k=o(b," guide to see all the different methods for processing your dataset."),b.forEach(e),this.h()},h(){u(d,"href","https://huggingface.co/transformers/preprocessing#"),u(d,"rel","nofollow"),u(f,"href","./process")},m($,b){c($,i,b),a(i,w),a(i,d),a(d,j),a(i,v),a(i,f),a(f,S),a(i,k)},d($){$&&e(i)}}}function ln(bs){let i,w,d,j,v,f,S,k,$,b,_,L,M;return{c(){i=t("p"),w=t("a"),d=r("Dataset.to_tf_dataset()"),j=r(" is the easiest way to create a TensorFlow compatible dataset. If you don\u2019t want a "),v=t("code"),f=r("tf.data.Dataset"),S=r(" and would rather the dataset emit "),k=t("code"),$=r("tf.Tensor"),b=r(" objects, take a look at the "),_=t("a"),L=r("format"),M=r(" section instead!"),this.h()},l(x){i=n(x,"P",{});var g=l(i);w=n(g,"A",{href:!0});var T=l(w);d=o(T,"Dataset.to_tf_dataset()"),T.forEach(e),j=o(g," is the easiest way to create a TensorFlow compatible dataset. If you don\u2019t want a "),v=n(g,"CODE",{});var B=l(v);f=o(B,"tf.data.Dataset"),B.forEach(e),S=o(g," and would rather the dataset emit "),k=n(g,"CODE",{});var K=l(k);$=o(K,"tf.Tensor"),K.forEach(e),b=o(g," objects, take a look at the "),_=n(g,"A",{href:!0});var q=l(_);L=o(q,"format"),q.forEach(e),M=o(g," section instead!"),g.forEach(e),this.h()},h(){u(w,"href","/docs/datasets/master/en/package_reference/main_classes#datasets.Dataset.to_tf_dataset"),u(_,"href","./process#format")},m(x,g){c(x,i,g),a(i,w),a(w,d),a(i,j),a(i,v),a(v,f),a(i,S),a(i,k),a(k,$),a(i,b),a(i,_),a(_,L),a(i,M)},d(x){x&&e(i)}}}function rn(bs){let i,w,d,j,v,f,S,k,$,b,_,L,M,x,g,T,B,K,q,qa,Ps,Ha,ia,js,Ra,ha,_s,Ya,ma,ls,ua,H,Ua,rs,Ga,Ma,os,Ka,Wa,da,ps,fa,W,Ja,Ds,Qa,Va,ba,cs,ja,E,Xa,As,Za,se,Fs,ae,ee,Cs,te,ne,_a,R,J,Os,is,le,Ns,re,ga,gs,oe,ya,Y,Q,Is,hs,pe,Ss,ce,wa,V,ie,ys,he,me,va,X,Bs,Z,Ls,ue,de,qs,fe,be,je,Hs,ws,Rs,_e,ge,ka,ss,ye,Ys,we,ve,xa,ms,$a,U,as,Us,us,ke,Gs,xe,Ta,y,$e,vs,Te,Ee,Ms,ze,Pe,Ks,De,Ae,Ws,Fe,Ce,ks,Oe,Ne,Ea,z,Js,xs,Qs,Ie,Se,Be,Vs,$s,Xs,Le,qe,He,Zs,Ts,sa,Re,Ye,Ue,aa,P,ea,Ge,Me,ta,Ke,We,na,Je,Qe,la,Ve,Xe,za,ds,Pa,es,Da,Es,Ze,Aa;return f=new pa({}),x=new Xt({props:{warning:!0,$$slots:{default:[nn]},$$scope:{ctx:bs}}}),q=new pa({}),ls=new ca({props:{code:"pip install transformers",highlighted:'pip <span class="hljs-keyword">install</span> transformers'}}),ps=new ca({props:{code:`from transformers import BertTokenizerFast
tokenizer = BertTokenizerFast.from_pretrained('bert-base-cased')`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertTokenizerFast
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = BertTokenizerFast.from_pretrained(<span class="hljs-string">&#x27;bert-base-cased&#x27;</span>)`}}),cs=new ca({props:{code:`encoded_dataset = dataset.map(lambda examples: tokenizer(examples['sentence1']), batched=True)
encoded_dataset.column_names
encoded_dataset[0]`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>encoded_dataset = dataset.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> examples: tokenizer(examples[<span class="hljs-string">&#x27;sentence1&#x27;</span>]), batched=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>encoded_dataset.column_names
[<span class="hljs-string">&#x27;sentence1&#x27;</span>, <span class="hljs-string">&#x27;sentence2&#x27;</span>, <span class="hljs-string">&#x27;label&#x27;</span>, <span class="hljs-string">&#x27;idx&#x27;</span>, <span class="hljs-string">&#x27;input_ids&#x27;</span>, <span class="hljs-string">&#x27;token_type_ids&#x27;</span>, <span class="hljs-string">&#x27;attention_mask&#x27;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>encoded_dataset[<span class="hljs-number">0</span>]
{<span class="hljs-string">&#x27;sentence1&#x27;</span>: <span class="hljs-string">&#x27;Amrozi accused his brother , whom he called &quot; the witness &quot; , of deliberately distorting his evidence .&#x27;</span>,
<span class="hljs-string">&#x27;sentence2&#x27;</span>: <span class="hljs-string">&#x27;Referring to him as only &quot; the witness &quot; , Amrozi accused his brother of deliberately distorting his evidence .&#x27;</span>,
<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-number">1</span>,
<span class="hljs-string">&#x27;idx&#x27;</span>: <span class="hljs-number">0</span>,
<span class="hljs-string">&#x27;input_ids&#x27;</span>: [  <span class="hljs-number">101</span>,  <span class="hljs-number">7277</span>,  <span class="hljs-number">2180</span>,  <span class="hljs-number">5303</span>,  <span class="hljs-number">4806</span>,  <span class="hljs-number">1117</span>,  <span class="hljs-number">1711</span>,   <span class="hljs-number">117</span>,  <span class="hljs-number">2292</span>, <span class="hljs-number">1119</span>,  <span class="hljs-number">1270</span>,   <span class="hljs-number">107</span>,  <span class="hljs-number">1103</span>,  <span class="hljs-number">7737</span>,   <span class="hljs-number">107</span>,   <span class="hljs-number">117</span>,  <span class="hljs-number">1104</span>,  <span class="hljs-number">9938</span>, <span class="hljs-number">4267</span>, <span class="hljs-number">12223</span>, <span class="hljs-number">21811</span>,  <span class="hljs-number">1117</span>,  <span class="hljs-number">2554</span>,   <span class="hljs-number">119</span>,   <span class="hljs-number">102</span>],
<span class="hljs-string">&#x27;token_type_ids&#x27;</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
<span class="hljs-string">&#x27;attention_mask&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
}`}}),is=new pa({}),hs=new pa({}),ms=new ca({props:{code:`import torch
from datasets import load_dataset
from transformers import AutoTokenizer
dataset = load_dataset('glue', 'mrpc', split='train')
tokenizer = AutoTokenizer.from_pretrained('bert-base-cased')
dataset = dataset.map(lambda e: tokenizer(e['sentence1'], truncation=True, padding='max_length'), batched=True)
dataset.set_format(type='torch', columns=['input_ids', 'token_type_ids', 'attention_mask', 'label'])
dataloader = torch.utils.data.DataLoader(dataset, batch_size=32)
next(iter(dataloader))`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&#x27;glue&#x27;</span>, <span class="hljs-string">&#x27;mrpc&#x27;</span>, split=<span class="hljs-string">&#x27;train&#x27;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&#x27;bert-base-cased&#x27;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = dataset.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> e: tokenizer(e[<span class="hljs-string">&#x27;sentence1&#x27;</span>], truncation=<span class="hljs-literal">True</span>, padding=<span class="hljs-string">&#x27;max_length&#x27;</span>), batched=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>dataset.set_format(<span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;torch&#x27;</span>, columns=[<span class="hljs-string">&#x27;input_ids&#x27;</span>, <span class="hljs-string">&#x27;token_type_ids&#x27;</span>, <span class="hljs-string">&#x27;attention_mask&#x27;</span>, <span class="hljs-string">&#x27;label&#x27;</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>dataloader = torch.utils.data.DataLoader(dataset, batch_size=<span class="hljs-number">32</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(dataloader))
{<span class="hljs-string">&#x27;attention_mask&#x27;</span>: tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>,  ..., <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
                         ...,
                         [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>,  ..., <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]),
<span class="hljs-string">&#x27;input_ids&#x27;</span>: tensor([[  <span class="hljs-number">101</span>,  <span class="hljs-number">7277</span>,  <span class="hljs-number">2180</span>,  ...,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>],
                    ...,
                    [  <span class="hljs-number">101</span>,  <span class="hljs-number">1109</span>,  <span class="hljs-number">4173</span>,  ...,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>]]),
<span class="hljs-string">&#x27;label&#x27;</span>: tensor([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]),
<span class="hljs-string">&#x27;token_type_ids&#x27;</span>: tensor([[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,  ..., <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
                         ...,
                         [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,  ..., <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]])}`}}),us=new pa({}),ds=new ca({props:{code:`import tensorflow as tf
from datasets import load_dataset
from transformers import AutoTokenizer
dataset = load_dataset('glue', 'mrpc', split='train')
tokenizer = AutoTokenizer.from_pretrained('bert-base-cased')
dataset = dataset.map(lambda e: tokenizer(e['sentence1'], truncation=True, padding='max_length'), batched=True)
data_collator = DataCollatorWithPadding(tokenizer=tokenizer, return_tensors="tf")
train_dataset = dataset["train"].to_tf_dataset(
  columns=['input_ids', 'token_type_ids', 'attention_mask', 'label'],
  shuffle=True,
  batch_size=16,
  collate_fn=data_collator,
)
model.fit(train_dataset)  # The output tf.data.Dataset is ready for training immediately
next(iter(train_dataset))  # You can also iterate over the dataset manually to get batches`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&#x27;glue&#x27;</span>, <span class="hljs-string">&#x27;mrpc&#x27;</span>, split=<span class="hljs-string">&#x27;train&#x27;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&#x27;bert-base-cased&#x27;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = dataset.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> e: tokenizer(e[<span class="hljs-string">&#x27;sentence1&#x27;</span>], truncation=<span class="hljs-literal">True</span>, padding=<span class="hljs-string">&#x27;max_length&#x27;</span>), batched=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>data_collator = DataCollatorWithPadding(tokenizer=tokenizer, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>train_dataset = dataset[<span class="hljs-string">&quot;train&quot;</span>].to_tf_dataset(
<span class="hljs-meta">... </span>  columns=[<span class="hljs-string">&#x27;input_ids&#x27;</span>, <span class="hljs-string">&#x27;token_type_ids&#x27;</span>, <span class="hljs-string">&#x27;attention_mask&#x27;</span>, <span class="hljs-string">&#x27;label&#x27;</span>],
<span class="hljs-meta">... </span>  shuffle=<span class="hljs-literal">True</span>,
<span class="hljs-meta">... </span>  batch_size=<span class="hljs-number">16</span>,
<span class="hljs-meta">... </span>  collate_fn=data_collator,
<span class="hljs-meta">... </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model.fit(train_dataset)  <span class="hljs-comment"># The output tf.data.Dataset is ready for training immediately</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(train_dataset))  <span class="hljs-comment"># You can also iterate over the dataset manually to get batches</span>
{<span class="hljs-string">&#x27;attention_mask&#x27;</span>: &lt;tf.Tensor: shape=(<span class="hljs-number">16</span>, <span class="hljs-number">512</span>), dtype=int64, numpy=
 array([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, ..., <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
      ...,
      [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, ..., <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]])&gt;,
 <span class="hljs-string">&#x27;input_ids&#x27;</span>: &lt;tf.Tensor: shape=(<span class="hljs-number">16</span>, <span class="hljs-number">512</span>), dtype=int64, numpy=
  array([[  <span class="hljs-number">101</span>, <span class="hljs-number">11336</span>, <span class="hljs-number">11154</span>, ...,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>],
      ..., 
      [  <span class="hljs-number">101</span>,   <span class="hljs-number">156</span>, <span class="hljs-number">22705</span>, ...,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>]])&gt;,
 <span class="hljs-string">&#x27;labels&#x27;</span>: &lt;tf.Tensor: shape=(<span class="hljs-number">16</span>,), dtype=int64, numpy=
  array([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>])&gt;,
 <span class="hljs-string">&#x27;token_type_ids&#x27;</span>: &lt;tf.Tensor: shape=(<span class="hljs-number">16</span>, <span class="hljs-number">512</span>), dtype=int64, numpy=
  array([[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, ..., <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
       ...,
      [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, ..., <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]])&gt;
}`}}),es=new Xt({props:{$$slots:{default:[ln]},$$scope:{ctx:bs}}}),{c(){i=t("meta"),w=h(),d=t("h1"),j=t("a"),v=t("span"),A(f.$$.fragment),S=h(),k=t("span"),$=r("Train with \u{1F917} Datasets"),b=h(),_=t("p"),L=r("So far, you loaded a dataset from the Hugging Face Hub and learned how to access the information stored inside the dataset. Now you will tokenize and use your dataset with a framework such as PyTorch or TensorFlow. By default, all the dataset columns are returned as Python objects. But you can bridge the gap between a Python object and your machine learning framework by setting the format of a dataset. Formatting casts the columns into compatible PyTorch or TensorFlow types."),M=h(),A(x.$$.fragment),g=h(),T=t("h2"),B=t("a"),K=t("span"),A(q.$$.fragment),qa=h(),Ps=t("span"),Ha=r("Tokenize"),ia=h(),js=t("p"),Ra=r("Tokenization divides text into individual words called tokens. Tokens are converted into numbers, which is what the model receives as its input."),ha=h(),_s=t("p"),Ya=r("The first step is to install the \u{1F917} Transformers library:"),ma=h(),A(ls.$$.fragment),ua=h(),H=t("p"),Ua=r("Next, import a tokenizer. It is important to use the tokenizer that is associated with the model you are using, so the text is split in the same way. In this example, load the "),rs=t("a"),Ga=r("BERT tokenizer"),Ma=r(" because you are using the "),os=t("a"),Ka=r("BERT"),Wa=r(" model:"),da=h(),A(ps.$$.fragment),fa=h(),W=t("p"),Ja=r("Now you can tokenize "),Ds=t("code"),Qa=r("sentence1"),Va=r(" field of the dataset:"),ba=h(),A(cs.$$.fragment),ja=h(),E=t("p"),Xa=r("The tokenization process creates three new columns: "),As=t("code"),Za=r("input_ids"),se=r(", "),Fs=t("code"),ae=r("token_type_ids"),ee=r(", and "),Cs=t("code"),te=r("attention_mask"),ne=r(". These are the inputs to the model."),_a=h(),R=t("h2"),J=t("a"),Os=t("span"),A(is.$$.fragment),le=h(),Ns=t("span"),re=r("Use in PyTorch or TensorFlow"),ga=h(),gs=t("p"),oe=r("Next, format the dataset into compatible PyTorch or TensorFlow types."),ya=h(),Y=t("h3"),Q=t("a"),Is=t("span"),A(hs.$$.fragment),pe=h(),Ss=t("span"),ce=r("PyTorch"),wa=h(),V=t("p"),ie=r("If you are using PyTorch, set the format with "),ys=t("a"),he=r("Dataset.set_format()"),me=r(", which accepts two main arguments:"),va=h(),X=t("ol"),Bs=t("li"),Z=t("p"),Ls=t("code"),ue=r("type"),de=r(" defines the type of column to cast to. For example, "),qs=t("code"),fe=r("torch"),be=r(" returns PyTorch tensors."),je=h(),Hs=t("li"),ws=t("p"),Rs=t("code"),_e=r("columns"),ge=r(" specify which columns should be formatted."),ka=h(),ss=t("p"),ye=r("After you set the format, wrap the dataset with "),Ys=t("code"),we=r("torch.utils.data.DataLoader"),ve=r(". Your dataset is now ready for use in a training loop!"),xa=h(),A(ms.$$.fragment),$a=h(),U=t("h3"),as=t("a"),Us=t("span"),A(us.$$.fragment),ke=h(),Gs=t("span"),xe=r("TensorFlow"),Ta=h(),y=t("p"),$e=r("If you are using TensorFlow, you can use "),vs=t("a"),Te=r("Dataset.to_tf_dataset()"),Ee=r(" to wrap the dataset with a "),Ms=t("strong"),ze=r("tf.data.Dataset"),Pe=r(`, which is natively understood by Keras.
This means a `),Ks=t("strong"),De=r("tf.data.Dataset"),Ae=r(" object can be iterated over to yield batches of data, and can be passed directly to methods like "),Ws=t("strong"),Fe=r("model.fit()"),Ce=r(`.
`),ks=t("a"),Oe=r("Dataset.to_tf_dataset()"),Ne=r(" accepts several arguments:"),Ea=h(),z=t("ol"),Js=t("li"),xs=t("p"),Qs=t("code"),Ie=r("columns"),Se=r(" specify which columns should be formatted (includes the inputs and labels)."),Be=h(),Vs=t("li"),$s=t("p"),Xs=t("code"),Le=r("shuffle"),qe=r(" determines whether the dataset should be shuffled."),He=h(),Zs=t("li"),Ts=t("p"),sa=t("code"),Re=r("batch_size"),Ye=r(" specifies the batch size."),Ue=h(),aa=t("li"),P=t("p"),ea=t("code"),Ge=r("collate_fn"),Me=r(" specifies a data collator that will batch each processed example and apply padding. If you are using a "),ta=t("code"),Ke=r("DataCollator"),We=r(", make sure you set "),na=t("code"),Je=r('return_tensors="tf"'),Qe=r(" when you initialize it to return "),la=t("code"),Ve=r("tf.Tensor"),Xe=r(" outputs."),za=h(),A(ds.$$.fragment),Pa=h(),A(es.$$.fragment),Da=h(),Es=t("p"),Ze=r("Your dataset is now ready for use in a training loop!"),this.h()},l(s){const p=en('[data-svelte="svelte-1phssyn"]',document.head);i=n(p,"META",{name:!0,content:!0}),p.forEach(e),w=m(s),d=n(s,"H1",{class:!0});var fs=l(d);j=n(fs,"A",{id:!0,class:!0,href:!0});var ra=l(j);v=n(ra,"SPAN",{});var nt=l(v);F(f.$$.fragment,nt),nt.forEach(e),ra.forEach(e),S=m(fs),k=n(fs,"SPAN",{});var lt=l(k);$=o(lt,"Train with \u{1F917} Datasets"),lt.forEach(e),fs.forEach(e),b=m(s),_=n(s,"P",{});var rt=l(_);L=o(rt,"So far, you loaded a dataset from the Hugging Face Hub and learned how to access the information stored inside the dataset. Now you will tokenize and use your dataset with a framework such as PyTorch or TensorFlow. By default, all the dataset columns are returned as Python objects. But you can bridge the gap between a Python object and your machine learning framework by setting the format of a dataset. Formatting casts the columns into compatible PyTorch or TensorFlow types."),rt.forEach(e),M=m(s),F(x.$$.fragment,s),g=m(s),T=n(s,"H2",{class:!0});var Fa=l(T);B=n(Fa,"A",{id:!0,class:!0,href:!0});var ot=l(B);K=n(ot,"SPAN",{});var pt=l(K);F(q.$$.fragment,pt),pt.forEach(e),ot.forEach(e),qa=m(Fa),Ps=n(Fa,"SPAN",{});var ct=l(Ps);Ha=o(ct,"Tokenize"),ct.forEach(e),Fa.forEach(e),ia=m(s),js=n(s,"P",{});var it=l(js);Ra=o(it,"Tokenization divides text into individual words called tokens. Tokens are converted into numbers, which is what the model receives as its input."),it.forEach(e),ha=m(s),_s=n(s,"P",{});var ht=l(_s);Ya=o(ht,"The first step is to install the \u{1F917} Transformers library:"),ht.forEach(e),ma=m(s),F(ls.$$.fragment,s),ua=m(s),H=n(s,"P",{});var zs=l(H);Ua=o(zs,"Next, import a tokenizer. It is important to use the tokenizer that is associated with the model you are using, so the text is split in the same way. In this example, load the "),rs=n(zs,"A",{href:!0,rel:!0});var mt=l(rs);Ga=o(mt,"BERT tokenizer"),mt.forEach(e),Ma=o(zs," because you are using the "),os=n(zs,"A",{href:!0,rel:!0});var ut=l(os);Ka=o(ut,"BERT"),ut.forEach(e),Wa=o(zs," model:"),zs.forEach(e),da=m(s),F(ps.$$.fragment,s),fa=m(s),W=n(s,"P",{});var Ca=l(W);Ja=o(Ca,"Now you can tokenize "),Ds=n(Ca,"CODE",{});var dt=l(Ds);Qa=o(dt,"sentence1"),dt.forEach(e),Va=o(Ca," field of the dataset:"),Ca.forEach(e),ba=m(s),F(cs.$$.fragment,s),ja=m(s),E=n(s,"P",{});var ts=l(E);Xa=o(ts,"The tokenization process creates three new columns: "),As=n(ts,"CODE",{});var ft=l(As);Za=o(ft,"input_ids"),ft.forEach(e),se=o(ts,", "),Fs=n(ts,"CODE",{});var bt=l(Fs);ae=o(bt,"token_type_ids"),bt.forEach(e),ee=o(ts,", and "),Cs=n(ts,"CODE",{});var jt=l(Cs);te=o(jt,"attention_mask"),jt.forEach(e),ne=o(ts,". These are the inputs to the model."),ts.forEach(e),_a=m(s),R=n(s,"H2",{class:!0});var Oa=l(R);J=n(Oa,"A",{id:!0,class:!0,href:!0});var _t=l(J);Os=n(_t,"SPAN",{});var gt=l(Os);F(is.$$.fragment,gt),gt.forEach(e),_t.forEach(e),le=m(Oa),Ns=n(Oa,"SPAN",{});var yt=l(Ns);re=o(yt,"Use in PyTorch or TensorFlow"),yt.forEach(e),Oa.forEach(e),ga=m(s),gs=n(s,"P",{});var wt=l(gs);oe=o(wt,"Next, format the dataset into compatible PyTorch or TensorFlow types."),wt.forEach(e),ya=m(s),Y=n(s,"H3",{class:!0});var Na=l(Y);Q=n(Na,"A",{id:!0,class:!0,href:!0});var vt=l(Q);Is=n(vt,"SPAN",{});var kt=l(Is);F(hs.$$.fragment,kt),kt.forEach(e),vt.forEach(e),pe=m(Na),Ss=n(Na,"SPAN",{});var xt=l(Ss);ce=o(xt,"PyTorch"),xt.forEach(e),Na.forEach(e),wa=m(s),V=n(s,"P",{});var Ia=l(V);ie=o(Ia,"If you are using PyTorch, set the format with "),ys=n(Ia,"A",{href:!0});var $t=l(ys);he=o($t,"Dataset.set_format()"),$t.forEach(e),me=o(Ia,", which accepts two main arguments:"),Ia.forEach(e),va=m(s),X=n(s,"OL",{});var Sa=l(X);Bs=n(Sa,"LI",{});var Tt=l(Bs);Z=n(Tt,"P",{});var oa=l(Z);Ls=n(oa,"CODE",{});var Et=l(Ls);ue=o(Et,"type"),Et.forEach(e),de=o(oa," defines the type of column to cast to. For example, "),qs=n(oa,"CODE",{});var zt=l(qs);fe=o(zt,"torch"),zt.forEach(e),be=o(oa," returns PyTorch tensors."),oa.forEach(e),Tt.forEach(e),je=m(Sa),Hs=n(Sa,"LI",{});var Pt=l(Hs);ws=n(Pt,"P",{});var st=l(ws);Rs=n(st,"CODE",{});var Dt=l(Rs);_e=o(Dt,"columns"),Dt.forEach(e),ge=o(st," specify which columns should be formatted."),st.forEach(e),Pt.forEach(e),Sa.forEach(e),ka=m(s),ss=n(s,"P",{});var Ba=l(ss);ye=o(Ba,"After you set the format, wrap the dataset with "),Ys=n(Ba,"CODE",{});var At=l(Ys);we=o(At,"torch.utils.data.DataLoader"),At.forEach(e),ve=o(Ba,". Your dataset is now ready for use in a training loop!"),Ba.forEach(e),xa=m(s),F(ms.$$.fragment,s),$a=m(s),U=n(s,"H3",{class:!0});var La=l(U);as=n(La,"A",{id:!0,class:!0,href:!0});var Ft=l(as);Us=n(Ft,"SPAN",{});var Ct=l(Us);F(us.$$.fragment,Ct),Ct.forEach(e),Ft.forEach(e),ke=m(La),Gs=n(La,"SPAN",{});var Ot=l(Gs);xe=o(Ot,"TensorFlow"),Ot.forEach(e),La.forEach(e),Ta=m(s),y=n(s,"P",{});var D=l(y);$e=o(D,"If you are using TensorFlow, you can use "),vs=n(D,"A",{href:!0});var Nt=l(vs);Te=o(Nt,"Dataset.to_tf_dataset()"),Nt.forEach(e),Ee=o(D," to wrap the dataset with a "),Ms=n(D,"STRONG",{});var It=l(Ms);ze=o(It,"tf.data.Dataset"),It.forEach(e),Pe=o(D,`, which is natively understood by Keras.
This means a `),Ks=n(D,"STRONG",{});var St=l(Ks);De=o(St,"tf.data.Dataset"),St.forEach(e),Ae=o(D," object can be iterated over to yield batches of data, and can be passed directly to methods like "),Ws=n(D,"STRONG",{});var Bt=l(Ws);Fe=o(Bt,"model.fit()"),Bt.forEach(e),Ce=o(D,`.
`),ks=n(D,"A",{href:!0});var Lt=l(ks);Oe=o(Lt,"Dataset.to_tf_dataset()"),Lt.forEach(e),Ne=o(D," accepts several arguments:"),D.forEach(e),Ea=m(s),z=n(s,"OL",{});var ns=l(z);Js=n(ns,"LI",{});var qt=l(Js);xs=n(qt,"P",{});var at=l(xs);Qs=n(at,"CODE",{});var Ht=l(Qs);Ie=o(Ht,"columns"),Ht.forEach(e),Se=o(at," specify which columns should be formatted (includes the inputs and labels)."),at.forEach(e),qt.forEach(e),Be=m(ns),Vs=n(ns,"LI",{});var Rt=l(Vs);$s=n(Rt,"P",{});var et=l($s);Xs=n(et,"CODE",{});var Yt=l(Xs);Le=o(Yt,"shuffle"),Yt.forEach(e),qe=o(et," determines whether the dataset should be shuffled."),et.forEach(e),Rt.forEach(e),He=m(ns),Zs=n(ns,"LI",{});var Ut=l(Zs);Ts=n(Ut,"P",{});var tt=l(Ts);sa=n(tt,"CODE",{});var Gt=l(sa);Re=o(Gt,"batch_size"),Gt.forEach(e),Ye=o(tt," specifies the batch size."),tt.forEach(e),Ut.forEach(e),Ue=m(ns),aa=n(ns,"LI",{});var Mt=l(aa);P=n(Mt,"P",{});var G=l(P);ea=n(G,"CODE",{});var Kt=l(ea);Ge=o(Kt,"collate_fn"),Kt.forEach(e),Me=o(G," specifies a data collator that will batch each processed example and apply padding. If you are using a "),ta=n(G,"CODE",{});var Wt=l(ta);Ke=o(Wt,"DataCollator"),Wt.forEach(e),We=o(G,", make sure you set "),na=n(G,"CODE",{});var Jt=l(na);Je=o(Jt,'return_tensors="tf"'),Jt.forEach(e),Qe=o(G," when you initialize it to return "),la=n(G,"CODE",{});var Qt=l(la);Ve=o(Qt,"tf.Tensor"),Qt.forEach(e),Xe=o(G," outputs."),G.forEach(e),Mt.forEach(e),ns.forEach(e),za=m(s),F(ds.$$.fragment,s),Pa=m(s),F(es.$$.fragment,s),Da=m(s),Es=n(s,"P",{});var Vt=l(Es);Ze=o(Vt,"Your dataset is now ready for use in a training loop!"),Vt.forEach(e),this.h()},h(){u(i,"name","hf:doc:metadata"),u(i,"content",JSON.stringify(on)),u(j,"id","train-with-datasets"),u(j,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(j,"href","#train-with-datasets"),u(d,"class","relative group"),u(B,"id","tokenize"),u(B,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(B,"href","#tokenize"),u(T,"class","relative group"),u(rs,"href","https://huggingface.co/transformers/model_doc/bert#berttokenizerfast"),u(rs,"rel","nofollow"),u(os,"href","https://huggingface.co/bert-base-cased"),u(os,"rel","nofollow"),u(J,"id","use-in-pytorch-or-tensorflow"),u(J,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(J,"href","#use-in-pytorch-or-tensorflow"),u(R,"class","relative group"),u(Q,"id","pytorch"),u(Q,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Q,"href","#pytorch"),u(Y,"class","relative group"),u(ys,"href","/docs/datasets/master/en/package_reference/main_classes#datasets.Dataset.set_format"),u(as,"id","tensorflow"),u(as,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(as,"href","#tensorflow"),u(U,"class","relative group"),u(vs,"href","/docs/datasets/master/en/package_reference/main_classes#datasets.Dataset.to_tf_dataset"),u(ks,"href","/docs/datasets/master/en/package_reference/main_classes#datasets.Dataset.to_tf_dataset")},m(s,p){a(document.head,i),c(s,w,p),c(s,d,p),a(d,j),a(j,v),C(f,v,null),a(d,S),a(d,k),a(k,$),c(s,b,p),c(s,_,p),a(_,L),c(s,M,p),C(x,s,p),c(s,g,p),c(s,T,p),a(T,B),a(B,K),C(q,K,null),a(T,qa),a(T,Ps),a(Ps,Ha),c(s,ia,p),c(s,js,p),a(js,Ra),c(s,ha,p),c(s,_s,p),a(_s,Ya),c(s,ma,p),C(ls,s,p),c(s,ua,p),c(s,H,p),a(H,Ua),a(H,rs),a(rs,Ga),a(H,Ma),a(H,os),a(os,Ka),a(H,Wa),c(s,da,p),C(ps,s,p),c(s,fa,p),c(s,W,p),a(W,Ja),a(W,Ds),a(Ds,Qa),a(W,Va),c(s,ba,p),C(cs,s,p),c(s,ja,p),c(s,E,p),a(E,Xa),a(E,As),a(As,Za),a(E,se),a(E,Fs),a(Fs,ae),a(E,ee),a(E,Cs),a(Cs,te),a(E,ne),c(s,_a,p),c(s,R,p),a(R,J),a(J,Os),C(is,Os,null),a(R,le),a(R,Ns),a(Ns,re),c(s,ga,p),c(s,gs,p),a(gs,oe),c(s,ya,p),c(s,Y,p),a(Y,Q),a(Q,Is),C(hs,Is,null),a(Y,pe),a(Y,Ss),a(Ss,ce),c(s,wa,p),c(s,V,p),a(V,ie),a(V,ys),a(ys,he),a(V,me),c(s,va,p),c(s,X,p),a(X,Bs),a(Bs,Z),a(Z,Ls),a(Ls,ue),a(Z,de),a(Z,qs),a(qs,fe),a(Z,be),a(X,je),a(X,Hs),a(Hs,ws),a(ws,Rs),a(Rs,_e),a(ws,ge),c(s,ka,p),c(s,ss,p),a(ss,ye),a(ss,Ys),a(Ys,we),a(ss,ve),c(s,xa,p),C(ms,s,p),c(s,$a,p),c(s,U,p),a(U,as),a(as,Us),C(us,Us,null),a(U,ke),a(U,Gs),a(Gs,xe),c(s,Ta,p),c(s,y,p),a(y,$e),a(y,vs),a(vs,Te),a(y,Ee),a(y,Ms),a(Ms,ze),a(y,Pe),a(y,Ks),a(Ks,De),a(y,Ae),a(y,Ws),a(Ws,Fe),a(y,Ce),a(y,ks),a(ks,Oe),a(y,Ne),c(s,Ea,p),c(s,z,p),a(z,Js),a(Js,xs),a(xs,Qs),a(Qs,Ie),a(xs,Se),a(z,Be),a(z,Vs),a(Vs,$s),a($s,Xs),a(Xs,Le),a($s,qe),a(z,He),a(z,Zs),a(Zs,Ts),a(Ts,sa),a(sa,Re),a(Ts,Ye),a(z,Ue),a(z,aa),a(aa,P),a(P,ea),a(ea,Ge),a(P,Me),a(P,ta),a(ta,Ke),a(P,We),a(P,na),a(na,Je),a(P,Qe),a(P,la),a(la,Ve),a(P,Xe),c(s,za,p),C(ds,s,p),c(s,Pa,p),C(es,s,p),c(s,Da,p),c(s,Es,p),a(Es,Ze),Aa=!0},p(s,[p]){const fs={};p&2&&(fs.$$scope={dirty:p,ctx:s}),x.$set(fs);const ra={};p&2&&(ra.$$scope={dirty:p,ctx:s}),es.$set(ra)},i(s){Aa||(O(f.$$.fragment,s),O(x.$$.fragment,s),O(q.$$.fragment,s),O(ls.$$.fragment,s),O(ps.$$.fragment,s),O(cs.$$.fragment,s),O(is.$$.fragment,s),O(hs.$$.fragment,s),O(ms.$$.fragment,s),O(us.$$.fragment,s),O(ds.$$.fragment,s),O(es.$$.fragment,s),Aa=!0)},o(s){N(f.$$.fragment,s),N(x.$$.fragment,s),N(q.$$.fragment,s),N(ls.$$.fragment,s),N(ps.$$.fragment,s),N(cs.$$.fragment,s),N(is.$$.fragment,s),N(hs.$$.fragment,s),N(ms.$$.fragment,s),N(us.$$.fragment,s),N(ds.$$.fragment,s),N(es.$$.fragment,s),Aa=!1},d(s){e(i),s&&e(w),s&&e(d),I(f),s&&e(b),s&&e(_),s&&e(M),I(x,s),s&&e(g),s&&e(T),I(q),s&&e(ia),s&&e(js),s&&e(ha),s&&e(_s),s&&e(ma),I(ls,s),s&&e(ua),s&&e(H),s&&e(da),I(ps,s),s&&e(fa),s&&e(W),s&&e(ba),I(cs,s),s&&e(ja),s&&e(E),s&&e(_a),s&&e(R),I(is),s&&e(ga),s&&e(gs),s&&e(ya),s&&e(Y),I(hs),s&&e(wa),s&&e(V),s&&e(va),s&&e(X),s&&e(ka),s&&e(ss),s&&e(xa),I(ms,s),s&&e($a),s&&e(U),I(us),s&&e(Ta),s&&e(y),s&&e(Ea),s&&e(z),s&&e(za),I(ds,s),s&&e(Pa),I(es,s),s&&e(Da),s&&e(Es)}}}const on={local:"train-with-datasets",sections:[{local:"tokenize",title:"Tokenize"},{local:"use-in-pytorch-or-tensorflow",sections:[{local:"pytorch",title:"PyTorch"},{local:"tensorflow",title:"TensorFlow"}],title:"Use in PyTorch or TensorFlow"}],title:"Train with \u{1F917} Datasets"};function pn(bs){return tn(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class dn extends Zt{constructor(i){super();sn(this,i,pn,rn,an,{})}}export{dn as default,on as metadata};
