import{S as f2,i as y2,s as v2,e as r,k as s,w as p,t as d,M as $2,c as o,d as a,m as l,a as n,x as m,h as c,b as i,G as e,g as I,y as b,q as h,o as u,B as g,v as _2,L as T2}from"../../chunks/vendor-hf-doc-builder.js";import{D as f}from"../../chunks/Docstring-hf-doc-builder.js";import{C as w2}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as No}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{E as x2}from"../../chunks/ExampleCodeBlock-hf-doc-builder.js";function E2(wl){let D,oe,P,C,A;return C=new w2({props:{code:`import pandas as pd
import pyarrow as pa
df = pd.DataFrame({
pa.Table.from_pandas(df)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> pyarrow <span class="hljs-keyword">as</span> pa
<span class="hljs-meta">&gt;&gt;&gt; </span>df = pd.DataFrame({
    ...     <span class="hljs-string">&#x27;int&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],
    ...     <span class="hljs-string">&#x27;str&#x27;</span>: [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]
    ... })
<span class="hljs-meta">&gt;&gt;&gt; </span>pa.Table.from_pandas(df)
&lt;pyarrow.lib.Table <span class="hljs-built_in">object</span> at <span class="hljs-number">0x7f05d1fb1b40</span>&gt;`}}),{c(){D=r("p"),oe=d("Examples:"),P=s(),p(C.$$.fragment)},l(M){D=o(M,"P",{});var N=n(D);oe=c(N,"Examples:"),N.forEach(a),P=l(M),m(C.$$.fragment,M)},m(M,N){I(M,D,N),e(D,oe),I(M,P,N),b(C,M,N),A=!0},p:T2,i(M){A||(h(C.$$.fragment,M),A=!0)},o(M){u(C.$$.fragment,M),A=!1},d(M){M&&a(D),M&&a(P),g(C,M)}}}function k2(wl){let D,oe,P,C,A,M,N,jo,Cc,xl,j,Pc,Fo,Lc,Ac,io,Nc,jc,El,J,ne,Vo,zt,Fc,So,Vc,kl,x,Bt,Sc,qo,qc,Rc,Ro,Uc,zc,Uo,Bc,Oc,F,Ot,Wc,zo,Xc,Hc,Wt,Kc,Bo,Yc,Gc,Jc,se,Xt,Qc,Oo,Zc,ei,le,Ht,ti,Wo,ai,ri,de,Kt,oi,Xo,ni,si,ce,Yt,li,Ho,di,ci,po,Gt,ii,ie,Jt,pi,Ko,mi,bi,pe,Qt,hi,Yo,ui,gi,me,Zt,fi,Go,yi,vi,be,ea,$i,Jo,_i,Ti,he,ta,wi,Qo,xi,Ei,ue,aa,ki,Zo,Ii,Mi,V,ra,Di,en,Ci,Pi,tn,Li,Ai,ge,oa,Ni,an,ji,Fi,fe,na,Vi,rn,Si,Il,Q,ye,on,sa,qi,nn,Ri,Ml,y,la,Ui,sn,zi,Bi,ln,Oi,Wi,dn,Xi,Hi,cn,Ki,Yi,S,da,Gi,pn,Ji,Qi,ca,Zi,mn,ep,tp,ap,ve,ia,rp,bn,op,np,$e,pa,sp,hn,lp,dp,_e,ma,cp,un,ip,pp,Te,ba,mp,gn,bp,hp,mo,ha,up,we,ua,gp,fn,fp,yp,xe,ga,vp,yn,$p,_p,Ee,fa,Tp,vn,wp,xp,ke,ya,Ep,$n,kp,Ip,Ie,va,Mp,_n,Dp,Cp,Me,$a,Pp,Tn,Lp,Ap,q,_a,Np,wn,jp,Fp,xn,Vp,Sp,De,Ta,qp,En,Rp,Up,Ce,wa,zp,kn,Bp,Op,Pe,xa,Wp,In,Xp,Hp,Le,Ea,Kp,Mn,Yp,Gp,Ae,ka,Jp,Dn,Qp,Zp,Ne,Ia,em,Cn,tm,am,R,Ma,rm,Pn,om,nm,Ln,sm,lm,je,Da,dm,An,cm,im,Fe,Ca,pm,Nn,mm,bm,U,Pa,hm,jn,um,gm,Fn,fm,ym,Ve,La,vm,Vn,$m,_m,Se,Aa,Tm,Sn,wm,xm,qe,Na,Em,qn,km,Im,Re,ja,Mm,Rn,Dm,Cm,Ue,Fa,Pm,Un,Lm,Am,bo,Va,Nm,ho,Sa,jm,L,qa,Fm,zn,Vm,Sm,Ra,qm,Bn,Rm,Um,zm,Ua,Bm,On,Om,Wm,Xm,ze,Hm,Be,za,Km,Wn,Ym,Gm,Oe,Ba,Jm,Xn,Qm,Zm,We,Oa,eb,Hn,tb,Dl,Z,Xe,Kn,Wa,ab,Yn,rb,Cl,_,Xa,ob,Gn,nb,sb,Jn,lb,db,Qn,cb,ib,Zn,pb,mb,es,bb,hb,z,Ha,ub,ts,gb,fb,Ka,yb,as,vb,$b,_b,He,Ya,Tb,rs,wb,xb,Ke,Ga,Eb,os,kb,Ib,Ye,Ja,Mb,ns,Db,Cb,Ge,Qa,Pb,ss,Lb,Ab,uo,Za,Nb,Je,er,jb,ls,Fb,Vb,Qe,tr,Sb,ds,qb,Rb,Ze,ar,Ub,cs,zb,Bb,et,rr,Ob,is,Wb,Xb,tt,or,Hb,ps,Kb,Yb,at,nr,Gb,ms,Jb,Qb,B,sr,Zb,bs,eh,th,hs,ah,rh,rt,lr,oh,us,nh,sh,ot,dr,lh,gs,dh,ch,nt,cr,ih,fs,ph,mh,st,ir,bh,ys,hh,uh,lt,pr,gh,vs,fh,yh,dt,mr,vh,$s,$h,_h,O,br,Th,_s,wh,xh,Ts,Eh,kh,ct,hr,Ih,ws,Mh,Dh,it,ur,Ch,xs,Ph,Lh,W,gr,Ah,Es,Nh,jh,ks,Fh,Vh,pt,fr,Sh,Is,qh,Rh,mt,yr,Uh,Ms,zh,Bh,bt,vr,Oh,Ds,Wh,Xh,ht,$r,Hh,Cs,Kh,Yh,ut,_r,Gh,Ps,Jh,Qh,go,Tr,Pl,ee,gt,Ls,wr,Zh,As,eu,Ll,v,xr,tu,Ns,au,ru,js,ou,nu,Er,Fs,su,lu,Vs,du,cu,kr,iu,Ss,pu,mu,bu,Ir,hu,qs,uu,gu,fu,Rs,yu,vu,X,Mr,$u,Us,_u,Tu,Dr,wu,zs,xu,Eu,ku,ft,Cr,Iu,Bs,Mu,Du,yt,Pr,Cu,Os,Pu,Lu,vt,Lr,Au,Ws,Nu,ju,$t,Ar,Fu,Xs,Vu,Su,fo,Nr,qu,_t,jr,Ru,Hs,Uu,zu,Tt,Fr,Bu,Ks,Ou,Wu,wt,Vr,Xu,Ys,Hu,Ku,xt,Sr,Yu,Gs,Gu,Ju,Et,qr,Qu,Js,Zu,eg,kt,Rr,tg,Qs,ag,rg,H,Ur,og,Zs,ng,sg,el,lg,dg,It,zr,cg,tl,ig,pg,Mt,Br,mg,al,bg,hg,Dt,Or,ug,rl,gg,fg,Ct,Wr,yg,ol,vg,$g,Pt,Xr,_g,nl,Tg,wg,Lt,Hr,xg,sl,Eg,kg,K,Kr,Ig,ll,Mg,Dg,dl,Cg,Pg,At,Yr,Lg,cl,Ag,Ng,Nt,Gr,jg,il,Fg,Vg,Y,Jr,Sg,pl,qg,Rg,ml,Ug,zg,jt,Qr,Bg,bl,Og,Wg,Ft,Zr,Xg,hl,Hg,Kg,Vt,eo,Yg,ul,Gg,Jg,St,to,Qg,gl,Zg,ef,qt,ao,tf,fl,af,rf,yo,ro,of,Rt,oo,nf,yl,sf,Al,te,Ut,vl,no,lf,$l,df,Nl,ae,so,cf,_l,pf,jl,re,lo,mf,Tl,bf,Fl;return M=new No({}),zt=new No({}),Bt=new f({props:{name:"class datasets.table.Table",anchor:"datasets.table.Table",parameters:[{name:"table",val:": Table"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L148"}}),Ot=new f({props:{name:"validate",anchor:"datasets.table.Table.validate",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.Table.validate.full",description:`<strong>full</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
If True, run expensive checks, otherwise cheap checks only.`,name:"full"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L199",raiseDescription:`
<ul>
<li><code>pa.lib.ArrowInvalid</code> \u2014 if validation fails</li>
</ul>
`,raiseType:`
<p><code>pa.lib.ArrowInvalid</code></p>
`}}),Xt=new f({props:{name:"equals",anchor:"datasets.table.Table.equals",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.Table.equals.other",description:`<strong>other</strong> (<a href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table">datasets.table.Table</a>) &#x2014;
Table to compare against.`,name:"other"},{anchor:"datasets.table.Table.equals.check_metadata",description:`<strong>check_metadata</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether schema metadata equality should be checked as well.`,name:"check_metadata"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L215",returnType:`
<p><code>bool</code></p>
`}}),Ht=new f({props:{name:"to_batches",anchor:"datasets.table.Table.to_batches",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.Table.to_batches.max_chunksize",description:`<strong>max_chunksize</strong> (<code>int</code>, defaults to <em>None</em>) &#x2014;
Maximum size for RecordBatch chunks. Individual chunks may be
smaller depending on the chunk layout of individual columns.`,name:"max_chunksize"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L232",returnType:`
<p><code>List[pyarrow.RecordBatch]</code></p>
`}}),Kt=new f({props:{name:"to_pydict",anchor:"datasets.table.Table.to_pydict",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L246",returnType:`
<p><code>dict</code></p>
`}}),Yt=new f({props:{name:"to_pandas",anchor:"datasets.table.Table.to_pandas",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.Table.to_pandas.memory_pool",description:`<strong>memory_pool</strong> (<code>MemoryPool</code>, defaults to <code>None</code>) &#x2014;
Arrow MemoryPool to use for allocations. Uses the default memory
pool is not passed.`,name:"memory_pool"},{anchor:"datasets.table.Table.to_pandas.strings_to_categorical",description:`<strong>strings_to_categorical</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Encode string (UTF8) and binary types to pandas.Categorical.`,name:"strings_to_categorical"},{anchor:"datasets.table.Table.to_pandas.categories",description:`<strong>categories</strong> (<code>list</code>, defaults to <code>empty</code>) &#x2014;
List of fields that should be returned as pandas.Categorical. Only
applies to table-like data structures.`,name:"categories"},{anchor:"datasets.table.Table.to_pandas.zero_copy_only",description:`<strong>zero_copy_only</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Raise an ArrowException if this function call would require copying
the underlying data.`,name:"zero_copy_only"},{anchor:"datasets.table.Table.to_pandas.integer_object_nulls",description:`<strong>integer_object_nulls</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Cast integers with nulls to objects`,name:"integer_object_nulls"},{anchor:"datasets.table.Table.to_pandas.date_as_object",description:`<strong>date_as_object</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Cast dates to objects. If False, convert to datetime64[ns] dtype.`,name:"date_as_object"},{anchor:"datasets.table.Table.to_pandas.timestamp_as_object",description:`<strong>timestamp_as_object</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Cast non-nanosecond timestamps (np.datetime64) to objects. This is
useful if you have timestamps that don&#x2019;t fit in the normal date
range of nanosecond timestamps (1678 CE-2262 CE).
If False, all timestamps are converted to datetime64[ns] dtype.`,name:"timestamp_as_object"},{anchor:"datasets.table.Table.to_pandas.use_threads",description:`<strong>use_threads</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether to parallelize the conversion using multiple threads.`,name:"use_threads"},{anchor:"datasets.table.Table.to_pandas.deduplicate_objects",description:`<strong>deduplicate_objects</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Do not create multiple copies Python objects when created, to save
on memory use. Conversion will be slower.`,name:"deduplicate_objects"},{anchor:"datasets.table.Table.to_pandas.ignore_metadata",description:`<strong>ignore_metadata</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
If True, do not use the &#x2018;pandas&#x2019; metadata to reconstruct the
DataFrame index, if present`,name:"ignore_metadata"},{anchor:"datasets.table.Table.to_pandas.safe",description:`<strong>safe</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
For certain data types, a cast is needed in order to store the
data in a pandas DataFrame or Series (e.g. timestamps are always
stored as nanoseconds in pandas). This option controls whether it
is a safe cast or not.`,name:"safe"},{anchor:"datasets.table.Table.to_pandas.split_blocks",description:`<strong>split_blocks</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
If True, generate one internal &#x201C;block&#x201D; for each column when
creating a pandas.DataFrame from a RecordBatch or Table. While this
can temporarily reduce memory note that various pandas operations
can trigger &#x201C;consolidation&#x201D; which may balloon memory use.`,name:"split_blocks"},{anchor:"datasets.table.Table.to_pandas.self_destruct",description:`<strong>self_destruct</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
EXPERIMENTAL: If True, attempt to deallocate the originating Arrow
memory while converting the Arrow object to pandas. If you use the
object after calling to_pandas with this option it will crash your
program.`,name:"self_destruct"},{anchor:"datasets.table.Table.to_pandas.types_mapper",description:`<strong>types_mapper</strong> (<code>function</code>, defaults to <code>None</code>) &#x2014;
A function mapping a pyarrow DataType to a pandas ExtensionDtype.
This can be used to override the default pandas type for conversion
of built-in pyarrow types or in absence of pandas_metadata in the
Table schema. The function receives a pyarrow DataType and is
expected to return a pandas ExtensionDtype or <code>None</code> if the
default conversion should be used for that type. If you have
a dictionary mapping, you can pass <code>dict.get</code> as function.`,name:"types_mapper"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L268",returnDescription:`
<p><code>pandas.Series</code> or <code>pandas.DataFrame</code> depending on type of object</p>
`,returnType:`
<p><code>pandas.Series</code> or <code>pandas.DataFrame</code></p>
`}}),Gt=new f({props:{name:"to_string",anchor:"datasets.table.Table.to_string",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L330"}}),Jt=new f({props:{name:"field",anchor:"datasets.table.Table.field",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.Table.field.i",description:`<strong>i</strong> (<code>Union[int, str]</code>) &#x2014;
The index or name of the field to retrieve.`,name:"i"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L357",returnType:`
<p><code>pyarrow.Field</code></p>
`}}),Qt=new f({props:{name:"column",anchor:"datasets.table.Table.column",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.Table.column.i",description:`<strong>i</strong> (<code>Union[int, str]</code>) &#x2014;
The index or name of the column to retrieve.`,name:"i"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L370",returnType:`
<p><code>pyarrow.ChunkedArray</code></p>
`}}),Zt=new f({props:{name:"itercolumns",anchor:"datasets.table.Table.itercolumns",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L383",returnType:`
<p><code>pyarrow.ChunkedArray</code></p>
`,isYield:!0}}),ea=new f({props:{name:"schema",anchor:"datasets.table.Table.schema",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L392",returnType:`
<p><code>pyarrow.Schema</code></p>
`}}),ta=new f({props:{name:"columns",anchor:"datasets.table.Table.columns",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L402",returnType:`
<p><code>List[pa.ChunkedArray]</code></p>
`}}),aa=new f({props:{name:"num_columns",anchor:"datasets.table.Table.num_columns",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L412",returnType:`
<p>int</p>
`}}),ra=new f({props:{name:"num_rows",anchor:"datasets.table.Table.num_rows",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L422",returnType:`
<p>int</p>
`}}),oa=new f({props:{name:"shape",anchor:"datasets.table.Table.shape",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L435",returnDescription:`
<p>Number of rows and number of columns.</p>
`,returnType:`
<p><code>(int, int)</code></p>
`}}),na=new f({props:{name:"nbytes",anchor:"datasets.table.Table.nbytes",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L445"}}),sa=new No({}),la=new f({props:{name:"class datasets.table.InMemoryTable",anchor:"datasets.table.InMemoryTable",parameters:[{name:"table",val:": Table"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L668"}}),da=new f({props:{name:"validate",anchor:"datasets.table.InMemoryTable.validate",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.validate.full",description:`<strong>full</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
If True, run expensive checks, otherwise cheap checks only.`,name:"full"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L199",raiseDescription:`
<ul>
<li><code>pa.lib.ArrowInvalid</code> \u2014 if validation fails</li>
</ul>
`,raiseType:`
<p><code>pa.lib.ArrowInvalid</code></p>
`}}),ia=new f({props:{name:"equals",anchor:"datasets.table.InMemoryTable.equals",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.equals.other",description:`<strong>other</strong> (<a href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table">datasets.table.Table</a>) &#x2014;
Table to compare against.`,name:"other"},{anchor:"datasets.table.InMemoryTable.equals.check_metadata",description:`<strong>check_metadata</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether schema metadata equality should be checked as well.`,name:"check_metadata"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L215",returnType:`
<p><code>bool</code></p>
`}}),pa=new f({props:{name:"to_batches",anchor:"datasets.table.InMemoryTable.to_batches",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.to_batches.max_chunksize",description:`<strong>max_chunksize</strong> (<code>int</code>, defaults to <em>None</em>) &#x2014;
Maximum size for RecordBatch chunks. Individual chunks may be
smaller depending on the chunk layout of individual columns.`,name:"max_chunksize"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L232",returnType:`
<p><code>List[pyarrow.RecordBatch]</code></p>
`}}),ma=new f({props:{name:"to_pydict",anchor:"datasets.table.InMemoryTable.to_pydict",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L246",returnType:`
<p><code>dict</code></p>
`}}),ba=new f({props:{name:"to_pandas",anchor:"datasets.table.InMemoryTable.to_pandas",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.to_pandas.memory_pool",description:`<strong>memory_pool</strong> (<code>MemoryPool</code>, defaults to <code>None</code>) &#x2014;
Arrow MemoryPool to use for allocations. Uses the default memory
pool is not passed.`,name:"memory_pool"},{anchor:"datasets.table.InMemoryTable.to_pandas.strings_to_categorical",description:`<strong>strings_to_categorical</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Encode string (UTF8) and binary types to pandas.Categorical.`,name:"strings_to_categorical"},{anchor:"datasets.table.InMemoryTable.to_pandas.categories",description:`<strong>categories</strong> (<code>list</code>, defaults to <code>empty</code>) &#x2014;
List of fields that should be returned as pandas.Categorical. Only
applies to table-like data structures.`,name:"categories"},{anchor:"datasets.table.InMemoryTable.to_pandas.zero_copy_only",description:`<strong>zero_copy_only</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Raise an ArrowException if this function call would require copying
the underlying data.`,name:"zero_copy_only"},{anchor:"datasets.table.InMemoryTable.to_pandas.integer_object_nulls",description:`<strong>integer_object_nulls</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Cast integers with nulls to objects`,name:"integer_object_nulls"},{anchor:"datasets.table.InMemoryTable.to_pandas.date_as_object",description:`<strong>date_as_object</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Cast dates to objects. If False, convert to datetime64[ns] dtype.`,name:"date_as_object"},{anchor:"datasets.table.InMemoryTable.to_pandas.timestamp_as_object",description:`<strong>timestamp_as_object</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Cast non-nanosecond timestamps (np.datetime64) to objects. This is
useful if you have timestamps that don&#x2019;t fit in the normal date
range of nanosecond timestamps (1678 CE-2262 CE).
If False, all timestamps are converted to datetime64[ns] dtype.`,name:"timestamp_as_object"},{anchor:"datasets.table.InMemoryTable.to_pandas.use_threads",description:`<strong>use_threads</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether to parallelize the conversion using multiple threads.`,name:"use_threads"},{anchor:"datasets.table.InMemoryTable.to_pandas.deduplicate_objects",description:`<strong>deduplicate_objects</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Do not create multiple copies Python objects when created, to save
on memory use. Conversion will be slower.`,name:"deduplicate_objects"},{anchor:"datasets.table.InMemoryTable.to_pandas.ignore_metadata",description:`<strong>ignore_metadata</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
If True, do not use the &#x2018;pandas&#x2019; metadata to reconstruct the
DataFrame index, if present`,name:"ignore_metadata"},{anchor:"datasets.table.InMemoryTable.to_pandas.safe",description:`<strong>safe</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
For certain data types, a cast is needed in order to store the
data in a pandas DataFrame or Series (e.g. timestamps are always
stored as nanoseconds in pandas). This option controls whether it
is a safe cast or not.`,name:"safe"},{anchor:"datasets.table.InMemoryTable.to_pandas.split_blocks",description:`<strong>split_blocks</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
If True, generate one internal &#x201C;block&#x201D; for each column when
creating a pandas.DataFrame from a RecordBatch or Table. While this
can temporarily reduce memory note that various pandas operations
can trigger &#x201C;consolidation&#x201D; which may balloon memory use.`,name:"split_blocks"},{anchor:"datasets.table.InMemoryTable.to_pandas.self_destruct",description:`<strong>self_destruct</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
EXPERIMENTAL: If True, attempt to deallocate the originating Arrow
memory while converting the Arrow object to pandas. If you use the
object after calling to_pandas with this option it will crash your
program.`,name:"self_destruct"},{anchor:"datasets.table.InMemoryTable.to_pandas.types_mapper",description:`<strong>types_mapper</strong> (<code>function</code>, defaults to <code>None</code>) &#x2014;
A function mapping a pyarrow DataType to a pandas ExtensionDtype.
This can be used to override the default pandas type for conversion
of built-in pyarrow types or in absence of pandas_metadata in the
Table schema. The function receives a pyarrow DataType and is
expected to return a pandas ExtensionDtype or <code>None</code> if the
default conversion should be used for that type. If you have
a dictionary mapping, you can pass <code>dict.get</code> as function.`,name:"types_mapper"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L268",returnDescription:`
<p><code>pandas.Series</code> or <code>pandas.DataFrame</code> depending on type of object</p>
`,returnType:`
<p><code>pandas.Series</code> or <code>pandas.DataFrame</code></p>
`}}),ha=new f({props:{name:"to_string",anchor:"datasets.table.InMemoryTable.to_string",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L330"}}),ua=new f({props:{name:"field",anchor:"datasets.table.InMemoryTable.field",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.field.i",description:`<strong>i</strong> (<code>Union[int, str]</code>) &#x2014;
The index or name of the field to retrieve.`,name:"i"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L357",returnType:`
<p><code>pyarrow.Field</code></p>
`}}),ga=new f({props:{name:"column",anchor:"datasets.table.InMemoryTable.column",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.column.i",description:`<strong>i</strong> (<code>Union[int, str]</code>) &#x2014;
The index or name of the column to retrieve.`,name:"i"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L370",returnType:`
<p><code>pyarrow.ChunkedArray</code></p>
`}}),fa=new f({props:{name:"itercolumns",anchor:"datasets.table.InMemoryTable.itercolumns",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L383",returnType:`
<p><code>pyarrow.ChunkedArray</code></p>
`,isYield:!0}}),ya=new f({props:{name:"schema",anchor:"datasets.table.InMemoryTable.schema",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L392",returnType:`
<p><code>pyarrow.Schema</code></p>
`}}),va=new f({props:{name:"columns",anchor:"datasets.table.InMemoryTable.columns",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L402",returnType:`
<p><code>List[pa.ChunkedArray]</code></p>
`}}),$a=new f({props:{name:"num_columns",anchor:"datasets.table.InMemoryTable.num_columns",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L412",returnType:`
<p>int</p>
`}}),_a=new f({props:{name:"num_rows",anchor:"datasets.table.InMemoryTable.num_rows",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L422",returnType:`
<p>int</p>
`}}),Ta=new f({props:{name:"shape",anchor:"datasets.table.InMemoryTable.shape",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L435",returnDescription:`
<p>Number of rows and number of columns.</p>
`,returnType:`
<p><code>(int, int)</code></p>
`}}),wa=new f({props:{name:"nbytes",anchor:"datasets.table.InMemoryTable.nbytes",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L445"}}),xa=new f({props:{name:"column_names",anchor:"datasets.table.InMemoryTable.column_names",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L452"}}),Ea=new f({props:{name:"slice",anchor:"datasets.table.InMemoryTable.slice",parameters:[{name:"offset",val:" = 0"},{name:"length",val:" = None"}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.slice.offset",description:`<strong>offset</strong> (<code>int</code>, defaults to <code>0</code>) &#x2014;
Offset from start of table to slice`,name:"offset"},{anchor:"datasets.table.InMemoryTable.slice.length",description:`<strong>length</strong> (<code>int</code>, defaults to <code>None</code>) &#x2014;
Length of slice (default is until end of table starting from
offset)`,name:"length"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L827",returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),ka=new f({props:{name:"filter",anchor:"datasets.table.InMemoryTable.filter",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L844"}}),Ia=new f({props:{name:"flatten",anchor:"datasets.table.InMemoryTable.flatten",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.flatten.memory_pool",description:`<strong>memory_pool</strong> (<code>MemoryPool</code>, defaults to <code>None</code>) &#x2014;
For memory allocations, if required, otherwise use default pool`,name:"memory_pool"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L850",returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),Ma=new f({props:{name:"combine_chunks",anchor:"datasets.table.InMemoryTable.combine_chunks",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.combine_chunks.memory_pool",description:`<strong>memory_pool</strong> (<code>MemoryPool</code>, defaults to <code>None</code>) &#x2014;
For memory allocations, if required, otherwise use default pool`,name:"memory_pool"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L864",returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),Da=new f({props:{name:"cast",anchor:"datasets.table.InMemoryTable.cast",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.cast.target_schema",description:`<strong>target_schema</strong> (<code>Schema</code>) &#x2014;
Schema to cast to, the names and order of fields must match`,name:"target_schema"},{anchor:"datasets.table.InMemoryTable.cast.safe",description:`<strong>safe</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Check for overflows or other unsafe conversions`,name:"safe"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L880",returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),Ca=new f({props:{name:"replace_schema_metadata",anchor:"datasets.table.InMemoryTable.replace_schema_metadata",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.replace_schema_metadata.metadata",description:"<strong>metadata</strong> (<code>dict</code>, defaults to <code>None</code>) &#x2014;",name:"metadata"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L895",returnDescription:`
<p>shallow_copy</p>
`,returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),Pa=new f({props:{name:"add_column",anchor:"datasets.table.InMemoryTable.add_column",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.add_column.i",description:`<strong>i</strong> (<code>int</code>) &#x2014;
Index to place the column at.`,name:"i"},{anchor:"datasets.table.InMemoryTable.add_column.field_",description:`<strong>field_</strong> (<code>Union[str, pyarrow.Field]</code>) &#x2014;
If a string is passed then the type is deduced from the column
data.`,name:"field_"},{anchor:"datasets.table.InMemoryTable.add_column.column",description:`<strong>column</strong> (<code>Union[pyarrow.Array, List[pyarrow.Array]]</code>) &#x2014;
Column data.`,name:"column"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L909",returnDescription:`
<p>New table with the passed column added.</p>
`,returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),La=new f({props:{name:"append_column",anchor:"datasets.table.InMemoryTable.append_column",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.append_column.field_",description:`<strong>field_</strong> (<code>Union[str, pyarrow.Field]</code>) &#x2014;
If a string is passed then the type is deduced from the column
data.`,name:"field_"},{anchor:"datasets.table.InMemoryTable.append_column.column",description:`<strong>column</strong> (<code>Union[pyarrow.Array, List[pyarrow.Array]]</code>) &#x2014;
Column data.`,name:"column"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L930",returnDescription:`
<p>New table with the passed column added.</p>
`,returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),Aa=new f({props:{name:"remove_column",anchor:"datasets.table.InMemoryTable.remove_column",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.remove_column.i",description:`<strong>i</strong> (<code>int</code>) &#x2014;
Index of column to remove.`,name:"i"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L947",returnDescription:`
<p>New table without the column.</p>
`,returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),Na=new f({props:{name:"set_column",anchor:"datasets.table.InMemoryTable.set_column",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.set_column.i",description:`<strong>i</strong> (<code>int</code>) &#x2014;
Index to place the column at.`,name:"i"},{anchor:"datasets.table.InMemoryTable.set_column.field_",description:`<strong>field_</strong> (<code>Union[str, pyarrow.Field]</code>) &#x2014;
If a string is passed then the type is deduced from the column
data.`,name:"field_"},{anchor:"datasets.table.InMemoryTable.set_column.column",description:`<strong>column</strong> (<code>Union[pyarrow.Array, List[pyarrow.Array]]</code>) &#x2014;
Column data.`,name:"column"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L961",returnDescription:`
<p>New table with the passed column set.</p>
`,returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),ja=new f({props:{name:"rename_columns",anchor:"datasets.table.InMemoryTable.rename_columns",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L980"}}),Fa=new f({props:{name:"drop",anchor:"datasets.table.InMemoryTable.drop",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.drop.columns",description:`<strong>columns</strong> (<code>List[str]</code>) &#x2014;
List of field names referencing existing columns.`,name:"columns"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L986",returnDescription:`
<p>New table without the columns.</p>
`,returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`,raiseDescription:`
<ul>
<li><code>KeyError</code> \u2014 : if any of the passed columns name are not existing.</li>
</ul>
`,raiseType:`
<p><code>KeyError</code></p>
`}}),Va=new f({props:{name:"from_file",anchor:"datasets.table.InMemoryTable.from_file",parameters:[{name:"filename",val:": str"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L683"}}),Sa=new f({props:{name:"from_buffer",anchor:"datasets.table.InMemoryTable.from_buffer",parameters:[{name:"buffer",val:": Buffer"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L688"}}),qa=new f({props:{name:"from_pandas",anchor:"datasets.table.InMemoryTable.from_pandas",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.from_pandas.df",description:"<strong>df</strong> (<code>pandas.DataFrame</code>) &#x2014;",name:"df"},{anchor:"datasets.table.InMemoryTable.from_pandas.schema",description:`<strong>schema</strong> (<code>pyarrow.Schema</code>, optional) &#x2014;
The expected schema of the Arrow Table. This can be used to
indicate the type of columns if we cannot infer it automatically.
If passed, the output will have exactly this schema. Columns
specified in the schema that are not found in the DataFrame columns
or its index will raise an error. Additional columns or index
levels in the DataFrame which are not specified in the schema will
be ignored.`,name:"schema"},{anchor:"datasets.table.InMemoryTable.from_pandas.preserve_index",description:`<strong>preserve_index</strong> (<code>bool</code>, optional) &#x2014;
Whether to store the index as an additional column in the resulting
<code>Table</code>. The default of None will store the index as a column,
except for RangeIndex which is stored as metadata only. Use
<code>preserve_index=True</code> to force it to be stored as a column.`,name:"preserve_index"},{anchor:"datasets.table.InMemoryTable.from_pandas.nthreads",description:`<strong>nthreads</strong> (<code>int</code>, defaults to <code>None</code> (may use up to system CPU count threads)) &#x2014;
If greater than 1, convert columns to Arrow in parallel using
indicated number of threads`,name:"nthreads"},{anchor:"datasets.table.InMemoryTable.from_pandas.columns",description:`<strong>columns</strong> (<code>List[str]</code>, optional) &#x2014;
List of column to be converted. If None, use all columns.`,name:"columns"},{anchor:"datasets.table.InMemoryTable.from_pandas.safe",description:`<strong>safe</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Check for overflows or other unsafe conversions`,name:"safe"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L693",returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),ze=new x2({props:{anchor:"datasets.table.InMemoryTable.from_pandas.example",$$slots:{default:[E2]},$$scope:{ctx:wl}}}),za=new f({props:{name:"from_arrays",anchor:"datasets.table.InMemoryTable.from_arrays",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.from_arrays.arrays",description:`<strong>arrays</strong> (<code>List[Union[pyarrow.Array, pyarrow.ChunkedArray]]</code>) &#x2014;
Equal-length arrays that should form the table.`,name:"arrays"},{anchor:"datasets.table.InMemoryTable.from_arrays.names",description:`<strong>names</strong> (<code>List[str]</code>, optional) &#x2014;
Names for the table columns. If not passed, schema must be passed`,name:"names"},{anchor:"datasets.table.InMemoryTable.from_arrays.schema",description:`<strong>schema</strong> (<code>Schema</code>, defaults to <code>None</code>) &#x2014;
Schema for the created table. If not passed, names must be passed`,name:"schema"},{anchor:"datasets.table.InMemoryTable.from_arrays.metadata",description:`<strong>metadata</strong> (<code>Union[dict, Mapping]</code>, default None) &#x2014;
Optional metadata for the schema (if inferred).`,name:"metadata"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L751",returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),Ba=new f({props:{name:"from_pydict",anchor:"datasets.table.InMemoryTable.from_pydict",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.from_pydict.mapping",description:`<strong>mapping</strong> (<code>Union[dict, Mapping]</code>) &#x2014;
A mapping of strings to Arrays or Python lists.`,name:"mapping"},{anchor:"datasets.table.InMemoryTable.from_pydict.schema",description:`<strong>schema</strong> (<code>Schema</code>, defaults to <code>None</code>) &#x2014;
If not passed, will be inferred from the Mapping values`,name:"schema"},{anchor:"datasets.table.InMemoryTable.from_pydict.metadata",description:`<strong>metadata</strong> (<code>Union[dict, Mapping]</code>, default None) &#x2014;
Optional metadata for the schema (if inferred).`,name:"metadata"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L771",returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),Oa=new f({props:{name:"from_batches",anchor:"datasets.table.InMemoryTable.from_batches",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.InMemoryTable.from_batches.batches",description:`<strong>batches</strong> (<code>Union[Sequence[pyarrow.RecordBatch], Iterator[pyarrow.RecordBatch]]</code>) &#x2014;
Sequence of RecordBatch to be converted, all schemas must be equal.`,name:"batches"},{anchor:"datasets.table.InMemoryTable.from_batches.schema",description:`<strong>schema</strong> (<code>Schema</code>, defaults to <code>None</code>) &#x2014;
If not passed, will be inferred from the first RecordBatch.`,name:"schema"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L811",returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),Wa=new No({}),Xa=new f({props:{name:"class datasets.table.MemoryMappedTable",anchor:"datasets.table.MemoryMappedTable",parameters:[{name:"table",val:": Table"},{name:"path",val:": str"},{name:"replays",val:": typing.Union[typing.List[typing.Tuple[str, tuple, dict]], NoneType] = None"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1008"}}),Ha=new f({props:{name:"validate",anchor:"datasets.table.MemoryMappedTable.validate",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.MemoryMappedTable.validate.full",description:`<strong>full</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
If True, run expensive checks, otherwise cheap checks only.`,name:"full"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L199",raiseDescription:`
<ul>
<li><code>pa.lib.ArrowInvalid</code> \u2014 if validation fails</li>
</ul>
`,raiseType:`
<p><code>pa.lib.ArrowInvalid</code></p>
`}}),Ya=new f({props:{name:"equals",anchor:"datasets.table.MemoryMappedTable.equals",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.MemoryMappedTable.equals.other",description:`<strong>other</strong> (<a href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table">datasets.table.Table</a>) &#x2014;
Table to compare against.`,name:"other"},{anchor:"datasets.table.MemoryMappedTable.equals.check_metadata",description:`<strong>check_metadata</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether schema metadata equality should be checked as well.`,name:"check_metadata"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L215",returnType:`
<p><code>bool</code></p>
`}}),Ga=new f({props:{name:"to_batches",anchor:"datasets.table.MemoryMappedTable.to_batches",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.MemoryMappedTable.to_batches.max_chunksize",description:`<strong>max_chunksize</strong> (<code>int</code>, defaults to <em>None</em>) &#x2014;
Maximum size for RecordBatch chunks. Individual chunks may be
smaller depending on the chunk layout of individual columns.`,name:"max_chunksize"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L232",returnType:`
<p><code>List[pyarrow.RecordBatch]</code></p>
`}}),Ja=new f({props:{name:"to_pydict",anchor:"datasets.table.MemoryMappedTable.to_pydict",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L246",returnType:`
<p><code>dict</code></p>
`}}),Qa=new f({props:{name:"to_pandas",anchor:"datasets.table.MemoryMappedTable.to_pandas",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.MemoryMappedTable.to_pandas.memory_pool",description:`<strong>memory_pool</strong> (<code>MemoryPool</code>, defaults to <code>None</code>) &#x2014;
Arrow MemoryPool to use for allocations. Uses the default memory
pool is not passed.`,name:"memory_pool"},{anchor:"datasets.table.MemoryMappedTable.to_pandas.strings_to_categorical",description:`<strong>strings_to_categorical</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Encode string (UTF8) and binary types to pandas.Categorical.`,name:"strings_to_categorical"},{anchor:"datasets.table.MemoryMappedTable.to_pandas.categories",description:`<strong>categories</strong> (<code>list</code>, defaults to <code>empty</code>) &#x2014;
List of fields that should be returned as pandas.Categorical. Only
applies to table-like data structures.`,name:"categories"},{anchor:"datasets.table.MemoryMappedTable.to_pandas.zero_copy_only",description:`<strong>zero_copy_only</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Raise an ArrowException if this function call would require copying
the underlying data.`,name:"zero_copy_only"},{anchor:"datasets.table.MemoryMappedTable.to_pandas.integer_object_nulls",description:`<strong>integer_object_nulls</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Cast integers with nulls to objects`,name:"integer_object_nulls"},{anchor:"datasets.table.MemoryMappedTable.to_pandas.date_as_object",description:`<strong>date_as_object</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Cast dates to objects. If False, convert to datetime64[ns] dtype.`,name:"date_as_object"},{anchor:"datasets.table.MemoryMappedTable.to_pandas.timestamp_as_object",description:`<strong>timestamp_as_object</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Cast non-nanosecond timestamps (np.datetime64) to objects. This is
useful if you have timestamps that don&#x2019;t fit in the normal date
range of nanosecond timestamps (1678 CE-2262 CE).
If False, all timestamps are converted to datetime64[ns] dtype.`,name:"timestamp_as_object"},{anchor:"datasets.table.MemoryMappedTable.to_pandas.use_threads",description:`<strong>use_threads</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether to parallelize the conversion using multiple threads.`,name:"use_threads"},{anchor:"datasets.table.MemoryMappedTable.to_pandas.deduplicate_objects",description:`<strong>deduplicate_objects</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Do not create multiple copies Python objects when created, to save
on memory use. Conversion will be slower.`,name:"deduplicate_objects"},{anchor:"datasets.table.MemoryMappedTable.to_pandas.ignore_metadata",description:`<strong>ignore_metadata</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
If True, do not use the &#x2018;pandas&#x2019; metadata to reconstruct the
DataFrame index, if present`,name:"ignore_metadata"},{anchor:"datasets.table.MemoryMappedTable.to_pandas.safe",description:`<strong>safe</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
For certain data types, a cast is needed in order to store the
data in a pandas DataFrame or Series (e.g. timestamps are always
stored as nanoseconds in pandas). This option controls whether it
is a safe cast or not.`,name:"safe"},{anchor:"datasets.table.MemoryMappedTable.to_pandas.split_blocks",description:`<strong>split_blocks</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
If True, generate one internal &#x201C;block&#x201D; for each column when
creating a pandas.DataFrame from a RecordBatch or Table. While this
can temporarily reduce memory note that various pandas operations
can trigger &#x201C;consolidation&#x201D; which may balloon memory use.`,name:"split_blocks"},{anchor:"datasets.table.MemoryMappedTable.to_pandas.self_destruct",description:`<strong>self_destruct</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
EXPERIMENTAL: If True, attempt to deallocate the originating Arrow
memory while converting the Arrow object to pandas. If you use the
object after calling to_pandas with this option it will crash your
program.`,name:"self_destruct"},{anchor:"datasets.table.MemoryMappedTable.to_pandas.types_mapper",description:`<strong>types_mapper</strong> (<code>function</code>, defaults to <code>None</code>) &#x2014;
A function mapping a pyarrow DataType to a pandas ExtensionDtype.
This can be used to override the default pandas type for conversion
of built-in pyarrow types or in absence of pandas_metadata in the
Table schema. The function receives a pyarrow DataType and is
expected to return a pandas ExtensionDtype or <code>None</code> if the
default conversion should be used for that type. If you have
a dictionary mapping, you can pass <code>dict.get</code> as function.`,name:"types_mapper"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L268",returnDescription:`
<p><code>pandas.Series</code> or <code>pandas.DataFrame</code> depending on type of object</p>
`,returnType:`
<p><code>pandas.Series</code> or <code>pandas.DataFrame</code></p>
`}}),Za=new f({props:{name:"to_string",anchor:"datasets.table.MemoryMappedTable.to_string",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L330"}}),er=new f({props:{name:"field",anchor:"datasets.table.MemoryMappedTable.field",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.MemoryMappedTable.field.i",description:`<strong>i</strong> (<code>Union[int, str]</code>) &#x2014;
The index or name of the field to retrieve.`,name:"i"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L357",returnType:`
<p><code>pyarrow.Field</code></p>
`}}),tr=new f({props:{name:"column",anchor:"datasets.table.MemoryMappedTable.column",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.MemoryMappedTable.column.i",description:`<strong>i</strong> (<code>Union[int, str]</code>) &#x2014;
The index or name of the column to retrieve.`,name:"i"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L370",returnType:`
<p><code>pyarrow.ChunkedArray</code></p>
`}}),ar=new f({props:{name:"itercolumns",anchor:"datasets.table.MemoryMappedTable.itercolumns",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L383",returnType:`
<p><code>pyarrow.ChunkedArray</code></p>
`,isYield:!0}}),rr=new f({props:{name:"schema",anchor:"datasets.table.MemoryMappedTable.schema",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L392",returnType:`
<p><code>pyarrow.Schema</code></p>
`}}),or=new f({props:{name:"columns",anchor:"datasets.table.MemoryMappedTable.columns",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L402",returnType:`
<p><code>List[pa.ChunkedArray]</code></p>
`}}),nr=new f({props:{name:"num_columns",anchor:"datasets.table.MemoryMappedTable.num_columns",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L412",returnType:`
<p>int</p>
`}}),sr=new f({props:{name:"num_rows",anchor:"datasets.table.MemoryMappedTable.num_rows",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L422",returnType:`
<p>int</p>
`}}),lr=new f({props:{name:"shape",anchor:"datasets.table.MemoryMappedTable.shape",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L435",returnDescription:`
<p>Number of rows and number of columns.</p>
`,returnType:`
<p><code>(int, int)</code></p>
`}}),dr=new f({props:{name:"nbytes",anchor:"datasets.table.MemoryMappedTable.nbytes",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L445"}}),cr=new f({props:{name:"column_names",anchor:"datasets.table.MemoryMappedTable.column_names",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L452"}}),ir=new f({props:{name:"slice",anchor:"datasets.table.MemoryMappedTable.slice",parameters:[{name:"offset",val:" = 0"},{name:"length",val:" = None"}],parametersDescription:[{anchor:"datasets.table.MemoryMappedTable.slice.offset",description:`<strong>offset</strong> (<code>int</code>, defaults to <code>0</code>) &#x2014;
Offset from start of table to slice`,name:"offset"},{anchor:"datasets.table.MemoryMappedTable.slice.length",description:`<strong>length</strong> (<code>int</code>, defaults to <code>None</code>) &#x2014;
Length of slice (default is until end of table starting from
offset)`,name:"length"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1067",returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),pr=new f({props:{name:"filter",anchor:"datasets.table.MemoryMappedTable.filter",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1086"}}),mr=new f({props:{name:"flatten",anchor:"datasets.table.MemoryMappedTable.flatten",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.MemoryMappedTable.flatten.memory_pool",description:`<strong>memory_pool</strong> (<code>MemoryPool</code>, defaults to <code>None</code>) &#x2014;
For memory allocations, if required, otherwise use default pool`,name:"memory_pool"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1094",returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),br=new f({props:{name:"combine_chunks",anchor:"datasets.table.MemoryMappedTable.combine_chunks",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.MemoryMappedTable.combine_chunks.memory_pool",description:`<strong>memory_pool</strong> (<code>MemoryPool</code>, defaults to <code>None</code>) &#x2014;
For memory allocations, if required, otherwise use default pool`,name:"memory_pool"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1110",returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),hr=new f({props:{name:"cast",anchor:"datasets.table.MemoryMappedTable.cast",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.MemoryMappedTable.cast.target_schema",description:`<strong>target_schema</strong> (<code>Schema</code>) &#x2014;
Schema to cast to, the names and order of fields must match`,name:"target_schema"},{anchor:"datasets.table.MemoryMappedTable.cast.safe",description:`<strong>safe</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Check for overflows or other unsafe conversions`,name:"safe"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1128",returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),ur=new f({props:{name:"replace_schema_metadata",anchor:"datasets.table.MemoryMappedTable.replace_schema_metadata",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.MemoryMappedTable.replace_schema_metadata.metadata",description:"<strong>metadata</strong> (<code>dict</code>, defaults to <code>None</code>) &#x2014;",name:"metadata"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1145",returnDescription:`
<p>shallow_copy</p>
`,returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),gr=new f({props:{name:"add_column",anchor:"datasets.table.MemoryMappedTable.add_column",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.MemoryMappedTable.add_column.i",description:`<strong>i</strong> (<code>int</code>) &#x2014;
Index to place the column at.`,name:"i"},{anchor:"datasets.table.MemoryMappedTable.add_column.field_",description:`<strong>field_</strong> (<code>Union[str, pyarrow.Field]</code>) &#x2014;
If a string is passed then the type is deduced from the column
data.`,name:"field_"},{anchor:"datasets.table.MemoryMappedTable.add_column.column",description:`<strong>column</strong> (<code>Union[pyarrow.Array, List[pyarrow.Array]]</code>) &#x2014;
Column data.`,name:"column"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1161",returnDescription:`
<p>New table with the passed column added.</p>
`,returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),fr=new f({props:{name:"append_column",anchor:"datasets.table.MemoryMappedTable.append_column",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.MemoryMappedTable.append_column.field_",description:`<strong>field_</strong> (<code>Union[str, pyarrow.Field]</code>) &#x2014;
If a string is passed then the type is deduced from the column
data.`,name:"field_"},{anchor:"datasets.table.MemoryMappedTable.append_column.column",description:`<strong>column</strong> (<code>Union[pyarrow.Array, List[pyarrow.Array]]</code>) &#x2014;
Column data.`,name:"column"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1184",returnDescription:`
<p>New table with the passed column added.</p>
`,returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),yr=new f({props:{name:"remove_column",anchor:"datasets.table.MemoryMappedTable.remove_column",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.MemoryMappedTable.remove_column.i",description:`<strong>i</strong> (<code>int</code>) &#x2014;
Index of column to remove.`,name:"i"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1203",returnDescription:`
<p>New table without the column.</p>
`,returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),vr=new f({props:{name:"set_column",anchor:"datasets.table.MemoryMappedTable.set_column",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.MemoryMappedTable.set_column.i",description:`<strong>i</strong> (<code>int</code>) &#x2014;
Index to place the column at.`,name:"i"},{anchor:"datasets.table.MemoryMappedTable.set_column.field_",description:`<strong>field_</strong> (<code>Union[str, pyarrow.Field]</code>) &#x2014;
If a string is passed then the type is deduced from the column
data.`,name:"field_"},{anchor:"datasets.table.MemoryMappedTable.set_column.column",description:`<strong>column</strong> (<code>Union[pyarrow.Array, List[pyarrow.Array]]</code>) &#x2014;
Column data.`,name:"column"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1219",returnDescription:`
<p>New table with the passed column set.</p>
`,returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),$r=new f({props:{name:"rename_columns",anchor:"datasets.table.MemoryMappedTable.rename_columns",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1240"}}),_r=new f({props:{name:"drop",anchor:"datasets.table.MemoryMappedTable.drop",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.MemoryMappedTable.drop.columns",description:`<strong>columns</strong> (<code>List[str]</code>) &#x2014;
List of field names referencing existing columns.`,name:"columns"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1248",returnDescription:`
<p>New table without the columns.</p>
`,returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`,raiseDescription:`
<ul>
<li><code>KeyError</code> \u2014 : if any of the passed columns name are not existing.</li>
</ul>
`,raiseType:`
<p><code>KeyError</code></p>
`}}),Tr=new f({props:{name:"from_file",anchor:"datasets.table.MemoryMappedTable.from_file",parameters:[{name:"filename",val:": str"},{name:"replays",val:" = None"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1034"}}),wr=new No({}),xr=new f({props:{name:"class datasets.table.ConcatenationTable",anchor:"datasets.table.ConcatenationTable",parameters:[{name:"table",val:": Table"},{name:"blocks",val:": typing.List[typing.List[datasets.table.TableBlock]]"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1275"}}),Mr=new f({props:{name:"validate",anchor:"datasets.table.ConcatenationTable.validate",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.ConcatenationTable.validate.full",description:`<strong>full</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
If True, run expensive checks, otherwise cheap checks only.`,name:"full"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L199",raiseDescription:`
<ul>
<li><code>pa.lib.ArrowInvalid</code> \u2014 if validation fails</li>
</ul>
`,raiseType:`
<p><code>pa.lib.ArrowInvalid</code></p>
`}}),Cr=new f({props:{name:"equals",anchor:"datasets.table.ConcatenationTable.equals",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.ConcatenationTable.equals.other",description:`<strong>other</strong> (<a href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table">datasets.table.Table</a>) &#x2014;
Table to compare against.`,name:"other"},{anchor:"datasets.table.ConcatenationTable.equals.check_metadata",description:`<strong>check_metadata</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether schema metadata equality should be checked as well.`,name:"check_metadata"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L215",returnType:`
<p><code>bool</code></p>
`}}),Pr=new f({props:{name:"to_batches",anchor:"datasets.table.ConcatenationTable.to_batches",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.ConcatenationTable.to_batches.max_chunksize",description:`<strong>max_chunksize</strong> (<code>int</code>, defaults to <em>None</em>) &#x2014;
Maximum size for RecordBatch chunks. Individual chunks may be
smaller depending on the chunk layout of individual columns.`,name:"max_chunksize"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L232",returnType:`
<p><code>List[pyarrow.RecordBatch]</code></p>
`}}),Lr=new f({props:{name:"to_pydict",anchor:"datasets.table.ConcatenationTable.to_pydict",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L246",returnType:`
<p><code>dict</code></p>
`}}),Ar=new f({props:{name:"to_pandas",anchor:"datasets.table.ConcatenationTable.to_pandas",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.ConcatenationTable.to_pandas.memory_pool",description:`<strong>memory_pool</strong> (<code>MemoryPool</code>, defaults to <code>None</code>) &#x2014;
Arrow MemoryPool to use for allocations. Uses the default memory
pool is not passed.`,name:"memory_pool"},{anchor:"datasets.table.ConcatenationTable.to_pandas.strings_to_categorical",description:`<strong>strings_to_categorical</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Encode string (UTF8) and binary types to pandas.Categorical.`,name:"strings_to_categorical"},{anchor:"datasets.table.ConcatenationTable.to_pandas.categories",description:`<strong>categories</strong> (<code>list</code>, defaults to <code>empty</code>) &#x2014;
List of fields that should be returned as pandas.Categorical. Only
applies to table-like data structures.`,name:"categories"},{anchor:"datasets.table.ConcatenationTable.to_pandas.zero_copy_only",description:`<strong>zero_copy_only</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Raise an ArrowException if this function call would require copying
the underlying data.`,name:"zero_copy_only"},{anchor:"datasets.table.ConcatenationTable.to_pandas.integer_object_nulls",description:`<strong>integer_object_nulls</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Cast integers with nulls to objects`,name:"integer_object_nulls"},{anchor:"datasets.table.ConcatenationTable.to_pandas.date_as_object",description:`<strong>date_as_object</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Cast dates to objects. If False, convert to datetime64[ns] dtype.`,name:"date_as_object"},{anchor:"datasets.table.ConcatenationTable.to_pandas.timestamp_as_object",description:`<strong>timestamp_as_object</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Cast non-nanosecond timestamps (np.datetime64) to objects. This is
useful if you have timestamps that don&#x2019;t fit in the normal date
range of nanosecond timestamps (1678 CE-2262 CE).
If False, all timestamps are converted to datetime64[ns] dtype.`,name:"timestamp_as_object"},{anchor:"datasets.table.ConcatenationTable.to_pandas.use_threads",description:`<strong>use_threads</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether to parallelize the conversion using multiple threads.`,name:"use_threads"},{anchor:"datasets.table.ConcatenationTable.to_pandas.deduplicate_objects",description:`<strong>deduplicate_objects</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Do not create multiple copies Python objects when created, to save
on memory use. Conversion will be slower.`,name:"deduplicate_objects"},{anchor:"datasets.table.ConcatenationTable.to_pandas.ignore_metadata",description:`<strong>ignore_metadata</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
If True, do not use the &#x2018;pandas&#x2019; metadata to reconstruct the
DataFrame index, if present`,name:"ignore_metadata"},{anchor:"datasets.table.ConcatenationTable.to_pandas.safe",description:`<strong>safe</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
For certain data types, a cast is needed in order to store the
data in a pandas DataFrame or Series (e.g. timestamps are always
stored as nanoseconds in pandas). This option controls whether it
is a safe cast or not.`,name:"safe"},{anchor:"datasets.table.ConcatenationTable.to_pandas.split_blocks",description:`<strong>split_blocks</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
If True, generate one internal &#x201C;block&#x201D; for each column when
creating a pandas.DataFrame from a RecordBatch or Table. While this
can temporarily reduce memory note that various pandas operations
can trigger &#x201C;consolidation&#x201D; which may balloon memory use.`,name:"split_blocks"},{anchor:"datasets.table.ConcatenationTable.to_pandas.self_destruct",description:`<strong>self_destruct</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
EXPERIMENTAL: If True, attempt to deallocate the originating Arrow
memory while converting the Arrow object to pandas. If you use the
object after calling to_pandas with this option it will crash your
program.`,name:"self_destruct"},{anchor:"datasets.table.ConcatenationTable.to_pandas.types_mapper",description:`<strong>types_mapper</strong> (<code>function</code>, defaults to <code>None</code>) &#x2014;
A function mapping a pyarrow DataType to a pandas ExtensionDtype.
This can be used to override the default pandas type for conversion
of built-in pyarrow types or in absence of pandas_metadata in the
Table schema. The function receives a pyarrow DataType and is
expected to return a pandas ExtensionDtype or <code>None</code> if the
default conversion should be used for that type. If you have
a dictionary mapping, you can pass <code>dict.get</code> as function.`,name:"types_mapper"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L268",returnDescription:`
<p><code>pandas.Series</code> or <code>pandas.DataFrame</code> depending on type of object</p>
`,returnType:`
<p><code>pandas.Series</code> or <code>pandas.DataFrame</code></p>
`}}),Nr=new f({props:{name:"to_string",anchor:"datasets.table.ConcatenationTable.to_string",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L330"}}),jr=new f({props:{name:"field",anchor:"datasets.table.ConcatenationTable.field",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.ConcatenationTable.field.i",description:`<strong>i</strong> (<code>Union[int, str]</code>) &#x2014;
The index or name of the field to retrieve.`,name:"i"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L357",returnType:`
<p><code>pyarrow.Field</code></p>
`}}),Fr=new f({props:{name:"column",anchor:"datasets.table.ConcatenationTable.column",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.ConcatenationTable.column.i",description:`<strong>i</strong> (<code>Union[int, str]</code>) &#x2014;
The index or name of the column to retrieve.`,name:"i"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L370",returnType:`
<p><code>pyarrow.ChunkedArray</code></p>
`}}),Vr=new f({props:{name:"itercolumns",anchor:"datasets.table.ConcatenationTable.itercolumns",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L383",returnType:`
<p><code>pyarrow.ChunkedArray</code></p>
`,isYield:!0}}),Sr=new f({props:{name:"schema",anchor:"datasets.table.ConcatenationTable.schema",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L392",returnType:`
<p><code>pyarrow.Schema</code></p>
`}}),qr=new f({props:{name:"columns",anchor:"datasets.table.ConcatenationTable.columns",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L402",returnType:`
<p><code>List[pa.ChunkedArray]</code></p>
`}}),Rr=new f({props:{name:"num_columns",anchor:"datasets.table.ConcatenationTable.num_columns",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L412",returnType:`
<p>int</p>
`}}),Ur=new f({props:{name:"num_rows",anchor:"datasets.table.ConcatenationTable.num_rows",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L422",returnType:`
<p>int</p>
`}}),zr=new f({props:{name:"shape",anchor:"datasets.table.ConcatenationTable.shape",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L435",returnDescription:`
<p>Number of rows and number of columns.</p>
`,returnType:`
<p><code>(int, int)</code></p>
`}}),Br=new f({props:{name:"nbytes",anchor:"datasets.table.ConcatenationTable.nbytes",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L445"}}),Or=new f({props:{name:"column_names",anchor:"datasets.table.ConcatenationTable.column_names",parameters:[],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L452"}}),Wr=new f({props:{name:"slice",anchor:"datasets.table.ConcatenationTable.slice",parameters:[{name:"offset",val:" = 0"},{name:"length",val:" = None"}],parametersDescription:[{anchor:"datasets.table.ConcatenationTable.slice.offset",description:`<strong>offset</strong> (<code>int</code>, defaults to <code>0</code>) &#x2014;
Offset from start of table to slice`,name:"offset"},{anchor:"datasets.table.ConcatenationTable.slice.length",description:`<strong>length</strong> (<code>int</code>, defaults to <code>None</code>) &#x2014;
Length of slice (default is until end of table starting from
offset)`,name:"length"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1447",returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),Xr=new f({props:{name:"filter",anchor:"datasets.table.ConcatenationTable.filter",parameters:[{name:"mask",val:""},{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1478"}}),Hr=new f({props:{name:"flatten",anchor:"datasets.table.ConcatenationTable.flatten",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.ConcatenationTable.flatten.memory_pool",description:`<strong>memory_pool</strong> (<code>MemoryPool</code>, defaults to <code>None</code>) &#x2014;
For memory allocations, if required, otherwise use default pool`,name:"memory_pool"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1489",returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),Kr=new f({props:{name:"combine_chunks",anchor:"datasets.table.ConcatenationTable.combine_chunks",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.ConcatenationTable.combine_chunks.memory_pool",description:`<strong>memory_pool</strong> (<code>MemoryPool</code>, defaults to <code>None</code>) &#x2014;
For memory allocations, if required, otherwise use default pool`,name:"memory_pool"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1507",returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),Yr=new f({props:{name:"cast",anchor:"datasets.table.ConcatenationTable.cast",parameters:[{name:"target_schema",val:""},{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.ConcatenationTable.cast.target_schema",description:`<strong>target_schema</strong> (<code>Schema</code>) &#x2014;
Schema to cast to, the names and order of fields must match`,name:"target_schema"},{anchor:"datasets.table.ConcatenationTable.cast.safe",description:`<strong>safe</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Check for overflows or other unsafe conversions`,name:"safe"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1527",returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),Gr=new f({props:{name:"replace_schema_metadata",anchor:"datasets.table.ConcatenationTable.replace_schema_metadata",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.ConcatenationTable.replace_schema_metadata.metadata",description:"<strong>metadata</strong> (<code>dict</code>, defaults to <code>None</code>) &#x2014;",name:"metadata"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1558",returnDescription:`
<p>shallow_copy</p>
`,returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),Jr=new f({props:{name:"add_column",anchor:"datasets.table.ConcatenationTable.add_column",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.ConcatenationTable.add_column.i",description:`<strong>i</strong> (<code>int</code>) &#x2014;
Index to place the column at.`,name:"i"},{anchor:"datasets.table.ConcatenationTable.add_column.field_",description:`<strong>field_</strong> (<code>Union[str, pyarrow.Field]</code>) &#x2014;
If a string is passed then the type is deduced from the column
data.`,name:"field_"},{anchor:"datasets.table.ConcatenationTable.add_column.column",description:`<strong>column</strong> (<code>Union[pyarrow.Array, List[pyarrow.Array]]</code>) &#x2014;
Column data.`,name:"column"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1576",returnDescription:`
<p>New table with the passed column added.</p>
`,returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),Qr=new f({props:{name:"append_column",anchor:"datasets.table.ConcatenationTable.append_column",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.ConcatenationTable.append_column.field_",description:`<strong>field_</strong> (<code>Union[str, pyarrow.Field]</code>) &#x2014;
If a string is passed then the type is deduced from the column
data.`,name:"field_"},{anchor:"datasets.table.ConcatenationTable.append_column.column",description:`<strong>column</strong> (<code>Union[pyarrow.Array, List[pyarrow.Array]]</code>) &#x2014;
Column data.`,name:"column"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1597",returnDescription:`
<p>New table with the passed column added.</p>
`,returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),Zr=new f({props:{name:"remove_column",anchor:"datasets.table.ConcatenationTable.remove_column",parameters:[{name:"i",val:""},{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.ConcatenationTable.remove_column.i",description:`<strong>i</strong> (<code>int</code>) &#x2014;
Index of column to remove.`,name:"i"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1614",returnDescription:`
<p>New table without the column.</p>
`,returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),eo=new f({props:{name:"set_column",anchor:"datasets.table.ConcatenationTable.set_column",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.ConcatenationTable.set_column.i",description:`<strong>i</strong> (<code>int</code>) &#x2014;
Index to place the column at.`,name:"i"},{anchor:"datasets.table.ConcatenationTable.set_column.field_",description:`<strong>field_</strong> (<code>Union[str, pyarrow.Field]</code>) &#x2014;
If a string is passed then the type is deduced from the column
data.`,name:"field_"},{anchor:"datasets.table.ConcatenationTable.set_column.column",description:`<strong>column</strong> (<code>Union[pyarrow.Array, List[pyarrow.Array]]</code>) &#x2014;
Column data.`,name:"column"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1638",returnDescription:`
<p>New table with the passed column set.</p>
`,returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),to=new f({props:{name:"rename_columns",anchor:"datasets.table.ConcatenationTable.rename_columns",parameters:[{name:"names",val:""},{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1657"}}),ao=new f({props:{name:"drop",anchor:"datasets.table.ConcatenationTable.drop",parameters:[{name:"columns",val:""},{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"datasets.table.ConcatenationTable.drop.columns",description:`<strong>columns</strong> (<code>List[str]</code>) &#x2014;
List of field names referencing existing columns.`,name:"columns"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1670",returnDescription:`
<p>New table without the columns.</p>
`,returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`,raiseDescription:`
<ul>
<li><code>KeyError</code> \u2014 : if any of the passed columns name are not existing.</li>
</ul>
`,raiseType:`
<p><code>KeyError</code></p>
`}}),ro=new f({props:{name:"from_blocks",anchor:"datasets.table.ConcatenationTable.from_blocks",parameters:[{name:"blocks",val:": TableBlockContainer"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1374"}}),oo=new f({props:{name:"from_tables",anchor:"datasets.table.ConcatenationTable.from_tables",parameters:[{name:"tables",val:": typing.List[typing.Union[pyarrow.lib.Table, datasets.table.Table]]"},{name:"axis",val:": int = 0"}],parametersDescription:[{anchor:"datasets.table.ConcatenationTable.from_tables.tables",description:`<strong>tables</strong> (list of <code>Table</code> or list of <code>pyarrow.Table</code>) &#x2014; List of tables.
axis &#x2014; (<code>{0, 1}</code>, defaults to <code>0</code>, meaning over rows):`,name:"tables"},{anchor:"datasets.table.ConcatenationTable.from_tables.Axis",description:`<strong>Axis</strong> to concatenate over, where <code>0</code> means over rows (vertically) and <code>1</code> means over columns &#x2014;
(horizontally). &#x2014;`,name:"Axis"},{anchor:"datasets.table.ConcatenationTable.from_tables.*New",description:"<strong>*New</strong> in version 1.6.0* &#x2014;",name:"*New"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1388"}}),no=new No({}),so=new f({props:{name:"datasets.table.concat_tables",anchor:"datasets.table.concat_tables",parameters:[{name:"tables",val:": typing.List[datasets.table.Table]"},{name:"axis",val:": int = 0"}],parametersDescription:[{anchor:"datasets.table.concat_tables.tables",description:"<strong>tables</strong> (list of <code>Table</code>) &#x2014; List of tables to be concatenated.",name:"tables"},{anchor:"datasets.table.concat_tables.axis",description:`<strong>axis</strong> (<code>{0, 1}</code>, defaults to <code>0</code>, meaning over rows) &#x2014;
Axis to concatenate over, where <code>0</code> means over rows (vertically) and <code>1</code> means over columns
(horizontally).</p>
<p><em>New in version 1.6.0</em>`,name:"axis"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1692",returnDescription:`
<p>If the number of input tables is > 1, then the returned table is a <code>datasets.table.ConcatenationTable</code>.
Otherwise if there\u2019s only one table, it is returned as is.</p>
`,returnType:`
<p><a
  href="/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"
>datasets.table.Table</a></p>
`}}),lo=new f({props:{name:"datasets.table.list_table_cache_files",anchor:"datasets.table.list_table_cache_files",parameters:[{name:"table",val:": Table"}],source:"https://github.com/huggingface/datasets/blob/2.7.0/src/datasets/table.py#L1715",returnDescription:`
<p>a list of paths to the cache files loaded by the table</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),{c(){D=r("meta"),oe=s(),P=r("h1"),C=r("a"),A=r("span"),p(M.$$.fragment),N=s(),jo=r("span"),Cc=d("Table Classes"),xl=s(),j=r("p"),Pc=d("Each "),Fo=r("code"),Lc=d("Dataset"),Ac=d(` object is backed by a PyArrow Table.
A Table can be loaded from either the disk (memory mapped) or in memory.
Several Table types are available, and they all inherit from `),io=r("a"),Nc=d("table.Table"),jc=d("."),El=s(),J=r("h2"),ne=r("a"),Vo=r("span"),p(zt.$$.fragment),Fc=s(),So=r("span"),Vc=d("Table"),kl=s(),x=r("div"),p(Bt.$$.fragment),Sc=s(),qo=r("p"),qc=d(`Wraps a pyarrow Table by using composition.
This is the base class for InMemoryTable, MemoryMappedTable and ConcatenationTable.`),Rc=s(),Ro=r("p"),Uc=d(`It implements all the basic attributes/methods of the pyarrow Table class except
the Table transforms: slice, filter, flatten, combine_chunks, cast, add_column,
append_column, remove_column, set_column, rename_columns and drop.`),zc=s(),Uo=r("p"),Bc=d("The implementation of these methods differs for the subclasses."),Oc=s(),F=r("div"),p(Ot.$$.fragment),Wc=s(),zo=r("p"),Xc=d("Perform validation checks.  An exception is raised if validation fails."),Hc=s(),Wt=r("p"),Kc=d("By default only cheap validation checks are run.  Pass "),Bo=r("em"),Yc=d("full=True"),Gc=d(`
for thorough validation checks (potentially O(n)).`),Jc=s(),se=r("div"),p(Xt.$$.fragment),Qc=s(),Oo=r("p"),Zc=d("Check if contents of two tables are equal."),ei=s(),le=r("div"),p(Ht.$$.fragment),ti=s(),Wo=r("p"),ai=d("Convert Table to list of (contiguous) RecordBatch objects."),ri=s(),de=r("div"),p(Kt.$$.fragment),oi=s(),Xo=r("p"),ni=d("Convert the Table to a dict or OrderedDict."),si=s(),ce=r("div"),p(Yt.$$.fragment),li=s(),Ho=r("p"),di=d("Convert to a pandas-compatible NumPy array or DataFrame, as appropriate"),ci=s(),po=r("div"),p(Gt.$$.fragment),ii=s(),ie=r("div"),p(Jt.$$.fragment),pi=s(),Ko=r("p"),mi=d("Select a schema field by its column name or numeric index."),bi=s(),pe=r("div"),p(Qt.$$.fragment),hi=s(),Yo=r("p"),ui=d("Select a column by its column name, or numeric index."),gi=s(),me=r("div"),p(Zt.$$.fragment),fi=s(),Go=r("p"),yi=d("Iterator over all columns in their numerical order."),vi=s(),be=r("div"),p(ea.$$.fragment),$i=s(),Jo=r("p"),_i=d("Schema of the table and its columns."),Ti=s(),he=r("div"),p(ta.$$.fragment),wi=s(),Qo=r("p"),xi=d("List of all columns in numerical order."),Ei=s(),ue=r("div"),p(aa.$$.fragment),ki=s(),Zo=r("p"),Ii=d("Number of columns in this table."),Mi=s(),V=r("div"),p(ra.$$.fragment),Di=s(),en=r("p"),Ci=d("Number of rows in this table."),Pi=s(),tn=r("p"),Li=d(`Due to the definition of a table, all columns have the same number of
rows.`),Ai=s(),ge=r("div"),p(oa.$$.fragment),Ni=s(),an=r("p"),ji=d("Dimensions of the table: (#rows, #columns)."),Fi=s(),fe=r("div"),p(na.$$.fragment),Vi=s(),rn=r("p"),Si=d("Total number of bytes consumed by the elements of the table."),Il=s(),Q=r("h2"),ye=r("a"),on=r("span"),p(sa.$$.fragment),qi=s(),nn=r("span"),Ri=d("InMemoryTable"),Ml=s(),y=r("div"),p(la.$$.fragment),Ui=s(),sn=r("p"),zi=d("The table is said in-memory when it is loaded into the user\u2019s RAM."),Bi=s(),ln=r("p"),Oi=d(`Pickling it does copy all the data using memory.
Its implementation is simple and uses the underlying pyarrow Table methods directly.`),Wi=s(),dn=r("p"),Xi=d(`This is different from the MemoryMapped table, for which pickling doesn\u2019t copy all the
data in memory. For a MemoryMapped, unpickling instead reloads the table from the disk.`),Hi=s(),cn=r("p"),Ki=d(`InMemoryTable must be used when data fit in memory, while MemoryMapped are reserved for
data bigger than memory or when you want the memory footprint of your application to
stay low.`),Yi=s(),S=r("div"),p(da.$$.fragment),Gi=s(),pn=r("p"),Ji=d("Perform validation checks.  An exception is raised if validation fails."),Qi=s(),ca=r("p"),Zi=d("By default only cheap validation checks are run.  Pass "),mn=r("em"),ep=d("full=True"),tp=d(`
for thorough validation checks (potentially O(n)).`),ap=s(),ve=r("div"),p(ia.$$.fragment),rp=s(),bn=r("p"),op=d("Check if contents of two tables are equal."),np=s(),$e=r("div"),p(pa.$$.fragment),sp=s(),hn=r("p"),lp=d("Convert Table to list of (contiguous) RecordBatch objects."),dp=s(),_e=r("div"),p(ma.$$.fragment),cp=s(),un=r("p"),ip=d("Convert the Table to a dict or OrderedDict."),pp=s(),Te=r("div"),p(ba.$$.fragment),mp=s(),gn=r("p"),bp=d("Convert to a pandas-compatible NumPy array or DataFrame, as appropriate"),hp=s(),mo=r("div"),p(ha.$$.fragment),up=s(),we=r("div"),p(ua.$$.fragment),gp=s(),fn=r("p"),fp=d("Select a schema field by its column name or numeric index."),yp=s(),xe=r("div"),p(ga.$$.fragment),vp=s(),yn=r("p"),$p=d("Select a column by its column name, or numeric index."),_p=s(),Ee=r("div"),p(fa.$$.fragment),Tp=s(),vn=r("p"),wp=d("Iterator over all columns in their numerical order."),xp=s(),ke=r("div"),p(ya.$$.fragment),Ep=s(),$n=r("p"),kp=d("Schema of the table and its columns."),Ip=s(),Ie=r("div"),p(va.$$.fragment),Mp=s(),_n=r("p"),Dp=d("List of all columns in numerical order."),Cp=s(),Me=r("div"),p($a.$$.fragment),Pp=s(),Tn=r("p"),Lp=d("Number of columns in this table."),Ap=s(),q=r("div"),p(_a.$$.fragment),Np=s(),wn=r("p"),jp=d("Number of rows in this table."),Fp=s(),xn=r("p"),Vp=d(`Due to the definition of a table, all columns have the same number of
rows.`),Sp=s(),De=r("div"),p(Ta.$$.fragment),qp=s(),En=r("p"),Rp=d("Dimensions of the table: (#rows, #columns)."),Up=s(),Ce=r("div"),p(wa.$$.fragment),zp=s(),kn=r("p"),Bp=d("Total number of bytes consumed by the elements of the table."),Op=s(),Pe=r("div"),p(xa.$$.fragment),Wp=s(),In=r("p"),Xp=d("Names of the table\u2019s columns"),Hp=s(),Le=r("div"),p(Ea.$$.fragment),Kp=s(),Mn=r("p"),Yp=d("Compute zero-copy slice of this Table"),Gp=s(),Ae=r("div"),p(ka.$$.fragment),Jp=s(),Dn=r("p"),Qp=d("Select records from a Table. See pyarrow.compute.filter for full usage."),Zp=s(),Ne=r("div"),p(Ia.$$.fragment),em=s(),Cn=r("p"),tm=d(`Flatten this Table.  Each column with a struct type is flattened
into one column per struct field.  Other columns are left unchanged.`),am=s(),R=r("div"),p(Ma.$$.fragment),rm=s(),Pn=r("p"),om=d("Make a new table by combining the chunks this table has."),nm=s(),Ln=r("p"),sm=d(`All the underlying chunks in the ChunkedArray of each column are
concatenated into zero or one chunk.`),lm=s(),je=r("div"),p(Da.$$.fragment),dm=s(),An=r("p"),cm=d("Cast table values to another schema"),im=s(),Fe=r("div"),p(Ca.$$.fragment),pm=s(),Nn=r("p"),mm=d(`EXPERIMENTAL: Create shallow copy of table by replacing schema
key-value metadata with the indicated new metadata (which may be None,
which deletes any existing metadata`),bm=s(),U=r("div"),p(Pa.$$.fragment),hm=s(),jn=r("p"),um=d("Add column to Table at position."),gm=s(),Fn=r("p"),fm=d(`A new table is returned with the column added, the original table
object is left unchanged.`),ym=s(),Ve=r("div"),p(La.$$.fragment),vm=s(),Vn=r("p"),$m=d("Append column at end of columns."),_m=s(),Se=r("div"),p(Aa.$$.fragment),Tm=s(),Sn=r("p"),wm=d("Create new Table with the indicated column removed."),xm=s(),qe=r("div"),p(Na.$$.fragment),Em=s(),qn=r("p"),km=d("Replace column in Table at position."),Im=s(),Re=r("div"),p(ja.$$.fragment),Mm=s(),Rn=r("p"),Dm=d("Create new table with columns renamed to provided names."),Cm=s(),Ue=r("div"),p(Fa.$$.fragment),Pm=s(),Un=r("p"),Lm=d("Drop one or more columns and return a new table."),Am=s(),bo=r("div"),p(Va.$$.fragment),Nm=s(),ho=r("div"),p(Sa.$$.fragment),jm=s(),L=r("div"),p(qa.$$.fragment),Fm=s(),zn=r("p"),Vm=d("Convert pandas.DataFrame to an Arrow Table."),Sm=s(),Ra=r("p"),qm=d(`The column types in the resulting Arrow Table are inferred from the
dtypes of the pandas.Series in the DataFrame. In the case of non-object
Series, the NumPy dtype is translated to its Arrow equivalent. In the
case of `),Bn=r("em"),Rm=d("object"),Um=d(`, we need to guess the datatype by looking at the
Python objects in this Series.`),zm=s(),Ua=r("p"),Bm=d("Be aware that Series of the "),On=r("em"),Om=d("object"),Wm=d(` dtype don\u2019t carry enough
information to always lead to a meaningful Arrow type. In the case that
we cannot infer a type, e.g. because the DataFrame is of length 0 or
the Series only contains None/nan objects, the type is set to
null. This behavior can be avoided by constructing an explicit schema
and passing it to this function.`),Xm=s(),p(ze.$$.fragment),Hm=s(),Be=r("div"),p(za.$$.fragment),Km=s(),Wn=r("p"),Ym=d("Construct a Table from Arrow arrays"),Gm=s(),Oe=r("div"),p(Ba.$$.fragment),Jm=s(),Xn=r("p"),Qm=d("Construct a Table from Arrow arrays or columns"),Zm=s(),We=r("div"),p(Oa.$$.fragment),eb=s(),Hn=r("p"),tb=d("Construct a Table from a sequence or iterator of Arrow RecordBatches."),Dl=s(),Z=r("h2"),Xe=r("a"),Kn=r("span"),p(Wa.$$.fragment),ab=s(),Yn=r("span"),rb=d("MemoryMappedTable"),Cl=s(),_=r("div"),p(Xa.$$.fragment),ob=s(),Gn=r("p"),nb=d(`The table is said memory mapped when it doesn\u2019t use the user\u2019s RAM but loads the data
from the disk instead.`),sb=s(),Jn=r("p"),lb=d(`Pickling it doesn\u2019t copy the data into memory.
Instead, only the path to the memory mapped arrow file is pickled, as well as the list
of transforms to \u201Creplay\u201D when reloading the table from the disk.`),db=s(),Qn=r("p"),cb=d(`Its implementation requires to store an history of all the transforms that were applied
to the underlying pyarrow Table, so that they can be \u201Creplayed\u201D when reloading the Table
from the disk.`),ib=s(),Zn=r("p"),pb=d(`This is different from the InMemoryTable table, for which pickling does copy all the
data in memory.`),mb=s(),es=r("p"),bb=d(`InMemoryTable must be used when data fit in memory, while MemoryMapped are reserved for
data bigger than memory or when you want the memory footprint of your application to
stay low.`),hb=s(),z=r("div"),p(Ha.$$.fragment),ub=s(),ts=r("p"),gb=d("Perform validation checks.  An exception is raised if validation fails."),fb=s(),Ka=r("p"),yb=d("By default only cheap validation checks are run.  Pass "),as=r("em"),vb=d("full=True"),$b=d(`
for thorough validation checks (potentially O(n)).`),_b=s(),He=r("div"),p(Ya.$$.fragment),Tb=s(),rs=r("p"),wb=d("Check if contents of two tables are equal."),xb=s(),Ke=r("div"),p(Ga.$$.fragment),Eb=s(),os=r("p"),kb=d("Convert Table to list of (contiguous) RecordBatch objects."),Ib=s(),Ye=r("div"),p(Ja.$$.fragment),Mb=s(),ns=r("p"),Db=d("Convert the Table to a dict or OrderedDict."),Cb=s(),Ge=r("div"),p(Qa.$$.fragment),Pb=s(),ss=r("p"),Lb=d("Convert to a pandas-compatible NumPy array or DataFrame, as appropriate"),Ab=s(),uo=r("div"),p(Za.$$.fragment),Nb=s(),Je=r("div"),p(er.$$.fragment),jb=s(),ls=r("p"),Fb=d("Select a schema field by its column name or numeric index."),Vb=s(),Qe=r("div"),p(tr.$$.fragment),Sb=s(),ds=r("p"),qb=d("Select a column by its column name, or numeric index."),Rb=s(),Ze=r("div"),p(ar.$$.fragment),Ub=s(),cs=r("p"),zb=d("Iterator over all columns in their numerical order."),Bb=s(),et=r("div"),p(rr.$$.fragment),Ob=s(),is=r("p"),Wb=d("Schema of the table and its columns."),Xb=s(),tt=r("div"),p(or.$$.fragment),Hb=s(),ps=r("p"),Kb=d("List of all columns in numerical order."),Yb=s(),at=r("div"),p(nr.$$.fragment),Gb=s(),ms=r("p"),Jb=d("Number of columns in this table."),Qb=s(),B=r("div"),p(sr.$$.fragment),Zb=s(),bs=r("p"),eh=d("Number of rows in this table."),th=s(),hs=r("p"),ah=d(`Due to the definition of a table, all columns have the same number of
rows.`),rh=s(),rt=r("div"),p(lr.$$.fragment),oh=s(),us=r("p"),nh=d("Dimensions of the table: (#rows, #columns)."),sh=s(),ot=r("div"),p(dr.$$.fragment),lh=s(),gs=r("p"),dh=d("Total number of bytes consumed by the elements of the table."),ch=s(),nt=r("div"),p(cr.$$.fragment),ih=s(),fs=r("p"),ph=d("Names of the table\u2019s columns"),mh=s(),st=r("div"),p(ir.$$.fragment),bh=s(),ys=r("p"),hh=d("Compute zero-copy slice of this Table"),uh=s(),lt=r("div"),p(pr.$$.fragment),gh=s(),vs=r("p"),fh=d("Select records from a Table. See pyarrow.compute.filter for full usage."),yh=s(),dt=r("div"),p(mr.$$.fragment),vh=s(),$s=r("p"),$h=d(`Flatten this Table.  Each column with a struct type is flattened
into one column per struct field.  Other columns are left unchanged.`),_h=s(),O=r("div"),p(br.$$.fragment),Th=s(),_s=r("p"),wh=d("Make a new table by combining the chunks this table has."),xh=s(),Ts=r("p"),Eh=d(`All the underlying chunks in the ChunkedArray of each column are
concatenated into zero or one chunk.`),kh=s(),ct=r("div"),p(hr.$$.fragment),Ih=s(),ws=r("p"),Mh=d("Cast table values to another schema"),Dh=s(),it=r("div"),p(ur.$$.fragment),Ch=s(),xs=r("p"),Ph=d(`EXPERIMENTAL: Create shallow copy of table by replacing schema
key-value metadata with the indicated new metadata (which may be None,
which deletes any existing metadata`),Lh=s(),W=r("div"),p(gr.$$.fragment),Ah=s(),Es=r("p"),Nh=d("Add column to Table at position."),jh=s(),ks=r("p"),Fh=d(`A new table is returned with the column added, the original table
object is left unchanged.`),Vh=s(),pt=r("div"),p(fr.$$.fragment),Sh=s(),Is=r("p"),qh=d("Append column at end of columns."),Rh=s(),mt=r("div"),p(yr.$$.fragment),Uh=s(),Ms=r("p"),zh=d("Create new Table with the indicated column removed."),Bh=s(),bt=r("div"),p(vr.$$.fragment),Oh=s(),Ds=r("p"),Wh=d("Replace column in Table at position."),Xh=s(),ht=r("div"),p($r.$$.fragment),Hh=s(),Cs=r("p"),Kh=d("Create new table with columns renamed to provided names."),Yh=s(),ut=r("div"),p(_r.$$.fragment),Gh=s(),Ps=r("p"),Jh=d("Drop one or more columns and return a new table."),Qh=s(),go=r("div"),p(Tr.$$.fragment),Pl=s(),ee=r("h2"),gt=r("a"),Ls=r("span"),p(wr.$$.fragment),Zh=s(),As=r("span"),eu=d("ConcatenationTable"),Ll=s(),v=r("div"),p(xr.$$.fragment),tu=s(),Ns=r("p"),au=d(`The table comes from the concatenation of several tables called blocks.
It enables concatenation on both axis 0 (append rows) and axis 1 (append columns).`),ru=s(),js=r("p"),ou=d(`The underlying tables are called \u201Cblocks\u201D and can be either InMemoryTable
or MemoryMappedTable objects.
This allows to combine tables that come from memory or that are memory mapped.
When a ConcatenationTable is pickled, then each block is pickled:`),nu=s(),Er=r("ul"),Fs=r("li"),su=d("the InMemoryTable objects are pickled by copying all the data in memory;"),lu=s(),Vs=r("li"),du=d(`the MemoryMappedTable objects are pickled without copying the data into memory.
Instead, only the path to the memory mapped arrow file is pickled, as well as the list
of transforms to \u201Creplays\u201D when reloading the table from the disk.`),cu=s(),kr=r("p"),iu=d(`Its implementation requires to store each block separately.
The `),Ss=r("code"),pu=d("blocks"),mu=d(` attributes stores a list of list of blocks.
The first axis concatenates the tables along the axis 0 (it appends rows),
while the second axis concatenates tables along the axis 1 (it appends columns).`),bu=s(),Ir=r("p"),hu=d(`If some columns are missing when concatenating on axis 0, they are filled with null values.
This is done using `),qs=r("em"),uu=d("pyarrow.concat_tables(tables, promote=True)"),gu=d("."),fu=s(),Rs=r("p"),yu=d(`You can access the fully combined table by accessing the ConcatenationTable.table attribute,
and the blocks by accessing the ConcatenationTable.blocks attribute.`),vu=s(),X=r("div"),p(Mr.$$.fragment),$u=s(),Us=r("p"),_u=d("Perform validation checks.  An exception is raised if validation fails."),Tu=s(),Dr=r("p"),wu=d("By default only cheap validation checks are run.  Pass "),zs=r("em"),xu=d("full=True"),Eu=d(`
for thorough validation checks (potentially O(n)).`),ku=s(),ft=r("div"),p(Cr.$$.fragment),Iu=s(),Bs=r("p"),Mu=d("Check if contents of two tables are equal."),Du=s(),yt=r("div"),p(Pr.$$.fragment),Cu=s(),Os=r("p"),Pu=d("Convert Table to list of (contiguous) RecordBatch objects."),Lu=s(),vt=r("div"),p(Lr.$$.fragment),Au=s(),Ws=r("p"),Nu=d("Convert the Table to a dict or OrderedDict."),ju=s(),$t=r("div"),p(Ar.$$.fragment),Fu=s(),Xs=r("p"),Vu=d("Convert to a pandas-compatible NumPy array or DataFrame, as appropriate"),Su=s(),fo=r("div"),p(Nr.$$.fragment),qu=s(),_t=r("div"),p(jr.$$.fragment),Ru=s(),Hs=r("p"),Uu=d("Select a schema field by its column name or numeric index."),zu=s(),Tt=r("div"),p(Fr.$$.fragment),Bu=s(),Ks=r("p"),Ou=d("Select a column by its column name, or numeric index."),Wu=s(),wt=r("div"),p(Vr.$$.fragment),Xu=s(),Ys=r("p"),Hu=d("Iterator over all columns in their numerical order."),Ku=s(),xt=r("div"),p(Sr.$$.fragment),Yu=s(),Gs=r("p"),Gu=d("Schema of the table and its columns."),Ju=s(),Et=r("div"),p(qr.$$.fragment),Qu=s(),Js=r("p"),Zu=d("List of all columns in numerical order."),eg=s(),kt=r("div"),p(Rr.$$.fragment),tg=s(),Qs=r("p"),ag=d("Number of columns in this table."),rg=s(),H=r("div"),p(Ur.$$.fragment),og=s(),Zs=r("p"),ng=d("Number of rows in this table."),sg=s(),el=r("p"),lg=d(`Due to the definition of a table, all columns have the same number of
rows.`),dg=s(),It=r("div"),p(zr.$$.fragment),cg=s(),tl=r("p"),ig=d("Dimensions of the table: (#rows, #columns)."),pg=s(),Mt=r("div"),p(Br.$$.fragment),mg=s(),al=r("p"),bg=d("Total number of bytes consumed by the elements of the table."),hg=s(),Dt=r("div"),p(Or.$$.fragment),ug=s(),rl=r("p"),gg=d("Names of the table\u2019s columns"),fg=s(),Ct=r("div"),p(Wr.$$.fragment),yg=s(),ol=r("p"),vg=d("Compute zero-copy slice of this Table"),$g=s(),Pt=r("div"),p(Xr.$$.fragment),_g=s(),nl=r("p"),Tg=d("Select records from a Table. See pyarrow.compute.filter for full usage."),wg=s(),Lt=r("div"),p(Hr.$$.fragment),xg=s(),sl=r("p"),Eg=d(`Flatten this Table.  Each column with a struct type is flattened
into one column per struct field.  Other columns are left unchanged.`),kg=s(),K=r("div"),p(Kr.$$.fragment),Ig=s(),ll=r("p"),Mg=d("Make a new table by combining the chunks this table has."),Dg=s(),dl=r("p"),Cg=d(`All the underlying chunks in the ChunkedArray of each column are
concatenated into zero or one chunk.`),Pg=s(),At=r("div"),p(Yr.$$.fragment),Lg=s(),cl=r("p"),Ag=d("Cast table values to another schema"),Ng=s(),Nt=r("div"),p(Gr.$$.fragment),jg=s(),il=r("p"),Fg=d(`EXPERIMENTAL: Create shallow copy of table by replacing schema
key-value metadata with the indicated new metadata (which may be None,
which deletes any existing metadata`),Vg=s(),Y=r("div"),p(Jr.$$.fragment),Sg=s(),pl=r("p"),qg=d("Add column to Table at position."),Rg=s(),ml=r("p"),Ug=d(`A new table is returned with the column added, the original table
object is left unchanged.`),zg=s(),jt=r("div"),p(Qr.$$.fragment),Bg=s(),bl=r("p"),Og=d("Append column at end of columns."),Wg=s(),Ft=r("div"),p(Zr.$$.fragment),Xg=s(),hl=r("p"),Hg=d("Create new Table with the indicated column removed."),Kg=s(),Vt=r("div"),p(eo.$$.fragment),Yg=s(),ul=r("p"),Gg=d("Replace column in Table at position."),Jg=s(),St=r("div"),p(to.$$.fragment),Qg=s(),gl=r("p"),Zg=d("Create new table with columns renamed to provided names."),ef=s(),qt=r("div"),p(ao.$$.fragment),tf=s(),fl=r("p"),af=d("Drop one or more columns and return a new table."),rf=s(),yo=r("div"),p(ro.$$.fragment),of=s(),Rt=r("div"),p(oo.$$.fragment),nf=s(),yl=r("p"),sf=d("Create ConcatenationTable from list of tables."),Al=s(),te=r("h2"),Ut=r("a"),vl=r("span"),p(no.$$.fragment),lf=s(),$l=r("span"),df=d("Utils"),Nl=s(),ae=r("div"),p(so.$$.fragment),cf=s(),_l=r("p"),pf=d("Concatenate tables."),jl=s(),re=r("div"),p(lo.$$.fragment),mf=s(),Tl=r("p"),bf=d(`Get the cache files that are loaded by the table.
Cache file are used when parts of the table come from the disk via memory mapping.`),this.h()},l(t){const k=$2('[data-svelte="svelte-1phssyn"]',document.head);D=o(k,"META",{name:!0,content:!0}),k.forEach(a),oe=l(t),P=o(t,"H1",{class:!0});var co=n(P);C=o(co,"A",{id:!0,class:!0,href:!0});var hf=n(C);A=o(hf,"SPAN",{});var uf=n(A);m(M.$$.fragment,uf),uf.forEach(a),hf.forEach(a),N=l(co),jo=o(co,"SPAN",{});var gf=n(jo);Cc=c(gf,"Table Classes"),gf.forEach(a),co.forEach(a),xl=l(t),j=o(t,"P",{});var vo=n(j);Pc=c(vo,"Each "),Fo=o(vo,"CODE",{});var ff=n(Fo);Lc=c(ff,"Dataset"),ff.forEach(a),Ac=c(vo,` object is backed by a PyArrow Table.
A Table can be loaded from either the disk (memory mapped) or in memory.
Several Table types are available, and they all inherit from `),io=o(vo,"A",{href:!0});var yf=n(io);Nc=c(yf,"table.Table"),yf.forEach(a),jc=c(vo,"."),vo.forEach(a),El=l(t),J=o(t,"H2",{class:!0});var Vl=n(J);ne=o(Vl,"A",{id:!0,class:!0,href:!0});var vf=n(ne);Vo=o(vf,"SPAN",{});var $f=n(Vo);m(zt.$$.fragment,$f),$f.forEach(a),vf.forEach(a),Fc=l(Vl),So=o(Vl,"SPAN",{});var _f=n(So);Vc=c(_f,"Table"),_f.forEach(a),Vl.forEach(a),kl=l(t),x=o(t,"DIV",{class:!0});var E=n(x);m(Bt.$$.fragment,E),Sc=l(E),qo=o(E,"P",{});var Tf=n(qo);qc=c(Tf,`Wraps a pyarrow Table by using composition.
This is the base class for InMemoryTable, MemoryMappedTable and ConcatenationTable.`),Tf.forEach(a),Rc=l(E),Ro=o(E,"P",{});var wf=n(Ro);Uc=c(wf,`It implements all the basic attributes/methods of the pyarrow Table class except
the Table transforms: slice, filter, flatten, combine_chunks, cast, add_column,
append_column, remove_column, set_column, rename_columns and drop.`),wf.forEach(a),zc=l(E),Uo=o(E,"P",{});var xf=n(Uo);Bc=c(xf,"The implementation of these methods differs for the subclasses."),xf.forEach(a),Oc=l(E),F=o(E,"DIV",{class:!0});var $o=n(F);m(Ot.$$.fragment,$o),Wc=l($o),zo=o($o,"P",{});var Ef=n(zo);Xc=c(Ef,"Perform validation checks.  An exception is raised if validation fails."),Ef.forEach(a),Hc=l($o),Wt=o($o,"P",{});var Sl=n(Wt);Kc=c(Sl,"By default only cheap validation checks are run.  Pass "),Bo=o(Sl,"EM",{});var kf=n(Bo);Yc=c(kf,"full=True"),kf.forEach(a),Gc=c(Sl,`
for thorough validation checks (potentially O(n)).`),Sl.forEach(a),$o.forEach(a),Jc=l(E),se=o(E,"DIV",{class:!0});var ql=n(se);m(Xt.$$.fragment,ql),Qc=l(ql),Oo=o(ql,"P",{});var If=n(Oo);Zc=c(If,"Check if contents of two tables are equal."),If.forEach(a),ql.forEach(a),ei=l(E),le=o(E,"DIV",{class:!0});var Rl=n(le);m(Ht.$$.fragment,Rl),ti=l(Rl),Wo=o(Rl,"P",{});var Mf=n(Wo);ai=c(Mf,"Convert Table to list of (contiguous) RecordBatch objects."),Mf.forEach(a),Rl.forEach(a),ri=l(E),de=o(E,"DIV",{class:!0});var Ul=n(de);m(Kt.$$.fragment,Ul),oi=l(Ul),Xo=o(Ul,"P",{});var Df=n(Xo);ni=c(Df,"Convert the Table to a dict or OrderedDict."),Df.forEach(a),Ul.forEach(a),si=l(E),ce=o(E,"DIV",{class:!0});var zl=n(ce);m(Yt.$$.fragment,zl),li=l(zl),Ho=o(zl,"P",{});var Cf=n(Ho);di=c(Cf,"Convert to a pandas-compatible NumPy array or DataFrame, as appropriate"),Cf.forEach(a),zl.forEach(a),ci=l(E),po=o(E,"DIV",{class:!0});var Pf=n(po);m(Gt.$$.fragment,Pf),Pf.forEach(a),ii=l(E),ie=o(E,"DIV",{class:!0});var Bl=n(ie);m(Jt.$$.fragment,Bl),pi=l(Bl),Ko=o(Bl,"P",{});var Lf=n(Ko);mi=c(Lf,"Select a schema field by its column name or numeric index."),Lf.forEach(a),Bl.forEach(a),bi=l(E),pe=o(E,"DIV",{class:!0});var Ol=n(pe);m(Qt.$$.fragment,Ol),hi=l(Ol),Yo=o(Ol,"P",{});var Af=n(Yo);ui=c(Af,"Select a column by its column name, or numeric index."),Af.forEach(a),Ol.forEach(a),gi=l(E),me=o(E,"DIV",{class:!0});var Wl=n(me);m(Zt.$$.fragment,Wl),fi=l(Wl),Go=o(Wl,"P",{});var Nf=n(Go);yi=c(Nf,"Iterator over all columns in their numerical order."),Nf.forEach(a),Wl.forEach(a),vi=l(E),be=o(E,"DIV",{class:!0});var Xl=n(be);m(ea.$$.fragment,Xl),$i=l(Xl),Jo=o(Xl,"P",{});var jf=n(Jo);_i=c(jf,"Schema of the table and its columns."),jf.forEach(a),Xl.forEach(a),Ti=l(E),he=o(E,"DIV",{class:!0});var Hl=n(he);m(ta.$$.fragment,Hl),wi=l(Hl),Qo=o(Hl,"P",{});var Ff=n(Qo);xi=c(Ff,"List of all columns in numerical order."),Ff.forEach(a),Hl.forEach(a),Ei=l(E),ue=o(E,"DIV",{class:!0});var Kl=n(ue);m(aa.$$.fragment,Kl),ki=l(Kl),Zo=o(Kl,"P",{});var Vf=n(Zo);Ii=c(Vf,"Number of columns in this table."),Vf.forEach(a),Kl.forEach(a),Mi=l(E),V=o(E,"DIV",{class:!0});var _o=n(V);m(ra.$$.fragment,_o),Di=l(_o),en=o(_o,"P",{});var Sf=n(en);Ci=c(Sf,"Number of rows in this table."),Sf.forEach(a),Pi=l(_o),tn=o(_o,"P",{});var qf=n(tn);Li=c(qf,`Due to the definition of a table, all columns have the same number of
rows.`),qf.forEach(a),_o.forEach(a),Ai=l(E),ge=o(E,"DIV",{class:!0});var Yl=n(ge);m(oa.$$.fragment,Yl),Ni=l(Yl),an=o(Yl,"P",{});var Rf=n(an);ji=c(Rf,"Dimensions of the table: (#rows, #columns)."),Rf.forEach(a),Yl.forEach(a),Fi=l(E),fe=o(E,"DIV",{class:!0});var Gl=n(fe);m(na.$$.fragment,Gl),Vi=l(Gl),rn=o(Gl,"P",{});var Uf=n(rn);Si=c(Uf,"Total number of bytes consumed by the elements of the table."),Uf.forEach(a),Gl.forEach(a),E.forEach(a),Il=l(t),Q=o(t,"H2",{class:!0});var Jl=n(Q);ye=o(Jl,"A",{id:!0,class:!0,href:!0});var zf=n(ye);on=o(zf,"SPAN",{});var Bf=n(on);m(sa.$$.fragment,Bf),Bf.forEach(a),zf.forEach(a),qi=l(Jl),nn=o(Jl,"SPAN",{});var Of=n(nn);Ri=c(Of,"InMemoryTable"),Of.forEach(a),Jl.forEach(a),Ml=l(t),y=o(t,"DIV",{class:!0});var $=n(y);m(la.$$.fragment,$),Ui=l($),sn=o($,"P",{});var Wf=n(sn);zi=c(Wf,"The table is said in-memory when it is loaded into the user\u2019s RAM."),Wf.forEach(a),Bi=l($),ln=o($,"P",{});var Xf=n(ln);Oi=c(Xf,`Pickling it does copy all the data using memory.
Its implementation is simple and uses the underlying pyarrow Table methods directly.`),Xf.forEach(a),Wi=l($),dn=o($,"P",{});var Hf=n(dn);Xi=c(Hf,`This is different from the MemoryMapped table, for which pickling doesn\u2019t copy all the
data in memory. For a MemoryMapped, unpickling instead reloads the table from the disk.`),Hf.forEach(a),Hi=l($),cn=o($,"P",{});var Kf=n(cn);Ki=c(Kf,`InMemoryTable must be used when data fit in memory, while MemoryMapped are reserved for
data bigger than memory or when you want the memory footprint of your application to
stay low.`),Kf.forEach(a),Yi=l($),S=o($,"DIV",{class:!0});var To=n(S);m(da.$$.fragment,To),Gi=l(To),pn=o(To,"P",{});var Yf=n(pn);Ji=c(Yf,"Perform validation checks.  An exception is raised if validation fails."),Yf.forEach(a),Qi=l(To),ca=o(To,"P",{});var Ql=n(ca);Zi=c(Ql,"By default only cheap validation checks are run.  Pass "),mn=o(Ql,"EM",{});var Gf=n(mn);ep=c(Gf,"full=True"),Gf.forEach(a),tp=c(Ql,`
for thorough validation checks (potentially O(n)).`),Ql.forEach(a),To.forEach(a),ap=l($),ve=o($,"DIV",{class:!0});var Zl=n(ve);m(ia.$$.fragment,Zl),rp=l(Zl),bn=o(Zl,"P",{});var Jf=n(bn);op=c(Jf,"Check if contents of two tables are equal."),Jf.forEach(a),Zl.forEach(a),np=l($),$e=o($,"DIV",{class:!0});var ed=n($e);m(pa.$$.fragment,ed),sp=l(ed),hn=o(ed,"P",{});var Qf=n(hn);lp=c(Qf,"Convert Table to list of (contiguous) RecordBatch objects."),Qf.forEach(a),ed.forEach(a),dp=l($),_e=o($,"DIV",{class:!0});var td=n(_e);m(ma.$$.fragment,td),cp=l(td),un=o(td,"P",{});var Zf=n(un);ip=c(Zf,"Convert the Table to a dict or OrderedDict."),Zf.forEach(a),td.forEach(a),pp=l($),Te=o($,"DIV",{class:!0});var ad=n(Te);m(ba.$$.fragment,ad),mp=l(ad),gn=o(ad,"P",{});var ey=n(gn);bp=c(ey,"Convert to a pandas-compatible NumPy array or DataFrame, as appropriate"),ey.forEach(a),ad.forEach(a),hp=l($),mo=o($,"DIV",{class:!0});var ty=n(mo);m(ha.$$.fragment,ty),ty.forEach(a),up=l($),we=o($,"DIV",{class:!0});var rd=n(we);m(ua.$$.fragment,rd),gp=l(rd),fn=o(rd,"P",{});var ay=n(fn);fp=c(ay,"Select a schema field by its column name or numeric index."),ay.forEach(a),rd.forEach(a),yp=l($),xe=o($,"DIV",{class:!0});var od=n(xe);m(ga.$$.fragment,od),vp=l(od),yn=o(od,"P",{});var ry=n(yn);$p=c(ry,"Select a column by its column name, or numeric index."),ry.forEach(a),od.forEach(a),_p=l($),Ee=o($,"DIV",{class:!0});var nd=n(Ee);m(fa.$$.fragment,nd),Tp=l(nd),vn=o(nd,"P",{});var oy=n(vn);wp=c(oy,"Iterator over all columns in their numerical order."),oy.forEach(a),nd.forEach(a),xp=l($),ke=o($,"DIV",{class:!0});var sd=n(ke);m(ya.$$.fragment,sd),Ep=l(sd),$n=o(sd,"P",{});var ny=n($n);kp=c(ny,"Schema of the table and its columns."),ny.forEach(a),sd.forEach(a),Ip=l($),Ie=o($,"DIV",{class:!0});var ld=n(Ie);m(va.$$.fragment,ld),Mp=l(ld),_n=o(ld,"P",{});var sy=n(_n);Dp=c(sy,"List of all columns in numerical order."),sy.forEach(a),ld.forEach(a),Cp=l($),Me=o($,"DIV",{class:!0});var dd=n(Me);m($a.$$.fragment,dd),Pp=l(dd),Tn=o(dd,"P",{});var ly=n(Tn);Lp=c(ly,"Number of columns in this table."),ly.forEach(a),dd.forEach(a),Ap=l($),q=o($,"DIV",{class:!0});var wo=n(q);m(_a.$$.fragment,wo),Np=l(wo),wn=o(wo,"P",{});var dy=n(wn);jp=c(dy,"Number of rows in this table."),dy.forEach(a),Fp=l(wo),xn=o(wo,"P",{});var cy=n(xn);Vp=c(cy,`Due to the definition of a table, all columns have the same number of
rows.`),cy.forEach(a),wo.forEach(a),Sp=l($),De=o($,"DIV",{class:!0});var cd=n(De);m(Ta.$$.fragment,cd),qp=l(cd),En=o(cd,"P",{});var iy=n(En);Rp=c(iy,"Dimensions of the table: (#rows, #columns)."),iy.forEach(a),cd.forEach(a),Up=l($),Ce=o($,"DIV",{class:!0});var id=n(Ce);m(wa.$$.fragment,id),zp=l(id),kn=o(id,"P",{});var py=n(kn);Bp=c(py,"Total number of bytes consumed by the elements of the table."),py.forEach(a),id.forEach(a),Op=l($),Pe=o($,"DIV",{class:!0});var pd=n(Pe);m(xa.$$.fragment,pd),Wp=l(pd),In=o(pd,"P",{});var my=n(In);Xp=c(my,"Names of the table\u2019s columns"),my.forEach(a),pd.forEach(a),Hp=l($),Le=o($,"DIV",{class:!0});var md=n(Le);m(Ea.$$.fragment,md),Kp=l(md),Mn=o(md,"P",{});var by=n(Mn);Yp=c(by,"Compute zero-copy slice of this Table"),by.forEach(a),md.forEach(a),Gp=l($),Ae=o($,"DIV",{class:!0});var bd=n(Ae);m(ka.$$.fragment,bd),Jp=l(bd),Dn=o(bd,"P",{});var hy=n(Dn);Qp=c(hy,"Select records from a Table. See pyarrow.compute.filter for full usage."),hy.forEach(a),bd.forEach(a),Zp=l($),Ne=o($,"DIV",{class:!0});var hd=n(Ne);m(Ia.$$.fragment,hd),em=l(hd),Cn=o(hd,"P",{});var uy=n(Cn);tm=c(uy,`Flatten this Table.  Each column with a struct type is flattened
into one column per struct field.  Other columns are left unchanged.`),uy.forEach(a),hd.forEach(a),am=l($),R=o($,"DIV",{class:!0});var xo=n(R);m(Ma.$$.fragment,xo),rm=l(xo),Pn=o(xo,"P",{});var gy=n(Pn);om=c(gy,"Make a new table by combining the chunks this table has."),gy.forEach(a),nm=l(xo),Ln=o(xo,"P",{});var fy=n(Ln);sm=c(fy,`All the underlying chunks in the ChunkedArray of each column are
concatenated into zero or one chunk.`),fy.forEach(a),xo.forEach(a),lm=l($),je=o($,"DIV",{class:!0});var ud=n(je);m(Da.$$.fragment,ud),dm=l(ud),An=o(ud,"P",{});var yy=n(An);cm=c(yy,"Cast table values to another schema"),yy.forEach(a),ud.forEach(a),im=l($),Fe=o($,"DIV",{class:!0});var gd=n(Fe);m(Ca.$$.fragment,gd),pm=l(gd),Nn=o(gd,"P",{});var vy=n(Nn);mm=c(vy,`EXPERIMENTAL: Create shallow copy of table by replacing schema
key-value metadata with the indicated new metadata (which may be None,
which deletes any existing metadata`),vy.forEach(a),gd.forEach(a),bm=l($),U=o($,"DIV",{class:!0});var Eo=n(U);m(Pa.$$.fragment,Eo),hm=l(Eo),jn=o(Eo,"P",{});var $y=n(jn);um=c($y,"Add column to Table at position."),$y.forEach(a),gm=l(Eo),Fn=o(Eo,"P",{});var _y=n(Fn);fm=c(_y,`A new table is returned with the column added, the original table
object is left unchanged.`),_y.forEach(a),Eo.forEach(a),ym=l($),Ve=o($,"DIV",{class:!0});var fd=n(Ve);m(La.$$.fragment,fd),vm=l(fd),Vn=o(fd,"P",{});var Ty=n(Vn);$m=c(Ty,"Append column at end of columns."),Ty.forEach(a),fd.forEach(a),_m=l($),Se=o($,"DIV",{class:!0});var yd=n(Se);m(Aa.$$.fragment,yd),Tm=l(yd),Sn=o(yd,"P",{});var wy=n(Sn);wm=c(wy,"Create new Table with the indicated column removed."),wy.forEach(a),yd.forEach(a),xm=l($),qe=o($,"DIV",{class:!0});var vd=n(qe);m(Na.$$.fragment,vd),Em=l(vd),qn=o(vd,"P",{});var xy=n(qn);km=c(xy,"Replace column in Table at position."),xy.forEach(a),vd.forEach(a),Im=l($),Re=o($,"DIV",{class:!0});var $d=n(Re);m(ja.$$.fragment,$d),Mm=l($d),Rn=o($d,"P",{});var Ey=n(Rn);Dm=c(Ey,"Create new table with columns renamed to provided names."),Ey.forEach(a),$d.forEach(a),Cm=l($),Ue=o($,"DIV",{class:!0});var _d=n(Ue);m(Fa.$$.fragment,_d),Pm=l(_d),Un=o(_d,"P",{});var ky=n(Un);Lm=c(ky,"Drop one or more columns and return a new table."),ky.forEach(a),_d.forEach(a),Am=l($),bo=o($,"DIV",{class:!0});var Iy=n(bo);m(Va.$$.fragment,Iy),Iy.forEach(a),Nm=l($),ho=o($,"DIV",{class:!0});var My=n(ho);m(Sa.$$.fragment,My),My.forEach(a),jm=l($),L=o($,"DIV",{class:!0});var G=n(L);m(qa.$$.fragment,G),Fm=l(G),zn=o(G,"P",{});var Dy=n(zn);Vm=c(Dy,"Convert pandas.DataFrame to an Arrow Table."),Dy.forEach(a),Sm=l(G),Ra=o(G,"P",{});var Td=n(Ra);qm=c(Td,`The column types in the resulting Arrow Table are inferred from the
dtypes of the pandas.Series in the DataFrame. In the case of non-object
Series, the NumPy dtype is translated to its Arrow equivalent. In the
case of `),Bn=o(Td,"EM",{});var Cy=n(Bn);Rm=c(Cy,"object"),Cy.forEach(a),Um=c(Td,`, we need to guess the datatype by looking at the
Python objects in this Series.`),Td.forEach(a),zm=l(G),Ua=o(G,"P",{});var wd=n(Ua);Bm=c(wd,"Be aware that Series of the "),On=o(wd,"EM",{});var Py=n(On);Om=c(Py,"object"),Py.forEach(a),Wm=c(wd,` dtype don\u2019t carry enough
information to always lead to a meaningful Arrow type. In the case that
we cannot infer a type, e.g. because the DataFrame is of length 0 or
the Series only contains None/nan objects, the type is set to
null. This behavior can be avoided by constructing an explicit schema
and passing it to this function.`),wd.forEach(a),Xm=l(G),m(ze.$$.fragment,G),G.forEach(a),Hm=l($),Be=o($,"DIV",{class:!0});var xd=n(Be);m(za.$$.fragment,xd),Km=l(xd),Wn=o(xd,"P",{});var Ly=n(Wn);Ym=c(Ly,"Construct a Table from Arrow arrays"),Ly.forEach(a),xd.forEach(a),Gm=l($),Oe=o($,"DIV",{class:!0});var Ed=n(Oe);m(Ba.$$.fragment,Ed),Jm=l(Ed),Xn=o(Ed,"P",{});var Ay=n(Xn);Qm=c(Ay,"Construct a Table from Arrow arrays or columns"),Ay.forEach(a),Ed.forEach(a),Zm=l($),We=o($,"DIV",{class:!0});var kd=n(We);m(Oa.$$.fragment,kd),eb=l(kd),Hn=o(kd,"P",{});var Ny=n(Hn);tb=c(Ny,"Construct a Table from a sequence or iterator of Arrow RecordBatches."),Ny.forEach(a),kd.forEach(a),$.forEach(a),Dl=l(t),Z=o(t,"H2",{class:!0});var Id=n(Z);Xe=o(Id,"A",{id:!0,class:!0,href:!0});var jy=n(Xe);Kn=o(jy,"SPAN",{});var Fy=n(Kn);m(Wa.$$.fragment,Fy),Fy.forEach(a),jy.forEach(a),ab=l(Id),Yn=o(Id,"SPAN",{});var Vy=n(Yn);rb=c(Vy,"MemoryMappedTable"),Vy.forEach(a),Id.forEach(a),Cl=l(t),_=o(t,"DIV",{class:!0});var w=n(_);m(Xa.$$.fragment,w),ob=l(w),Gn=o(w,"P",{});var Sy=n(Gn);nb=c(Sy,`The table is said memory mapped when it doesn\u2019t use the user\u2019s RAM but loads the data
from the disk instead.`),Sy.forEach(a),sb=l(w),Jn=o(w,"P",{});var qy=n(Jn);lb=c(qy,`Pickling it doesn\u2019t copy the data into memory.
Instead, only the path to the memory mapped arrow file is pickled, as well as the list
of transforms to \u201Creplay\u201D when reloading the table from the disk.`),qy.forEach(a),db=l(w),Qn=o(w,"P",{});var Ry=n(Qn);cb=c(Ry,`Its implementation requires to store an history of all the transforms that were applied
to the underlying pyarrow Table, so that they can be \u201Creplayed\u201D when reloading the Table
from the disk.`),Ry.forEach(a),ib=l(w),Zn=o(w,"P",{});var Uy=n(Zn);pb=c(Uy,`This is different from the InMemoryTable table, for which pickling does copy all the
data in memory.`),Uy.forEach(a),mb=l(w),es=o(w,"P",{});var zy=n(es);bb=c(zy,`InMemoryTable must be used when data fit in memory, while MemoryMapped are reserved for
data bigger than memory or when you want the memory footprint of your application to
stay low.`),zy.forEach(a),hb=l(w),z=o(w,"DIV",{class:!0});var ko=n(z);m(Ha.$$.fragment,ko),ub=l(ko),ts=o(ko,"P",{});var By=n(ts);gb=c(By,"Perform validation checks.  An exception is raised if validation fails."),By.forEach(a),fb=l(ko),Ka=o(ko,"P",{});var Md=n(Ka);yb=c(Md,"By default only cheap validation checks are run.  Pass "),as=o(Md,"EM",{});var Oy=n(as);vb=c(Oy,"full=True"),Oy.forEach(a),$b=c(Md,`
for thorough validation checks (potentially O(n)).`),Md.forEach(a),ko.forEach(a),_b=l(w),He=o(w,"DIV",{class:!0});var Dd=n(He);m(Ya.$$.fragment,Dd),Tb=l(Dd),rs=o(Dd,"P",{});var Wy=n(rs);wb=c(Wy,"Check if contents of two tables are equal."),Wy.forEach(a),Dd.forEach(a),xb=l(w),Ke=o(w,"DIV",{class:!0});var Cd=n(Ke);m(Ga.$$.fragment,Cd),Eb=l(Cd),os=o(Cd,"P",{});var Xy=n(os);kb=c(Xy,"Convert Table to list of (contiguous) RecordBatch objects."),Xy.forEach(a),Cd.forEach(a),Ib=l(w),Ye=o(w,"DIV",{class:!0});var Pd=n(Ye);m(Ja.$$.fragment,Pd),Mb=l(Pd),ns=o(Pd,"P",{});var Hy=n(ns);Db=c(Hy,"Convert the Table to a dict or OrderedDict."),Hy.forEach(a),Pd.forEach(a),Cb=l(w),Ge=o(w,"DIV",{class:!0});var Ld=n(Ge);m(Qa.$$.fragment,Ld),Pb=l(Ld),ss=o(Ld,"P",{});var Ky=n(ss);Lb=c(Ky,"Convert to a pandas-compatible NumPy array or DataFrame, as appropriate"),Ky.forEach(a),Ld.forEach(a),Ab=l(w),uo=o(w,"DIV",{class:!0});var Yy=n(uo);m(Za.$$.fragment,Yy),Yy.forEach(a),Nb=l(w),Je=o(w,"DIV",{class:!0});var Ad=n(Je);m(er.$$.fragment,Ad),jb=l(Ad),ls=o(Ad,"P",{});var Gy=n(ls);Fb=c(Gy,"Select a schema field by its column name or numeric index."),Gy.forEach(a),Ad.forEach(a),Vb=l(w),Qe=o(w,"DIV",{class:!0});var Nd=n(Qe);m(tr.$$.fragment,Nd),Sb=l(Nd),ds=o(Nd,"P",{});var Jy=n(ds);qb=c(Jy,"Select a column by its column name, or numeric index."),Jy.forEach(a),Nd.forEach(a),Rb=l(w),Ze=o(w,"DIV",{class:!0});var jd=n(Ze);m(ar.$$.fragment,jd),Ub=l(jd),cs=o(jd,"P",{});var Qy=n(cs);zb=c(Qy,"Iterator over all columns in their numerical order."),Qy.forEach(a),jd.forEach(a),Bb=l(w),et=o(w,"DIV",{class:!0});var Fd=n(et);m(rr.$$.fragment,Fd),Ob=l(Fd),is=o(Fd,"P",{});var Zy=n(is);Wb=c(Zy,"Schema of the table and its columns."),Zy.forEach(a),Fd.forEach(a),Xb=l(w),tt=o(w,"DIV",{class:!0});var Vd=n(tt);m(or.$$.fragment,Vd),Hb=l(Vd),ps=o(Vd,"P",{});var ev=n(ps);Kb=c(ev,"List of all columns in numerical order."),ev.forEach(a),Vd.forEach(a),Yb=l(w),at=o(w,"DIV",{class:!0});var Sd=n(at);m(nr.$$.fragment,Sd),Gb=l(Sd),ms=o(Sd,"P",{});var tv=n(ms);Jb=c(tv,"Number of columns in this table."),tv.forEach(a),Sd.forEach(a),Qb=l(w),B=o(w,"DIV",{class:!0});var Io=n(B);m(sr.$$.fragment,Io),Zb=l(Io),bs=o(Io,"P",{});var av=n(bs);eh=c(av,"Number of rows in this table."),av.forEach(a),th=l(Io),hs=o(Io,"P",{});var rv=n(hs);ah=c(rv,`Due to the definition of a table, all columns have the same number of
rows.`),rv.forEach(a),Io.forEach(a),rh=l(w),rt=o(w,"DIV",{class:!0});var qd=n(rt);m(lr.$$.fragment,qd),oh=l(qd),us=o(qd,"P",{});var ov=n(us);nh=c(ov,"Dimensions of the table: (#rows, #columns)."),ov.forEach(a),qd.forEach(a),sh=l(w),ot=o(w,"DIV",{class:!0});var Rd=n(ot);m(dr.$$.fragment,Rd),lh=l(Rd),gs=o(Rd,"P",{});var nv=n(gs);dh=c(nv,"Total number of bytes consumed by the elements of the table."),nv.forEach(a),Rd.forEach(a),ch=l(w),nt=o(w,"DIV",{class:!0});var Ud=n(nt);m(cr.$$.fragment,Ud),ih=l(Ud),fs=o(Ud,"P",{});var sv=n(fs);ph=c(sv,"Names of the table\u2019s columns"),sv.forEach(a),Ud.forEach(a),mh=l(w),st=o(w,"DIV",{class:!0});var zd=n(st);m(ir.$$.fragment,zd),bh=l(zd),ys=o(zd,"P",{});var lv=n(ys);hh=c(lv,"Compute zero-copy slice of this Table"),lv.forEach(a),zd.forEach(a),uh=l(w),lt=o(w,"DIV",{class:!0});var Bd=n(lt);m(pr.$$.fragment,Bd),gh=l(Bd),vs=o(Bd,"P",{});var dv=n(vs);fh=c(dv,"Select records from a Table. See pyarrow.compute.filter for full usage."),dv.forEach(a),Bd.forEach(a),yh=l(w),dt=o(w,"DIV",{class:!0});var Od=n(dt);m(mr.$$.fragment,Od),vh=l(Od),$s=o(Od,"P",{});var cv=n($s);$h=c(cv,`Flatten this Table.  Each column with a struct type is flattened
into one column per struct field.  Other columns are left unchanged.`),cv.forEach(a),Od.forEach(a),_h=l(w),O=o(w,"DIV",{class:!0});var Mo=n(O);m(br.$$.fragment,Mo),Th=l(Mo),_s=o(Mo,"P",{});var iv=n(_s);wh=c(iv,"Make a new table by combining the chunks this table has."),iv.forEach(a),xh=l(Mo),Ts=o(Mo,"P",{});var pv=n(Ts);Eh=c(pv,`All the underlying chunks in the ChunkedArray of each column are
concatenated into zero or one chunk.`),pv.forEach(a),Mo.forEach(a),kh=l(w),ct=o(w,"DIV",{class:!0});var Wd=n(ct);m(hr.$$.fragment,Wd),Ih=l(Wd),ws=o(Wd,"P",{});var mv=n(ws);Mh=c(mv,"Cast table values to another schema"),mv.forEach(a),Wd.forEach(a),Dh=l(w),it=o(w,"DIV",{class:!0});var Xd=n(it);m(ur.$$.fragment,Xd),Ch=l(Xd),xs=o(Xd,"P",{});var bv=n(xs);Ph=c(bv,`EXPERIMENTAL: Create shallow copy of table by replacing schema
key-value metadata with the indicated new metadata (which may be None,
which deletes any existing metadata`),bv.forEach(a),Xd.forEach(a),Lh=l(w),W=o(w,"DIV",{class:!0});var Do=n(W);m(gr.$$.fragment,Do),Ah=l(Do),Es=o(Do,"P",{});var hv=n(Es);Nh=c(hv,"Add column to Table at position."),hv.forEach(a),jh=l(Do),ks=o(Do,"P",{});var uv=n(ks);Fh=c(uv,`A new table is returned with the column added, the original table
object is left unchanged.`),uv.forEach(a),Do.forEach(a),Vh=l(w),pt=o(w,"DIV",{class:!0});var Hd=n(pt);m(fr.$$.fragment,Hd),Sh=l(Hd),Is=o(Hd,"P",{});var gv=n(Is);qh=c(gv,"Append column at end of columns."),gv.forEach(a),Hd.forEach(a),Rh=l(w),mt=o(w,"DIV",{class:!0});var Kd=n(mt);m(yr.$$.fragment,Kd),Uh=l(Kd),Ms=o(Kd,"P",{});var fv=n(Ms);zh=c(fv,"Create new Table with the indicated column removed."),fv.forEach(a),Kd.forEach(a),Bh=l(w),bt=o(w,"DIV",{class:!0});var Yd=n(bt);m(vr.$$.fragment,Yd),Oh=l(Yd),Ds=o(Yd,"P",{});var yv=n(Ds);Wh=c(yv,"Replace column in Table at position."),yv.forEach(a),Yd.forEach(a),Xh=l(w),ht=o(w,"DIV",{class:!0});var Gd=n(ht);m($r.$$.fragment,Gd),Hh=l(Gd),Cs=o(Gd,"P",{});var vv=n(Cs);Kh=c(vv,"Create new table with columns renamed to provided names."),vv.forEach(a),Gd.forEach(a),Yh=l(w),ut=o(w,"DIV",{class:!0});var Jd=n(ut);m(_r.$$.fragment,Jd),Gh=l(Jd),Ps=o(Jd,"P",{});var $v=n(Ps);Jh=c($v,"Drop one or more columns and return a new table."),$v.forEach(a),Jd.forEach(a),Qh=l(w),go=o(w,"DIV",{class:!0});var _v=n(go);m(Tr.$$.fragment,_v),_v.forEach(a),w.forEach(a),Pl=l(t),ee=o(t,"H2",{class:!0});var Qd=n(ee);gt=o(Qd,"A",{id:!0,class:!0,href:!0});var Tv=n(gt);Ls=o(Tv,"SPAN",{});var wv=n(Ls);m(wr.$$.fragment,wv),wv.forEach(a),Tv.forEach(a),Zh=l(Qd),As=o(Qd,"SPAN",{});var xv=n(As);eu=c(xv,"ConcatenationTable"),xv.forEach(a),Qd.forEach(a),Ll=l(t),v=o(t,"DIV",{class:!0});var T=n(v);m(xr.$$.fragment,T),tu=l(T),Ns=o(T,"P",{});var Ev=n(Ns);au=c(Ev,`The table comes from the concatenation of several tables called blocks.
It enables concatenation on both axis 0 (append rows) and axis 1 (append columns).`),Ev.forEach(a),ru=l(T),js=o(T,"P",{});var kv=n(js);ou=c(kv,`The underlying tables are called \u201Cblocks\u201D and can be either InMemoryTable
or MemoryMappedTable objects.
This allows to combine tables that come from memory or that are memory mapped.
When a ConcatenationTable is pickled, then each block is pickled:`),kv.forEach(a),nu=l(T),Er=o(T,"UL",{});var Zd=n(Er);Fs=o(Zd,"LI",{});var Iv=n(Fs);su=c(Iv,"the InMemoryTable objects are pickled by copying all the data in memory;"),Iv.forEach(a),lu=l(Zd),Vs=o(Zd,"LI",{});var Mv=n(Vs);du=c(Mv,`the MemoryMappedTable objects are pickled without copying the data into memory.
Instead, only the path to the memory mapped arrow file is pickled, as well as the list
of transforms to \u201Creplays\u201D when reloading the table from the disk.`),Mv.forEach(a),Zd.forEach(a),cu=l(T),kr=o(T,"P",{});var ec=n(kr);iu=c(ec,`Its implementation requires to store each block separately.
The `),Ss=o(ec,"CODE",{});var Dv=n(Ss);pu=c(Dv,"blocks"),Dv.forEach(a),mu=c(ec,` attributes stores a list of list of blocks.
The first axis concatenates the tables along the axis 0 (it appends rows),
while the second axis concatenates tables along the axis 1 (it appends columns).`),ec.forEach(a),bu=l(T),Ir=o(T,"P",{});var tc=n(Ir);hu=c(tc,`If some columns are missing when concatenating on axis 0, they are filled with null values.
This is done using `),qs=o(tc,"EM",{});var Cv=n(qs);uu=c(Cv,"pyarrow.concat_tables(tables, promote=True)"),Cv.forEach(a),gu=c(tc,"."),tc.forEach(a),fu=l(T),Rs=o(T,"P",{});var Pv=n(Rs);yu=c(Pv,`You can access the fully combined table by accessing the ConcatenationTable.table attribute,
and the blocks by accessing the ConcatenationTable.blocks attribute.`),Pv.forEach(a),vu=l(T),X=o(T,"DIV",{class:!0});var Co=n(X);m(Mr.$$.fragment,Co),$u=l(Co),Us=o(Co,"P",{});var Lv=n(Us);_u=c(Lv,"Perform validation checks.  An exception is raised if validation fails."),Lv.forEach(a),Tu=l(Co),Dr=o(Co,"P",{});var ac=n(Dr);wu=c(ac,"By default only cheap validation checks are run.  Pass "),zs=o(ac,"EM",{});var Av=n(zs);xu=c(Av,"full=True"),Av.forEach(a),Eu=c(ac,`
for thorough validation checks (potentially O(n)).`),ac.forEach(a),Co.forEach(a),ku=l(T),ft=o(T,"DIV",{class:!0});var rc=n(ft);m(Cr.$$.fragment,rc),Iu=l(rc),Bs=o(rc,"P",{});var Nv=n(Bs);Mu=c(Nv,"Check if contents of two tables are equal."),Nv.forEach(a),rc.forEach(a),Du=l(T),yt=o(T,"DIV",{class:!0});var oc=n(yt);m(Pr.$$.fragment,oc),Cu=l(oc),Os=o(oc,"P",{});var jv=n(Os);Pu=c(jv,"Convert Table to list of (contiguous) RecordBatch objects."),jv.forEach(a),oc.forEach(a),Lu=l(T),vt=o(T,"DIV",{class:!0});var nc=n(vt);m(Lr.$$.fragment,nc),Au=l(nc),Ws=o(nc,"P",{});var Fv=n(Ws);Nu=c(Fv,"Convert the Table to a dict or OrderedDict."),Fv.forEach(a),nc.forEach(a),ju=l(T),$t=o(T,"DIV",{class:!0});var sc=n($t);m(Ar.$$.fragment,sc),Fu=l(sc),Xs=o(sc,"P",{});var Vv=n(Xs);Vu=c(Vv,"Convert to a pandas-compatible NumPy array or DataFrame, as appropriate"),Vv.forEach(a),sc.forEach(a),Su=l(T),fo=o(T,"DIV",{class:!0});var Sv=n(fo);m(Nr.$$.fragment,Sv),Sv.forEach(a),qu=l(T),_t=o(T,"DIV",{class:!0});var lc=n(_t);m(jr.$$.fragment,lc),Ru=l(lc),Hs=o(lc,"P",{});var qv=n(Hs);Uu=c(qv,"Select a schema field by its column name or numeric index."),qv.forEach(a),lc.forEach(a),zu=l(T),Tt=o(T,"DIV",{class:!0});var dc=n(Tt);m(Fr.$$.fragment,dc),Bu=l(dc),Ks=o(dc,"P",{});var Rv=n(Ks);Ou=c(Rv,"Select a column by its column name, or numeric index."),Rv.forEach(a),dc.forEach(a),Wu=l(T),wt=o(T,"DIV",{class:!0});var cc=n(wt);m(Vr.$$.fragment,cc),Xu=l(cc),Ys=o(cc,"P",{});var Uv=n(Ys);Hu=c(Uv,"Iterator over all columns in their numerical order."),Uv.forEach(a),cc.forEach(a),Ku=l(T),xt=o(T,"DIV",{class:!0});var ic=n(xt);m(Sr.$$.fragment,ic),Yu=l(ic),Gs=o(ic,"P",{});var zv=n(Gs);Gu=c(zv,"Schema of the table and its columns."),zv.forEach(a),ic.forEach(a),Ju=l(T),Et=o(T,"DIV",{class:!0});var pc=n(Et);m(qr.$$.fragment,pc),Qu=l(pc),Js=o(pc,"P",{});var Bv=n(Js);Zu=c(Bv,"List of all columns in numerical order."),Bv.forEach(a),pc.forEach(a),eg=l(T),kt=o(T,"DIV",{class:!0});var mc=n(kt);m(Rr.$$.fragment,mc),tg=l(mc),Qs=o(mc,"P",{});var Ov=n(Qs);ag=c(Ov,"Number of columns in this table."),Ov.forEach(a),mc.forEach(a),rg=l(T),H=o(T,"DIV",{class:!0});var Po=n(H);m(Ur.$$.fragment,Po),og=l(Po),Zs=o(Po,"P",{});var Wv=n(Zs);ng=c(Wv,"Number of rows in this table."),Wv.forEach(a),sg=l(Po),el=o(Po,"P",{});var Xv=n(el);lg=c(Xv,`Due to the definition of a table, all columns have the same number of
rows.`),Xv.forEach(a),Po.forEach(a),dg=l(T),It=o(T,"DIV",{class:!0});var bc=n(It);m(zr.$$.fragment,bc),cg=l(bc),tl=o(bc,"P",{});var Hv=n(tl);ig=c(Hv,"Dimensions of the table: (#rows, #columns)."),Hv.forEach(a),bc.forEach(a),pg=l(T),Mt=o(T,"DIV",{class:!0});var hc=n(Mt);m(Br.$$.fragment,hc),mg=l(hc),al=o(hc,"P",{});var Kv=n(al);bg=c(Kv,"Total number of bytes consumed by the elements of the table."),Kv.forEach(a),hc.forEach(a),hg=l(T),Dt=o(T,"DIV",{class:!0});var uc=n(Dt);m(Or.$$.fragment,uc),ug=l(uc),rl=o(uc,"P",{});var Yv=n(rl);gg=c(Yv,"Names of the table\u2019s columns"),Yv.forEach(a),uc.forEach(a),fg=l(T),Ct=o(T,"DIV",{class:!0});var gc=n(Ct);m(Wr.$$.fragment,gc),yg=l(gc),ol=o(gc,"P",{});var Gv=n(ol);vg=c(Gv,"Compute zero-copy slice of this Table"),Gv.forEach(a),gc.forEach(a),$g=l(T),Pt=o(T,"DIV",{class:!0});var fc=n(Pt);m(Xr.$$.fragment,fc),_g=l(fc),nl=o(fc,"P",{});var Jv=n(nl);Tg=c(Jv,"Select records from a Table. See pyarrow.compute.filter for full usage."),Jv.forEach(a),fc.forEach(a),wg=l(T),Lt=o(T,"DIV",{class:!0});var yc=n(Lt);m(Hr.$$.fragment,yc),xg=l(yc),sl=o(yc,"P",{});var Qv=n(sl);Eg=c(Qv,`Flatten this Table.  Each column with a struct type is flattened
into one column per struct field.  Other columns are left unchanged.`),Qv.forEach(a),yc.forEach(a),kg=l(T),K=o(T,"DIV",{class:!0});var Lo=n(K);m(Kr.$$.fragment,Lo),Ig=l(Lo),ll=o(Lo,"P",{});var Zv=n(ll);Mg=c(Zv,"Make a new table by combining the chunks this table has."),Zv.forEach(a),Dg=l(Lo),dl=o(Lo,"P",{});var e2=n(dl);Cg=c(e2,`All the underlying chunks in the ChunkedArray of each column are
concatenated into zero or one chunk.`),e2.forEach(a),Lo.forEach(a),Pg=l(T),At=o(T,"DIV",{class:!0});var vc=n(At);m(Yr.$$.fragment,vc),Lg=l(vc),cl=o(vc,"P",{});var t2=n(cl);Ag=c(t2,"Cast table values to another schema"),t2.forEach(a),vc.forEach(a),Ng=l(T),Nt=o(T,"DIV",{class:!0});var $c=n(Nt);m(Gr.$$.fragment,$c),jg=l($c),il=o($c,"P",{});var a2=n(il);Fg=c(a2,`EXPERIMENTAL: Create shallow copy of table by replacing schema
key-value metadata with the indicated new metadata (which may be None,
which deletes any existing metadata`),a2.forEach(a),$c.forEach(a),Vg=l(T),Y=o(T,"DIV",{class:!0});var Ao=n(Y);m(Jr.$$.fragment,Ao),Sg=l(Ao),pl=o(Ao,"P",{});var r2=n(pl);qg=c(r2,"Add column to Table at position."),r2.forEach(a),Rg=l(Ao),ml=o(Ao,"P",{});var o2=n(ml);Ug=c(o2,`A new table is returned with the column added, the original table
object is left unchanged.`),o2.forEach(a),Ao.forEach(a),zg=l(T),jt=o(T,"DIV",{class:!0});var _c=n(jt);m(Qr.$$.fragment,_c),Bg=l(_c),bl=o(_c,"P",{});var n2=n(bl);Og=c(n2,"Append column at end of columns."),n2.forEach(a),_c.forEach(a),Wg=l(T),Ft=o(T,"DIV",{class:!0});var Tc=n(Ft);m(Zr.$$.fragment,Tc),Xg=l(Tc),hl=o(Tc,"P",{});var s2=n(hl);Hg=c(s2,"Create new Table with the indicated column removed."),s2.forEach(a),Tc.forEach(a),Kg=l(T),Vt=o(T,"DIV",{class:!0});var wc=n(Vt);m(eo.$$.fragment,wc),Yg=l(wc),ul=o(wc,"P",{});var l2=n(ul);Gg=c(l2,"Replace column in Table at position."),l2.forEach(a),wc.forEach(a),Jg=l(T),St=o(T,"DIV",{class:!0});var xc=n(St);m(to.$$.fragment,xc),Qg=l(xc),gl=o(xc,"P",{});var d2=n(gl);Zg=c(d2,"Create new table with columns renamed to provided names."),d2.forEach(a),xc.forEach(a),ef=l(T),qt=o(T,"DIV",{class:!0});var Ec=n(qt);m(ao.$$.fragment,Ec),tf=l(Ec),fl=o(Ec,"P",{});var c2=n(fl);af=c(c2,"Drop one or more columns and return a new table."),c2.forEach(a),Ec.forEach(a),rf=l(T),yo=o(T,"DIV",{class:!0});var i2=n(yo);m(ro.$$.fragment,i2),i2.forEach(a),of=l(T),Rt=o(T,"DIV",{class:!0});var kc=n(Rt);m(oo.$$.fragment,kc),nf=l(kc),yl=o(kc,"P",{});var p2=n(yl);sf=c(p2,"Create ConcatenationTable from list of tables."),p2.forEach(a),kc.forEach(a),T.forEach(a),Al=l(t),te=o(t,"H2",{class:!0});var Ic=n(te);Ut=o(Ic,"A",{id:!0,class:!0,href:!0});var m2=n(Ut);vl=o(m2,"SPAN",{});var b2=n(vl);m(no.$$.fragment,b2),b2.forEach(a),m2.forEach(a),lf=l(Ic),$l=o(Ic,"SPAN",{});var h2=n($l);df=c(h2,"Utils"),h2.forEach(a),Ic.forEach(a),Nl=l(t),ae=o(t,"DIV",{class:!0});var Mc=n(ae);m(so.$$.fragment,Mc),cf=l(Mc),_l=o(Mc,"P",{});var u2=n(_l);pf=c(u2,"Concatenate tables."),u2.forEach(a),Mc.forEach(a),jl=l(t),re=o(t,"DIV",{class:!0});var Dc=n(re);m(lo.$$.fragment,Dc),mf=l(Dc),Tl=o(Dc,"P",{});var g2=n(Tl);bf=c(g2,`Get the cache files that are loaded by the table.
Cache file are used when parts of the table come from the disk via memory mapping.`),g2.forEach(a),Dc.forEach(a),this.h()},h(){i(D,"name","hf:doc:metadata"),i(D,"content",JSON.stringify(I2)),i(C,"id","table-classes"),i(C,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(C,"href","#table-classes"),i(P,"class","relative group"),i(io,"href","/docs/datasets/v2.7.0/en/package_reference/table_classes#datasets.table.Table"),i(ne,"id","datasets.table.Table"),i(ne,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(ne,"href","#datasets.table.Table"),i(J,"class","relative group"),i(F,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(se,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(le,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(de,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(ce,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(po,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(ie,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(me,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(be,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(he,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(ue,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(V,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(ge,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(fe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(x,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(ye,"id","datasets.table.InMemoryTable"),i(ye,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(ye,"href","#datasets.table.InMemoryTable"),i(Q,"class","relative group"),i(S,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(ve,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i($e,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(_e,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Te,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(mo,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(we,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(xe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(ke,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ie,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Me,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(De,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ce,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Le,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ae,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ne,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(R,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(je,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Fe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(U,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ve,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Se,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(qe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Re,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ue,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(bo,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(ho,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(L,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Be,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Oe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(We,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(y,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Xe,"id","datasets.table.MemoryMappedTable"),i(Xe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(Xe,"href","#datasets.table.MemoryMappedTable"),i(Z,"class","relative group"),i(z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(He,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ke,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ye,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ge,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(uo,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Je,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Qe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ze,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(et,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(tt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(at,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(B,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(rt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(ot,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(nt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(st,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(lt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(dt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(O,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(ct,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(it,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(W,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(pt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(mt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(bt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(ht,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(ut,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(go,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(_,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(gt,"id","datasets.table.ConcatenationTable"),i(gt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(gt,"href","#datasets.table.ConcatenationTable"),i(ee,"class","relative group"),i(X,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(ft,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(yt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(vt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i($t,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(fo,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(_t,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Tt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(wt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(xt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Et,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(kt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(H,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(It,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Mt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Dt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ct,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Pt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Lt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(K,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(At,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Nt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Y,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(jt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ft,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Vt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(St,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(qt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(yo,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Rt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(v,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ut,"id","datasets.table.concat_tables"),i(Ut,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(Ut,"href","#datasets.table.concat_tables"),i(te,"class","relative group"),i(ae,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(re,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,k){e(document.head,D),I(t,oe,k),I(t,P,k),e(P,C),e(C,A),b(M,A,null),e(P,N),e(P,jo),e(jo,Cc),I(t,xl,k),I(t,j,k),e(j,Pc),e(j,Fo),e(Fo,Lc),e(j,Ac),e(j,io),e(io,Nc),e(j,jc),I(t,El,k),I(t,J,k),e(J,ne),e(ne,Vo),b(zt,Vo,null),e(J,Fc),e(J,So),e(So,Vc),I(t,kl,k),I(t,x,k),b(Bt,x,null),e(x,Sc),e(x,qo),e(qo,qc),e(x,Rc),e(x,Ro),e(Ro,Uc),e(x,zc),e(x,Uo),e(Uo,Bc),e(x,Oc),e(x,F),b(Ot,F,null),e(F,Wc),e(F,zo),e(zo,Xc),e(F,Hc),e(F,Wt),e(Wt,Kc),e(Wt,Bo),e(Bo,Yc),e(Wt,Gc),e(x,Jc),e(x,se),b(Xt,se,null),e(se,Qc),e(se,Oo),e(Oo,Zc),e(x,ei),e(x,le),b(Ht,le,null),e(le,ti),e(le,Wo),e(Wo,ai),e(x,ri),e(x,de),b(Kt,de,null),e(de,oi),e(de,Xo),e(Xo,ni),e(x,si),e(x,ce),b(Yt,ce,null),e(ce,li),e(ce,Ho),e(Ho,di),e(x,ci),e(x,po),b(Gt,po,null),e(x,ii),e(x,ie),b(Jt,ie,null),e(ie,pi),e(ie,Ko),e(Ko,mi),e(x,bi),e(x,pe),b(Qt,pe,null),e(pe,hi),e(pe,Yo),e(Yo,ui),e(x,gi),e(x,me),b(Zt,me,null),e(me,fi),e(me,Go),e(Go,yi),e(x,vi),e(x,be),b(ea,be,null),e(be,$i),e(be,Jo),e(Jo,_i),e(x,Ti),e(x,he),b(ta,he,null),e(he,wi),e(he,Qo),e(Qo,xi),e(x,Ei),e(x,ue),b(aa,ue,null),e(ue,ki),e(ue,Zo),e(Zo,Ii),e(x,Mi),e(x,V),b(ra,V,null),e(V,Di),e(V,en),e(en,Ci),e(V,Pi),e(V,tn),e(tn,Li),e(x,Ai),e(x,ge),b(oa,ge,null),e(ge,Ni),e(ge,an),e(an,ji),e(x,Fi),e(x,fe),b(na,fe,null),e(fe,Vi),e(fe,rn),e(rn,Si),I(t,Il,k),I(t,Q,k),e(Q,ye),e(ye,on),b(sa,on,null),e(Q,qi),e(Q,nn),e(nn,Ri),I(t,Ml,k),I(t,y,k),b(la,y,null),e(y,Ui),e(y,sn),e(sn,zi),e(y,Bi),e(y,ln),e(ln,Oi),e(y,Wi),e(y,dn),e(dn,Xi),e(y,Hi),e(y,cn),e(cn,Ki),e(y,Yi),e(y,S),b(da,S,null),e(S,Gi),e(S,pn),e(pn,Ji),e(S,Qi),e(S,ca),e(ca,Zi),e(ca,mn),e(mn,ep),e(ca,tp),e(y,ap),e(y,ve),b(ia,ve,null),e(ve,rp),e(ve,bn),e(bn,op),e(y,np),e(y,$e),b(pa,$e,null),e($e,sp),e($e,hn),e(hn,lp),e(y,dp),e(y,_e),b(ma,_e,null),e(_e,cp),e(_e,un),e(un,ip),e(y,pp),e(y,Te),b(ba,Te,null),e(Te,mp),e(Te,gn),e(gn,bp),e(y,hp),e(y,mo),b(ha,mo,null),e(y,up),e(y,we),b(ua,we,null),e(we,gp),e(we,fn),e(fn,fp),e(y,yp),e(y,xe),b(ga,xe,null),e(xe,vp),e(xe,yn),e(yn,$p),e(y,_p),e(y,Ee),b(fa,Ee,null),e(Ee,Tp),e(Ee,vn),e(vn,wp),e(y,xp),e(y,ke),b(ya,ke,null),e(ke,Ep),e(ke,$n),e($n,kp),e(y,Ip),e(y,Ie),b(va,Ie,null),e(Ie,Mp),e(Ie,_n),e(_n,Dp),e(y,Cp),e(y,Me),b($a,Me,null),e(Me,Pp),e(Me,Tn),e(Tn,Lp),e(y,Ap),e(y,q),b(_a,q,null),e(q,Np),e(q,wn),e(wn,jp),e(q,Fp),e(q,xn),e(xn,Vp),e(y,Sp),e(y,De),b(Ta,De,null),e(De,qp),e(De,En),e(En,Rp),e(y,Up),e(y,Ce),b(wa,Ce,null),e(Ce,zp),e(Ce,kn),e(kn,Bp),e(y,Op),e(y,Pe),b(xa,Pe,null),e(Pe,Wp),e(Pe,In),e(In,Xp),e(y,Hp),e(y,Le),b(Ea,Le,null),e(Le,Kp),e(Le,Mn),e(Mn,Yp),e(y,Gp),e(y,Ae),b(ka,Ae,null),e(Ae,Jp),e(Ae,Dn),e(Dn,Qp),e(y,Zp),e(y,Ne),b(Ia,Ne,null),e(Ne,em),e(Ne,Cn),e(Cn,tm),e(y,am),e(y,R),b(Ma,R,null),e(R,rm),e(R,Pn),e(Pn,om),e(R,nm),e(R,Ln),e(Ln,sm),e(y,lm),e(y,je),b(Da,je,null),e(je,dm),e(je,An),e(An,cm),e(y,im),e(y,Fe),b(Ca,Fe,null),e(Fe,pm),e(Fe,Nn),e(Nn,mm),e(y,bm),e(y,U),b(Pa,U,null),e(U,hm),e(U,jn),e(jn,um),e(U,gm),e(U,Fn),e(Fn,fm),e(y,ym),e(y,Ve),b(La,Ve,null),e(Ve,vm),e(Ve,Vn),e(Vn,$m),e(y,_m),e(y,Se),b(Aa,Se,null),e(Se,Tm),e(Se,Sn),e(Sn,wm),e(y,xm),e(y,qe),b(Na,qe,null),e(qe,Em),e(qe,qn),e(qn,km),e(y,Im),e(y,Re),b(ja,Re,null),e(Re,Mm),e(Re,Rn),e(Rn,Dm),e(y,Cm),e(y,Ue),b(Fa,Ue,null),e(Ue,Pm),e(Ue,Un),e(Un,Lm),e(y,Am),e(y,bo),b(Va,bo,null),e(y,Nm),e(y,ho),b(Sa,ho,null),e(y,jm),e(y,L),b(qa,L,null),e(L,Fm),e(L,zn),e(zn,Vm),e(L,Sm),e(L,Ra),e(Ra,qm),e(Ra,Bn),e(Bn,Rm),e(Ra,Um),e(L,zm),e(L,Ua),e(Ua,Bm),e(Ua,On),e(On,Om),e(Ua,Wm),e(L,Xm),b(ze,L,null),e(y,Hm),e(y,Be),b(za,Be,null),e(Be,Km),e(Be,Wn),e(Wn,Ym),e(y,Gm),e(y,Oe),b(Ba,Oe,null),e(Oe,Jm),e(Oe,Xn),e(Xn,Qm),e(y,Zm),e(y,We),b(Oa,We,null),e(We,eb),e(We,Hn),e(Hn,tb),I(t,Dl,k),I(t,Z,k),e(Z,Xe),e(Xe,Kn),b(Wa,Kn,null),e(Z,ab),e(Z,Yn),e(Yn,rb),I(t,Cl,k),I(t,_,k),b(Xa,_,null),e(_,ob),e(_,Gn),e(Gn,nb),e(_,sb),e(_,Jn),e(Jn,lb),e(_,db),e(_,Qn),e(Qn,cb),e(_,ib),e(_,Zn),e(Zn,pb),e(_,mb),e(_,es),e(es,bb),e(_,hb),e(_,z),b(Ha,z,null),e(z,ub),e(z,ts),e(ts,gb),e(z,fb),e(z,Ka),e(Ka,yb),e(Ka,as),e(as,vb),e(Ka,$b),e(_,_b),e(_,He),b(Ya,He,null),e(He,Tb),e(He,rs),e(rs,wb),e(_,xb),e(_,Ke),b(Ga,Ke,null),e(Ke,Eb),e(Ke,os),e(os,kb),e(_,Ib),e(_,Ye),b(Ja,Ye,null),e(Ye,Mb),e(Ye,ns),e(ns,Db),e(_,Cb),e(_,Ge),b(Qa,Ge,null),e(Ge,Pb),e(Ge,ss),e(ss,Lb),e(_,Ab),e(_,uo),b(Za,uo,null),e(_,Nb),e(_,Je),b(er,Je,null),e(Je,jb),e(Je,ls),e(ls,Fb),e(_,Vb),e(_,Qe),b(tr,Qe,null),e(Qe,Sb),e(Qe,ds),e(ds,qb),e(_,Rb),e(_,Ze),b(ar,Ze,null),e(Ze,Ub),e(Ze,cs),e(cs,zb),e(_,Bb),e(_,et),b(rr,et,null),e(et,Ob),e(et,is),e(is,Wb),e(_,Xb),e(_,tt),b(or,tt,null),e(tt,Hb),e(tt,ps),e(ps,Kb),e(_,Yb),e(_,at),b(nr,at,null),e(at,Gb),e(at,ms),e(ms,Jb),e(_,Qb),e(_,B),b(sr,B,null),e(B,Zb),e(B,bs),e(bs,eh),e(B,th),e(B,hs),e(hs,ah),e(_,rh),e(_,rt),b(lr,rt,null),e(rt,oh),e(rt,us),e(us,nh),e(_,sh),e(_,ot),b(dr,ot,null),e(ot,lh),e(ot,gs),e(gs,dh),e(_,ch),e(_,nt),b(cr,nt,null),e(nt,ih),e(nt,fs),e(fs,ph),e(_,mh),e(_,st),b(ir,st,null),e(st,bh),e(st,ys),e(ys,hh),e(_,uh),e(_,lt),b(pr,lt,null),e(lt,gh),e(lt,vs),e(vs,fh),e(_,yh),e(_,dt),b(mr,dt,null),e(dt,vh),e(dt,$s),e($s,$h),e(_,_h),e(_,O),b(br,O,null),e(O,Th),e(O,_s),e(_s,wh),e(O,xh),e(O,Ts),e(Ts,Eh),e(_,kh),e(_,ct),b(hr,ct,null),e(ct,Ih),e(ct,ws),e(ws,Mh),e(_,Dh),e(_,it),b(ur,it,null),e(it,Ch),e(it,xs),e(xs,Ph),e(_,Lh),e(_,W),b(gr,W,null),e(W,Ah),e(W,Es),e(Es,Nh),e(W,jh),e(W,ks),e(ks,Fh),e(_,Vh),e(_,pt),b(fr,pt,null),e(pt,Sh),e(pt,Is),e(Is,qh),e(_,Rh),e(_,mt),b(yr,mt,null),e(mt,Uh),e(mt,Ms),e(Ms,zh),e(_,Bh),e(_,bt),b(vr,bt,null),e(bt,Oh),e(bt,Ds),e(Ds,Wh),e(_,Xh),e(_,ht),b($r,ht,null),e(ht,Hh),e(ht,Cs),e(Cs,Kh),e(_,Yh),e(_,ut),b(_r,ut,null),e(ut,Gh),e(ut,Ps),e(Ps,Jh),e(_,Qh),e(_,go),b(Tr,go,null),I(t,Pl,k),I(t,ee,k),e(ee,gt),e(gt,Ls),b(wr,Ls,null),e(ee,Zh),e(ee,As),e(As,eu),I(t,Ll,k),I(t,v,k),b(xr,v,null),e(v,tu),e(v,Ns),e(Ns,au),e(v,ru),e(v,js),e(js,ou),e(v,nu),e(v,Er),e(Er,Fs),e(Fs,su),e(Er,lu),e(Er,Vs),e(Vs,du),e(v,cu),e(v,kr),e(kr,iu),e(kr,Ss),e(Ss,pu),e(kr,mu),e(v,bu),e(v,Ir),e(Ir,hu),e(Ir,qs),e(qs,uu),e(Ir,gu),e(v,fu),e(v,Rs),e(Rs,yu),e(v,vu),e(v,X),b(Mr,X,null),e(X,$u),e(X,Us),e(Us,_u),e(X,Tu),e(X,Dr),e(Dr,wu),e(Dr,zs),e(zs,xu),e(Dr,Eu),e(v,ku),e(v,ft),b(Cr,ft,null),e(ft,Iu),e(ft,Bs),e(Bs,Mu),e(v,Du),e(v,yt),b(Pr,yt,null),e(yt,Cu),e(yt,Os),e(Os,Pu),e(v,Lu),e(v,vt),b(Lr,vt,null),e(vt,Au),e(vt,Ws),e(Ws,Nu),e(v,ju),e(v,$t),b(Ar,$t,null),e($t,Fu),e($t,Xs),e(Xs,Vu),e(v,Su),e(v,fo),b(Nr,fo,null),e(v,qu),e(v,_t),b(jr,_t,null),e(_t,Ru),e(_t,Hs),e(Hs,Uu),e(v,zu),e(v,Tt),b(Fr,Tt,null),e(Tt,Bu),e(Tt,Ks),e(Ks,Ou),e(v,Wu),e(v,wt),b(Vr,wt,null),e(wt,Xu),e(wt,Ys),e(Ys,Hu),e(v,Ku),e(v,xt),b(Sr,xt,null),e(xt,Yu),e(xt,Gs),e(Gs,Gu),e(v,Ju),e(v,Et),b(qr,Et,null),e(Et,Qu),e(Et,Js),e(Js,Zu),e(v,eg),e(v,kt),b(Rr,kt,null),e(kt,tg),e(kt,Qs),e(Qs,ag),e(v,rg),e(v,H),b(Ur,H,null),e(H,og),e(H,Zs),e(Zs,ng),e(H,sg),e(H,el),e(el,lg),e(v,dg),e(v,It),b(zr,It,null),e(It,cg),e(It,tl),e(tl,ig),e(v,pg),e(v,Mt),b(Br,Mt,null),e(Mt,mg),e(Mt,al),e(al,bg),e(v,hg),e(v,Dt),b(Or,Dt,null),e(Dt,ug),e(Dt,rl),e(rl,gg),e(v,fg),e(v,Ct),b(Wr,Ct,null),e(Ct,yg),e(Ct,ol),e(ol,vg),e(v,$g),e(v,Pt),b(Xr,Pt,null),e(Pt,_g),e(Pt,nl),e(nl,Tg),e(v,wg),e(v,Lt),b(Hr,Lt,null),e(Lt,xg),e(Lt,sl),e(sl,Eg),e(v,kg),e(v,K),b(Kr,K,null),e(K,Ig),e(K,ll),e(ll,Mg),e(K,Dg),e(K,dl),e(dl,Cg),e(v,Pg),e(v,At),b(Yr,At,null),e(At,Lg),e(At,cl),e(cl,Ag),e(v,Ng),e(v,Nt),b(Gr,Nt,null),e(Nt,jg),e(Nt,il),e(il,Fg),e(v,Vg),e(v,Y),b(Jr,Y,null),e(Y,Sg),e(Y,pl),e(pl,qg),e(Y,Rg),e(Y,ml),e(ml,Ug),e(v,zg),e(v,jt),b(Qr,jt,null),e(jt,Bg),e(jt,bl),e(bl,Og),e(v,Wg),e(v,Ft),b(Zr,Ft,null),e(Ft,Xg),e(Ft,hl),e(hl,Hg),e(v,Kg),e(v,Vt),b(eo,Vt,null),e(Vt,Yg),e(Vt,ul),e(ul,Gg),e(v,Jg),e(v,St),b(to,St,null),e(St,Qg),e(St,gl),e(gl,Zg),e(v,ef),e(v,qt),b(ao,qt,null),e(qt,tf),e(qt,fl),e(fl,af),e(v,rf),e(v,yo),b(ro,yo,null),e(v,of),e(v,Rt),b(oo,Rt,null),e(Rt,nf),e(Rt,yl),e(yl,sf),I(t,Al,k),I(t,te,k),e(te,Ut),e(Ut,vl),b(no,vl,null),e(te,lf),e(te,$l),e($l,df),I(t,Nl,k),I(t,ae,k),b(so,ae,null),e(ae,cf),e(ae,_l),e(_l,pf),I(t,jl,k),I(t,re,k),b(lo,re,null),e(re,mf),e(re,Tl),e(Tl,bf),Fl=!0},p(t,[k]){const co={};k&2&&(co.$$scope={dirty:k,ctx:t}),ze.$set(co)},i(t){Fl||(h(M.$$.fragment,t),h(zt.$$.fragment,t),h(Bt.$$.fragment,t),h(Ot.$$.fragment,t),h(Xt.$$.fragment,t),h(Ht.$$.fragment,t),h(Kt.$$.fragment,t),h(Yt.$$.fragment,t),h(Gt.$$.fragment,t),h(Jt.$$.fragment,t),h(Qt.$$.fragment,t),h(Zt.$$.fragment,t),h(ea.$$.fragment,t),h(ta.$$.fragment,t),h(aa.$$.fragment,t),h(ra.$$.fragment,t),h(oa.$$.fragment,t),h(na.$$.fragment,t),h(sa.$$.fragment,t),h(la.$$.fragment,t),h(da.$$.fragment,t),h(ia.$$.fragment,t),h(pa.$$.fragment,t),h(ma.$$.fragment,t),h(ba.$$.fragment,t),h(ha.$$.fragment,t),h(ua.$$.fragment,t),h(ga.$$.fragment,t),h(fa.$$.fragment,t),h(ya.$$.fragment,t),h(va.$$.fragment,t),h($a.$$.fragment,t),h(_a.$$.fragment,t),h(Ta.$$.fragment,t),h(wa.$$.fragment,t),h(xa.$$.fragment,t),h(Ea.$$.fragment,t),h(ka.$$.fragment,t),h(Ia.$$.fragment,t),h(Ma.$$.fragment,t),h(Da.$$.fragment,t),h(Ca.$$.fragment,t),h(Pa.$$.fragment,t),h(La.$$.fragment,t),h(Aa.$$.fragment,t),h(Na.$$.fragment,t),h(ja.$$.fragment,t),h(Fa.$$.fragment,t),h(Va.$$.fragment,t),h(Sa.$$.fragment,t),h(qa.$$.fragment,t),h(ze.$$.fragment,t),h(za.$$.fragment,t),h(Ba.$$.fragment,t),h(Oa.$$.fragment,t),h(Wa.$$.fragment,t),h(Xa.$$.fragment,t),h(Ha.$$.fragment,t),h(Ya.$$.fragment,t),h(Ga.$$.fragment,t),h(Ja.$$.fragment,t),h(Qa.$$.fragment,t),h(Za.$$.fragment,t),h(er.$$.fragment,t),h(tr.$$.fragment,t),h(ar.$$.fragment,t),h(rr.$$.fragment,t),h(or.$$.fragment,t),h(nr.$$.fragment,t),h(sr.$$.fragment,t),h(lr.$$.fragment,t),h(dr.$$.fragment,t),h(cr.$$.fragment,t),h(ir.$$.fragment,t),h(pr.$$.fragment,t),h(mr.$$.fragment,t),h(br.$$.fragment,t),h(hr.$$.fragment,t),h(ur.$$.fragment,t),h(gr.$$.fragment,t),h(fr.$$.fragment,t),h(yr.$$.fragment,t),h(vr.$$.fragment,t),h($r.$$.fragment,t),h(_r.$$.fragment,t),h(Tr.$$.fragment,t),h(wr.$$.fragment,t),h(xr.$$.fragment,t),h(Mr.$$.fragment,t),h(Cr.$$.fragment,t),h(Pr.$$.fragment,t),h(Lr.$$.fragment,t),h(Ar.$$.fragment,t),h(Nr.$$.fragment,t),h(jr.$$.fragment,t),h(Fr.$$.fragment,t),h(Vr.$$.fragment,t),h(Sr.$$.fragment,t),h(qr.$$.fragment,t),h(Rr.$$.fragment,t),h(Ur.$$.fragment,t),h(zr.$$.fragment,t),h(Br.$$.fragment,t),h(Or.$$.fragment,t),h(Wr.$$.fragment,t),h(Xr.$$.fragment,t),h(Hr.$$.fragment,t),h(Kr.$$.fragment,t),h(Yr.$$.fragment,t),h(Gr.$$.fragment,t),h(Jr.$$.fragment,t),h(Qr.$$.fragment,t),h(Zr.$$.fragment,t),h(eo.$$.fragment,t),h(to.$$.fragment,t),h(ao.$$.fragment,t),h(ro.$$.fragment,t),h(oo.$$.fragment,t),h(no.$$.fragment,t),h(so.$$.fragment,t),h(lo.$$.fragment,t),Fl=!0)},o(t){u(M.$$.fragment,t),u(zt.$$.fragment,t),u(Bt.$$.fragment,t),u(Ot.$$.fragment,t),u(Xt.$$.fragment,t),u(Ht.$$.fragment,t),u(Kt.$$.fragment,t),u(Yt.$$.fragment,t),u(Gt.$$.fragment,t),u(Jt.$$.fragment,t),u(Qt.$$.fragment,t),u(Zt.$$.fragment,t),u(ea.$$.fragment,t),u(ta.$$.fragment,t),u(aa.$$.fragment,t),u(ra.$$.fragment,t),u(oa.$$.fragment,t),u(na.$$.fragment,t),u(sa.$$.fragment,t),u(la.$$.fragment,t),u(da.$$.fragment,t),u(ia.$$.fragment,t),u(pa.$$.fragment,t),u(ma.$$.fragment,t),u(ba.$$.fragment,t),u(ha.$$.fragment,t),u(ua.$$.fragment,t),u(ga.$$.fragment,t),u(fa.$$.fragment,t),u(ya.$$.fragment,t),u(va.$$.fragment,t),u($a.$$.fragment,t),u(_a.$$.fragment,t),u(Ta.$$.fragment,t),u(wa.$$.fragment,t),u(xa.$$.fragment,t),u(Ea.$$.fragment,t),u(ka.$$.fragment,t),u(Ia.$$.fragment,t),u(Ma.$$.fragment,t),u(Da.$$.fragment,t),u(Ca.$$.fragment,t),u(Pa.$$.fragment,t),u(La.$$.fragment,t),u(Aa.$$.fragment,t),u(Na.$$.fragment,t),u(ja.$$.fragment,t),u(Fa.$$.fragment,t),u(Va.$$.fragment,t),u(Sa.$$.fragment,t),u(qa.$$.fragment,t),u(ze.$$.fragment,t),u(za.$$.fragment,t),u(Ba.$$.fragment,t),u(Oa.$$.fragment,t),u(Wa.$$.fragment,t),u(Xa.$$.fragment,t),u(Ha.$$.fragment,t),u(Ya.$$.fragment,t),u(Ga.$$.fragment,t),u(Ja.$$.fragment,t),u(Qa.$$.fragment,t),u(Za.$$.fragment,t),u(er.$$.fragment,t),u(tr.$$.fragment,t),u(ar.$$.fragment,t),u(rr.$$.fragment,t),u(or.$$.fragment,t),u(nr.$$.fragment,t),u(sr.$$.fragment,t),u(lr.$$.fragment,t),u(dr.$$.fragment,t),u(cr.$$.fragment,t),u(ir.$$.fragment,t),u(pr.$$.fragment,t),u(mr.$$.fragment,t),u(br.$$.fragment,t),u(hr.$$.fragment,t),u(ur.$$.fragment,t),u(gr.$$.fragment,t),u(fr.$$.fragment,t),u(yr.$$.fragment,t),u(vr.$$.fragment,t),u($r.$$.fragment,t),u(_r.$$.fragment,t),u(Tr.$$.fragment,t),u(wr.$$.fragment,t),u(xr.$$.fragment,t),u(Mr.$$.fragment,t),u(Cr.$$.fragment,t),u(Pr.$$.fragment,t),u(Lr.$$.fragment,t),u(Ar.$$.fragment,t),u(Nr.$$.fragment,t),u(jr.$$.fragment,t),u(Fr.$$.fragment,t),u(Vr.$$.fragment,t),u(Sr.$$.fragment,t),u(qr.$$.fragment,t),u(Rr.$$.fragment,t),u(Ur.$$.fragment,t),u(zr.$$.fragment,t),u(Br.$$.fragment,t),u(Or.$$.fragment,t),u(Wr.$$.fragment,t),u(Xr.$$.fragment,t),u(Hr.$$.fragment,t),u(Kr.$$.fragment,t),u(Yr.$$.fragment,t),u(Gr.$$.fragment,t),u(Jr.$$.fragment,t),u(Qr.$$.fragment,t),u(Zr.$$.fragment,t),u(eo.$$.fragment,t),u(to.$$.fragment,t),u(ao.$$.fragment,t),u(ro.$$.fragment,t),u(oo.$$.fragment,t),u(no.$$.fragment,t),u(so.$$.fragment,t),u(lo.$$.fragment,t),Fl=!1},d(t){a(D),t&&a(oe),t&&a(P),g(M),t&&a(xl),t&&a(j),t&&a(El),t&&a(J),g(zt),t&&a(kl),t&&a(x),g(Bt),g(Ot),g(Xt),g(Ht),g(Kt),g(Yt),g(Gt),g(Jt),g(Qt),g(Zt),g(ea),g(ta),g(aa),g(ra),g(oa),g(na),t&&a(Il),t&&a(Q),g(sa),t&&a(Ml),t&&a(y),g(la),g(da),g(ia),g(pa),g(ma),g(ba),g(ha),g(ua),g(ga),g(fa),g(ya),g(va),g($a),g(_a),g(Ta),g(wa),g(xa),g(Ea),g(ka),g(Ia),g(Ma),g(Da),g(Ca),g(Pa),g(La),g(Aa),g(Na),g(ja),g(Fa),g(Va),g(Sa),g(qa),g(ze),g(za),g(Ba),g(Oa),t&&a(Dl),t&&a(Z),g(Wa),t&&a(Cl),t&&a(_),g(Xa),g(Ha),g(Ya),g(Ga),g(Ja),g(Qa),g(Za),g(er),g(tr),g(ar),g(rr),g(or),g(nr),g(sr),g(lr),g(dr),g(cr),g(ir),g(pr),g(mr),g(br),g(hr),g(ur),g(gr),g(fr),g(yr),g(vr),g($r),g(_r),g(Tr),t&&a(Pl),t&&a(ee),g(wr),t&&a(Ll),t&&a(v),g(xr),g(Mr),g(Cr),g(Pr),g(Lr),g(Ar),g(Nr),g(jr),g(Fr),g(Vr),g(Sr),g(qr),g(Rr),g(Ur),g(zr),g(Br),g(Or),g(Wr),g(Xr),g(Hr),g(Kr),g(Yr),g(Gr),g(Jr),g(Qr),g(Zr),g(eo),g(to),g(ao),g(ro),g(oo),t&&a(Al),t&&a(te),g(no),t&&a(Nl),t&&a(ae),g(so),t&&a(jl),t&&a(re),g(lo)}}}const I2={local:"table-classes",sections:[{local:"datasets.table.Table",title:"Table"},{local:"datasets.table.InMemoryTable",title:"InMemoryTable"},{local:"datasets.table.MemoryMappedTable",title:"MemoryMappedTable"},{local:"datasets.table.ConcatenationTable",title:"ConcatenationTable"},{local:"datasets.table.concat_tables",title:"Utils"}],title:"Table Classes"};function M2(wl){return _2(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class N2 extends f2{constructor(D){super();y2(this,D,M2,k2,v2,{})}}export{N2 as default,I2 as metadata};
