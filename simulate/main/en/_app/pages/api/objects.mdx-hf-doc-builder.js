import{S as Xa,i as qa,s as Ya,F as Za,e as n,w as _,k as r,c as a,a as i,x as y,d as o,m as s,b as d,g as c,G as t,y as b,Q as Qa,H as Ka,I as ei,J as ti,q as g,o as f,B as v,v as Ja,_ as oi,$ as ni,t as m,M as ai,h as p,L as ii}from"../../chunks/vendor-hf-doc-builder.js";import{D as $}from"../../chunks/Docstring-hf-doc-builder.js";import{C as ri}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as Ze}from"../../chunks/IconCopyLink-hf-doc-builder.js";const{window:si}=oi;function li(C){let u,x,L,w,O,h,F,S,T;w=new Ze({props:{classNames:"text-smd"}});const M=C[4].default,A=Za(M,C,C[3],null);return{c(){u=n("div"),x=n("a"),L=n("span"),_(w.$$.fragment),h=r(),A&&A.c(),this.h()},l(N){u=a(N,"DIV",{class:!0});var P=i(u);x=a(P,"A",{id:!0,class:!0,href:!0});var He=i(x);L=a(He,"SPAN",{});var Xe=i(L);y(w.$$.fragment,Xe),Xe.forEach(o),He.forEach(o),h=s(P),A&&A.l(P),P.forEach(o),this.h()},h(){d(x,"id",C[0]),d(x,"class","header-link block pr-0.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(x,"href",O=`#${C[0]}`),d(u,"class","relative group rounded-md")},m(N,P){c(N,u,P),t(u,x),t(x,L),b(w,L,null),t(u,h),A&&A.m(u,null),C[5](u),F=!0,S||(T=Qa(si,"hashchange",C[2]),S=!0)},p(N,[P]){(!F||P&1)&&d(x,"id",N[0]),(!F||P&1&&O!==(O=`#${N[0]}`))&&d(x,"href",O),A&&A.p&&(!F||P&8)&&Ka(A,M,N,N[3],F?ti(M,N[3],P,null):ei(N[3]),null)},i(N){F||(g(w.$$.fragment,N),g(A,N),F=!0)},o(N){f(w.$$.fragment,N),f(A,N),F=!1},d(N){N&&o(u),v(w),A&&A.d(N),C[5](null),S=!1,T()}}}const Ha="bg-yellow-50 dark:bg-[#494a3d]";function di(C,u,x){let{$$slots:L={},$$scope:w}=u,{anchor:O}=u,h;function F(){const{hash:T}=window.location,M=T.substring(1);h&&h.classList.remove(...Ha.split(" ")),M===O&&h.classList.add(...Ha.split(" "))}Ja(()=>{F()});function S(T){ni[T?"unshift":"push"](()=>{h=T,x(1,h)})}return C.$$set=T=>{"anchor"in T&&x(0,O=T.anchor),"$$scope"in T&&x(3,w=T.$$scope)},[O,h,F,w,L,S]}class ci extends Xa{constructor(u){super();qa(this,u,di,li,Ya,{anchor:0})}}function mi(C){let u,x,L,w,O;return w=new ri({props:{code:`# create a 5x5 mesh grid
xrng = np.arange(-2, 3, dtype=np.float32)
zrng = np.arange(-2, 3, dtype=np.float32)
x, z = np.meshgrid(xrng, zrng)
# let's make the y-axis a sort of cone
y = 1. / np.sqrt(x*x + z*z + 0.1)
asset = sm.StructuredGrid(x, y, z)`,highlighted:`<span class="hljs-comment"># create a 5x5 mesh grid</span>
xrng = np.arange(-<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, dtype=np.float32)
zrng = np.arange(-<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, dtype=np.float32)
x, z = np.meshgrid(xrng, zrng)
<span class="hljs-comment"># let&#x27;s make the y-axis a sort of cone</span>
y = <span class="hljs-number">1.</span> / np.sqrt(x*x + z*z + <span class="hljs-number">0.1</span>)
asset = sm.StructuredGrid(x, y, z)`}}),{c(){u=n("p"),x=m("Examples:"),L=r(),_(w.$$.fragment)},l(h){u=a(h,"P",{});var F=i(u);x=p(F,"Examples:"),F.forEach(o),L=s(h),y(w.$$.fragment,h)},m(h,F){c(h,u,F),t(u,x),c(h,L,F),b(w,h,F),O=!0},p:ii,i(h){O||(g(w.$$.fragment,h),O=!0)},o(h){f(w.$$.fragment,h),O=!1},d(h){h&&o(u),h&&o(L),v(w,h)}}}function pi(C){let u,x,L,w,O,h,F,S,T,M,A,N,P,He,Xe,St,E,fe,Ao,Qe,Do,Oo,j,_e,Po,Ke,Co,To,ae,ie,et,ye,Ro,tt,Eo,jo,ot,So,zo,I,be,ko,nt,Wo,Mo,at,Io,zt,U,re,it,ve,Uo,rt,Go,kt,G,we,Vo,st,Bo,Wt,V,xe,Ho,lt,Xo,Mt,B,Ne,qo,dt,Yo,It,H,$e,Jo,ct,Zo,Ut,X,Le,Qo,mt,Ko,Gt,q,Fe,en,pt,tn,Vt,Y,Ae,on,ht,nn,Bt,J,De,an,ut,rn,Ht,Z,Oe,sn,gt,ln,Xt,Q,Pe,dn,ft,cn,qt,K,Ce,mn,_t,pn,Yt,z,Te,hn,yt,un,gn,bt,fn,Jt,ee,Re,_n,vt,yn,Zt,te,Ee,bn,wt,vn,Qt,oe,je,wn,xt,xn,Kt,ne,Se,Nn,Nt,$n,eo,k,ze,Ln,$t,Fn,An,se,to,D,ke,Dn,Lt,On,Pn,le,de,Ft,We,Cn,At,Tn,Rn,Dt,En,jn,W,Ot,Sn,zn,Me,kn,Pt,Wn,Mn,In,Ct,Un,Gn,Tt,Vn,Bn,Hn,Xn,ce,me,Rt,Ie,qn,Et,Yn,Jn,pe,Ue,Zn,jt,Qn,oo,Ge,Ve,no;return h=new Ze({}),fe=new $({props:{name:"class simulate.Object3D",anchor:"simulate.Object3D",parameters:[{name:"mesh",val:": typing.Union[pyvista.core.pointset.UnstructuredGrid, pyvista.core.composite.MultiBlock, pyvista.core.pointset.PolyData, pyvista.core.dataset.DataSet, NoneType] = None"},{name:"material",val:": typing.Union[simulate.assets.material.Material, typing.List[simulate.assets.material.Material], NoneType] = None"},{name:"name",val:": typing.Optional[str] = None"},{name:"position",val:": typing.Optional[typing.List[float]] = None"},{name:"is_actor",val:": bool = False"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"set_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"original_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"recompute_normals",val:": bool = True"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"**kwargs",val:": typing.Any"}],parametersDescription:[{anchor:"simulate.Object3D.mesh",description:`<strong>mesh</strong> (<code>pyvista.[UnstructuredGrid, MultiBlock, PolyData, DataSet]</code>, <em>optional</em>, defaults to None) &#x2014;
The mesh of the object.`,name:"mesh"},{anchor:"simulate.Object3D.material",description:`<strong>material</strong> (<code>Material</code> or <code>List[Material]</code>, <em>optional</em>, defaults to None) &#x2014;
The material of the object.`,name:"material"},{anchor:"simulate.Object3D.name",description:`<strong>name</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
The name of the object.`,name:"name"},{anchor:"simulate.Object3D.position",description:`<strong>position</strong> (<code>List[float]</code>, <em>optional</em>, defaults to <code>[0.0, 0.0, 0.0]</code>) &#x2014;
The position of the object.`,name:"position"},{anchor:"simulate.Object3D.is_actor",description:`<strong>is_actor</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the object is an actor.`,name:"is_actor"},{anchor:"simulate.Object3D.is_actor",description:`<strong>is_actor</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the object is an actor.`,name:"is_actor"},{anchor:"simulate.Object3D.with_rigid_body",description:`<strong>with_rigid_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the object has a rigid body.`,name:"with_rigid_body"},{anchor:"simulate.Object3D.with_articulation_body",description:`<strong>with_articulation_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the object has an articulation body.`,name:"with_articulation_body"},{anchor:"simulate.Object3D.set_mesh_direction",description:`<strong>set_mesh_direction</strong> (<code>List[float]</code>, <em>optional</em>, defaults to <code>[1.0, 0.0, 0.0]</code>) &#x2014;
The direction of the mesh.`,name:"set_mesh_direction"},{anchor:"simulate.Object3D.original_mesh_direction",description:`<strong>original_mesh_direction</strong> (<code>List[float]</code>, <em>optional</em>, defaults to <code>[1.0, 0.0, 0.0]</code>) &#x2014;
The original direction of the mesh.`,name:"original_mesh_direction"},{anchor:"simulate.Object3D.recompute_normals",description:`<strong>recompute_normals</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to recompute normals per vertex for this object.`,name:"recompute_normals"},{anchor:"simulate.Object3D.parent",description:`<strong>parent</strong> (<code>Asset</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
The parent of the object.`,name:"parent"},{anchor:"simulate.Object3D.children",description:`<strong>children</strong> (<code>Asset</code> or <code>List[Asset]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
The children of the object.`,name:"children"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L80"}}),_e=new $({props:{name:"build_collider",anchor:"simulate.Object3D.build_collider",parameters:[{name:"max_convex_hulls",val:" = 16"},{name:"resolution",val:" = 4000"},{name:"minimum_volume_percent_error_allowed",val:" = 1"},{name:"max_recursion_depth",val:" = 10"},{name:"shrink_wrap",val:" = True"},{name:"fill_mode",val:" = 'FLOOD_FILL'"},{name:"max_num_vertices_per_hull",val:" = 64"},{name:"async_ACD",val:" = True"},{name:"min_edge_length",val:" = 2"},{name:"find_best_plane",val:" = False"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L161"}}),ye=new Ze({}),be=new $({props:{name:"copy",anchor:"simulate.Object3D.copy",parameters:[{name:"with_children",val:": bool = True"},{name:"**kwargs",val:": typing.Any"}],parametersDescription:[{anchor:"simulate.Object3D.copy.with_children",description:`<strong>with_children</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to copy the children of the object.`,name:"with_children"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L236",returnDescription:`
<p>The copied object.</p>
`,returnType:`
<p>copy (<code>Object3D</code>)</p>
`}}),ve=new Ze({}),we=new $({props:{name:"class simulate.Plane",anchor:"simulate.Plane",parameters:[{name:"i_size",val:": float = 10.0"},{name:"j_size",val:": float = 10.0"},{name:"i_resolution",val:": int = 1"},{name:"j_resolution",val:": int = 1"},{name:"name",val:": typing.Optional[str] = None"},{name:"position",val:": typing.Optional[typing.List[float]] = None"},{name:"is_actor",val:": bool = False"},{name:"with_collider",val:": bool = True"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"set_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"collider_thickness",val:": typing.Optional[float] = None"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"**kwargs",val:": typing.Any"}],parametersDescription:[{anchor:"simulate.Plane.i_size",description:`<strong>i_size</strong> (<code>float</code>, <em>optional</em>, defaults to <code>10.0</code>) &#x2014;
Size of the plane in the i direction.`,name:"i_size"},{anchor:"simulate.Plane.j_size",description:`<strong>j_size</strong> (<code>float</code>, <em>optional</em>, defaults to <code>10.0</code>) &#x2014;
Size of the plane in the j direction.`,name:"j_size"},{anchor:"simulate.Plane.i_resolution",description:`<strong>i_resolution</strong> (<code>int</code>, <em>optional</em>, defaults to <code>1</code>) &#x2014;
Number of points on the plane in the i direction.`,name:"i_resolution"},{anchor:"simulate.Plane.j_resolution",description:`<strong>j_resolution</strong> (<code>int</code>, <em>optional</em>, defaults to <code>1</code>) &#x2014;
Number of points on the plane in the j direction.`,name:"j_resolution"},{anchor:"simulate.Plane.name",description:`<strong>name</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Name of the plane.`,name:"name"},{anchor:"simulate.Plane.position",description:`<strong>position</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>[0, 0, 0]</code>) &#x2014;
Position of the plane.`,name:"position"},{anchor:"simulate.Plane.is_actor",description:`<strong>is_actor</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the plane is an actor or not.`,name:"is_actor"},{anchor:"simulate.Plane.with_collider",description:`<strong>with_collider</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the plane has a collider or not.`,name:"with_collider"},{anchor:"simulate.Plane.with_rigid_body",description:`<strong>with_rigid_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the plane has a rigid body or not.`,name:"with_rigid_body"},{anchor:"simulate.Plane.with_articulation_body",description:`<strong>with_articulation_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the plane has an articulation body or not.`,name:"with_articulation_body"},{anchor:"simulate.Plane.set_mesh_direction",description:`<strong>set_mesh_direction</strong>  &#x2014; list or tuple or np.ndarray, optional
Direction the normal to the plane in <code>[x, y, z]</code>.
Default to normal pointing in the <code>y</code> (up) direction.`,name:"set_mesh_direction"},{anchor:"simulate.Plane.collider_thickness",description:`<strong>collider_thickness</strong> (<code>float</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Thickness of the collider.`,name:"collider_thickness"},{anchor:"simulate.Plane.parent",description:`<strong>parent</strong> (<code>Asset</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Parent of the plane.`,name:"parent"},{anchor:"simulate.Plane.children",description:`<strong>children</strong> (<code>Asset</code> or <code>List[Asset]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Children of the plane.`,name:"children"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L316"}}),xe=new $({props:{name:"class simulate.Sphere",anchor:"simulate.Sphere",parameters:[{name:"position",val:": typing.Optional[typing.List[float]] = None"},{name:"radius",val:": float = 1.0"},{name:"theta_resolution",val:": int = 10"},{name:"phi_resolution",val:": int = 10"},{name:"start_theta",val:": float = 0.0"},{name:"end_theta",val:": float = 360.0"},{name:"start_phi",val:": float = 0.0"},{name:"end_phi",val:": float = 180.0"},{name:"sphere_type",val:": str = 'uv'"},{name:"with_collider",val:": bool = True"},{name:"name",val:": typing.Optional[str] = None"},{name:"is_actor",val:": bool = False"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"set_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"**kwargs",val:": typing.Any"}],parametersDescription:[{anchor:"simulate.Sphere.position",description:`<strong>position</strong> (<em>np.ndarray</em> or <em>List[float]</em>, <em>optional</em>, defaults to <em>[0, 0, 0]</em>) &#x2014;
Position of the sphere.`,name:"position"},{anchor:"simulate.Sphere.radius",description:`<strong>radius</strong> (<em>float</em>, <em>optional</em>, defaults to <em>1.0</em>) &#x2014;
Sphere radius.`,name:"radius"},{anchor:"simulate.Sphere.theta_resolution",description:`<strong>theta_resolution</strong> (<em>int</em>, <em>optional</em>, defaults to <em>10</em>) &#x2014;
Set the number of points in the longitude direction (ranging from <em>start_theta</em> to <em>end_theta</em>).`,name:"theta_resolution"},{anchor:"simulate.Sphere.phi_resolution",description:`<strong>phi_resolution</strong> (<em>int</em>, <em>optional</em>, defaults to <em>10</em>) &#x2014;
Set the number of points in the latitude direction (ranging from <em>start_phi</em> to <em>end_phi</em>).`,name:"phi_resolution"},{anchor:"simulate.Sphere.start_theta",description:`<strong>start_theta</strong> (<em>float</em>, <em>optional</em>, defaults to <em>0.0</em>) &#x2014;
Starting longitude angle.`,name:"start_theta"},{anchor:"simulate.Sphere.end_theta",description:`<strong>end_theta</strong> (<em>float</em>, <em>optional</em>, defaults to <em>360.0</em>) &#x2014;
Ending longitude angle.`,name:"end_theta"},{anchor:"simulate.Sphere.start_phi",description:`<strong>start_phi</strong> (<em>float</em>, <em>optional</em>, defaults to <em>0.0</em>) &#x2014;
Starting latitude angle.`,name:"start_phi"},{anchor:"simulate.Sphere.end_phi",description:`<strong>end_phi</strong> (<em>float</em>, <em>optional</em>, defaults to <em>180.0</em>) &#x2014;
Ending latitude angle.`,name:"end_phi"},{anchor:"simulate.Sphere.sphere_type",description:`<strong>sphere_type</strong> (<em>str</em>, <em>optional</em>, defaults to <em>&#x201C;uv&#x201D;</em>) &#x2014;
One of &#x2018;uv&#x2019; for a UV-sphere or &#x2018;ico&#x2019; for an icosphere.`,name:"sphere_type"},{anchor:"simulate.Sphere.with_collider",description:`<strong>with_collider</strong> (<em>bool</em>, <em>optional</em>, defaults to <em>True</em>) &#x2014;
Set to true to automatically add an associated Sphere collider.`,name:"with_collider"},{anchor:"simulate.Sphere.name",description:`<strong>name</strong> (<em>str</em>, <em>optional</em>, defaults to <em>None</em>) &#x2014;
Name of the sphere.`,name:"name"},{anchor:"simulate.Sphere.is_actor",description:`<strong>is_actor</strong> (<em>bool</em>, <em>optional</em>, defaults to <em>False</em>) &#x2014;
Whether the sphere is an actor or not.`,name:"is_actor"},{anchor:"simulate.Sphere.with_rigid_body",description:`<strong>with_rigid_body</strong> (<em>bool</em>, <em>optional</em>, defaults to <em>False</em>) &#x2014;
Whether the sphere has a rigid body or not.`,name:"with_rigid_body"},{anchor:"simulate.Sphere.with_articulation_body",description:`<strong>with_articulation_body</strong> (<em>bool</em>, <em>optional</em>, defaults to <em>False</em>) &#x2014;
Whether the sphere has an articulation body or not.`,name:"with_articulation_body"},{anchor:"simulate.Sphere.set_mesh_direction",description:`<strong>set_mesh_direction</strong> (<em>np.ndarray</em> or <em>List[float]</em>, <em>optional</em>, defaults to <em>None</em>) &#x2014;
Direction the top of the sphere points to in <code>[x, y, z]</code>.
Default to top of sphere pointing in the <code>y</code> (up) direction.`,name:"set_mesh_direction"},{anchor:"simulate.Sphere.parent",description:`<strong>parent</strong> (<em>Asset</em>, <em>optional</em>, defaults to <em>None</em>) &#x2014;
Parent of the sphere.`,name:"parent"},{anchor:"simulate.Sphere.children",description:`<strong>children</strong> (<em>Asset</em> or <em>List[Asset]</em>, <em>optional</em>, defaults to <em>None</em>) &#x2014;
Children of the sphere.`,name:"children"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L406"}}),Ne=new $({props:{name:"class simulate.Capsule",anchor:"simulate.Capsule",parameters:[{name:"position",val:": typing.Optional[typing.List[float]] = None"},{name:"height",val:": float = 1.0"},{name:"radius",val:": float = 0.2"},{name:"theta_resolution",val:": int = 4"},{name:"phi_resolution",val:": int = 4"},{name:"sphere_type",val:": str = 'uv'"},{name:"with_collider",val:": bool = True"},{name:"name",val:": typing.Optional[str] = None"},{name:"is_actor",val:": bool = False"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"set_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"**kwargs",val:": typing.Any"}],parametersDescription:[{anchor:"simulate.Capsule.position",description:`<strong>position</strong> (<em>np.ndarray</em> or <em>List[float]</em>, <em>optional</em>, defaults to <em>[0, 0, 0]</em>) &#x2014;
Position of the capsule.`,name:"position"},{anchor:"simulate.Capsule.height",description:`<strong>height</strong> (<em>float</em>, <em>optional</em>, defaults to <em>1.0</em>) &#x2014;
Height of the capsule.`,name:"height"},{anchor:"simulate.Capsule.radius",description:`<strong>radius</strong> (<em>float</em>, <em>optional</em>, defaults to <em>0.2</em>) &#x2014;
Radius of the capsule.`,name:"radius"},{anchor:"simulate.Capsule.theta_resolution",description:`<strong>theta_resolution</strong> (<em>int</em>, <em>optional</em>, defaults to <em>4</em>) &#x2014;
Set the number of points in the longitude direction.`,name:"theta_resolution"},{anchor:"simulate.Capsule.phi_resolution",description:`<strong>phi_resolution</strong> (<em>int</em>, <em>optional</em>, defaults to <em>4</em>) &#x2014;
Set the number of points in the latitude direction.`,name:"phi_resolution"},{anchor:"simulate.Capsule.sphere_type",description:`<strong>sphere_type</strong> (<em>str</em>, <em>optional</em>, defaults to <em>&#x201C;uv&#x201D;</em>) &#x2014;
One of &#x2018;uv&#x2019; for a UV-sphere or &#x2018;ico&#x2019; for an icosphere.`,name:"sphere_type"},{anchor:"simulate.Capsule.with_collider",description:`<strong>with_collider</strong> (<em>bool</em>, <em>optional</em>, defaults to <em>True</em>) &#x2014;
Set to true to automatically add an associated Sphere collider.`,name:"with_collider"},{anchor:"simulate.Capsule.name",description:`<strong>name</strong> (<em>str</em>, <em>optional</em>, defaults to <em>None</em>) &#x2014;
Name of the capsule.`,name:"name"},{anchor:"simulate.Capsule.is_actor",description:`<strong>is_actor</strong> (<em>bool</em>, <em>optional</em>, defaults to <em>False</em>) &#x2014;
Whether the capsule is an actor or not.`,name:"is_actor"},{anchor:"simulate.Capsule.with_rigid_body",description:`<strong>with_rigid_body</strong> (<em>bool</em>, <em>optional</em>, defaults to <em>False</em>) &#x2014;
Whether the capsule has a rigid body or not.`,name:"with_rigid_body"},{anchor:"simulate.Capsule.with_articulation_body",description:`<strong>with_articulation_body</strong> (<em>bool</em>, <em>optional</em>, defaults to <em>False</em>) &#x2014;
Whether the capsule has an articulation body or not.`,name:"with_articulation_body"},{anchor:"simulate.Capsule.set_mesh_direction",description:`<strong>set_mesh_direction</strong> (<em>np.ndarray</em> or <em>List[float]</em>, <em>optional</em>, defaults to <em>None</em>) &#x2014;
Direction the top of the capsule points to in <code>[x, y, z]</code>.
Default to top of capsule pointing in the <code>y</code> (up) direction.`,name:"set_mesh_direction"},{anchor:"simulate.Capsule.parent",description:`<strong>parent</strong> (<em>Asset</em>, <em>optional</em>, defaults to <em>None</em>) &#x2014;
Parent of the capsule.`,name:"parent"},{anchor:"simulate.Capsule.children",description:`<strong>children</strong> (<em>Asset</em> or <em>List[Asset]</em>, <em>optional</em>, defaults to <em>None</em>) &#x2014;
Children of the capsule.`,name:"children"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L514"}}),$e=new $({props:{name:"class simulate.Cylinder",anchor:"simulate.Cylinder",parameters:[{name:"height",val:": float = 1.0"},{name:"radius",val:": float = 1.0"},{name:"resolution",val:": int = 16"},{name:"capping",val:": bool = True"},{name:"name",val:": typing.Optional[str] = None"},{name:"position",val:": typing.Optional[typing.List[float]] = None"},{name:"set_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"is_actor",val:": bool = False"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"**kwargs",val:": typing.Any"}],parametersDescription:[{anchor:"simulate.Cylinder.height",description:`<strong>height</strong> (<code>float</code>, <em>optional</em>, defaults to <code>1.0</code>) &#x2014;
Height of the cylinder.`,name:"height"},{anchor:"simulate.Cylinder.radius",description:`<strong>radius</strong> (<code>float</code>, <em>optional</em>, defaults to <code>1.0</code>) &#x2014;
Radius of the cylinder.`,name:"radius"},{anchor:"simulate.Cylinder.resolution",description:`<strong>resolution</strong> (<code>int</code>, <em>optional</em>, defaults to <code>16</code>) &#x2014;
Number of points on the circular face of the cylinder.`,name:"resolution"},{anchor:"simulate.Cylinder.capping",description:`<strong>capping</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Cap cylinder ends with polygons.`,name:"capping"},{anchor:"simulate.Cylinder.name",description:`<strong>name</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Name of the cylinder.`,name:"name"},{anchor:"simulate.Cylinder.position",description:`<strong>position</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>[0, 0, 0]</code>) &#x2014;
Position of the cylinder.`,name:"position"},{anchor:"simulate.Cylinder.set_mesh_direction",description:`<strong>set_mesh_direction</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Direction the top of the cylinder points to in <code>[x, y, z]</code>.
Default to top of cylinder pointing in the <code>y</code> (up) direction.`,name:"set_mesh_direction"},{anchor:"simulate.Cylinder.is_actor",description:`<strong>is_actor</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the cylinder is an actor or not.`,name:"is_actor"},{anchor:"simulate.Cylinder.with_rigid_body",description:`<strong>with_rigid_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the cylinder has a rigid body or not.`,name:"with_rigid_body"},{anchor:"simulate.Cylinder.with_articulation_body",description:`<strong>with_articulation_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the cylinder has an articulation body or not.`,name:"with_articulation_body"},{anchor:"simulate.Cylinder.parent",description:`<strong>parent</strong> (<code>Asset</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Parent of the cylinder.`,name:"parent"},{anchor:"simulate.Cylinder.children",description:`<strong>children</strong> (<code>Asset</code> or <code>List[Asset]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Children of the cylinder.`,name:"children"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L608"}}),Le=new $({props:{name:"class simulate.Box",anchor:"simulate.Box",parameters:[{name:"bounds",val:": typing.Union[int, float, typing.List[float], numpy.ndarray, typing.Tuple[float, ...], NoneType] = None"},{name:"level",val:": int = 0"},{name:"quads",val:": bool = True"},{name:"with_collider",val:": bool = True"},{name:"name",val:": typing.Optional[str] = None"},{name:"position",val:": typing.Optional[typing.List[float]] = None"},{name:"set_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"is_actor",val:": bool = False"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"**kwargs",val:": typing.Any"}],parametersDescription:[{anchor:"simulate.Box.bounds",description:`<strong>bounds</strong> (<em>float</em> or <em>np.ndarray</em> or <em>List[float]</em>, <em>optional</em>, defaults to <em>(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5)</em>) &#x2014;
Specify the bounding box of the cube as either:<ul>
<li>a list of 6 floats:(xMin, xMax, yMin, yMax, zMin, zMax)
=&gt; bounds are <code>(xMin, xMax, yMin, yMax, zMin, zMax)</code></li>
<li>a list of 3 floats: xSize, ySize, zSize
=&gt; bounds are <code>(-xSize/2, xSize/2, ySize/2, ySize/2, -zSize/2, zSize/2)</code><ul>
<li>a single float: size
=&gt; bounds are <code>(-size/2, size/2, size/2, size/2, -size/2, size/2)</code>
If no value is provided, create a centered unit box</li>
</ul></li>
</ul>`,name:"bounds"},{anchor:"simulate.Box.level",description:`<strong>level</strong> (<em>int</em>, <em>optional</em>, defaults to <em>0</em>) &#x2014;
The level of subdivision of the box. The number of faces will be 6*4**level.<ul>
<li><strong>quads</strong> (<em>bool</em>, <em>optional</em>, defaults to <em>True</em>) &#x2014;
If <em>True</em>, the faces of the box will be quads. Otherwise, they will be triangles.</li>
</ul>`,name:"level"},{anchor:"simulate.Box.with_colliders",description:`<strong>with_colliders</strong> (<em>bool</em>, <em>optional</em>, defaults to <em>True</em>) &#x2014;
Whether the box has colliders or not.`,name:"with_colliders"},{anchor:"simulate.Box.name",description:`<strong>name</strong> (<em>str</em>, <em>optional</em>, defaults to <em>None</em>) &#x2014;
Name of the box.`,name:"name"},{anchor:"simulate.Box.position",description:`<strong>position</strong> (<em>np.ndarray</em> or <em>List[float]</em>, <em>optional</em>, defaults to <em>[0, 0, 0]</em>) &#x2014;
Position of the box.`,name:"position"},{anchor:"simulate.Box.set_mesh_direction",description:`<strong>set_mesh_direction</strong> (<em>np.ndarray</em> or <em>List[float]</em>, <em>optional</em>, defaults to <em>None</em>) &#x2014;
Direction the top of the box points to in <em>[x, y, z]</em>.
Default to top of box pointing in the <em>y</em> (up) direction.`,name:"set_mesh_direction"},{anchor:"simulate.Box.is_actor",description:`<strong>is_actor</strong> (<em>bool</em>, <em>optional</em>, defaults to <em>False</em>) &#x2014;
Whether the box is an actor or not.`,name:"is_actor"},{anchor:"simulate.Box.with_rigid_body",description:`<strong>with_rigid_body</strong> (<em>bool</em>, <em>optional</em>, defaults to <em>False</em>) &#x2014;
Whether the box has a rigid body or not.`,name:"with_rigid_body"},{anchor:"simulate.Box.with_articulation_body",description:`<strong>with_articulation_body</strong> (<em>bool</em>, <em>optional</em>, defaults to <em>False</em>) &#x2014;
Whether the box has an articulation body or not.`,name:"with_articulation_body"},{anchor:"simulate.Box.parent",description:`<strong>parent</strong> (<em>Asset</em>, <em>optional</em>, defaults to <em>None</em>) &#x2014;
Parent of the box.`,name:"parent"},{anchor:"simulate.Box.children",description:`<strong>children</strong> (<em>Asset</em> or <em>List[Asset]</em>, <em>optional</em>, defaults to <em>None</em>) &#x2014;
Children of the box.`,name:"children"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L677"}}),Fe=new $({props:{name:"class simulate.Cone",anchor:"simulate.Cone",parameters:[{name:"height",val:": float = 1.0"},{name:"radius",val:": float = 1.0"},{name:"resolution",val:": int = 6"},{name:"name",val:": typing.Optional[str] = None"},{name:"position",val:": typing.Optional[typing.List[float]] = None"},{name:"set_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"is_actor",val:": bool = False"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"**kwargs",val:": typing.Any"}],parametersDescription:[{anchor:"simulate.Cone.height",description:`<strong>height</strong> (<code>float</code>, <em>optional</em>, defaults to <code>1.0</code>) &#x2014;
Height of the cone.`,name:"height"},{anchor:"simulate.Cone.radius",description:`<strong>radius</strong> (<code>float</code>, <em>optional</em>, defaults to <code>1.0</code>) &#x2014;
Radius of the cone.`,name:"radius"},{anchor:"simulate.Cone.resolution",description:`<strong>resolution</strong> (<code>int</code>, <em>optional</em>, defaults to <code>6</code>) &#x2014;
Number of facets used to represent the cone.`,name:"resolution"},{anchor:"simulate.Cone.name",description:`<strong>name</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Name of the cone.`,name:"name"},{anchor:"simulate.Cone.position",description:`<strong>position</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>[0, 0, 0]</code>) &#x2014;
Position of the cone.`,name:"position"},{anchor:"simulate.Cone.set_mesh_direction",description:`<strong>set_mesh_direction</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Direction the top of the cone points to in <code>[x, y, z]</code>.
Default to top of cone pointing in the <code>y</code> (up) direction.`,name:"set_mesh_direction"},{anchor:"simulate.Cone.is_actor",description:`<strong>is_actor</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the cone is an actor or not.`,name:"is_actor"},{anchor:"simulate.Cone.with_rigid_body",description:`<strong>with_rigid_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the cone has a rigid body or not.`,name:"with_rigid_body"},{anchor:"simulate.Cone.with_articulation_body",description:`<strong>with_articulation_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the cone has an articulation body or not.`,name:"with_articulation_body"},{anchor:"simulate.Cone.parent",description:`<strong>parent</strong> (<code>Asset</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Parent of the cone.`,name:"parent"},{anchor:"simulate.Cone.children",description:`<strong>children</strong> (<code>Asset</code> or <code>List[Asset]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Children of the cone.`,name:"children"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L775"}}),Ae=new $({props:{name:"class simulate.Line",anchor:"simulate.Line",parameters:[{name:"pointa",val:": typing.Optional[typing.List[float]] = None"},{name:"pointb",val:": typing.Optional[typing.List[float]] = None"},{name:"resolution",val:": int = 1"},{name:"name",val:": typing.Optional[str] = None"},{name:"is_actor",val:": bool = False"},{name:"set_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"**kwargs",val:": typing.Any"}],parametersDescription:[{anchor:"simulate.Line.pointa",description:`<strong>pointa</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>[-1.0, 0.0, 0.0]</code>) &#x2014;
Location of the first point of the line.`,name:"pointa"},{anchor:"simulate.Line.pointb",description:`<strong>pointb</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>[1.0, 0.0, 0.0]</code>) &#x2014;
Location of the second point of the line.`,name:"pointb"},{anchor:"simulate.Line.resolution",description:`<strong>resolution</strong> (<code>int</code>, <em>optional</em>, defaults to <code>1</code>) &#x2014;
Number of pieces to divide line into.`,name:"resolution"},{anchor:"simulate.Line.name",description:`<strong>name</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Name of the line.`,name:"name"},{anchor:"simulate.Line.set_mesh_direction",description:`<strong>set_mesh_direction</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Direction the line points to in <code>[x, y, z]</code>.
Default to line pointing in the <code>x</code> direction.`,name:"set_mesh_direction"},{anchor:"simulate.Line.is_actor",description:`<strong>is_actor</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the line is an actor or not.`,name:"is_actor"},{anchor:"simulate.Line.with_rigid_body",description:`<strong>with_rigid_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the line has a rigid body or not.`,name:"with_rigid_body"},{anchor:"simulate.Line.with_articulation_body",description:`<strong>with_articulation_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the line has an articulation body or not.`,name:"with_articulation_body"},{anchor:"simulate.Line.parent",description:`<strong>parent</strong> (<code>Asset</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Parent of the line.`,name:"parent"},{anchor:"simulate.Line.children",description:`<strong>children</strong> (<code>Asset</code> or <code>List[Asset]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Children of the line.`,name:"children"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L839"}}),De=new $({props:{name:"class simulate.MultipleLines",anchor:"simulate.MultipleLines",parameters:[{name:"points",val:": typing.Optional[typing.List[typing.List[float]]] = None"},{name:"name",val:": typing.Optional[str] = None"},{name:"is_actor",val:": bool = False"},{name:"set_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"**kwargs",val:": typing.Any"}],parametersDescription:[{anchor:"simulate.MultipleLines.points",description:`<strong>points</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
List of points defining a broken line, default is <code>[[-0.5, 0.0, 0.0], [0.5, 0.0, 0.0]]</code>.`,name:"points"},{anchor:"simulate.MultipleLines.name",description:`<strong>name</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Name of the multiple lines.`,name:"name"},{anchor:"simulate.MultipleLines.is_actor",description:`<strong>is_actor</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the multiple lines is an actor or not.`,name:"is_actor"},{anchor:"simulate.MultipleLines.set_mesh_direction",description:`<strong>set_mesh_direction</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Direction the multiple lines points to in <code>[x, y, z]</code>.
Default to multiple lines pointing in the <code>x</code> direction.`,name:"set_mesh_direction"},{anchor:"simulate.MultipleLines.with_rigid_body",description:`<strong>with_rigid_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the multiple lines have a rigid body or not.`,name:"with_rigid_body"},{anchor:"simulate.MultipleLines.with_articulation_body",description:`<strong>with_articulation_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the multiple lines have an articulation body or not.`,name:"with_articulation_body"},{anchor:"simulate.MultipleLines.parent",description:`<strong>parent</strong> (<code>Asset</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Parent of the multiple lines.`,name:"parent"},{anchor:"simulate.MultipleLines.children",description:`<strong>children</strong> (<code>Asset</code> or <code>List[Asset]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Children of the multiple lines.`,name:"children"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L903"}}),Oe=new $({props:{name:"class simulate.Tube",anchor:"simulate.Tube",parameters:[{name:"pointa",val:": typing.Optional[typing.List[float]] = None"},{name:"pointb",val:": typing.Optional[typing.List[float]] = None"},{name:"resolution",val:": int = 1"},{name:"radius",val:": float = 1.0"},{name:"n_sides",val:": int = 16"},{name:"name",val:": typing.Optional[str] = None"},{name:"is_actor",val:": bool = False"},{name:"set_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"**kwargs",val:": typing.Any"}],parametersDescription:[{anchor:"simulate.Tube.pointa",description:`<strong>pointa</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>[-1.0, 0.0, 0.0]</code>) &#x2014;
Location of the first point of the tube.`,name:"pointa"},{anchor:"simulate.Tube.pointb",description:`<strong>pointb</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>[1.0, 0.0, 0.0]</code>) &#x2014;
Location of the second point of the tube.`,name:"pointb"},{anchor:"simulate.Tube.resolution",description:`<strong>resolution</strong> (<code>int</code>, <em>optional</em>, defaults to <code>1</code>) &#x2014;
Number of pieces to divide tube into.`,name:"resolution"},{anchor:"simulate.Tube.radius",description:`<strong>radius</strong> (<code>float</code>, <em>optional</em>, defaults to <code>0.1</code>) &#x2014;
Minimum tube radius (minimum because the tube radius may vary).`,name:"radius"},{anchor:"simulate.Tube.n_sides",description:`<strong>n_sides</strong> (<code>int</code>, <em>optional</em>, defaults to <code>16</code>) &#x2014;
Number of sides of the tube.`,name:"n_sides"},{anchor:"simulate.Tube.name",description:`<strong>name</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Name of the tube.`,name:"name"},{anchor:"simulate.Tube.is_actor",description:`<strong>is_actor</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the tube is an actor or not.`,name:"is_actor"},{anchor:"simulate.Tube.set_mesh_direction",description:`<strong>set_mesh_direction</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Direction the tube points to in <code>[x, y, z]</code>.
Default to tube pointing in the <code>y</code> direction.`,name:"set_mesh_direction"},{anchor:"simulate.Tube.with_rigid_body",description:`<strong>with_rigid_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the tube has a rigid body or not.`,name:"with_rigid_body"},{anchor:"simulate.Tube.with_articulation_body",description:`<strong>with_articulation_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the tube has an articulation body or not.`,name:"with_articulation_body"},{anchor:"simulate.Tube.parent",description:`<strong>parent</strong> (<code>Asset</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Parent of the tube.`,name:"parent"},{anchor:"simulate.Tube.children",description:`<strong>children</strong> (<code>Asset</code> or <code>List[Asset]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Children of the tube.`,name:"children"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L958"}}),Pe=new $({props:{name:"class simulate.Polygon",anchor:"simulate.Polygon",parameters:[{name:"points",val:": typing.List[typing.List[float]]"},{name:"position",val:": typing.Optional[typing.List[float]] = None"},{name:"name",val:": typing.Optional[str] = None"},{name:"is_actor",val:": bool = False"},{name:"set_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"with_collider",val:": bool = False"},{name:"**kwargs",val:": typing.Any"}],parametersDescription:[{anchor:"simulate.Polygon.points",description:`<strong>points</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
List of points defining the polygon,
e.g. <code>[[0, 0, 0], [1, 0, -.1], [.8, 0, .5], [1, 0, 1], [.6, 0, 1.2], [0, 0, .8]]</code>.
The polygon is defined by an ordered list of three or more points lying in a plane.
The polygon normal is implicitly defined by a counterclockwise ordering of
its points using the right-hand rule.`,name:"points"},{anchor:"simulate.Polygon.position",description:`<strong>position</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>[0, 0, 0]</code>) &#x2014;
Position of the polygon.`,name:"position"},{anchor:"simulate.Polygon.name",description:`<strong>name</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Name of the polygon.`,name:"name"},{anchor:"simulate.Polygon.is_actor",description:`<strong>is_actor</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the polygon is an actor or not.`,name:"is_actor"},{anchor:"simulate.Polygon.set_mesh_direction",description:`<strong>set_mesh_direction</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Direction the polygon points to in <code>[x, y, z]</code>.
Default to polygon pointing in the <code>y</code> direction.`,name:"set_mesh_direction"},{anchor:"simulate.Polygon.with_rigid_body",description:`<strong>with_rigid_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the polygon has a rigid body or not.`,name:"with_rigid_body"},{anchor:"simulate.Polygon.with_articulation_body",description:`<strong>with_articulation_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the polygon has an articulation body or not.`,name:"with_articulation_body"},{anchor:"simulate.Polygon.parent",description:`<strong>parent</strong> (<code>Asset</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Parent of the polygon.`,name:"parent"},{anchor:"simulate.Polygon.children",description:`<strong>children</strong> (<code>Asset</code> or <code>List[Asset]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Children of the polygon.`,name:"children"},{anchor:"simulate.Polygon.with_colliders",description:`<strong>with_colliders</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the polygon has colliders or not.`,name:"with_colliders"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L1027"}}),Ce=new $({props:{name:"class simulate.RegularPolygon",anchor:"simulate.RegularPolygon",parameters:[{name:"radius",val:": float = 1.0"},{name:"n_sides",val:": int = 6"},{name:"position",val:": typing.Optional[typing.List[float]] = None"},{name:"name",val:": typing.Optional[str] = None"},{name:"is_actor",val:": bool = False"},{name:"set_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"**kwargs",val:": typing.Any"}],parametersDescription:[{anchor:"simulate.RegularPolygon.radius",description:`<strong>radius</strong> (<code>float</code>, <em>optional</em>, defaults to <code>1.0</code>) &#x2014;
Radius of the regular polygon.`,name:"radius"},{anchor:"simulate.RegularPolygon.n_sides",description:`<strong>n_sides</strong> (<code>int</code>, <em>optional</em>, defaults to <code>6</code>) &#x2014;
Number of sides of the regular polygon.`,name:"n_sides"},{anchor:"simulate.RegularPolygon.position",description:`<strong>position</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>[0, 0, 0]</code>) &#x2014;
Position of the regular polygon.`,name:"position"},{anchor:"simulate.RegularPolygon.name",description:`<strong>name</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Name of the regular polygon.`,name:"name"},{anchor:"simulate.RegularPolygon.is_actor",description:`<strong>is_actor</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the regular polygon is an actor or not.`,name:"is_actor"},{anchor:"simulate.RegularPolygon.set_mesh_direction",description:`<strong>set_mesh_direction</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Direction the regular polygon points to in <code>[x, y, z]</code>.
Default to regular polygon pointing in the <code>y</code> direction.`,name:"set_mesh_direction"},{anchor:"simulate.RegularPolygon.with_rigid_body",description:`<strong>with_rigid_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the regular polygon has a rigid body or not.`,name:"with_rigid_body"},{anchor:"simulate.RegularPolygon.with_articulation_body",description:`<strong>with_articulation_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the regular polygon has an articulation body or not.`,name:"with_articulation_body"},{anchor:"simulate.RegularPolygon.parent",description:`<strong>parent</strong> (<code>Asset</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Parent of the regular polygon.`,name:"parent"},{anchor:"simulate.RegularPolygon.children",description:`<strong>children</strong> (<code>Asset</code> or <code>List[Asset]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Children of the regular polygon.`,name:"children"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L1121"}}),Te=new $({props:{name:"class simulate.Ring",anchor:"simulate.Ring",parameters:[{name:"inner",val:": float = 0.25"},{name:"outer",val:": float = 0.5"},{name:"r_res",val:": int = 1"},{name:"c_res",val:": int = 6"},{name:"name",val:": typing.Optional[str] = None"},{name:"position",val:": typing.Optional[typing.List[float]] = None"},{name:"set_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"is_actor",val:": bool = False"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"**kwargs",val:": typing.Any"}],parametersDescription:[{anchor:"simulate.Ring.inner",description:`<strong>inner</strong> (<code>float</code>, <em>optional</em>, defaults to <code>0.25</code>) &#x2014;
Inner radius of the ring.`,name:"inner"},{anchor:"simulate.Ring.outer",description:`<strong>outer</strong> (<code>float</code>, <em>optional</em>, defaults to <code>0.5</code>) &#x2014;
Outer radius of the ring.`,name:"outer"},{anchor:"simulate.Ring.r_res",description:`<strong>r_res</strong> (<code>int</code>, <em>optional</em>, defaults to <code>1</code>) &#x2014;
Number of points in radial direction.`,name:"r_res"},{anchor:"simulate.Ring.c_res",description:`<strong>c_res</strong> (<code>int</code>, <em>optional</em>, defaults to <code>6</code>) &#x2014;
Number of points in circumferential direction.`,name:"c_res"},{anchor:"simulate.Ring.name",description:`<strong>name</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Name of the ring.`,name:"name"},{anchor:"simulate.Ring.position",description:`<strong>position</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>[0, 0, 0]</code>) &#x2014;
Position of the ring.`,name:"position"},{anchor:"simulate.Ring.set_mesh_direction",description:`<strong>set_mesh_direction</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Direction the ring points to in <code>[x, y, z]</code>.
Default to ring pointing in the <code>y</code> direction.`,name:"set_mesh_direction"},{anchor:"simulate.Ring.is_actor",description:`<strong>is_actor</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the ring is an actor or not.`,name:"is_actor"},{anchor:"simulate.Ring.with_rigid_body",description:`<strong>with_rigid_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the ring has a rigid body or not.`,name:"with_rigid_body"},{anchor:"simulate.Ring.with_articulation_body",description:`<strong>with_articulation_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the ring has an articulation body or not.`,name:"with_articulation_body"},{anchor:"simulate.Ring.parent",description:`<strong>parent</strong> (<code>Asset</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Parent of the ring.`,name:"parent"},{anchor:"simulate.Ring.children",description:`<strong>children</strong> (<code>Asset</code> or <code>List[Asset]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Children of the ring.`,name:"children"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L1183"}}),Re=new $({props:{name:"class simulate.Text3D",anchor:"simulate.Text3D",parameters:[{name:"string",val:": str = 'Hello'"},{name:"depth",val:": float = 0.5"},{name:"name",val:": typing.Optional[str] = None"},{name:"position",val:": typing.Optional[typing.List[float]] = None"},{name:"set_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"is_actor",val:": bool = False"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"**kwargs",val:": typing.Any"}],parametersDescription:[{anchor:"simulate.Text3D.string",description:`<strong>string</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
String to be converted to 3D text.`,name:"string"},{anchor:"simulate.Text3D.depth",description:`<strong>depth</strong> (<code>float</code>, <em>optional</em>, defaults to <code>0.5</code>) &#x2014;
Depth of the text.`,name:"depth"},{anchor:"simulate.Text3D.name",description:`<strong>name</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Name of the text.`,name:"name"},{anchor:"simulate.Text3D.position",description:`<strong>position</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>[0, 0, 0]</code>) &#x2014;
Position of the text.`,name:"position"},{anchor:"simulate.Text3D.set_mesh_direction",description:`<strong>set_mesh_direction</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Direction the text points to in <code>[x, y, z]</code>.
Default to text pointing in the <code>z</code> direction.`,name:"set_mesh_direction"},{anchor:"simulate.Text3D.is_actor",description:`<strong>is_actor</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the text is an actor or not.`,name:"is_actor"},{anchor:"simulate.Text3D.with_rigid_body",description:`<strong>with_rigid_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the text has a rigid body or not.`,name:"with_rigid_body"},{anchor:"simulate.Text3D.with_articulation_body",description:`<strong>with_articulation_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the text has an articulation body or not.`,name:"with_articulation_body"},{anchor:"simulate.Text3D.parent",description:`<strong>parent</strong> (<code>Asset</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Parent of the text.`,name:"parent"},{anchor:"simulate.Text3D.children",description:`<strong>children</strong> (<code>Asset</code> or <code>List[Asset]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Children of the text.`,name:"children"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L1255"}}),Ee=new $({props:{name:"class simulate.Triangle",anchor:"simulate.Triangle",parameters:[{name:"points",val:": typing.Optional[typing.List[typing.List[float]]] = None"},{name:"name",val:": typing.Optional[str] = None"},{name:"is_actor",val:": bool = False"},{name:"set_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"**kwargs",val:": typing.Any"}],parametersDescription:[{anchor:"simulate.Triangle.points",description:`<strong>points</strong> (<code>np.ndarray</code> or <code>List[List[float]]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Points of the triangle.`,name:"points"},{anchor:"simulate.Triangle.name",description:`<strong>name</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Name of the triangle.`,name:"name"},{anchor:"simulate.Triangle.is_actor",description:`<strong>is_actor</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the triangle is an actor or not.`,name:"is_actor"},{anchor:"simulate.Triangle.set_mesh_direction",description:`<strong>set_mesh_direction</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Direction the triangle points to in <code>[x, y, z]</code>.
Default to triangle pointing in the <code>y</code> direction.`,name:"set_mesh_direction"},{anchor:"simulate.Triangle.with_rigid_body",description:`<strong>with_rigid_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the triangle has a rigid body or not.`,name:"with_rigid_body"},{anchor:"simulate.Triangle.with_articulation_body",description:`<strong>with_articulation_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the triangle has an articulation body or not.`,name:"with_articulation_body"},{anchor:"simulate.Triangle.parent",description:`<strong>parent</strong> (<code>Asset</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Parent of the triangle.`,name:"parent"},{anchor:"simulate.Triangle.children",description:`<strong>children</strong> (<code>Asset</code> or <code>List[Asset]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Children of the triangle.`,name:"children"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L1319"}}),je=new $({props:{name:"class simulate.Rectangle",anchor:"simulate.Rectangle",parameters:[{name:"points",val:": typing.Optional[typing.List[typing.List[float]]] = None"},{name:"name",val:": typing.Optional[str] = None"},{name:"is_actor",val:": bool = False"},{name:"set_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"**kwargs",val:": typing.Any"}],parametersDescription:[{anchor:"simulate.Rectangle.points",description:`<strong>points</strong> (<code>np.ndarray</code> or <code>List[List[float]]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Points of the rectangle.`,name:"points"},{anchor:"simulate.Rectangle.name",description:`<strong>name</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Name of the rectangle.`,name:"name"},{anchor:"simulate.Rectangle.is_actor",description:`<strong>is_actor</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the rectangle is an actor or not.`,name:"is_actor"},{anchor:"simulate.Rectangle.set_mesh_direction",description:`<strong>set_mesh_direction</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Direction the rectangle points to in <code>[x, y, z]</code>.
Default to rectangle pointing in the <code>y</code> direction.`,name:"set_mesh_direction"},{anchor:"simulate.Rectangle.with_rigid_body",description:`<strong>with_rigid_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the rectangle has a rigid body or not.`,name:"with_rigid_body"},{anchor:"simulate.Rectangle.with_articulation_body",description:`<strong>with_articulation_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the rectangle has an articulation body or not.`,name:"with_articulation_body"},{anchor:"simulate.Rectangle.parent",description:`<strong>parent</strong> (<code>Asset</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Parent of the rectangle.`,name:"parent"},{anchor:"simulate.Rectangle.children",description:`<strong>children</strong> (<code>Asset</code> or <code>List[Asset]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Children of the rectangle.`,name:"children"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L1372"}}),Se=new $({props:{name:"class simulate.Circle",anchor:"simulate.Circle",parameters:[{name:"radius",val:": float = 0.5"},{name:"resolution",val:": int = 100"},{name:"name",val:": typing.Optional[str] = None"},{name:"position",val:": typing.Optional[typing.List[float]] = None"},{name:"is_actor",val:": bool = False"},{name:"set_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"**kwargs",val:": typing.Any"}],parametersDescription:[{anchor:"simulate.Circle.radius",description:`<strong>radius</strong> (<code>float</code>, <em>optional</em>, defaults to <code>0.5</code>) &#x2014;
Radius of the circle.`,name:"radius"},{anchor:"simulate.Circle.resolution",description:`<strong>resolution</strong> (<code>int</code>, <em>optional</em>, defaults to <code>100</code>) &#x2014;
Number of points to define the circle.`,name:"resolution"},{anchor:"simulate.Circle.name",description:`<strong>name</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Name of the circle.`,name:"name"},{anchor:"simulate.Circle.position",description:`<strong>position</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>[0, 0, 0]</code>) &#x2014;
Position of the circle.`,name:"position"},{anchor:"simulate.Circle.is_actor",description:`<strong>is_actor</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the circle is an actor or not.`,name:"is_actor"},{anchor:"simulate.Circle.set_mesh_direction",description:`<strong>set_mesh_direction</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Direction the circle points to in <code>[x, y, z]</code>.
Default to circle pointing in the <code>y</code> direction.`,name:"set_mesh_direction"},{anchor:"simulate.Circle.with_rigid_body",description:`<strong>with_rigid_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the circle has a rigid body or not.`,name:"with_rigid_body"},{anchor:"simulate.Circle.with_articulation_body",description:`<strong>with_articulation_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the circle has an articulation body or not.`,name:"with_articulation_body"},{anchor:"simulate.Circle.parent",description:`<strong>parent</strong> (<code>Asset</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Parent of the circle.`,name:"parent"},{anchor:"simulate.Circle.children",description:`<strong>children</strong> (<code>Asset</code> or <code>List[Asset]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Children of the circle.`,name:"children"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L1425"}}),ze=new $({props:{name:"class simulate.StructuredGrid",anchor:"simulate.StructuredGrid",parameters:[{name:"x",val:": typing.Union[numpy.ndarray, typing.List[typing.List[float]]]"},{name:"y",val:": typing.Union[numpy.ndarray, typing.List[typing.List[float]]]"},{name:"z",val:": typing.Union[numpy.ndarray, typing.List[typing.List[float]]]"},{name:"name",val:": typing.Optional[str] = None"},{name:"position",val:": typing.Optional[typing.List[float]] = None"},{name:"set_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"is_actor",val:": bool = False"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"**kwargs",val:": typing.Any"}],parametersDescription:[{anchor:"simulate.StructuredGrid.x",description:`<strong>x</strong> (<code>np.ndarray</code> or <code>List[List[float]]</code>) &#x2014;
Position of the points in x direction.`,name:"x"},{anchor:"simulate.StructuredGrid.y",description:`<strong>y</strong> (<code>np.ndarray</code> or <code>List[List[float]]</code>) &#x2014;
Position of the points in y direction.`,name:"y"},{anchor:"simulate.StructuredGrid.z",description:`<strong>z</strong> (<code>np.ndarray</code> or <code>List[List[float]]</code>) &#x2014;
Position of the points in z direction.`,name:"z"},{anchor:"simulate.StructuredGrid.name",description:`<strong>name</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Name of the structured grid.`,name:"name"},{anchor:"simulate.StructuredGrid.position",description:`<strong>position</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>[0, 0, 0]</code>) &#x2014;
Position of the structured grid.`,name:"position"},{anchor:"simulate.StructuredGrid.set_mesh_direction",description:`<strong>set_mesh_direction</strong> (<code>np.ndarray</code> or <code>List[float]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Direction the structured grid points to in <code>[x, y, z]</code>.
Default to structured grid pointing in the <code>y</code> direction.`,name:"set_mesh_direction"},{anchor:"simulate.StructuredGrid.is_actor",description:`<strong>is_actor</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the structured grid is an actor or not.`,name:"is_actor"},{anchor:"simulate.StructuredGrid.with_rigid_body",description:`<strong>with_rigid_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the structured grid has a rigid body or not.`,name:"with_rigid_body"},{anchor:"simulate.StructuredGrid.with_articulation_body",description:`<strong>with_articulation_body</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the structured grid has an articulation body or not.`,name:"with_articulation_body"},{anchor:"simulate.StructuredGrid.parent",description:`<strong>parent</strong> (<code>Asset</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Parent of the structured grid.`,name:"parent"},{anchor:"simulate.StructuredGrid.children",description:`<strong>children</strong> (<code>Asset</code> or <code>List[Asset]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Children of the structured grid.`,name:"children"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L1488"}}),se=new ci({props:{anchor:"simulate.StructuredGrid.example",$$slots:{default:[mi]},$$scope:{ctx:C}}}),ke=new $({props:{name:"class simulate.ProcGenGrid",anchor:"simulate.ProcGenGrid",parameters:[{name:"sample_map",val:": typing.Union[numpy.ndarray, typing.List[typing.List[typing.List[int]]]] = None"},{name:"specific_map",val:": typing.Union[numpy.ndarray, typing.List[typing.List[typing.List[int]]]] = None"},{name:"tiles",val:": typing.Optional[typing.List] = None"},{name:"neighbors",val:": typing.Optional[typing.List] = None"},{name:"symmetries",val:": typing.Optional[typing.List] = None"},{name:"weights",val:": typing.Optional[typing.List] = None"},{name:"width",val:": int = 9"},{name:"height",val:": int = 9"},{name:"shallow",val:": bool = False"},{name:"algorithm_args",val:": typing.Optional[dict] = None"},{name:"seed",val:": int = None"},{name:"name",val:": typing.Optional[str] = None"},{name:"is_actor",val:": bool = False"},{name:"position",val:": typing.Optional[typing.List[float]] = None"},{name:"set_mesh_direction",val:": typing.Optional[typing.List[float]] = None"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"verbose",val:": bool = False"},{name:"**kwargs",val:": typing.Any"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L1574"}}),We=new Ze({}),Ie=new Ze({}),Ue=new $({props:{name:"generate_3D",anchor:"simulate.ProcGenGrid.generate_3D",parameters:[{name:"name",val:": typing.Optional[str] = None"},{name:"is_actor",val:": bool = False"},{name:"with_rigid_body",val:": bool = False"},{name:"with_articulation_body",val:": bool = False"},{name:"parent",val:": typing.Optional[ForwardRef('Asset')] = None"},{name:"children",val:": typing.Union[ForwardRef('Asset'), typing.List[ForwardRef('Asset')], NoneType] = None"},{name:"**kwargs",val:": typing.Any"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L1713"}}),Ve=new $({props:{name:"class simulate.ProcGenPrimsMaze3D",anchor:"simulate.ProcGenPrimsMaze3D",parameters:[{name:"width",val:": int"},{name:"depth",val:": int"},{name:"name",val:": typing.Optional[str] = None"},{name:"wall_keep_prob",val:": float = 0.5"},{name:"wall_material",val:": typing.Optional[simulate.assets.material.Material] = None"},{name:"**kwargs",val:": typing.Any"}],source:"https://github.com/huggingface/simulate/blob/main/src/simulate/assets/object.py#L1743"}}),{c(){u=n("meta"),x=r(),L=n("h1"),w=n("a"),O=n("span"),_(h.$$.fragment),F=r(),S=n("span"),T=m("Objects"),M=r(),A=n("p"),N=m("The base object class is "),P=n("code"),He=m("Object3D"),Xe=m("."),St=r(),E=n("div"),_(fe.$$.fragment),Ao=r(),Qe=n("p"),Do=m("Create a 3D Object."),Oo=r(),j=n("div"),_(_e.$$.fragment),Po=r(),Ke=n("p"),Co=m("Build a collider from the mesh."),To=r(),ae=n("h2"),ie=n("a"),et=n("span"),_(ye.$$.fragment),Ro=r(),tt=n("span"),Eo=m("Parameters"),jo=r(),ot=n("p"),So=m(`max_convex_hulls : int, optional
Maximum number of convex hulls to generate, by default 16
resolution : int, optional
Resolution of the voxel grid, by default 4000
minimum_volume_percent_error_allowed : float, optional
Minimum volume percent error allowed, by default 1
max_recursion_depth : int, optional
Maximum recursion depth, by default 10
shrink_wrap : bool, optional
Shrink wrap, by default True
fill_mode : str, optional
Fill mode, by default \u201CFLOOD_FILL\u201D
max_num_vertices_per_hull : int, optional
Maximum number of vertices per hull, by default 64
async_ACD : bool, optional
Async ACD, by default True
min_edge_length : int, optional
Minimum edge length, by default 2
find_best_plane : bool, optional
Find best plane, by default False`),zo=r(),I=n("div"),_(be.$$.fragment),ko=r(),nt=n("p"),Wo=m("Copy an Object3D node in a new (returned) object."),Mo=r(),at=n("p"),Io=m(`By default, mesh and materials are copied in respectively new mesh and material.
\u2018share_material\u2019 and \u2018share_mesh\u2019 can be set to True to share mesh and/or material
between original and copy instead of creating new one.`),zt=r(),U=n("h2"),re=n("a"),it=n("span"),_(ve.$$.fragment),Uo=r(),rt=n("span"),Go=m("Other included objects"),kt=r(),G=n("div"),_(we.$$.fragment),Vo=r(),st=n("p"),Bo=m("Create a plane."),Wt=r(),V=n("div"),_(xe.$$.fragment),Ho=r(),lt=n("p"),Xo=m("Create a Sphere"),Mt=r(),B=n("div"),_(Ne.$$.fragment),qo=r(),dt=n("p"),Yo=m("A capsule (a cylinder with hemispheric ends)."),It=r(),H=n("div"),_($e.$$.fragment),Jo=r(),ct=n("p"),Zo=m("Create the surface of a cylinder."),Ut=r(),X=n("div"),_(Le.$$.fragment),Qo=r(),mt=n("p"),Ko=m("Create a box with solid faces for the given bounds."),Gt=r(),q=n("div"),_(Fe.$$.fragment),en=r(),pt=n("p"),tn=m("Create a cone."),Vt=r(),Y=n("div"),_(Ae.$$.fragment),on=r(),ht=n("p"),nn=m("Create a line."),Bt=r(),J=n("div"),_(De.$$.fragment),an=r(),ut=n("p"),rn=m("Create multiple lines."),Ht=r(),Z=n("div"),_(Oe.$$.fragment),sn=r(),gt=n("p"),ln=m("Create a tube that goes from point A to point B."),Xt=r(),Q=n("div"),_(Pe.$$.fragment),dn=r(),ft=n("p"),cn=m("Create a polygon."),qt=r(),K=n("div"),_(Ce.$$.fragment),mn=r(),_t=n("p"),pn=m("Create a regular polygon."),Yt=r(),z=n("div"),_(Te.$$.fragment),hn=r(),yt=n("p"),un=m("Create a polygonal disk with a hole in the center."),gn=r(),bt=n("p"),fn=m(`The disk has zero height. The user can specify the inner and outer
radius of the disk, and the radial and circumferential resolution
of the polygonal representation.`),Jt=r(),ee=n("div"),_(Re.$$.fragment),_n=r(),vt=n("p"),yn=m("Create 3D text from a string."),Zt=r(),te=n("div"),_(Ee.$$.fragment),bn=r(),wt=n("p"),vn=m("Create a triangle defined by 3 points."),Qt=r(),oe=n("div"),_(je.$$.fragment),wn=r(),xt=n("p"),xn=m("Create a rectangle defined by 4 points."),Kt=r(),ne=n("div"),_(Se.$$.fragment),Nn=r(),Nt=n("p"),$n=m("Create a single PolyData circle defined by radius in the XY plane."),eo=r(),k=n("div"),_(ze.$$.fragment),Ln=r(),$t=n("p"),Fn=m("Create a 3D grid (structured plane) defined by lists of X, Y and Z positions of points."),An=r(),_(se.$$.fragment),to=r(),D=n("div"),_(ke.$$.fragment),Dn=r(),Lt=n("p"),On=m(`Create a procedural generated 3D grid (structured plane) from
tiles / previous map.`),Pn=r(),le=n("h2"),de=n("a"),Ft=n("span"),_(We.$$.fragment),Cn=r(),At=n("span"),Tn=m("Parameters"),Rn=r(),Dt=n("p"),En=m(`sample_map : np.ndarray or python list of lists of floats
Map to procedurally generate from.
specific_map: np.ndarray or python list of lists of floats
Map to show as it is.
tiles : list of tiles
Tiles for procedural generation when using generation from tiles and neighbors definitions.
Tiles must be NxN np.ndarray that define height maps. In the future, we plan to support
more generic tiles.
neighbors: list of available neighbors for each tile
Expects pair of tiles.
symmetries: list of char
Expects a list of symmetry definitions. If passed, you must define a symmetry for each tile.
Possible symmetries are \u201CX\u201D, \u201CI\u201D / \u201D/\u201D, \u201CT\u201D / \u201CL\u201D, another character, and each character defines
the tile with the same level of symmetry as the character:`),jn=r(),W=n("ul"),Ot=n("li"),Sn=m("X: has symmetry in all ways. So it has 1 different format."),zn=r(),Me=n("li"),kn=m("I / "),Pt=n("code"),Wn=m("/"),Mn=m(": when rotated, it\u2019s different from the original tile. Has 2 different formats."),In=r(),Ct=n("li"),Un=m("T / L: Has 4 different formats."),Gn=r(),Tt=n("li"),Vn=m(`other characters: the algorithm supposes it has 8 different formats.
weights: list of floats
sampling weights for each of the tiles
width: int
width of the generated map
height: int
height of the generated map
shallow: bool
Indicates whether procedural generation mesh should be generated in simenv or not.
When it\u2019s true, we just return the map returned by the algorithm without
actually creating the mesh in simenv.
Created for the purpose of optimizing certain environments such as XLand.
seed: int
Random seed used for procedural generation.
algorithm_args: dict
Extra arguments to be passed to the procedural generation.
Returns`),Bn=r(),Hn=n("hr"),Xn=r(),ce=n("h2"),me=n("a"),Rt=n("span"),_(Ie.$$.fragment),qn=r(),Et=n("span"),Yn=m("Examples"),Jn=r(),pe=n("div"),_(Ue.$$.fragment),Zn=r(),jt=n("p"),Qn=m("Function for creating the mesh in case the creation of map was shallow."),oo=r(),Ge=n("div"),_(Ve.$$.fragment),this.h()},l(e){const l=ai('[data-svelte="svelte-1phssyn"]',document.head);u=a(l,"META",{name:!0,content:!0}),l.forEach(o),x=s(e),L=a(e,"H1",{class:!0});var Be=i(L);w=a(Be,"A",{id:!0,class:!0,href:!0});var Kn=i(w);O=a(Kn,"SPAN",{});var ea=i(O);y(h.$$.fragment,ea),ea.forEach(o),Kn.forEach(o),F=s(Be),S=a(Be,"SPAN",{});var ta=i(S);T=p(ta,"Objects"),ta.forEach(o),Be.forEach(o),M=s(e),A=a(e,"P",{});var ao=i(A);N=p(ao,"The base object class is "),P=a(ao,"CODE",{});var oa=i(P);He=p(oa,"Object3D"),oa.forEach(o),Xe=p(ao,"."),ao.forEach(o),St=s(e),E=a(e,"DIV",{class:!0});var he=i(E);y(fe.$$.fragment,he),Ao=s(he),Qe=a(he,"P",{});var na=i(Qe);Do=p(na,"Create a 3D Object."),na.forEach(o),Oo=s(he),j=a(he,"DIV",{class:!0});var ue=i(j);y(_e.$$.fragment,ue),Po=s(ue),Ke=a(ue,"P",{});var aa=i(Ke);Co=p(aa,"Build a collider from the mesh."),aa.forEach(o),To=s(ue),ae=a(ue,"H2",{class:!0});var io=i(ae);ie=a(io,"A",{id:!0,class:!0,href:!0});var ia=i(ie);et=a(ia,"SPAN",{});var ra=i(et);y(ye.$$.fragment,ra),ra.forEach(o),ia.forEach(o),Ro=s(io),tt=a(io,"SPAN",{});var sa=i(tt);Eo=p(sa,"Parameters"),sa.forEach(o),io.forEach(o),jo=s(ue),ot=a(ue,"P",{});var la=i(ot);So=p(la,`max_convex_hulls : int, optional
Maximum number of convex hulls to generate, by default 16
resolution : int, optional
Resolution of the voxel grid, by default 4000
minimum_volume_percent_error_allowed : float, optional
Minimum volume percent error allowed, by default 1
max_recursion_depth : int, optional
Maximum recursion depth, by default 10
shrink_wrap : bool, optional
Shrink wrap, by default True
fill_mode : str, optional
Fill mode, by default \u201CFLOOD_FILL\u201D
max_num_vertices_per_hull : int, optional
Maximum number of vertices per hull, by default 64
async_ACD : bool, optional
Async ACD, by default True
min_edge_length : int, optional
Minimum edge length, by default 2
find_best_plane : bool, optional
Find best plane, by default False`),la.forEach(o),ue.forEach(o),zo=s(he),I=a(he,"DIV",{class:!0});var qe=i(I);y(be.$$.fragment,qe),ko=s(qe),nt=a(qe,"P",{});var da=i(nt);Wo=p(da,"Copy an Object3D node in a new (returned) object."),da.forEach(o),Mo=s(qe),at=a(qe,"P",{});var ca=i(at);Io=p(ca,`By default, mesh and materials are copied in respectively new mesh and material.
\u2018share_material\u2019 and \u2018share_mesh\u2019 can be set to True to share mesh and/or material
between original and copy instead of creating new one.`),ca.forEach(o),qe.forEach(o),he.forEach(o),zt=s(e),U=a(e,"H2",{class:!0});var ro=i(U);re=a(ro,"A",{id:!0,class:!0,href:!0});var ma=i(re);it=a(ma,"SPAN",{});var pa=i(it);y(ve.$$.fragment,pa),pa.forEach(o),ma.forEach(o),Uo=s(ro),rt=a(ro,"SPAN",{});var ha=i(rt);Go=p(ha,"Other included objects"),ha.forEach(o),ro.forEach(o),kt=s(e),G=a(e,"DIV",{class:!0});var so=i(G);y(we.$$.fragment,so),Vo=s(so),st=a(so,"P",{});var ua=i(st);Bo=p(ua,"Create a plane."),ua.forEach(o),so.forEach(o),Wt=s(e),V=a(e,"DIV",{class:!0});var lo=i(V);y(xe.$$.fragment,lo),Ho=s(lo),lt=a(lo,"P",{});var ga=i(lt);Xo=p(ga,"Create a Sphere"),ga.forEach(o),lo.forEach(o),Mt=s(e),B=a(e,"DIV",{class:!0});var co=i(B);y(Ne.$$.fragment,co),qo=s(co),dt=a(co,"P",{});var fa=i(dt);Yo=p(fa,"A capsule (a cylinder with hemispheric ends)."),fa.forEach(o),co.forEach(o),It=s(e),H=a(e,"DIV",{class:!0});var mo=i(H);y($e.$$.fragment,mo),Jo=s(mo),ct=a(mo,"P",{});var _a=i(ct);Zo=p(_a,"Create the surface of a cylinder."),_a.forEach(o),mo.forEach(o),Ut=s(e),X=a(e,"DIV",{class:!0});var po=i(X);y(Le.$$.fragment,po),Qo=s(po),mt=a(po,"P",{});var ya=i(mt);Ko=p(ya,"Create a box with solid faces for the given bounds."),ya.forEach(o),po.forEach(o),Gt=s(e),q=a(e,"DIV",{class:!0});var ho=i(q);y(Fe.$$.fragment,ho),en=s(ho),pt=a(ho,"P",{});var ba=i(pt);tn=p(ba,"Create a cone."),ba.forEach(o),ho.forEach(o),Vt=s(e),Y=a(e,"DIV",{class:!0});var uo=i(Y);y(Ae.$$.fragment,uo),on=s(uo),ht=a(uo,"P",{});var va=i(ht);nn=p(va,"Create a line."),va.forEach(o),uo.forEach(o),Bt=s(e),J=a(e,"DIV",{class:!0});var go=i(J);y(De.$$.fragment,go),an=s(go),ut=a(go,"P",{});var wa=i(ut);rn=p(wa,"Create multiple lines."),wa.forEach(o),go.forEach(o),Ht=s(e),Z=a(e,"DIV",{class:!0});var fo=i(Z);y(Oe.$$.fragment,fo),sn=s(fo),gt=a(fo,"P",{});var xa=i(gt);ln=p(xa,"Create a tube that goes from point A to point B."),xa.forEach(o),fo.forEach(o),Xt=s(e),Q=a(e,"DIV",{class:!0});var _o=i(Q);y(Pe.$$.fragment,_o),dn=s(_o),ft=a(_o,"P",{});var Na=i(ft);cn=p(Na,"Create a polygon."),Na.forEach(o),_o.forEach(o),qt=s(e),K=a(e,"DIV",{class:!0});var yo=i(K);y(Ce.$$.fragment,yo),mn=s(yo),_t=a(yo,"P",{});var $a=i(_t);pn=p($a,"Create a regular polygon."),$a.forEach(o),yo.forEach(o),Yt=s(e),z=a(e,"DIV",{class:!0});var Ye=i(z);y(Te.$$.fragment,Ye),hn=s(Ye),yt=a(Ye,"P",{});var La=i(yt);un=p(La,"Create a polygonal disk with a hole in the center."),La.forEach(o),gn=s(Ye),bt=a(Ye,"P",{});var Fa=i(bt);fn=p(Fa,`The disk has zero height. The user can specify the inner and outer
radius of the disk, and the radial and circumferential resolution
of the polygonal representation.`),Fa.forEach(o),Ye.forEach(o),Jt=s(e),ee=a(e,"DIV",{class:!0});var bo=i(ee);y(Re.$$.fragment,bo),_n=s(bo),vt=a(bo,"P",{});var Aa=i(vt);yn=p(Aa,"Create 3D text from a string."),Aa.forEach(o),bo.forEach(o),Zt=s(e),te=a(e,"DIV",{class:!0});var vo=i(te);y(Ee.$$.fragment,vo),bn=s(vo),wt=a(vo,"P",{});var Da=i(wt);vn=p(Da,"Create a triangle defined by 3 points."),Da.forEach(o),vo.forEach(o),Qt=s(e),oe=a(e,"DIV",{class:!0});var wo=i(oe);y(je.$$.fragment,wo),wn=s(wo),xt=a(wo,"P",{});var Oa=i(xt);xn=p(Oa,"Create a rectangle defined by 4 points."),Oa.forEach(o),wo.forEach(o),Kt=s(e),ne=a(e,"DIV",{class:!0});var xo=i(ne);y(Se.$$.fragment,xo),Nn=s(xo),Nt=a(xo,"P",{});var Pa=i(Nt);$n=p(Pa,"Create a single PolyData circle defined by radius in the XY plane."),Pa.forEach(o),xo.forEach(o),eo=s(e),k=a(e,"DIV",{class:!0});var Je=i(k);y(ze.$$.fragment,Je),Ln=s(Je),$t=a(Je,"P",{});var Ca=i($t);Fn=p(Ca,"Create a 3D grid (structured plane) defined by lists of X, Y and Z positions of points."),Ca.forEach(o),An=s(Je),y(se.$$.fragment,Je),Je.forEach(o),to=s(e),D=a(e,"DIV",{class:!0});var R=i(D);y(ke.$$.fragment,R),Dn=s(R),Lt=a(R,"P",{});var Ta=i(Lt);On=p(Ta,`Create a procedural generated 3D grid (structured plane) from
tiles / previous map.`),Ta.forEach(o),Pn=s(R),le=a(R,"H2",{class:!0});var No=i(le);de=a(No,"A",{id:!0,class:!0,href:!0});var Ra=i(de);Ft=a(Ra,"SPAN",{});var Ea=i(Ft);y(We.$$.fragment,Ea),Ea.forEach(o),Ra.forEach(o),Cn=s(No),At=a(No,"SPAN",{});var ja=i(At);Tn=p(ja,"Parameters"),ja.forEach(o),No.forEach(o),Rn=s(R),Dt=a(R,"P",{});var Sa=i(Dt);En=p(Sa,`sample_map : np.ndarray or python list of lists of floats
Map to procedurally generate from.
specific_map: np.ndarray or python list of lists of floats
Map to show as it is.
tiles : list of tiles
Tiles for procedural generation when using generation from tiles and neighbors definitions.
Tiles must be NxN np.ndarray that define height maps. In the future, we plan to support
more generic tiles.
neighbors: list of available neighbors for each tile
Expects pair of tiles.
symmetries: list of char
Expects a list of symmetry definitions. If passed, you must define a symmetry for each tile.
Possible symmetries are \u201CX\u201D, \u201CI\u201D / \u201D/\u201D, \u201CT\u201D / \u201CL\u201D, another character, and each character defines
the tile with the same level of symmetry as the character:`),Sa.forEach(o),jn=s(R),W=a(R,"UL",{});var ge=i(W);Ot=a(ge,"LI",{});var za=i(Ot);Sn=p(za,"X: has symmetry in all ways. So it has 1 different format."),za.forEach(o),zn=s(ge),Me=a(ge,"LI",{});var $o=i(Me);kn=p($o,"I / "),Pt=a($o,"CODE",{});var ka=i(Pt);Wn=p(ka,"/"),ka.forEach(o),Mn=p($o,": when rotated, it\u2019s different from the original tile. Has 2 different formats."),$o.forEach(o),In=s(ge),Ct=a(ge,"LI",{});var Wa=i(Ct);Un=p(Wa,"T / L: Has 4 different formats."),Wa.forEach(o),Gn=s(ge),Tt=a(ge,"LI",{});var Ma=i(Tt);Vn=p(Ma,`other characters: the algorithm supposes it has 8 different formats.
weights: list of floats
sampling weights for each of the tiles
width: int
width of the generated map
height: int
height of the generated map
shallow: bool
Indicates whether procedural generation mesh should be generated in simenv or not.
When it\u2019s true, we just return the map returned by the algorithm without
actually creating the mesh in simenv.
Created for the purpose of optimizing certain environments such as XLand.
seed: int
Random seed used for procedural generation.
algorithm_args: dict
Extra arguments to be passed to the procedural generation.
Returns`),Ma.forEach(o),ge.forEach(o),Bn=s(R),Hn=a(R,"HR",{}),Xn=s(R),ce=a(R,"H2",{class:!0});var Lo=i(ce);me=a(Lo,"A",{id:!0,class:!0,href:!0});var Ia=i(me);Rt=a(Ia,"SPAN",{});var Ua=i(Rt);y(Ie.$$.fragment,Ua),Ua.forEach(o),Ia.forEach(o),qn=s(Lo),Et=a(Lo,"SPAN",{});var Ga=i(Et);Yn=p(Ga,"Examples"),Ga.forEach(o),Lo.forEach(o),Jn=s(R),pe=a(R,"DIV",{class:!0});var Fo=i(pe);y(Ue.$$.fragment,Fo),Zn=s(Fo),jt=a(Fo,"P",{});var Va=i(jt);Qn=p(Va,"Function for creating the mesh in case the creation of map was shallow."),Va.forEach(o),Fo.forEach(o),R.forEach(o),oo=s(e),Ge=a(e,"DIV",{class:!0});var Ba=i(Ge);y(Ve.$$.fragment,Ba),Ba.forEach(o),this.h()},h(){d(u,"name","hf:doc:metadata"),d(u,"content",JSON.stringify(hi)),d(w,"id","simulate.Object3D"),d(w,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(w,"href","#simulate.Object3D"),d(L,"class","relative group"),d(ie,"id","parameters"),d(ie,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(ie,"href","#parameters"),d(ae,"class","relative group"),d(j,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(I,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(E,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(re,"id","simulate.Plane"),d(re,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(re,"href","#simulate.Plane"),d(U,"class","relative group"),d(G,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(V,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(B,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(H,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(X,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Y,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(J,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(K,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(te,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(oe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ne,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(k,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(de,"id","parameters"),d(de,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(de,"href","#parameters"),d(le,"class","relative group"),d(me,"id","examples"),d(me,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(me,"href","#examples"),d(ce,"class","relative group"),d(pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(D,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ge,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(e,l){t(document.head,u),c(e,x,l),c(e,L,l),t(L,w),t(w,O),b(h,O,null),t(L,F),t(L,S),t(S,T),c(e,M,l),c(e,A,l),t(A,N),t(A,P),t(P,He),t(A,Xe),c(e,St,l),c(e,E,l),b(fe,E,null),t(E,Ao),t(E,Qe),t(Qe,Do),t(E,Oo),t(E,j),b(_e,j,null),t(j,Po),t(j,Ke),t(Ke,Co),t(j,To),t(j,ae),t(ae,ie),t(ie,et),b(ye,et,null),t(ae,Ro),t(ae,tt),t(tt,Eo),t(j,jo),t(j,ot),t(ot,So),t(E,zo),t(E,I),b(be,I,null),t(I,ko),t(I,nt),t(nt,Wo),t(I,Mo),t(I,at),t(at,Io),c(e,zt,l),c(e,U,l),t(U,re),t(re,it),b(ve,it,null),t(U,Uo),t(U,rt),t(rt,Go),c(e,kt,l),c(e,G,l),b(we,G,null),t(G,Vo),t(G,st),t(st,Bo),c(e,Wt,l),c(e,V,l),b(xe,V,null),t(V,Ho),t(V,lt),t(lt,Xo),c(e,Mt,l),c(e,B,l),b(Ne,B,null),t(B,qo),t(B,dt),t(dt,Yo),c(e,It,l),c(e,H,l),b($e,H,null),t(H,Jo),t(H,ct),t(ct,Zo),c(e,Ut,l),c(e,X,l),b(Le,X,null),t(X,Qo),t(X,mt),t(mt,Ko),c(e,Gt,l),c(e,q,l),b(Fe,q,null),t(q,en),t(q,pt),t(pt,tn),c(e,Vt,l),c(e,Y,l),b(Ae,Y,null),t(Y,on),t(Y,ht),t(ht,nn),c(e,Bt,l),c(e,J,l),b(De,J,null),t(J,an),t(J,ut),t(ut,rn),c(e,Ht,l),c(e,Z,l),b(Oe,Z,null),t(Z,sn),t(Z,gt),t(gt,ln),c(e,Xt,l),c(e,Q,l),b(Pe,Q,null),t(Q,dn),t(Q,ft),t(ft,cn),c(e,qt,l),c(e,K,l),b(Ce,K,null),t(K,mn),t(K,_t),t(_t,pn),c(e,Yt,l),c(e,z,l),b(Te,z,null),t(z,hn),t(z,yt),t(yt,un),t(z,gn),t(z,bt),t(bt,fn),c(e,Jt,l),c(e,ee,l),b(Re,ee,null),t(ee,_n),t(ee,vt),t(vt,yn),c(e,Zt,l),c(e,te,l),b(Ee,te,null),t(te,bn),t(te,wt),t(wt,vn),c(e,Qt,l),c(e,oe,l),b(je,oe,null),t(oe,wn),t(oe,xt),t(xt,xn),c(e,Kt,l),c(e,ne,l),b(Se,ne,null),t(ne,Nn),t(ne,Nt),t(Nt,$n),c(e,eo,l),c(e,k,l),b(ze,k,null),t(k,Ln),t(k,$t),t($t,Fn),t(k,An),b(se,k,null),c(e,to,l),c(e,D,l),b(ke,D,null),t(D,Dn),t(D,Lt),t(Lt,On),t(D,Pn),t(D,le),t(le,de),t(de,Ft),b(We,Ft,null),t(le,Cn),t(le,At),t(At,Tn),t(D,Rn),t(D,Dt),t(Dt,En),t(D,jn),t(D,W),t(W,Ot),t(Ot,Sn),t(W,zn),t(W,Me),t(Me,kn),t(Me,Pt),t(Pt,Wn),t(Me,Mn),t(W,In),t(W,Ct),t(Ct,Un),t(W,Gn),t(W,Tt),t(Tt,Vn),t(D,Bn),t(D,Hn),t(D,Xn),t(D,ce),t(ce,me),t(me,Rt),b(Ie,Rt,null),t(ce,qn),t(ce,Et),t(Et,Yn),t(D,Jn),t(D,pe),b(Ue,pe,null),t(pe,Zn),t(pe,jt),t(jt,Qn),c(e,oo,l),c(e,Ge,l),b(Ve,Ge,null),no=!0},p(e,[l]){const Be={};l&2&&(Be.$$scope={dirty:l,ctx:e}),se.$set(Be)},i(e){no||(g(h.$$.fragment,e),g(fe.$$.fragment,e),g(_e.$$.fragment,e),g(ye.$$.fragment,e),g(be.$$.fragment,e),g(ve.$$.fragment,e),g(we.$$.fragment,e),g(xe.$$.fragment,e),g(Ne.$$.fragment,e),g($e.$$.fragment,e),g(Le.$$.fragment,e),g(Fe.$$.fragment,e),g(Ae.$$.fragment,e),g(De.$$.fragment,e),g(Oe.$$.fragment,e),g(Pe.$$.fragment,e),g(Ce.$$.fragment,e),g(Te.$$.fragment,e),g(Re.$$.fragment,e),g(Ee.$$.fragment,e),g(je.$$.fragment,e),g(Se.$$.fragment,e),g(ze.$$.fragment,e),g(se.$$.fragment,e),g(ke.$$.fragment,e),g(We.$$.fragment,e),g(Ie.$$.fragment,e),g(Ue.$$.fragment,e),g(Ve.$$.fragment,e),no=!0)},o(e){f(h.$$.fragment,e),f(fe.$$.fragment,e),f(_e.$$.fragment,e),f(ye.$$.fragment,e),f(be.$$.fragment,e),f(ve.$$.fragment,e),f(we.$$.fragment,e),f(xe.$$.fragment,e),f(Ne.$$.fragment,e),f($e.$$.fragment,e),f(Le.$$.fragment,e),f(Fe.$$.fragment,e),f(Ae.$$.fragment,e),f(De.$$.fragment,e),f(Oe.$$.fragment,e),f(Pe.$$.fragment,e),f(Ce.$$.fragment,e),f(Te.$$.fragment,e),f(Re.$$.fragment,e),f(Ee.$$.fragment,e),f(je.$$.fragment,e),f(Se.$$.fragment,e),f(ze.$$.fragment,e),f(se.$$.fragment,e),f(ke.$$.fragment,e),f(We.$$.fragment,e),f(Ie.$$.fragment,e),f(Ue.$$.fragment,e),f(Ve.$$.fragment,e),no=!1},d(e){o(u),e&&o(x),e&&o(L),v(h),e&&o(M),e&&o(A),e&&o(St),e&&o(E),v(fe),v(_e),v(ye),v(be),e&&o(zt),e&&o(U),v(ve),e&&o(kt),e&&o(G),v(we),e&&o(Wt),e&&o(V),v(xe),e&&o(Mt),e&&o(B),v(Ne),e&&o(It),e&&o(H),v($e),e&&o(Ut),e&&o(X),v(Le),e&&o(Gt),e&&o(q),v(Fe),e&&o(Vt),e&&o(Y),v(Ae),e&&o(Bt),e&&o(J),v(De),e&&o(Ht),e&&o(Z),v(Oe),e&&o(Xt),e&&o(Q),v(Pe),e&&o(qt),e&&o(K),v(Ce),e&&o(Yt),e&&o(z),v(Te),e&&o(Jt),e&&o(ee),v(Re),e&&o(Zt),e&&o(te),v(Ee),e&&o(Qt),e&&o(oe),v(je),e&&o(Kt),e&&o(ne),v(Se),e&&o(eo),e&&o(k),v(ze),v(se),e&&o(to),e&&o(D),v(ke),v(We),v(Ie),v(Ue),e&&o(oo),e&&o(Ge),v(Ve)}}}const hi={local:"simulate.Object3D",sections:[{local:"simulate.Plane",title:"Other included objects"}],title:"Objects"};function ui(C){return Ja(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class bi extends Xa{constructor(u){super();qa(this,u,ui,pi,Ya,{})}}export{bi as default,hi as metadata};
