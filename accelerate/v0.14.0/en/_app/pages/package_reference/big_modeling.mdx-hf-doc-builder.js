import{S as Wr,i as qr,s as Sr,e as a,k as l,w as u,t as s,M as jr,c as r,d as t,m as c,a as n,x as g,h as d,b as h,G as o,g as m,y as _,q as v,o as b,B as k,v as Rr,L as Vr}from"../../chunks/vendor-hf-doc-builder.js";import{T as Fr}from"../../chunks/Tip-hf-doc-builder.js";import{D as T}from"../../chunks/Docstring-hf-doc-builder.js";import{C as zr}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as Ve}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{E as Gr}from"../../chunks/ExampleCodeBlock-hf-doc-builder.js";function Br(ee){let p,A,w,y,E;return y=new zr({props:{code:`import torch.nn as nn
from accelerate import init_empty_weights

# Initialize a model with 100 billions parameters in no time and without using any RAM.
with init_empty_weights():
    tst = nn.Sequential(*[nn.Linear(10000, 10000) for _ in range(1000)])`,highlighted:`<span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn
<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> init_empty_weights

<span class="hljs-comment"># Initialize a model with 100 billions parameters in no time and without using any RAM.</span>
<span class="hljs-keyword">with</span> init_empty_weights():
    tst = nn.Sequential(*[nn.Linear(<span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>)])`}}),{c(){p=a("p"),A=s("Example:"),w=l(),u(y.$$.fragment)},l(f){p=r(f,"P",{});var D=n(p);A=d(D,"Example:"),D.forEach(t),w=c(f),g(y.$$.fragment,f)},m(f,D){m(f,p,D),o(p,A),m(f,w,D),_(y,f,D),E=!0},p:Vr,i(f){E||(v(y.$$.fragment,f),E=!0)},o(f){b(y.$$.fragment,f),E=!1},d(f){f&&t(p),f&&t(w),k(y,f)}}}function Jr(ee){let p,A,w,y,E,f,D,U;return{c(){p=a("p"),A=s(`Any model created under this context manager has no weights. As such you can\u2019t do something like
`),w=a("code"),y=s("model.to(some_device)"),E=s(" with it. To load weights inside your empty model, see "),f=a("a"),D=s("load_checkpoint_and_dispatch()"),U=s("."),this.h()},l(P){p=r(P,"P",{});var $=n(p);A=d($,`Any model created under this context manager has no weights. As such you can\u2019t do something like
`),w=r($,"CODE",{});var H=n(w);y=d(H,"model.to(some_device)"),H.forEach(t),E=d($," with it. To load weights inside your empty model, see "),f=r($,"A",{href:!0});var L=n(f);D=d(L,"load_checkpoint_and_dispatch()"),L.forEach(t),U=d($,"."),$.forEach(t),this.h()},h(){h(f,"href","/docs/accelerate/v0.14.0/en/package_reference/big_modeling#accelerate.load_checkpoint_and_dispatch")},m(P,$){m(P,p,$),o(p,A),o(p,w),o(w,y),o(p,E),o(p,f),o(f,D),o(p,U)},d(P){P&&t(p)}}}function Kr(ee){let p,A,w,y,E,f,D,U;return{c(){p=a("p"),A=s(`If the module already contains a hook, this will replace it with the new hook passed by default. To chain two hooks
together, pass `),w=a("code"),y=s("append=True"),E=s(", so it chains the current and new hook into an instance of the "),f=a("code"),D=s("SequentialHook"),U=s(" class.")},l(P){p=r(P,"P",{});var $=n(p);A=d($,`If the module already contains a hook, this will replace it with the new hook passed by default. To chain two hooks
together, pass `),w=r($,"CODE",{});var H=n(w);y=d(H,"append=True"),H.forEach(t),E=d($,", so it chains the current and new hook into an instance of the "),f=r($,"CODE",{});var L=n(f);D=d(L,"SequentialHook"),L.forEach(t),U=d($," class."),$.forEach(t)},m(P,$){m(P,p,$),o(p,A),o(p,w),o(w,y),o(p,E),o(p,f),o(f,D),o(p,U)},d(P){P&&t(p)}}}function Qr(ee){let p,A,w,y,E,f,D,U,P,$,H,L,ze,fe,wt,Ge,yt,Ho,C,ue,$t,Be,xt,Et,oe,Dt,te,Lo,W,ge,Tt,Je,At,No,q,_e,Mt,Ke,Pt,Uo,S,ve,Ht,Qe,Lt,Co,j,be,Nt,Xe,Ut,Oo,R,ae,Ye,ke,Ct,Ze,Ot,Io,V,re,eo,we,It,oo,Ft,Fo,x,ye,Wt,to,qt,St,ao,jt,Rt,ro,N,no,Vt,zt,so,Gt,Bt,lo,Jt,Kt,co,Qt,Xt,io,Yt,Zt,ea,ne,$e,oa,ho,ta,aa,se,xe,ra,mo,na,sa,de,Ee,da,po,la,ca,le,De,ia,fo,ha,Wo,z,Te,ma,Ae,pa,uo,fa,ua,qo,G,Me,ga,go,_a,So,B,ce,_o,Pe,va,vo,ba,jo,O,He,ka,I,wa,bo,ya,$a,ko,xa,Ea,wo,Da,Ta,Aa,ie,Ro,J,Le,Ma,Ne,Pa,yo,Ha,La,Vo,K,Ue,Na,Ce,Ua,$o,Ca,Oa,zo,Q,Oe,Ia,Ie,Fa,xo,Wa,qa,Go,X,he,Eo,Fe,Sa,Do,ja,Bo,Y,We,Ra,qe,Va,To,za,Ga,Jo,Z,Se,Ba,Ao,Ja,Ko;return f=new Ve({}),fe=new Ve({}),ue=new T({props:{name:"accelerate.init_empty_weights",anchor:"accelerate.init_empty_weights",parameters:[{name:"include_buffers",val:": bool = False"}],parametersDescription:[{anchor:"accelerate.init_empty_weights.include_buffers",description:`<strong>include_buffers</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to also put all buffers on the meta device while initializing.`,name:"include_buffers"}],source:"https://github.com/huggingface/accelerate/blob/v0.14.0/src/accelerate/big_modeling.py#L35"}}),oe=new Gr({props:{anchor:"accelerate.init_empty_weights.example",$$slots:{default:[Br]},$$scope:{ctx:ee}}}),te=new Fr({props:{warning:!0,$$slots:{default:[Jr]},$$scope:{ctx:ee}}}),ge=new T({props:{name:"accelerate.cpu_offload",anchor:"accelerate.cpu_offload",parameters:[{name:"model",val:": Module"},{name:"execution_device",val:": typing.Optional[torch.device] = None"},{name:"offload_buffers",val:": bool = False"},{name:"state_dict",val:": typing.Union[typing.Dict[str, torch.Tensor], NoneType] = None"},{name:"preload_module_classes",val:": typing.Optional[typing.List[str]] = None"}],parametersDescription:[{anchor:"accelerate.cpu_offload.model",description:`<strong>model</strong> (<code>torch.nn.Module</code>) &#x2014;
The model to offload.`,name:"model"},{anchor:"accelerate.cpu_offload.execution_device",description:`<strong>execution_device</strong> (<code>torch.device</code>, <em>optional</em>) &#x2014;
The device on which the forward pass of the model will be executed (should be a GPU). Will default to the
model first parameter device.`,name:"execution_device"},{anchor:"accelerate.cpu_offload.offload_buffers",description:`<strong>offload_buffers</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to offload the buffers with the model parameters.`,name:"offload_buffers"},{anchor:"accelerate.cpu_offload.state_dict",description:`<strong>state_dict</strong> (<code>Dict[str, torch.Tensor]</code>, <em>optional</em>) &#x2014;
The state dict of the model that will be kept on CPU.`,name:"state_dict"},{anchor:"accelerate.cpu_offload.preload_module_classes",description:`<strong>preload_module_classes</strong> (<code>List[str]</code>, <em>optional</em>) &#x2014;
A list of classes whose instances should load all their weights (even in the submodules) at the beginning
of the forward. This should only be used for classes that have submodules which are registered but not
called directly during the forward, for instance if a <code>dense</code> linear layer is registered, but at forward,
<code>dense.weight</code> and <code>dense.bias</code> are used in some operations instead of calling <code>dense</code> directly.`,name:"preload_module_classes"}],source:"https://github.com/huggingface/accelerate/blob/v0.14.0/src/accelerate/big_modeling.py#L112"}}),_e=new T({props:{name:"accelerate.disk_offload",anchor:"accelerate.disk_offload",parameters:[{name:"model",val:": Module"},{name:"offload_dir",val:": typing.Union[str, os.PathLike]"},{name:"execution_device",val:": typing.Optional[torch.device] = None"},{name:"offload_buffers",val:": bool = False"},{name:"preload_module_classes",val:": typing.Optional[typing.List[str]] = None"}],parametersDescription:[{anchor:"accelerate.disk_offload.model",description:"<strong>model</strong> (<code>torch.nn.Module</code>) &#x2014; The model to offload.",name:"model"},{anchor:"accelerate.disk_offload.offload_dir",description:`<strong>offload_dir</strong> (<code>str</code> or <code>os.PathLike</code>) &#x2014;
The folder in which to offload the model weights (or where the model weights are already offloaded).`,name:"offload_dir"},{anchor:"accelerate.disk_offload.execution_device",description:`<strong>execution_device</strong> (<code>torch.device</code>, <em>optional</em>) &#x2014;
The device on which the forward pass of the model will be executed (should be a GPU). Will default to the
model&#x2019;s first parameter device.`,name:"execution_device"},{anchor:"accelerate.disk_offload.offload_buffers",description:`<strong>offload_buffers</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to offload the buffers with the model parameters.`,name:"offload_buffers"},{anchor:"accelerate.disk_offload.preload_module_classes",description:`<strong>preload_module_classes</strong> (<code>List[str]</code>, <em>optional</em>) &#x2014;
A list of classes whose instances should load all their weights (even in the submodules) at the beginning
of the forward. This should only be used for classes that have submodules which are registered but not
called directly during the forward, for instance if a <code>dense</code> linear layer is registered, but at forward,
<code>dense.weight</code> and <code>dense.bias</code> are used in some operations instead of calling <code>dense</code> directly.`,name:"preload_module_classes"}],source:"https://github.com/huggingface/accelerate/blob/v0.14.0/src/accelerate/big_modeling.py#L160"}}),ve=new T({props:{name:"accelerate.dispatch_model",anchor:"accelerate.dispatch_model",parameters:[{name:"model",val:": Module"},{name:"device_map",val:": typing.Dict[str, typing.Union[str, int, torch.device]]"},{name:"main_device",val:": typing.Optional[torch.device] = None"},{name:"state_dict",val:": typing.Union[typing.Dict[str, torch.Tensor], NoneType] = None"},{name:"offload_dir",val:": typing.Union[str, os.PathLike] = None"},{name:"offload_buffers",val:": bool = False"},{name:"preload_module_classes",val:": typing.Optional[typing.List[str]] = None"}],parametersDescription:[{anchor:"accelerate.dispatch_model.model",description:`<strong>model</strong> (<code>torch.nn.Module</code>) &#x2014;
The model to dispatch.`,name:"model"},{anchor:"accelerate.dispatch_model.device_map",description:`<strong>device_map</strong> (<code>Dict[str, Union[str, int, torch.device]]</code>) &#x2014;
A dictionary mapping module names in the models <code>state_dict</code> to the device they should go to. Note that
<code>&quot;disk&quot;</code> is accepted even if it&#x2019;s not a proper value for <code>torch.device</code>.`,name:"device_map"},{anchor:"accelerate.dispatch_model.main_device",description:`<strong>main_device</strong> (<code>str</code>, <code>int</code> or <code>torch.device</code>, <em>optional</em>) &#x2014;
The main execution device. Will default to the first device in the <code>device_map</code> different from <code>&quot;cpu&quot;</code> or
<code>&quot;disk&quot;</code>.`,name:"main_device"},{anchor:"accelerate.dispatch_model.state_dict",description:`<strong>state_dict</strong> (<code>Dict[str, torch.Tensor]</code>, <em>optional</em>) &#x2014;
The state dict of the part of the model that will be kept on CPU.`,name:"state_dict"},{anchor:"accelerate.dispatch_model.offload_dir",description:`<strong>offload_dir</strong> (<code>str</code> or <code>os.PathLike</code>) &#x2014;
The folder in which to offload the model weights (or where the model weights are already offloaded).`,name:"offload_dir"},{anchor:"accelerate.dispatch_model.offload_buffers",description:`<strong>offload_buffers</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to offload the buffers with the model parameters.`,name:"offload_buffers"},{anchor:"accelerate.dispatch_model.preload_module_classes",description:`<strong>preload_module_classes</strong> (<code>List[str]</code>, <em>optional</em>) &#x2014;
A list of classes whose instances should load all their weights (even in the submodules) at the beginning
of the forward. This should only be used for classes that have submodules which are registered but not
called directly during the forward, for instance if a <code>dense</code> linear layer is registered, but at forward,
<code>dense.weight</code> and <code>dense.bias</code> are used in some operations instead of calling <code>dense</code> directly.`,name:"preload_module_classes"}],source:"https://github.com/huggingface/accelerate/blob/v0.14.0/src/accelerate/big_modeling.py#L208"}}),be=new T({props:{name:"accelerate.load_checkpoint_and_dispatch",anchor:"accelerate.load_checkpoint_and_dispatch",parameters:[{name:"model",val:": Module"},{name:"checkpoint",val:": typing.Union[str, os.PathLike]"},{name:"device_map",val:": typing.Union[str, typing.Dict[str, typing.Union[str, int, torch.device]], NoneType] = None"},{name:"max_memory",val:": typing.Union[typing.Dict[typing.Union[int, str], typing.Union[int, str]], NoneType] = None"},{name:"no_split_module_classes",val:": typing.Optional[typing.List[str]] = None"},{name:"offload_folder",val:": typing.Union[str, os.PathLike, NoneType] = None"},{name:"offload_buffers",val:": bool = False"},{name:"dtype",val:": typing.Union[str, torch.dtype, NoneType] = None"},{name:"offload_state_dict",val:": typing.Optional[bool] = None"},{name:"preload_module_classes",val:": typing.Optional[typing.List[str]] = None"}],parametersDescription:[{anchor:"accelerate.load_checkpoint_and_dispatch.model",description:"<strong>model</strong> (<code>torch.nn.Module</code>) &#x2014; The model in which we want to load a checkpoint.",name:"model"},{anchor:"accelerate.load_checkpoint_and_dispatch.checkpoint",description:`<strong>checkpoint</strong> (<code>str</code> or <code>os.PathLike</code>) &#x2014;
The folder checkpoint to load. It can be:</p>
<ul>
<li>a path to a file containing a whole model state dict</li>
<li>a path to a <code>.json</code> file containing the index to a sharded checkpoint</li>
<li>a path to a folder containing a unique <code>.index.json</code> file and the shards of a checkpoint.</li>
</ul>`,name:"checkpoint"},{anchor:"accelerate.load_checkpoint_and_dispatch.device_map",description:`<strong>device_map</strong> (<code>Dict[str, Union[int, str, torch.device]]</code>, <em>optional</em>) &#x2014;
A map that specifies where each submodule should go. It doesn&#x2019;t need to be refined to each parameter/buffer
name, once a given module name is inside, every submodule of it will be sent to the same device.</p>
<p>To have Accelerate compute the most optimized <code>device_map</code> automatically, set <code>device_map=&quot;auto&quot;</code>. For more
information about each option see <a href="big_modeling#designing-a-device-map">here</a>.`,name:"device_map"},{anchor:"accelerate.load_checkpoint_and_dispatch.max_memory",description:`<strong>max_memory</strong> (<code>Dict</code>, <em>optional</em>) &#x2014;
A dictionary device identifier to maximum memory. Will default to the maximum memory available for each GPU
and the available CPU RAM if unset.`,name:"max_memory"},{anchor:"accelerate.load_checkpoint_and_dispatch.no_split_module_classes",description:`<strong>no_split_module_classes</strong> (<code>List[str]</code>, <em>optional</em>) &#x2014;
A list of layer class names that should never be split across device (for instance any layer that has a
residual connection).`,name:"no_split_module_classes"},{anchor:"accelerate.load_checkpoint_and_dispatch.offload_folder",description:`<strong>offload_folder</strong> (<code>str</code> or <code>os.PathLike</code>, <em>optional</em>) &#x2014;
If the <code>device_map</code> contains any value <code>&quot;disk&quot;</code>, the folder where we will offload weights.`,name:"offload_folder"},{anchor:"accelerate.load_checkpoint_and_dispatch.offload_buffers",description:`<strong>offload_buffers</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
In the layers that are offloaded on the CPU or the hard drive, whether or not to offload the buffers as
well as the parameters.`,name:"offload_buffers"},{anchor:"accelerate.load_checkpoint_and_dispatch.dtype",description:`<strong>dtype</strong> (<code>str</code> or <code>torch.dtype</code>, <em>optional</em>) &#x2014;
If provided, the weights will be converted to that type when loaded.`,name:"dtype"},{anchor:"accelerate.load_checkpoint_and_dispatch.offload_state_dict",description:`<strong>offload_state_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
If <code>True</code>, will temporarily offload the CPU state dict on the hard drive to avoid getting out of CPU RAM if
the weight of the CPU state dict + the biggest shard does not fit. Will default to <code>True</code> if the device map
picked contains <code>&quot;disk&quot;</code> values.`,name:"offload_state_dict"},{anchor:"accelerate.load_checkpoint_and_dispatch.preload_module_classes",description:`<strong>preload_module_classes</strong> (<code>List[str]</code>, <em>optional</em>) &#x2014;
A list of classes whose instances should load all their weights (even in the submodules) at the beginning
of the forward. This should only be used for classes that have submodules which are registered but not
called directly during the forward, for instance if a <code>dense</code> linear layer is registered, but at forward,
<code>dense.weight</code> and <code>dense.bias</code> are used in some operations instead of calling <code>dense</code> directly.`,name:"preload_module_classes"}],source:"https://github.com/huggingface/accelerate/blob/v0.14.0/src/accelerate/big_modeling.py#L293"}}),ke=new Ve({}),we=new Ve({}),ye=new T({props:{name:"class accelerate.hooks.ModelHook",anchor:"accelerate.hooks.ModelHook",parameters:[],source:"https://github.com/huggingface/accelerate/blob/v0.14.0/src/accelerate/hooks.py#L24"}}),$e=new T({props:{name:"detach_hook",anchor:"accelerate.hooks.ModelHook.detach_hook",parameters:[{name:"module",val:""}],parametersDescription:[{anchor:"accelerate.hooks.ModelHook.detach_hook.module",description:"<strong>module</strong> (<code>torch.nn.Module</code>) &#x2014; The module detached from this hook.",name:"module"}],source:"https://github.com/huggingface/accelerate/blob/v0.14.0/src/accelerate/hooks.py#L72"}}),xe=new T({props:{name:"init_hook",anchor:"accelerate.hooks.ModelHook.init_hook",parameters:[{name:"module",val:""}],parametersDescription:[{anchor:"accelerate.hooks.ModelHook.init_hook.module",description:"<strong>module</strong> (<code>torch.nn.Module</code>) &#x2014; The module attached to this hook.",name:"module"}],source:"https://github.com/huggingface/accelerate/blob/v0.14.0/src/accelerate/hooks.py#L36"}}),Ee=new T({props:{name:"post_forward",anchor:"accelerate.hooks.ModelHook.post_forward",parameters:[{name:"module",val:""},{name:"output",val:""}],parametersDescription:[{anchor:"accelerate.hooks.ModelHook.post_forward.module",description:"<strong>module</strong> (<code>torch.nn.Module</code>) &#x2014; The module whose forward pass been executed just before this event.",name:"module"},{anchor:"accelerate.hooks.ModelHook.post_forward.output",description:"<strong>output</strong> (<code>Any</code>) &#x2014; The output of the module.",name:"output"}],source:"https://github.com/huggingface/accelerate/blob/v0.14.0/src/accelerate/hooks.py#L59",returnDescription:`
<p>The processed <code>output</code>.</p>
`,returnType:`
<p><code>Any</code></p>
`}}),De=new T({props:{name:"pre_forward",anchor:"accelerate.hooks.ModelHook.pre_forward",parameters:[{name:"module",val:""},{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"accelerate.hooks.ModelHook.pre_forward.module",description:"<strong>module</strong> (<code>torch.nn.Module</code>) &#x2014; The module whose forward pass will be executed just after this event.",name:"module"},{anchor:"accelerate.hooks.ModelHook.pre_forward.args",description:"<strong>args</strong> (<code>Tuple[Any]</code>) &#x2014; The positional arguments passed to the module.",name:"args"},{anchor:"accelerate.hooks.ModelHook.pre_forward.kwargs",description:"<strong>kwargs</strong> (<code>Dict[Str, Any]</code>) &#x2014; The keyword arguments passed to the module.",name:"kwargs"}],source:"https://github.com/huggingface/accelerate/blob/v0.14.0/src/accelerate/hooks.py#L45",returnDescription:`
<p>A tuple with the treated <code>args</code> and <code>kwargs</code>.</p>
`,returnType:`
<p><code>Tuple[Tuple[Any], Dict[Str, Any]]</code></p>
`}}),Te=new T({props:{name:"class accelerate.hooks.AlignDevicesHook",anchor:"accelerate.hooks.AlignDevicesHook",parameters:[{name:"execution_device",val:": typing.Union[int, str, torch.device, NoneType] = None"},{name:"offload",val:": bool = False"},{name:"io_same_device",val:": bool = False"},{name:"weights_map",val:": typing.Optional[typing.Mapping] = None"},{name:"offload_buffers",val:": bool = False"},{name:"place_submodules",val:": bool = False"}],parametersDescription:[{anchor:"accelerate.hooks.AlignDevicesHook.execution_device",description:`<strong>execution_device</strong> (<code>torch.device</code>, <em>optional</em>) &#x2014;
The device on which inputs and model weights should be placed before the forward pass.`,name:"execution_device"},{anchor:"accelerate.hooks.AlignDevicesHook.offload",description:`<strong>offload</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not the weights should be offloaded after the forward pass.`,name:"offload"},{anchor:"accelerate.hooks.AlignDevicesHook.io_same_device",description:`<strong>io_same_device</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not the output should be placed on the same device as the input was.`,name:"io_same_device"},{anchor:"accelerate.hooks.AlignDevicesHook.weights_map",description:`<strong>weights_map</strong> (<code>Mapping[str, torch.Tensor]</code>, <em>optional</em>) &#x2014;
When the model weights are offloaded, a (potentially lazy) map from param names to the tensor values.`,name:"weights_map"},{anchor:"accelerate.hooks.AlignDevicesHook.offload_buffers",description:`<strong>offload_buffers</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to include the associated module&#x2019;s buffers when offloading.`,name:"offload_buffers"},{anchor:"accelerate.hooks.AlignDevicesHook.place_submodules",description:`<strong>place_submodules</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to place the submodules on <code>execution_device</code> during the <code>init_hook</code> event.`,name:"place_submodules"}],source:"https://github.com/huggingface/accelerate/blob/v0.14.0/src/accelerate/hooks.py#L191"}}),Me=new T({props:{name:"class accelerate.hooks.SequentialHook",anchor:"accelerate.hooks.SequentialHook",parameters:[{name:"*hooks",val:""}],source:"https://github.com/huggingface/accelerate/blob/v0.14.0/src/accelerate/hooks.py#L82"}}),Pe=new Ve({}),He=new T({props:{name:"accelerate.hooks.add_hook_to_module",anchor:"accelerate.hooks.add_hook_to_module",parameters:[{name:"module",val:": Module"},{name:"hook",val:": ModelHook"},{name:"append",val:": bool = False"}],parametersDescription:[{anchor:"accelerate.hooks.add_hook_to_module.module",description:"<strong>module</strong> (<code>torch.nn.Module</code>) &#x2014; The module to attach a hook to.",name:"module"},{anchor:"accelerate.hooks.add_hook_to_module.hook",description:"<strong>hook</strong> (<code>ModelHook</code>) &#x2014; The hook to attach.",name:"hook"},{anchor:"accelerate.hooks.add_hook_to_module.append",description:`<strong>append</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the hook should be chained with an existing one (if module already contains a hook) or not.`,name:"append"}],source:"https://github.com/huggingface/accelerate/blob/v0.14.0/src/accelerate/hooks.py#L111",returnDescription:`
<p>The same module, with the hook attached (the module is modified in place, so the result can
be discarded).</p>
`,returnType:`
<p><code>torch.nn.Module</code></p>
`}}),ie=new Fr({props:{warning:!0,$$slots:{default:[Kr]},$$scope:{ctx:ee}}}),Le=new T({props:{name:"accelerate.hooks.attach_execution_device_hook",anchor:"accelerate.hooks.attach_execution_device_hook",parameters:[{name:"module",val:": Module"},{name:"execution_device",val:": typing.Union[int, str, torch.device]"},{name:"preload_module_classes",val:": typing.Optional[typing.List[str]] = None"}],parametersDescription:[{anchor:"accelerate.hooks.attach_execution_device_hook.module",description:`<strong>module</strong> (<code>torch.nn.Module</code>) &#x2014;
The module where we want to attach the hooks.`,name:"module"},{anchor:"accelerate.hooks.attach_execution_device_hook.execution_device",description:`<strong>execution_device</strong> (<code>int</code>, <code>str</code> or <code>torch.device</code>) &#x2014;
The device on which inputs and model weights should be placed before the forward pass.`,name:"execution_device"},{anchor:"accelerate.hooks.attach_execution_device_hook.preload_module_classes",description:`<strong>preload_module_classes</strong> (<code>List[str]</code>, <em>optional</em>) &#x2014;
A list of classes whose instances should load all their weights (even in the submodules) at the beginning
of the forward. This should only be used for classes that have submodules which are registered but not
called directly during the forward, for instance if a <code>dense</code> linear layer is registered, but at forward,
<code>dense.weight</code> and <code>dense.bias</code> are used in some operations instead of calling <code>dense</code> directly.`,name:"preload_module_classes"}],source:"https://github.com/huggingface/accelerate/blob/v0.14.0/src/accelerate/hooks.py#L287"}}),Ue=new T({props:{name:"accelerate.hooks.attach_align_device_hook",anchor:"accelerate.hooks.attach_align_device_hook",parameters:[{name:"module",val:": Module"},{name:"execution_device",val:": typing.Optional[torch.device] = None"},{name:"offload",val:": bool = False"},{name:"weights_map",val:": typing.Optional[typing.Mapping] = None"},{name:"offload_buffers",val:": bool = False"},{name:"module_name",val:": str = ''"},{name:"preload_module_classes",val:": typing.Optional[typing.List[str]] = None"}],parametersDescription:[{anchor:"accelerate.hooks.attach_align_device_hook.module",description:`<strong>module</strong> (<code>torch.nn.Module</code>) &#x2014;
The module where we want to attach the hooks.`,name:"module"},{anchor:"accelerate.hooks.attach_align_device_hook.execution_device",description:`<strong>execution_device</strong> (<code>torch.device</code>, <em>optional</em>) &#x2014;
The device on which inputs and model weights should be placed before the forward pass.`,name:"execution_device"},{anchor:"accelerate.hooks.attach_align_device_hook.offload",description:`<strong>offload</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not the weights should be offloaded after the forward pass.`,name:"offload"},{anchor:"accelerate.hooks.attach_align_device_hook.weights_map",description:`<strong>weights_map</strong> (<code>Mapping[str, torch.Tensor]</code>, <em>optional</em>) &#x2014;
When the model weights are offloaded, a (potentially lazy) map from param names to the tensor values.`,name:"weights_map"},{anchor:"accelerate.hooks.attach_align_device_hook.offload_buffers",description:`<strong>offload_buffers</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to include the associated module&#x2019;s buffers when offloading.`,name:"offload_buffers"},{anchor:"accelerate.hooks.attach_align_device_hook.module_name",description:`<strong>module_name</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;&quot;</code>) &#x2014;
The name of the module.`,name:"module_name"},{anchor:"accelerate.hooks.attach_align_device_hook.preload_module_classes",description:`<strong>preload_module_classes</strong> (<code>List[str]</code>, <em>optional</em>) &#x2014;
A list of classes whose instances should load all their weights (even in the submodules) at the beginning
of the forward. This should only be used for classes that have submodules which are registered but not
called directly during the forward, for instance if a <code>dense</code> linear layer is registered, but at forward,
<code>dense.weight</code> and <code>dense.bias</code> are used in some operations instead of calling <code>dense</code> directly.`,name:"preload_module_classes"}],source:"https://github.com/huggingface/accelerate/blob/v0.14.0/src/accelerate/hooks.py#L318"}}),Oe=new T({props:{name:"accelerate.hooks.attach_align_device_hook_on_blocks",anchor:"accelerate.hooks.attach_align_device_hook_on_blocks",parameters:[{name:"module",val:": Module"},{name:"execution_device",val:": typing.Union[torch.device, typing.Dict[str, torch.device], NoneType] = None"},{name:"offload",val:": typing.Union[bool, typing.Dict[str, bool]] = False"},{name:"weights_map",val:": typing.Mapping = None"},{name:"offload_buffers",val:": bool = False"},{name:"module_name",val:": str = ''"},{name:"preload_module_classes",val:": typing.Optional[typing.List[str]] = None"}],parametersDescription:[{anchor:"accelerate.hooks.attach_align_device_hook_on_blocks.module",description:`<strong>module</strong> (<code>torch.nn.Module</code>) &#x2014;
The module where we want to attach the hooks.`,name:"module"},{anchor:"accelerate.hooks.attach_align_device_hook_on_blocks.execution_device",description:`<strong>execution_device</strong> (<code>torch.device</code> or <code>Dict[str, torch.device]</code>, <em>optional</em>) &#x2014;
The device on which inputs and model weights should be placed before the forward pass. It can be one device
for the whole module, or a dictionary mapping module name to device.`,name:"execution_device"},{anchor:"accelerate.hooks.attach_align_device_hook_on_blocks.offload",description:`<strong>offload</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not the weights should be offloaded after the forward pass. It can be one boolean for the whole
module, or a dictionary mapping module name to boolean.`,name:"offload"},{anchor:"accelerate.hooks.attach_align_device_hook_on_blocks.weights_map",description:`<strong>weights_map</strong> (<code>Mapping[str, torch.Tensor]</code>, <em>optional</em>) &#x2014;
When the model weights are offloaded, a (potentially lazy) map from param names to the tensor values.`,name:"weights_map"},{anchor:"accelerate.hooks.attach_align_device_hook_on_blocks.offload_buffers",description:`<strong>offload_buffers</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to include the associated module&#x2019;s buffers when offloading.`,name:"offload_buffers"},{anchor:"accelerate.hooks.attach_align_device_hook_on_blocks.module_name",description:`<strong>module_name</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;&quot;</code>) &#x2014;
The name of the module.`,name:"module_name"},{anchor:"accelerate.hooks.attach_align_device_hook_on_blocks.preload_module_classes",description:`<strong>preload_module_classes</strong> (<code>List[str]</code>, <em>optional</em>) &#x2014;
A list of classes whose instances should load all their weights (even in the submodules) at the beginning
of the forward. This should only be used for classes that have submodules which are registered but not
called directly during the forward, for instance if a <code>dense</code> linear layer is registered, but at forward,
<code>dense.weight</code> and <code>dense.bias</code> are used in some operations instead of calling <code>dense</code> directly.`,name:"preload_module_classes"}],source:"https://github.com/huggingface/accelerate/blob/v0.14.0/src/accelerate/hooks.py#L401"}}),Fe=new Ve({}),We=new T({props:{name:"accelerate.hooks.remove_hook_from_module",anchor:"accelerate.hooks.remove_hook_from_module",parameters:[{name:"module",val:": Module"},{name:"recurse",val:" = False"}],parametersDescription:[{anchor:"accelerate.hooks.remove_hook_from_module.module",description:"<strong>module</strong> (<code>torch.nn.Module</code>) &#x2014; The module to attach a hook to.",name:"module"},{anchor:"accelerate.hooks.remove_hook_from_module.recurse",description:"<strong>recurse</strong> (<code>bool</code>, <strong>optional</strong>) &#x2014; Whether to remove the hooks recursively",name:"recurse"}],source:"https://github.com/huggingface/accelerate/blob/v0.14.0/src/accelerate/hooks.py#L163",returnDescription:`
<p>The same module, with the hook detached (the module is modified in place, so the result can
be discarded).</p>
`,returnType:`
<p><code>torch.nn.Module</code></p>
`}}),Se=new T({props:{name:"accelerate.hooks.remove_hook_from_submodules",anchor:"accelerate.hooks.remove_hook_from_submodules",parameters:[{name:"module",val:": Module"}],parametersDescription:[{anchor:"accelerate.hooks.remove_hook_from_submodules.module",description:"<strong>module</strong> (<code>torch.nn.Module</code>) &#x2014; The module on which to remove all hooks.",name:"module"}],source:"https://github.com/huggingface/accelerate/blob/v0.14.0/src/accelerate/hooks.py#L389"}}),{c(){p=a("meta"),A=l(),w=a("h1"),y=a("a"),E=a("span"),u(f.$$.fragment),D=l(),U=a("span"),P=s("Working with large models"),$=l(),H=a("h2"),L=a("a"),ze=a("span"),u(fe.$$.fragment),wt=l(),Ge=a("span"),yt=s("Dispatching and Offloading Models"),Ho=l(),C=a("div"),u(ue.$$.fragment),$t=l(),Be=a("p"),xt=s(`A context manager under which models are initialized with all parameters on the meta device, therefore creating an
empty model. Useful when just initializing the model would blow the available RAM.`),Et=l(),u(oe.$$.fragment),Dt=l(),u(te.$$.fragment),Lo=l(),W=a("div"),u(ge.$$.fragment),Tt=l(),Je=a("p"),At=s(`Activates full CPU offload for a model. As a result, all parameters of the model will be offloaded and only one
copy of the state dict of the model will be kept. During the forward pass, parameters will be extracted from that
state dict and put on the execution device passed as they are needed, then offloaded again.`),No=l(),q=a("div"),u(_e.$$.fragment),Mt=l(),Ke=a("p"),Pt=s(`Activates full disk offload for a model. As a result, all parameters of the model will be offloaded as
memory-mapped array in a given folder. During the forward pass, parameters will be accessed from that folder and
put on the execution device passed as they are needed, then offloaded again.`),Uo=l(),S=a("div"),u(ve.$$.fragment),Ht=l(),Qe=a("p"),Lt=s(`Dispatches a model according to a given device map. Layers of the model might be spread across GPUs, offloaded on
the CPU or even the disk.`),Co=l(),j=a("div"),u(be.$$.fragment),Nt=l(),Xe=a("p"),Ut=s(`Loads a (potentially sharded) checkpoint inside a model, potentially sending weights to a given device as they are
loaded and adds the various hooks that will make this model run properly (even if split across devices).`),Oo=l(),R=a("h2"),ae=a("a"),Ye=a("span"),u(ke.$$.fragment),Ct=l(),Ze=a("span"),Ot=s("Model Hooks"),Io=l(),V=a("h3"),re=a("a"),eo=a("span"),u(we.$$.fragment),It=l(),oo=a("span"),Ft=s("Hook Classes"),Fo=l(),x=a("div"),u(ye.$$.fragment),Wt=l(),to=a("p"),qt=s(`A hook that contains callbacks to be executed just before and after the forward method of a model. The difference
with PyTorch existing hooks is that they get passed along the kwargs.`),St=l(),ao=a("p"),jt=s("Class attribute:"),Rt=l(),ro=a("ul"),N=a("li"),no=a("strong"),Vt=s("no_grad"),zt=s(" ("),so=a("code"),Gt=s("bool"),Bt=s(", "),lo=a("em"),Jt=s("optional"),Kt=s(", defaults to "),co=a("code"),Qt=s("False"),Xt=s(`) \u2014 Whether or not to execute the actual forward pass under
the `),io=a("code"),Yt=s("torch.no_grad()"),Zt=s(" context manager."),ea=l(),ne=a("div"),u($e.$$.fragment),oa=l(),ho=a("p"),ta=s("To be executed when the hook is detached from a module."),aa=l(),se=a("div"),u(xe.$$.fragment),ra=l(),mo=a("p"),na=s("To be executed when the hook is attached to the module."),sa=l(),de=a("div"),u(Ee.$$.fragment),da=l(),po=a("p"),la=s("To be executed just after the forward method of the model."),ca=l(),le=a("div"),u(De.$$.fragment),ia=l(),fo=a("p"),ha=s("To be executed just before the forward method of the model."),Wo=l(),z=a("div"),u(Te.$$.fragment),ma=l(),Ae=a("p"),pa=s("A generic "),uo=a("code"),fa=s("ModelHook"),ua=s(` that ensures inputs and model weights are on the same device for the forward pass of the
associated module, potentially offloading the weights after the forward pass.`),qo=l(),G=a("div"),u(Me.$$.fragment),ga=l(),go=a("p"),_a=s("A hook that can contain several hooks and iterates through them at each event."),So=l(),B=a("h3"),ce=a("a"),_o=a("span"),u(Pe.$$.fragment),va=l(),vo=a("span"),ba=s("Adding Hooks"),jo=l(),O=a("div"),u(He.$$.fragment),ka=l(),I=a("p"),wa=s("Adds a hook to a given module. This will rewrite the "),bo=a("code"),ya=s("forward"),$a=s(` method of the module to include the hook, to remove
this behavior and restore the original `),ko=a("code"),xa=s("forward"),Ea=s(" method, use "),wo=a("code"),Da=s("remove_hook_from_module"),Ta=s("."),Aa=l(),u(ie.$$.fragment),Ro=l(),J=a("div"),u(Le.$$.fragment),Ma=l(),Ne=a("p"),Pa=s("Recursively attaches "),yo=a("code"),Ha=s("AlignDevicesHook"),La=s(` to all submodules of a given model to make sure they have the right
execution device`),Vo=l(),K=a("div"),u(Ue.$$.fragment),Na=l(),Ce=a("p"),Ua=s("Recursively attaches "),$o=a("code"),Ca=s("AlignDevicesHook"),Oa=s(` to all submodules of a given model that have direct parameters and/or
buffers.`),zo=l(),Q=a("div"),u(Oe.$$.fragment),Ia=l(),Ie=a("p"),Fa=s("Attaches "),xo=a("code"),Wa=s("AlignDevicesHook"),qa=s(" to all blocks of a given model as needed."),Go=l(),X=a("h3"),he=a("a"),Eo=a("span"),u(Fe.$$.fragment),Sa=l(),Do=a("span"),ja=s("Removing Hooks"),Bo=l(),Y=a("div"),u(We.$$.fragment),Ra=l(),qe=a("p"),Va=s("Removes any hook attached to a module via "),To=a("code"),za=s("add_hook_to_module"),Ga=s("."),Jo=l(),Z=a("div"),u(Se.$$.fragment),Ba=l(),Ao=a("p"),Ja=s("Recursively removes all hooks attached on the submodules of a given model."),this.h()},l(e){const i=jr('[data-svelte="svelte-1phssyn"]',document.head);p=r(i,"META",{name:!0,content:!0}),i.forEach(t),A=c(e),w=r(e,"H1",{class:!0});var je=n(w);y=r(je,"A",{id:!0,class:!0,href:!0});var Mo=n(y);E=r(Mo,"SPAN",{});var Po=n(E);g(f.$$.fragment,Po),Po.forEach(t),Mo.forEach(t),D=c(je),U=r(je,"SPAN",{});var Ka=n(U);P=d(Ka,"Working with large models"),Ka.forEach(t),je.forEach(t),$=c(e),H=r(e,"H2",{class:!0});var Qo=n(H);L=r(Qo,"A",{id:!0,class:!0,href:!0});var Qa=n(L);ze=r(Qa,"SPAN",{});var Xa=n(ze);g(fe.$$.fragment,Xa),Xa.forEach(t),Qa.forEach(t),wt=c(Qo),Ge=r(Qo,"SPAN",{});var Ya=n(Ge);yt=d(Ya,"Dispatching and Offloading Models"),Ya.forEach(t),Qo.forEach(t),Ho=c(e),C=r(e,"DIV",{class:!0});var me=n(C);g(ue.$$.fragment,me),$t=c(me),Be=r(me,"P",{});var Za=n(Be);xt=d(Za,`A context manager under which models are initialized with all parameters on the meta device, therefore creating an
empty model. Useful when just initializing the model would blow the available RAM.`),Za.forEach(t),Et=c(me),g(oe.$$.fragment,me),Dt=c(me),g(te.$$.fragment,me),me.forEach(t),Lo=c(e),W=r(e,"DIV",{class:!0});var Xo=n(W);g(ge.$$.fragment,Xo),Tt=c(Xo),Je=r(Xo,"P",{});var er=n(Je);At=d(er,`Activates full CPU offload for a model. As a result, all parameters of the model will be offloaded and only one
copy of the state dict of the model will be kept. During the forward pass, parameters will be extracted from that
state dict and put on the execution device passed as they are needed, then offloaded again.`),er.forEach(t),Xo.forEach(t),No=c(e),q=r(e,"DIV",{class:!0});var Yo=n(q);g(_e.$$.fragment,Yo),Mt=c(Yo),Ke=r(Yo,"P",{});var or=n(Ke);Pt=d(or,`Activates full disk offload for a model. As a result, all parameters of the model will be offloaded as
memory-mapped array in a given folder. During the forward pass, parameters will be accessed from that folder and
put on the execution device passed as they are needed, then offloaded again.`),or.forEach(t),Yo.forEach(t),Uo=c(e),S=r(e,"DIV",{class:!0});var Zo=n(S);g(ve.$$.fragment,Zo),Ht=c(Zo),Qe=r(Zo,"P",{});var tr=n(Qe);Lt=d(tr,`Dispatches a model according to a given device map. Layers of the model might be spread across GPUs, offloaded on
the CPU or even the disk.`),tr.forEach(t),Zo.forEach(t),Co=c(e),j=r(e,"DIV",{class:!0});var et=n(j);g(be.$$.fragment,et),Nt=c(et),Xe=r(et,"P",{});var ar=n(Xe);Ut=d(ar,`Loads a (potentially sharded) checkpoint inside a model, potentially sending weights to a given device as they are
loaded and adds the various hooks that will make this model run properly (even if split across devices).`),ar.forEach(t),et.forEach(t),Oo=c(e),R=r(e,"H2",{class:!0});var ot=n(R);ae=r(ot,"A",{id:!0,class:!0,href:!0});var rr=n(ae);Ye=r(rr,"SPAN",{});var nr=n(Ye);g(ke.$$.fragment,nr),nr.forEach(t),rr.forEach(t),Ct=c(ot),Ze=r(ot,"SPAN",{});var sr=n(Ze);Ot=d(sr,"Model Hooks"),sr.forEach(t),ot.forEach(t),Io=c(e),V=r(e,"H3",{class:!0});var tt=n(V);re=r(tt,"A",{id:!0,class:!0,href:!0});var dr=n(re);eo=r(dr,"SPAN",{});var lr=n(eo);g(we.$$.fragment,lr),lr.forEach(t),dr.forEach(t),It=c(tt),oo=r(tt,"SPAN",{});var cr=n(oo);Ft=d(cr,"Hook Classes"),cr.forEach(t),tt.forEach(t),Fo=c(e),x=r(e,"DIV",{class:!0});var M=n(x);g(ye.$$.fragment,M),Wt=c(M),to=r(M,"P",{});var ir=n(to);qt=d(ir,`A hook that contains callbacks to be executed just before and after the forward method of a model. The difference
with PyTorch existing hooks is that they get passed along the kwargs.`),ir.forEach(t),St=c(M),ao=r(M,"P",{});var hr=n(ao);jt=d(hr,"Class attribute:"),hr.forEach(t),Rt=c(M),ro=r(M,"UL",{});var mr=n(ro);N=r(mr,"LI",{});var F=n(N);no=r(F,"STRONG",{});var pr=n(no);Vt=d(pr,"no_grad"),pr.forEach(t),zt=d(F," ("),so=r(F,"CODE",{});var fr=n(so);Gt=d(fr,"bool"),fr.forEach(t),Bt=d(F,", "),lo=r(F,"EM",{});var ur=n(lo);Jt=d(ur,"optional"),ur.forEach(t),Kt=d(F,", defaults to "),co=r(F,"CODE",{});var gr=n(co);Qt=d(gr,"False"),gr.forEach(t),Xt=d(F,`) \u2014 Whether or not to execute the actual forward pass under
the `),io=r(F,"CODE",{});var _r=n(io);Yt=d(_r,"torch.no_grad()"),_r.forEach(t),Zt=d(F," context manager."),F.forEach(t),mr.forEach(t),ea=c(M),ne=r(M,"DIV",{class:!0});var at=n(ne);g($e.$$.fragment,at),oa=c(at),ho=r(at,"P",{});var vr=n(ho);ta=d(vr,"To be executed when the hook is detached from a module."),vr.forEach(t),at.forEach(t),aa=c(M),se=r(M,"DIV",{class:!0});var rt=n(se);g(xe.$$.fragment,rt),ra=c(rt),mo=r(rt,"P",{});var br=n(mo);na=d(br,"To be executed when the hook is attached to the module."),br.forEach(t),rt.forEach(t),sa=c(M),de=r(M,"DIV",{class:!0});var nt=n(de);g(Ee.$$.fragment,nt),da=c(nt),po=r(nt,"P",{});var kr=n(po);la=d(kr,"To be executed just after the forward method of the model."),kr.forEach(t),nt.forEach(t),ca=c(M),le=r(M,"DIV",{class:!0});var st=n(le);g(De.$$.fragment,st),ia=c(st),fo=r(st,"P",{});var wr=n(fo);ha=d(wr,"To be executed just before the forward method of the model."),wr.forEach(t),st.forEach(t),M.forEach(t),Wo=c(e),z=r(e,"DIV",{class:!0});var dt=n(z);g(Te.$$.fragment,dt),ma=c(dt),Ae=r(dt,"P",{});var lt=n(Ae);pa=d(lt,"A generic "),uo=r(lt,"CODE",{});var yr=n(uo);fa=d(yr,"ModelHook"),yr.forEach(t),ua=d(lt,` that ensures inputs and model weights are on the same device for the forward pass of the
associated module, potentially offloading the weights after the forward pass.`),lt.forEach(t),dt.forEach(t),qo=c(e),G=r(e,"DIV",{class:!0});var ct=n(G);g(Me.$$.fragment,ct),ga=c(ct),go=r(ct,"P",{});var $r=n(go);_a=d($r,"A hook that can contain several hooks and iterates through them at each event."),$r.forEach(t),ct.forEach(t),So=c(e),B=r(e,"H3",{class:!0});var it=n(B);ce=r(it,"A",{id:!0,class:!0,href:!0});var xr=n(ce);_o=r(xr,"SPAN",{});var Er=n(_o);g(Pe.$$.fragment,Er),Er.forEach(t),xr.forEach(t),va=c(it),vo=r(it,"SPAN",{});var Dr=n(vo);ba=d(Dr,"Adding Hooks"),Dr.forEach(t),it.forEach(t),jo=c(e),O=r(e,"DIV",{class:!0});var Re=n(O);g(He.$$.fragment,Re),ka=c(Re),I=r(Re,"P",{});var pe=n(I);wa=d(pe,"Adds a hook to a given module. This will rewrite the "),bo=r(pe,"CODE",{});var Tr=n(bo);ya=d(Tr,"forward"),Tr.forEach(t),$a=d(pe,` method of the module to include the hook, to remove
this behavior and restore the original `),ko=r(pe,"CODE",{});var Ar=n(ko);xa=d(Ar,"forward"),Ar.forEach(t),Ea=d(pe," method, use "),wo=r(pe,"CODE",{});var Mr=n(wo);Da=d(Mr,"remove_hook_from_module"),Mr.forEach(t),Ta=d(pe,"."),pe.forEach(t),Aa=c(Re),g(ie.$$.fragment,Re),Re.forEach(t),Ro=c(e),J=r(e,"DIV",{class:!0});var ht=n(J);g(Le.$$.fragment,ht),Ma=c(ht),Ne=r(ht,"P",{});var mt=n(Ne);Pa=d(mt,"Recursively attaches "),yo=r(mt,"CODE",{});var Pr=n(yo);Ha=d(Pr,"AlignDevicesHook"),Pr.forEach(t),La=d(mt,` to all submodules of a given model to make sure they have the right
execution device`),mt.forEach(t),ht.forEach(t),Vo=c(e),K=r(e,"DIV",{class:!0});var pt=n(K);g(Ue.$$.fragment,pt),Na=c(pt),Ce=r(pt,"P",{});var ft=n(Ce);Ua=d(ft,"Recursively attaches "),$o=r(ft,"CODE",{});var Hr=n($o);Ca=d(Hr,"AlignDevicesHook"),Hr.forEach(t),Oa=d(ft,` to all submodules of a given model that have direct parameters and/or
buffers.`),ft.forEach(t),pt.forEach(t),zo=c(e),Q=r(e,"DIV",{class:!0});var ut=n(Q);g(Oe.$$.fragment,ut),Ia=c(ut),Ie=r(ut,"P",{});var gt=n(Ie);Fa=d(gt,"Attaches "),xo=r(gt,"CODE",{});var Lr=n(xo);Wa=d(Lr,"AlignDevicesHook"),Lr.forEach(t),qa=d(gt," to all blocks of a given model as needed."),gt.forEach(t),ut.forEach(t),Go=c(e),X=r(e,"H3",{class:!0});var _t=n(X);he=r(_t,"A",{id:!0,class:!0,href:!0});var Nr=n(he);Eo=r(Nr,"SPAN",{});var Ur=n(Eo);g(Fe.$$.fragment,Ur),Ur.forEach(t),Nr.forEach(t),Sa=c(_t),Do=r(_t,"SPAN",{});var Cr=n(Do);ja=d(Cr,"Removing Hooks"),Cr.forEach(t),_t.forEach(t),Bo=c(e),Y=r(e,"DIV",{class:!0});var vt=n(Y);g(We.$$.fragment,vt),Ra=c(vt),qe=r(vt,"P",{});var bt=n(qe);Va=d(bt,"Removes any hook attached to a module via "),To=r(bt,"CODE",{});var Or=n(To);za=d(Or,"add_hook_to_module"),Or.forEach(t),Ga=d(bt,"."),bt.forEach(t),vt.forEach(t),Jo=c(e),Z=r(e,"DIV",{class:!0});var kt=n(Z);g(Se.$$.fragment,kt),Ba=c(kt),Ao=r(kt,"P",{});var Ir=n(Ao);Ja=d(Ir,"Recursively removes all hooks attached on the submodules of a given model."),Ir.forEach(t),kt.forEach(t),this.h()},h(){h(p,"name","hf:doc:metadata"),h(p,"content",JSON.stringify(Xr)),h(y,"id","working-with-large-models"),h(y,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(y,"href","#working-with-large-models"),h(w,"class","relative group"),h(L,"id","accelerate.init_empty_weights"),h(L,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(L,"href","#accelerate.init_empty_weights"),h(H,"class","relative group"),h(C,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(W,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(S,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(j,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(ae,"id","model-hooks"),h(ae,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(ae,"href","#model-hooks"),h(R,"class","relative group"),h(re,"id","accelerate.hooks.ModelHook"),h(re,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(re,"href","#accelerate.hooks.ModelHook"),h(V,"class","relative group"),h(ne,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(se,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(de,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(le,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(x,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(G,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(ce,"id","accelerate.hooks.add_hook_to_module"),h(ce,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(ce,"href","#accelerate.hooks.add_hook_to_module"),h(B,"class","relative group"),h(O,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(J,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(K,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(he,"id","accelerate.hooks.remove_hook_from_module"),h(he,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(he,"href","#accelerate.hooks.remove_hook_from_module"),h(X,"class","relative group"),h(Y,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(e,i){o(document.head,p),m(e,A,i),m(e,w,i),o(w,y),o(y,E),_(f,E,null),o(w,D),o(w,U),o(U,P),m(e,$,i),m(e,H,i),o(H,L),o(L,ze),_(fe,ze,null),o(H,wt),o(H,Ge),o(Ge,yt),m(e,Ho,i),m(e,C,i),_(ue,C,null),o(C,$t),o(C,Be),o(Be,xt),o(C,Et),_(oe,C,null),o(C,Dt),_(te,C,null),m(e,Lo,i),m(e,W,i),_(ge,W,null),o(W,Tt),o(W,Je),o(Je,At),m(e,No,i),m(e,q,i),_(_e,q,null),o(q,Mt),o(q,Ke),o(Ke,Pt),m(e,Uo,i),m(e,S,i),_(ve,S,null),o(S,Ht),o(S,Qe),o(Qe,Lt),m(e,Co,i),m(e,j,i),_(be,j,null),o(j,Nt),o(j,Xe),o(Xe,Ut),m(e,Oo,i),m(e,R,i),o(R,ae),o(ae,Ye),_(ke,Ye,null),o(R,Ct),o(R,Ze),o(Ze,Ot),m(e,Io,i),m(e,V,i),o(V,re),o(re,eo),_(we,eo,null),o(V,It),o(V,oo),o(oo,Ft),m(e,Fo,i),m(e,x,i),_(ye,x,null),o(x,Wt),o(x,to),o(to,qt),o(x,St),o(x,ao),o(ao,jt),o(x,Rt),o(x,ro),o(ro,N),o(N,no),o(no,Vt),o(N,zt),o(N,so),o(so,Gt),o(N,Bt),o(N,lo),o(lo,Jt),o(N,Kt),o(N,co),o(co,Qt),o(N,Xt),o(N,io),o(io,Yt),o(N,Zt),o(x,ea),o(x,ne),_($e,ne,null),o(ne,oa),o(ne,ho),o(ho,ta),o(x,aa),o(x,se),_(xe,se,null),o(se,ra),o(se,mo),o(mo,na),o(x,sa),o(x,de),_(Ee,de,null),o(de,da),o(de,po),o(po,la),o(x,ca),o(x,le),_(De,le,null),o(le,ia),o(le,fo),o(fo,ha),m(e,Wo,i),m(e,z,i),_(Te,z,null),o(z,ma),o(z,Ae),o(Ae,pa),o(Ae,uo),o(uo,fa),o(Ae,ua),m(e,qo,i),m(e,G,i),_(Me,G,null),o(G,ga),o(G,go),o(go,_a),m(e,So,i),m(e,B,i),o(B,ce),o(ce,_o),_(Pe,_o,null),o(B,va),o(B,vo),o(vo,ba),m(e,jo,i),m(e,O,i),_(He,O,null),o(O,ka),o(O,I),o(I,wa),o(I,bo),o(bo,ya),o(I,$a),o(I,ko),o(ko,xa),o(I,Ea),o(I,wo),o(wo,Da),o(I,Ta),o(O,Aa),_(ie,O,null),m(e,Ro,i),m(e,J,i),_(Le,J,null),o(J,Ma),o(J,Ne),o(Ne,Pa),o(Ne,yo),o(yo,Ha),o(Ne,La),m(e,Vo,i),m(e,K,i),_(Ue,K,null),o(K,Na),o(K,Ce),o(Ce,Ua),o(Ce,$o),o($o,Ca),o(Ce,Oa),m(e,zo,i),m(e,Q,i),_(Oe,Q,null),o(Q,Ia),o(Q,Ie),o(Ie,Fa),o(Ie,xo),o(xo,Wa),o(Ie,qa),m(e,Go,i),m(e,X,i),o(X,he),o(he,Eo),_(Fe,Eo,null),o(X,Sa),o(X,Do),o(Do,ja),m(e,Bo,i),m(e,Y,i),_(We,Y,null),o(Y,Ra),o(Y,qe),o(qe,Va),o(qe,To),o(To,za),o(qe,Ga),m(e,Jo,i),m(e,Z,i),_(Se,Z,null),o(Z,Ba),o(Z,Ao),o(Ao,Ja),Ko=!0},p(e,[i]){const je={};i&2&&(je.$$scope={dirty:i,ctx:e}),oe.$set(je);const Mo={};i&2&&(Mo.$$scope={dirty:i,ctx:e}),te.$set(Mo);const Po={};i&2&&(Po.$$scope={dirty:i,ctx:e}),ie.$set(Po)},i(e){Ko||(v(f.$$.fragment,e),v(fe.$$.fragment,e),v(ue.$$.fragment,e),v(oe.$$.fragment,e),v(te.$$.fragment,e),v(ge.$$.fragment,e),v(_e.$$.fragment,e),v(ve.$$.fragment,e),v(be.$$.fragment,e),v(ke.$$.fragment,e),v(we.$$.fragment,e),v(ye.$$.fragment,e),v($e.$$.fragment,e),v(xe.$$.fragment,e),v(Ee.$$.fragment,e),v(De.$$.fragment,e),v(Te.$$.fragment,e),v(Me.$$.fragment,e),v(Pe.$$.fragment,e),v(He.$$.fragment,e),v(ie.$$.fragment,e),v(Le.$$.fragment,e),v(Ue.$$.fragment,e),v(Oe.$$.fragment,e),v(Fe.$$.fragment,e),v(We.$$.fragment,e),v(Se.$$.fragment,e),Ko=!0)},o(e){b(f.$$.fragment,e),b(fe.$$.fragment,e),b(ue.$$.fragment,e),b(oe.$$.fragment,e),b(te.$$.fragment,e),b(ge.$$.fragment,e),b(_e.$$.fragment,e),b(ve.$$.fragment,e),b(be.$$.fragment,e),b(ke.$$.fragment,e),b(we.$$.fragment,e),b(ye.$$.fragment,e),b($e.$$.fragment,e),b(xe.$$.fragment,e),b(Ee.$$.fragment,e),b(De.$$.fragment,e),b(Te.$$.fragment,e),b(Me.$$.fragment,e),b(Pe.$$.fragment,e),b(He.$$.fragment,e),b(ie.$$.fragment,e),b(Le.$$.fragment,e),b(Ue.$$.fragment,e),b(Oe.$$.fragment,e),b(Fe.$$.fragment,e),b(We.$$.fragment,e),b(Se.$$.fragment,e),Ko=!1},d(e){t(p),e&&t(A),e&&t(w),k(f),e&&t($),e&&t(H),k(fe),e&&t(Ho),e&&t(C),k(ue),k(oe),k(te),e&&t(Lo),e&&t(W),k(ge),e&&t(No),e&&t(q),k(_e),e&&t(Uo),e&&t(S),k(ve),e&&t(Co),e&&t(j),k(be),e&&t(Oo),e&&t(R),k(ke),e&&t(Io),e&&t(V),k(we),e&&t(Fo),e&&t(x),k(ye),k($e),k(xe),k(Ee),k(De),e&&t(Wo),e&&t(z),k(Te),e&&t(qo),e&&t(G),k(Me),e&&t(So),e&&t(B),k(Pe),e&&t(jo),e&&t(O),k(He),k(ie),e&&t(Ro),e&&t(J),k(Le),e&&t(Vo),e&&t(K),k(Ue),e&&t(zo),e&&t(Q),k(Oe),e&&t(Go),e&&t(X),k(Fe),e&&t(Bo),e&&t(Y),k(We),e&&t(Jo),e&&t(Z),k(Se)}}}const Xr={local:"working-with-large-models",sections:[{local:"accelerate.init_empty_weights",title:"Dispatching and Offloading Models"},{local:"model-hooks",sections:[{local:"accelerate.hooks.ModelHook",title:"Hook Classes"},{local:"accelerate.hooks.add_hook_to_module",title:"Adding Hooks"},{local:"accelerate.hooks.remove_hook_from_module",title:"Removing Hooks"}],title:"Model Hooks"}],title:"Working with large models"};function Yr(ee){return Rr(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class nn extends Wr{constructor(p){super();qr(this,p,Yr,Qr,Sr,{})}}export{nn as default,Xr as metadata};
