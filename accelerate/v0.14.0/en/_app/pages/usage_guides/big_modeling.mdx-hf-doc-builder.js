import{S as Zh,i as ec,s as tc,e as n,c as i,a as r,d as s,b as m,$ as Kh,g as h,L as Xh,k as c,w,t as a,M as sc,m as p,x as _,h as o,G as t,y,q as g,o as $,B as b,v as ac}from"../../chunks/vendor-hf-doc-builder.js";import{T as dt}from"../../chunks/Tip-hf-doc-builder.js";import{I as ce}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{C as D}from"../../chunks/CodeBlock-hf-doc-builder.js";function oc(x){let d,v;return{c(){d=n("iframe"),this.h()},l(f){d=i(f,"IFRAME",{class:!0,src:!0,title:!0,frameborder:!0,allow:!0}),r(d).forEach(s),this.h()},h(){m(d,"class","w-full xl:w-4/6 h-80"),Kh(d.src,v="https://www.youtube-nocookie.com/embed/"+x[0])||m(d,"src",v),m(d,"title","YouTube video player"),m(d,"frameborder","0"),m(d,"allow","accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"),d.allowFullscreen=!0},m(f,u){h(f,d,u)},p(f,[u]){u&1&&!Kh(d.src,v="https://www.youtube-nocookie.com/embed/"+f[0])&&m(d,"src",v)},i:Xh,o:Xh,d(f){f&&s(d)}}}function lc(x,d,v){let{id:f}=d;return x.$$set=u=>{"id"in u&&v(0,f=u.id)},[f]}class nc extends Zh{constructor(d){super();ec(this,d,lc,oc,tc,{id:0})}}function ic(x){let d,v;return{c(){d=n("p"),v=a("This API is quite new and still in its experimental stage. While we strive to provide a stable API, it\u2019s possible some small parts of the public API will change in the future.")},l(f){d=i(f,"P",{});var u=r(d);v=o(u,"This API is quite new and still in its experimental stage. While we strive to provide a stable API, it\u2019s possible some small parts of the public API will change in the future."),u.forEach(s)},m(f,u){h(f,d,u),t(d,v)},d(f){f&&s(d)}}}function rc(x){let d,v;return{c(){d=n("p"),v=a("You can\u2019t move a model initialized like this on CPU or another device directly, since it doesn\u2019t have any data. It\u2019s also very likely that a forward pass with that empty model will fail, as not all operations are supported on the meta device.")},l(f){d=i(f,"P",{});var u=r(d);v=o(u,"You can\u2019t move a model initialized like this on CPU or another device directly, since it doesn\u2019t have any data. It\u2019s also very likely that a forward pass with that empty model will fail, as not all operations are supported on the meta device."),u.forEach(s)},m(f,u){h(f,d,u),t(d,v)},d(f){f&&s(d)}}}function hc(x){let d,v,f,u,U;return{c(){d=n("p"),v=a("This only supports inference of your model, not training. Most of the computation happens behind "),f=n("code"),u=a("torch.no_grad()"),U=a(" context managers to avoid spending some GPU memory with intermediate activations.")},l(k){d=i(k,"P",{});var E=r(d);v=o(E,"This only supports inference of your model, not training. Most of the computation happens behind "),f=i(E,"CODE",{});var C=r(f);u=o(C,"torch.no_grad()"),C.forEach(s),U=o(E," context managers to avoid spending some GPU memory with intermediate activations."),E.forEach(s)},m(k,E){h(k,d,E),t(d,v),t(d,f),t(f,u),t(d,U)},d(k){k&&s(d)}}}function cc(x){let d,v,f,u,U;return{c(){d=n("p"),v=a("You can derive all sizes of the model (and thus compute a "),f=n("code"),u=a("device_map"),U=a(") on a model that is on the meta device.")},l(k){d=i(k,"P",{});var E=r(d);v=o(E,"You can derive all sizes of the model (and thus compute a "),f=i(E,"CODE",{});var C=r(f);u=o(C,"device_map"),C.forEach(s),U=o(E,") on a model that is on the meta device."),E.forEach(s)},m(k,E){h(k,d,E),t(d,v),t(d,f),t(f,u),t(d,U)},d(k){k&&s(d)}}}function pc(x){let d,v,f,u,U,k,E,C,z,F,R,A,T,S;return{c(){d=n("p"),v=a("The options "),f=n("code"),u=a('"auto"'),U=a(" and "),k=n("code"),E=a('"balanced"'),C=a(" produce the same results for now, but the behavior of "),z=n("code"),F=a('"auto"'),R=a(" might change in the future if we find a strategy that makes more sense, while "),A=n("code"),T=a('"balanced"'),S=a(" will stay stable.")},l(L){d=i(L,"P",{});var P=r(d);v=o(P,"The options "),f=i(P,"CODE",{});var ft=r(f);u=o(ft,'"auto"'),ft.forEach(s),U=o(P," and "),k=i(P,"CODE",{});var Oe=r(k);E=o(Oe,'"balanced"'),Oe.forEach(s),C=o(P," produce the same results for now, but the behavior of "),z=i(P,"CODE",{});var H=r(z);F=o(H,'"auto"'),H.forEach(s),R=o(P," might change in the future if we find a strategy that makes more sense, while "),A=i(P,"CODE",{});var pe=r(A);T=o(pe,'"balanced"'),pe.forEach(s),S=o(P," will stay stable."),P.forEach(s)},m(L,P){h(L,d,P),t(d,v),t(d,f),t(f,u),t(d,U),t(d,k),t(k,E),t(d,C),t(d,z),t(z,F),t(d,R),t(d,A),t(A,T),t(d,S)},d(L){L&&s(d)}}}function dc(x){let d,v,f,u,U,k,E,C,z,F,R;return{c(){d=n("p"),v=a("When a first allocation happens in PyTorch, it loads CUDA kernels which take about 1-2GB of memory depending on the GPU. Therefore you always have less usable memory than the actual size of the GPU. To see how much memory is actually used do "),f=n("code"),u=a("torch.ones(1).cuda()"),U=a(" and look at the memory usage."),k=c(),E=n("p"),C=a("Therefore when you create memory maps with "),z=n("code"),F=a("max_memory"),R=a(" make sure to adjust the avaialble memory accordingly to avoid out-of-memory errors.")},l(A){d=i(A,"P",{});var T=r(d);v=o(T,"When a first allocation happens in PyTorch, it loads CUDA kernels which take about 1-2GB of memory depending on the GPU. Therefore you always have less usable memory than the actual size of the GPU. To see how much memory is actually used do "),f=i(T,"CODE",{});var S=r(f);u=o(S,"torch.ones(1).cuda()"),S.forEach(s),U=o(T," and look at the memory usage."),T.forEach(s),k=p(A),E=i(A,"P",{});var L=r(E);C=o(L,"Therefore when you create memory maps with "),z=i(L,"CODE",{});var P=r(z);F=o(P,"max_memory"),P.forEach(s),R=o(L," make sure to adjust the avaialble memory accordingly to avoid out-of-memory errors."),L.forEach(s)},m(A,T){h(A,d,T),t(d,v),t(d,f),t(f,u),t(d,U),h(A,k,T),h(A,E,T),t(E,C),t(E,z),t(z,F),t(E,R)},d(A){A&&s(d),A&&s(k),A&&s(E)}}}function fc(x){let d,v;return{c(){d=n("p"),v=a("To be the most efficient, make sure your device map puts the parameters on the GPUs in a sequential manner (e.g. don\u2019t put one of the first weights on GPU 0, then weights on GPU 1 and the last weight back to GPU 0) to avoid making many transfers of data between the GPUs.")},l(f){d=i(f,"P",{});var u=r(d);v=o(u,"To be the most efficient, make sure your device map puts the parameters on the GPUs in a sequential manner (e.g. don\u2019t put one of the first weights on GPU 0, then weights on GPU 1 and the last weight back to GPU 0) to avoid making many transfers of data between the GPUs."),u.forEach(s)},m(f,u){h(f,d,u),t(d,v)},d(f){f&&s(d)}}}function mc(x){let d,v,f,u,U,k,E,C,z,F,R,A,T,S,L,P,ft,Oe,H,pe,Wo,Ho,St,No,Fo,Wt,Yo,ua,mt,Jo,va,de,wa,ee,fe,Ht,De,Qo,Nt,Vo,_a,Me,ya,te,me,Ft,ze,Ko,Yt,Xo,ga,se,ue,Jt,Le,Zo,Qt,el,$a,ve,tl,ut,sl,al,ba,Re,ka,vt,ol,Ea,Se,Pa,wt,ll,ja,we,Ga,ae,_e,Vt,We,nl,Kt,il,xa,_t,rl,Ua,yt,hl,Aa,He,Ca,gt,cl,qa,Ne,Ba,O,pl,Xt,dl,fl,Zt,ml,ul,es,vl,wl,ts,_l,yl,ss,gl,$l,as,bl,Ia,oe,ye,os,Fe,kl,ls,El,Ta,ge,Pl,$t,jl,Gl,Oa,$e,xl,Ye,Ul,Al,Da,Je,Ma,bt,Cl,za,Qe,La,kt,ql,Ra,Ve,Sa,be,Bl,ns,Il,Tl,Wa,J,is,Ol,Dl,rs,Ml,zl,hs,Ll,Ha,le,cs,Rl,Sl,ps,Wl,Hl,Na,Q,Nl,ds,Fl,Yl,fs,Jl,Ql,Fa,Ke,Ya,Xe,Ja,ke,Vl,ms,Kl,Xl,Qa,Ze,Va,ne,Ee,us,et,Zl,vs,en,Ka,Et,tn,Xa,tt,Za,Pt,sn,eo,V,ws,an,on,_s,ln,nn,ys,rn,to,jt,hn,so,Pe,ao,ie,je,gs,st,cn,$s,pn,oo,M,dn,bs,fn,mn,ks,un,vn,Es,wn,_n,Ps,yn,gn,js,$n,bn,lo,Ge,no,Gt,kn,io,xt,En,ro,K,xe,Gs,Pn,jn,xs,Gn,xn,Un,Ue,Us,An,Cn,As,qn,Bn,In,Ut,Cs,Tn,On,ho,Ae,co,j,Dn,qs,Mn,zn,Bs,Ln,Rn,Is,Sn,Wn,Ts,Hn,Nn,Os,Fn,Yn,Ds,Jn,Qn,Ms,Vn,Kn,zs,Xn,Zn,po,At,ei,fo,at,mo,Ce,uo,qe,ti,Ls,si,ai,vo,ot,wo,Ct,oi,_o,G,li,Rs,ni,ii,Ss,ri,hi,Ws,ci,pi,Hs,di,fi,Ns,mi,ui,Fs,vi,wi,Ys,_i,yi,Js,gi,$i,yo,lt,go,qt,bi,$o,nt,bo,Bt,ki,ko,it,Eo,Be,Po,re,Ie,Qs,rt,Ei,Vs,Pi,jo,It,ji,Go,q,Ks,Gi,xi,X,Xs,Ui,Ai,Zs,Ci,qi,Tt,Bi,Ii,Ti,Z,ea,Oi,Di,ta,Mi,zi,Ot,Li,Ri,Si,Te,Dt,Wi,Hi,sa,Ni,Fi,Yi,aa,Ji,Qi,oa,Vi,Ki,la,Xi,xo;return k=new ce({}),S=new D({props:{code:`import torch

my_model = ModelClass(...)
state_dict = torch.load(checkpoint_file)
my_model.load_state_dict(state_dict)`,highlighted:`<span class="hljs-keyword">import</span> torch

my_model = ModelClass(...)
state_dict = torch.load(checkpoint_file)
my_model.load_state_dict(state_dict)`}}),de=new dt({props:{warning:!0,$$slots:{default:[ic]},$$scope:{ctx:x}}}),De=new ce({}),Me=new nc({props:{id:"MWCSGj9jEAo"}}),ze=new ce({}),Le=new ce({}),Re=new D({props:{code:`from accelerate import init_empty_weights

with init_empty_weights():
    my_model = ModelClass(...)`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> init_empty_weights

<span class="hljs-keyword">with</span> init_empty_weights():
    my_model = ModelClass(...)`}}),Se=new D({props:{code:`with init_empty_weights():
    model = nn.Sequential(*[nn.Linear(10000, 10000) for _ in range(1000)])`,highlighted:`<span class="hljs-keyword">with</span> init_empty_weights():
    model = nn.Sequential(*[nn.Linear(<span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>)])`}}),we=new dt({props:{warning:!0,$$slots:{default:[rc]},$$scope:{ctx:x}}}),We=new ce({}),He=new D({props:{code:`first_state_dict.bin
index.json
second_state_dict.bin`,highlighted:`first_state_dict.bin
index.json
second_state_dict.bin`}}),Ne=new D({props:{code:`{
  "linear1.weight": "first_state_dict.bin",
  "linear1.bias": "first_state_dict.bin",
  "linear2.weight": "second_state_dict.bin",
  "linear2.bias": "second_state_dict.bin"
}`,highlighted:`<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;linear1.weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;first_state_dict.bin&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;linear1.bias&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;first_state_dict.bin&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;linear2.weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;second_state_dict.bin&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;linear2.bias&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;second_state_dict.bin&quot;</span>
<span class="hljs-punctuation">}</span>`}}),Fe=new ce({}),Je=new D({props:{code:`git clone https://huggingface.co/sgugger/sharded-gpt-j-6B
cd sharded-gpt-j-6B
git-lfs install
git pull`,highlighted:`git <span class="hljs-built_in">clone</span> https://huggingface.co/sgugger/sharded-gpt-j-6B
<span class="hljs-built_in">cd</span> sharded-gpt-j-6B
git-lfs install
git pull`}}),Qe=new D({props:{code:`from accelerate import init_empty_weights
from transformers import AutoConfig, AutoModelForCausalLM

checkpoint = "EleutherAI/gpt-j-6B"
config = AutoConfig.from_pretrained(checkpoint)

with init_empty_weights():
    model = AutoModelForCausalLM.from_config(config)`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> init_empty_weights
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoConfig, AutoModelForCausalLM

checkpoint = <span class="hljs-string">&quot;EleutherAI/gpt-j-6B&quot;</span>
config = AutoConfig.from_pretrained(checkpoint)

<span class="hljs-keyword">with</span> init_empty_weights():
    model = AutoModelForCausalLM.from_config(config)`}}),Ve=new D({props:{code:`from accelerate import load_checkpoint_and_dispatch

model = load_checkpoint_and_dispatch(
    model, "sharded-gpt-j-6B", device_map="auto", no_split_module_classes=["GPTJBlock"]
)`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> load_checkpoint_and_dispatch

model = load_checkpoint_and_dispatch(
    model, <span class="hljs-string">&quot;sharded-gpt-j-6B&quot;</span>, device_map=<span class="hljs-string">&quot;auto&quot;</span>, no_split_module_classes=[<span class="hljs-string">&quot;GPTJBlock&quot;</span>]
)`}}),Ke=new D({props:{code:"model.hf_device_map",highlighted:"model.hf_device_map"}}),Xe=new D({props:{code:`{'transformer.wte': 0,
 'transformer.drop': 0,
 'transformer.h.0': 0,
 'transformer.h.1': 0,
 'transformer.h.2': 0,
 'transformer.h.3': 0,
 'transformer.h.4': 0,
 'transformer.h.5': 0,
 'transformer.h.6': 0,
 'transformer.h.7': 0,
 'transformer.h.8': 0,
 'transformer.h.9': 0,
 'transformer.h.10': 0,
 'transformer.h.11': 0,
 'transformer.h.12': 0,
 'transformer.h.13': 0,
 'transformer.h.14': 0,
 'transformer.h.15': 0,
 'transformer.h.16': 0,
 'transformer.h.17': 0,
 'transformer.h.18': 0,
 'transformer.h.19': 0,
 'transformer.h.20': 0,
 'transformer.h.21': 0,
 'transformer.h.22': 0,
 'transformer.h.23': 0,
 'transformer.h.24': 1,
 'transformer.h.25': 1,
 'transformer.h.26': 1,
 'transformer.h.27': 1,
 'transformer.ln_f': 1,
 'lm_head': 1}`,highlighted:`{<span class="hljs-string">&#x27;transformer.wte&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.drop&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.0&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.1&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.2&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.3&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.4&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.5&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.6&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.7&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.8&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.9&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.10&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.11&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.12&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.13&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.14&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.15&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.16&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.17&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.18&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.19&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.20&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.21&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.22&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.23&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;transformer.h.24&#x27;</span>: <span class="hljs-number">1</span>,
 <span class="hljs-string">&#x27;transformer.h.25&#x27;</span>: <span class="hljs-number">1</span>,
 <span class="hljs-string">&#x27;transformer.h.26&#x27;</span>: <span class="hljs-number">1</span>,
 <span class="hljs-string">&#x27;transformer.h.27&#x27;</span>: <span class="hljs-number">1</span>,
 <span class="hljs-string">&#x27;transformer.ln_f&#x27;</span>: <span class="hljs-number">1</span>,
 <span class="hljs-string">&#x27;lm_head&#x27;</span>: <span class="hljs-number">1</span>}`}}),Ze=new D({props:{code:'model = load_checkpoint_and_dispatch(model, "sharded-gpt-j-6B", device_map=my_device_map)',highlighted:'model = load_checkpoint_and_dispatch(model, <span class="hljs-string">&quot;sharded-gpt-j-6B&quot;</span>, device_map=my_device_map)'}}),et=new ce({}),tt=new D({props:{code:`from transformers import AutoTokenizer

tokenizer = AutoTokenizer.from_pretrained(checkpoint)
inputs = tokenizer("Hello, my name is", return_tensors="pt")
inputs = inputs.to(0)
output = model.generate(inputs["input_ids"])
tokenizer.decode(output[0].tolist())`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer

tokenizer = AutoTokenizer.from_pretrained(checkpoint)
inputs = tokenizer(<span class="hljs-string">&quot;Hello, my name is&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
inputs = inputs.to(<span class="hljs-number">0</span>)
output = model.generate(inputs[<span class="hljs-string">&quot;input_ids&quot;</span>])
tokenizer.decode(output[<span class="hljs-number">0</span>].tolist())`}}),Pe=new dt({props:{warning:!0,$$slots:{default:[hc]},$$scope:{ctx:x}}}),st=new ce({}),Ge=new dt({props:{$$slots:{default:[cc]},$$scope:{ctx:x}}}),Ae=new dt({props:{$$slots:{default:[pc]},$$scope:{ctx:x}}}),at=new D({props:{code:`from accelerate import infer_auto_device_map

device_map = infer_auto_device_map(my_model, max_memory={0: "10GiB", 1: "10GiB", "cpu": "30GiB"})`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> infer_auto_device_map

device_map = infer_auto_device_map(my_model, max_memory={<span class="hljs-number">0</span>: <span class="hljs-string">&quot;10GiB&quot;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&quot;10GiB&quot;</span>, <span class="hljs-string">&quot;cpu&quot;</span>: <span class="hljs-string">&quot;30GiB&quot;</span>})`}}),Ce=new dt({props:{warning:!0,$$slots:{default:[dc]},$$scope:{ctx:x}}}),ot=new D({props:{code:'max_memory = {0: "30GIB", 1: "46GIB", 2: "46GIB", 3: "46GIB", 4: "46GIB", 5: "46GIB", 6: "46GIB", 7: "46GIB"}',highlighted:'max_memory = {<span class="hljs-number">0</span>: <span class="hljs-string">&quot;30GIB&quot;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&quot;46GIB&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;46GIB&quot;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&quot;46GIB&quot;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&quot;46GIB&quot;</span>, <span class="hljs-number">5</span>: <span class="hljs-string">&quot;46GIB&quot;</span>, <span class="hljs-number">6</span>: <span class="hljs-string">&quot;46GIB&quot;</span>, <span class="hljs-number">7</span>: <span class="hljs-string">&quot;46GIB&quot;</span>}'}}),lt=new D({props:{code:'device_map = {"block1": 0, "block2": 1}',highlighted:'device_map = {<span class="hljs-string">&quot;block1&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;block2&quot;</span>: <span class="hljs-number">1</span>}'}}),nt=new D({props:{code:'device_map = {"block1": 0, "block2.linear1": 0, "block2.linear2": 1, "block2.linear3": 1}',highlighted:'device_map = {<span class="hljs-string">&quot;block1&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;block2.linear1&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;block2.linear2&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;block2.linear3&quot;</span>: <span class="hljs-number">1</span>}'}}),it=new D({props:{code:'device_map = {"block1": 0, "block2.linear1": 1, "block2.linear2": 1}',highlighted:'device_map = {<span class="hljs-string">&quot;block1&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;block2.linear1&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;block2.linear2&quot;</span>: <span class="hljs-number">1</span>}'}}),Be=new dt({props:{$$slots:{default:[fc]},$$scope:{ctx:x}}}),rt=new ce({}),{c(){d=n("meta"),v=c(),f=n("h1"),u=n("a"),U=n("span"),w(k.$$.fragment),E=c(),C=n("span"),z=a("Handling big models"),F=c(),R=n("p"),A=a("When loading a pretrained model in PyTorch, the usual workflow looks like this:"),T=c(),w(S.$$.fragment),L=c(),P=n("p"),ft=a("In plain English, those steps are:"),Oe=c(),H=n("ol"),pe=n("li"),Wo=a("Create the model with randomly initialized weights"),Ho=c(),St=n("li"),No=a("Load the model weights (in a dictionary usually called a state dict) from the disk"),Fo=c(),Wt=n("li"),Yo=a("Load those weights inside the model"),ua=c(),mt=n("p"),Jo=a("While this works very well for regularly sized models, this workflow has some clear limitations when we deal with a huge model: in step 1, we load a full version of the model in RAM, and spend some time randomly initializing the weights (which will be discarded in step 3). In step 2, we load another full version of the model in RAM, with the pretrained weights. If you\u2019re loading a model with 6 billions parameters, this means you will need 24GB of RAM for each copy of the model, so 48GB in total (half of it to load the model in FP16)."),va=c(),w(de.$$.fragment),wa=c(),ee=n("h2"),fe=n("a"),Ht=n("span"),w(De.$$.fragment),Qo=c(),Nt=n("span"),Vo=a("How the Process Works: A Quick Overview"),_a=c(),w(Me.$$.fragment),ya=c(),te=n("h2"),me=n("a"),Ft=n("span"),w(ze.$$.fragment),Ko=c(),Yt=n("span"),Xo=a("How the Process Works: Working with Code"),ga=c(),se=n("h3"),ue=n("a"),Jt=n("span"),w(Le.$$.fragment),Zo=c(),Qt=n("span"),el=a("Instantiating an empty model"),$a=c(),ve=n("p"),tl=a("The first tool \u{1F917} Accelerate introduces to help with big models is a context manager "),ut=n("a"),sl=a("init_empty_weights()"),al=a(" that helps you initialize a model without using any RAM, so that step 1 can be done on models of any size. Here is how it works:"),ba=c(),w(Re.$$.fragment),ka=c(),vt=n("p"),ol=a("For instance:"),Ea=c(),w(Se.$$.fragment),Pa=c(),wt=n("p"),ll=a("initializes an empty model with a bit more than 100B parameters. Behind the scenes, this relies on the meta device introduced in PyTorch 1.9. During the initialization under the context manager, each time a parameter is created, it is instantly moved on that device."),ja=c(),w(we.$$.fragment),Ga=c(),ae=n("h3"),_e=n("a"),Vt=n("span"),w(We.$$.fragment),nl=c(),Kt=n("span"),il=a("Sharded checkpoints"),xa=c(),_t=n("p"),rl=a("It\u2019s possible your model is so big that even a single copy won\u2019t fit in RAM. That doesn\u2019t mean it can\u2019t be loaded: if you have one or several GPUs, this is more memory available to store your model. In this case, it\u2019s better if your checkpoint is split in several smaller files that we call checkpoint shards."),Ua=c(),yt=n("p"),hl=a("\u{1F917} Accelerate will handle sharded checkpoints as long as you follow the following format: your checkpoint should be in a folder, with several files containing the partial state dicts, and there should be an index in the JSON format that contains a dictionary mapping parameter names to the file containing their weights. For instance we could have a folder containing:"),Aa=c(),w(He.$$.fragment),Ca=c(),gt=n("p"),cl=a("with index.json being the following file:"),qa=c(),w(Ne.$$.fragment),Ba=c(),O=n("p"),pl=a("and "),Xt=n("code"),dl=a("first_state_dict.bin"),fl=a(" containing the weights for "),Zt=n("code"),ml=a('"linear1.weight"'),ul=a(" and "),es=n("code"),vl=a('"linear1.bias"'),wl=a(", "),ts=n("code"),_l=a("second_state_dict.bin"),yl=a(" the ones for "),ss=n("code"),gl=a('"linear2.weight"'),$l=a(" and "),as=n("code"),bl=a('"linear2.bias"'),Ia=c(),oe=n("h3"),ye=n("a"),os=n("span"),w(Fe.$$.fragment),kl=c(),ls=n("span"),El=a("Loading weights"),Ta=c(),ge=n("p"),Pl=a("The second tool \u{1F917} Accelerate introduces is a function "),$t=n("a"),jl=a("load_checkpoint_and_dispatch()"),Gl=a(", that will allow you to load a checkpoint inside your empty model. This supports full checkpoints (a single file containing the whole state dict) as well as sharded checkpoints. It will also automatically dispatch those weights across the devices you have available (GPUs, CPU RAM), so if you are loading a sharded checkpoint, the maximum RAM usage will be the size of the biggest shard."),Oa=c(),$e=n("p"),xl=a("Here is how we can use this to load the "),Ye=n("a"),Ul=a("GPT-J-6B"),Al=a(" model. You clone the sharded version of this model with:"),Da=c(),w(Je.$$.fragment),Ma=c(),bt=n("p"),Cl=a("then we can initialize the model with"),za=c(),w(Qe.$$.fragment),La=c(),kt=n("p"),ql=a("and load the checkpoint we just downloaded with:"),Ra=c(),w(Ve.$$.fragment),Sa=c(),be=n("p"),Bl=a("By passing "),ns=n("code"),Il=a('device_map="auto"'),Tl=a(", we tell \u{1F917} Accelerate to determine automatically where to put each layer of the model depending on the available resources:"),Wa=c(),J=n("ul"),is=n("li"),Ol=a("first we use the maximum space available on the GPU(s)"),Dl=c(),rs=n("li"),Ml=a("if we still need space, we store the remaining weights on the CPU"),zl=c(),hs=n("li"),Ll=a("if there is not enough RAM, we store the remaining weights on the hard drive as memory-mapped tensors"),Ha=c(),le=n("p"),cs=n("code"),Rl=a('no_split_module_classes=["GPTJBlock"]'),Sl=a(" indicates that the modules that are "),ps=n("code"),Wl=a("GPTJBlock"),Hl=a(" should not be split on different devices. You should set here all blocks that include a residual connection of some kind."),Na=c(),Q=n("p"),Nl=a("You can see the "),ds=n("code"),Fl=a("device_map"),Yl=a(" that \u{1F917} Accelerate picked by accessing the "),fs=n("code"),Jl=a("hf_device_map"),Ql=a(" attribute of your model:"),Fa=c(),w(Ke.$$.fragment),Ya=c(),w(Xe.$$.fragment),Ja=c(),ke=n("p"),Vl=a("You can also design your "),ms=n("code"),Kl=a("device_map"),Xl=a(" yourself, if you prefer to explicitly decide where each layer should be. In this case, the command above becomes:"),Qa=c(),w(Ze.$$.fragment),Va=c(),ne=n("h3"),Ee=n("a"),us=n("span"),w(et.$$.fragment),Zl=c(),vs=n("span"),en=a("Run the model"),Ka=c(),Et=n("p"),tn=a("Now that we have done this, our model lies across several devices, and maybe the hard drive. But it can still be used as a regular PyTorch model:"),Xa=c(),w(tt.$$.fragment),Za=c(),Pt=n("p"),sn=a("Behind the scenes, \u{1F917} Accelerate added hooks to the model, so that:"),eo=c(),V=n("ul"),ws=n("li"),an=a("at each layer, the inputs are put on the right device (so even if your model is spread across several GPUs, it works)"),on=c(),_s=n("li"),ln=a("for the weights offloaded on the CPU, they are put on a GPU just before the forward pass, and cleaned up just after"),nn=c(),ys=n("li"),rn=a("for the weights offloaded on the hard drive, they are loaded in RAM then put on a GPU just before the forward pass, and cleaned up just after"),to=c(),jt=n("p"),hn=a("This way, you model can run for inference even if it doesn\u2019t fit on one of the GPUs or the CPU RAM!"),so=c(),w(Pe.$$.fragment),ao=c(),ie=n("h3"),je=n("a"),gs=n("span"),w(st.$$.fragment),cn=c(),$s=n("span"),pn=a("Designing a device map"),oo=c(),M=n("p"),dn=a("You can let \u{1F917} Accelerate handle the device map computation by setting "),bs=n("code"),fn=a("device_map"),mn=a(" to one of the supported options ("),ks=n("code"),un=a('"auto"'),vn=a(", "),Es=n("code"),wn=a('"balanced"'),_n=a(", "),Ps=n("code"),yn=a('"balanced_low_0"'),gn=a(", "),js=n("code"),$n=a('"sequential"'),bn=a(") or create one yourself, if you want more control over where each layer should go."),lo=c(),w(Ge.$$.fragment),no=c(),Gt=n("p"),kn=a("All the options will produce the same result when you don\u2019t have enough GPU memory to accommodate the whole model (which is to fit everything that can on the GPU, then offload weights on the CPU or even on the disk if there is not enough RAM)."),io=c(),xt=n("p"),En=a("When you have more GPU memory available than the model size, here the difference between each option:"),ro=c(),K=n("ul"),xe=n("li"),Gs=n("code"),Pn=a('"auto"'),jn=a(" and "),xs=n("code"),Gn=a('"balanced"'),xn=a(" evenly split the model on all available GPUs, making it possible for you to use a batch size greater than 1."),Un=c(),Ue=n("li"),Us=n("code"),An=a('"balanced_low_0"'),Cn=a(" evenly splits the model on all GPUs except the first one, and only puts on GPU 0 what does not fit on the others. This option is great when you need to use GPU 0 for some processing of the outputs, like when using the "),As=n("code"),qn=a("generate"),Bn=a(" function for Transformers models"),In=c(),Ut=n("li"),Cs=n("code"),Tn=a('"sequential"'),On=a(" will fit what it can on GPU 0, then move on GPU 1 and so forth (so won\u2019t use the last GPUs if it doesn\u2019t need to)."),ho=c(),w(Ae.$$.fragment),co=c(),j=n("p"),Dn=a("First note that you can limit the memory used on each GPU by using the "),qs=n("code"),Mn=a("max_memory"),zn=a(" argument (available in "),Bs=n("code"),Ln=a("infer_auto_device_map()"),Rn=a(" and in all functions using it). When setting "),Is=n("code"),Sn=a("max_memory"),Wn=a(", you should pass along a dictionary containing the GPU identifiers (for instance "),Ts=n("code"),Hn=a("0"),Nn=a(", "),Os=n("code"),Fn=a("1"),Yn=a(" etc.) and the "),Ds=n("code"),Jn=a('"cpu"'),Qn=a(" key for the maximum RAM you want used for CPU offload. The values can either be an integer (in bytes) or a string representing a number with its unit, such as "),Ms=n("code"),Vn=a('"10GiB"'),Kn=a(" or "),zs=n("code"),Xn=a('"10GB"'),Zn=a("."),po=c(),At=n("p"),ei=a("Here is an example where we don\u2019t want to use more than 10GiB on each of two GPUs and no more than 30GiB of CPU RAM for the model weights:"),fo=c(),w(at.$$.fragment),mo=c(),w(Ce.$$.fragment),uo=c(),qe=n("p"),ti=a("Additionally, if you do some additional operations with your outputs without placing them back on the CPU (for instance inside the "),Ls=n("code"),si=a("generate"),ai=a(" method of Transformers) and if you placed your inputs on a GPU, that GPU will consume more memory than the others (Accelerate always place the output back to the device of the input). Therefore if you would like to optimize the maximum batch size and you have many GPUs, give the first GPU less memory. For example, with BLOOM-176B on 8x80 A100 setup the close to ideal map is:"),vo=c(),w(ot.$$.fragment),wo=c(),Ct=n("p"),oi=a("as you can see we gave the remaining 7 GPUs ~50% more memory than GPU 0."),_o=c(),G=n("p"),li=a("If you opt to fully design the "),Rs=n("code"),ni=a("device_map"),ii=a(" yourself, it should be a dictionary with keys being module names of your model and values being a valid device identifier (for instance an integer for the GPUs) or "),Ss=n("code"),ri=a('"cpu"'),hi=a(" for CPU offload, "),Ws=n("code"),ci=a('"disk"'),pi=a(" for disk offload. The keys need to cover the whole model, you can then define your device map as you wish: for instance if your model has two blocks (let\u2019s say "),Hs=n("code"),di=a("block1"),fi=a(" and "),Ns=n("code"),mi=a("block2"),ui=a(") which each contain three linear layers (let\u2019s say "),Fs=n("code"),vi=a("linear1"),wi=a(", "),Ys=n("code"),_i=a("linear2"),yi=a(" and "),Js=n("code"),gi=a("linear3"),$i=a("), a valid device map can be:"),yo=c(),w(lt.$$.fragment),go=c(),qt=n("p"),bi=a("another one that is valid could be:"),$o=c(),w(nt.$$.fragment),bo=c(),Bt=n("p"),ki=a("On the other hand, this one is not valid as it does not cover every parameter of the model:"),ko=c(),w(it.$$.fragment),Eo=c(),w(Be.$$.fragment),Po=c(),re=n("h2"),Ie=n("a"),Qs=n("span"),w(rt.$$.fragment),Ei=c(),Vs=n("span"),Pi=a("Limits and further development"),jo=c(),It=n("p"),ji=a("We are aware of the current limitations in the API:"),Go=c(),q=n("ul"),Ks=n("li"),Gi=a("While this could theoretically work on just one CPU with potential disk offload, you need at least one GPU to run this API. This will be fixed in further development."),xi=c(),X=n("li"),Xs=n("code"),Ui=a("infer_auto_device_map()"),Ai=a(" (or "),Zs=n("code"),Ci=a('device_map="auto"'),qi=a(" in "),Tt=n("a"),Bi=a("load_checkpoint_and_dispatch()"),Ii=a(") tries to maximize GPU and CPU RAM it sees available when you execute it. While PyTorch is very good at managing GPU RAM efficiently (and giving it back when not needed), it\u2019s not entirely true with Python and CPU RAM. Therefore, an automatically computed device map might be too intense on the CPU. Move a few modules to the disk device if you get crashes due to lack of RAM."),Ti=c(),Z=n("li"),ea=n("code"),Oi=a("infer_auto_device_map()"),Di=a(" (or "),ta=n("code"),Mi=a('device_map="auto"'),zi=a(" in "),Ot=n("a"),Li=a("load_checkpoint_and_dispatch()"),Ri=a(") attributes devices sequentially (to avoid moving things back and forth) so if your first layer is bigger than the size of the GPU you have, it will end up with everything on the CPU/Disk."),Si=c(),Te=n("li"),Dt=n("a"),Wi=a("load_checkpoint_and_dispatch()"),Hi=a(" and "),sa=n("code"),Ni=a("load_checkpoint_in_model()"),Fi=a(" do not perform any check on the correctness of your state dict compared to your model at the moment (this will be fixed in a future version), so you may get some weird errors if trying to load a checkpoint with mismatched or missing keys."),Yi=c(),aa=n("li"),Ji=a("The model parallelism used when your model is split on several GPUs is naive and not optimized, meaning that only one GPU works at a given time and the other sits idle."),Qi=c(),oa=n("li"),Vi=a("When weights are offloaded on the CPU/hard drive, there is no pre-fetching (yet, we will work on this for future versions) which means the weights are put on the GPU when they are needed and not before."),Ki=c(),la=n("li"),Xi=a("Hard-drive offloading might be very slow if the hardware you run on does not have fast communication between disk and CPU (like NVMes)."),this.h()},l(e){const l=sc('[data-svelte="svelte-1phssyn"]',document.head);d=i(l,"META",{name:!0,content:!0}),l.forEach(s),v=p(e),f=i(e,"H1",{class:!0});var ht=r(f);u=i(ht,"A",{id:!0,class:!0,href:!0});var na=r(u);U=i(na,"SPAN",{});var ia=r(U);_(k.$$.fragment,ia),ia.forEach(s),na.forEach(s),E=p(ht),C=i(ht,"SPAN",{});var ra=r(C);z=o(ra,"Handling big models"),ra.forEach(s),ht.forEach(s),F=p(e),R=i(e,"P",{});var ha=r(R);A=o(ha,"When loading a pretrained model in PyTorch, the usual workflow looks like this:"),ha.forEach(s),T=p(e),_(S.$$.fragment,e),L=p(e),P=i(e,"P",{});var ca=r(P);ft=o(ca,"In plain English, those steps are:"),ca.forEach(s),Oe=p(e),H=i(e,"OL",{});var he=r(H);pe=i(he,"LI",{});var er=r(pe);Wo=o(er,"Create the model with randomly initialized weights"),er.forEach(s),Ho=p(he),St=i(he,"LI",{});var tr=r(St);No=o(tr,"Load the model weights (in a dictionary usually called a state dict) from the disk"),tr.forEach(s),Fo=p(he),Wt=i(he,"LI",{});var sr=r(Wt);Yo=o(sr,"Load those weights inside the model"),sr.forEach(s),he.forEach(s),ua=p(e),mt=i(e,"P",{});var ar=r(mt);Jo=o(ar,"While this works very well for regularly sized models, this workflow has some clear limitations when we deal with a huge model: in step 1, we load a full version of the model in RAM, and spend some time randomly initializing the weights (which will be discarded in step 3). In step 2, we load another full version of the model in RAM, with the pretrained weights. If you\u2019re loading a model with 6 billions parameters, this means you will need 24GB of RAM for each copy of the model, so 48GB in total (half of it to load the model in FP16)."),ar.forEach(s),va=p(e),_(de.$$.fragment,e),wa=p(e),ee=i(e,"H2",{class:!0});var Uo=r(ee);fe=i(Uo,"A",{id:!0,class:!0,href:!0});var or=r(fe);Ht=i(or,"SPAN",{});var lr=r(Ht);_(De.$$.fragment,lr),lr.forEach(s),or.forEach(s),Qo=p(Uo),Nt=i(Uo,"SPAN",{});var nr=r(Nt);Vo=o(nr,"How the Process Works: A Quick Overview"),nr.forEach(s),Uo.forEach(s),_a=p(e),_(Me.$$.fragment,e),ya=p(e),te=i(e,"H2",{class:!0});var Ao=r(te);me=i(Ao,"A",{id:!0,class:!0,href:!0});var ir=r(me);Ft=i(ir,"SPAN",{});var rr=r(Ft);_(ze.$$.fragment,rr),rr.forEach(s),ir.forEach(s),Ko=p(Ao),Yt=i(Ao,"SPAN",{});var hr=r(Yt);Xo=o(hr,"How the Process Works: Working with Code"),hr.forEach(s),Ao.forEach(s),ga=p(e),se=i(e,"H3",{class:!0});var Co=r(se);ue=i(Co,"A",{id:!0,class:!0,href:!0});var cr=r(ue);Jt=i(cr,"SPAN",{});var pr=r(Jt);_(Le.$$.fragment,pr),pr.forEach(s),cr.forEach(s),Zo=p(Co),Qt=i(Co,"SPAN",{});var dr=r(Qt);el=o(dr,"Instantiating an empty model"),dr.forEach(s),Co.forEach(s),$a=p(e),ve=i(e,"P",{});var qo=r(ve);tl=o(qo,"The first tool \u{1F917} Accelerate introduces to help with big models is a context manager "),ut=i(qo,"A",{href:!0});var fr=r(ut);sl=o(fr,"init_empty_weights()"),fr.forEach(s),al=o(qo," that helps you initialize a model without using any RAM, so that step 1 can be done on models of any size. Here is how it works:"),qo.forEach(s),ba=p(e),_(Re.$$.fragment,e),ka=p(e),vt=i(e,"P",{});var mr=r(vt);ol=o(mr,"For instance:"),mr.forEach(s),Ea=p(e),_(Se.$$.fragment,e),Pa=p(e),wt=i(e,"P",{});var ur=r(wt);ll=o(ur,"initializes an empty model with a bit more than 100B parameters. Behind the scenes, this relies on the meta device introduced in PyTorch 1.9. During the initialization under the context manager, each time a parameter is created, it is instantly moved on that device."),ur.forEach(s),ja=p(e),_(we.$$.fragment,e),Ga=p(e),ae=i(e,"H3",{class:!0});var Bo=r(ae);_e=i(Bo,"A",{id:!0,class:!0,href:!0});var vr=r(_e);Vt=i(vr,"SPAN",{});var wr=r(Vt);_(We.$$.fragment,wr),wr.forEach(s),vr.forEach(s),nl=p(Bo),Kt=i(Bo,"SPAN",{});var _r=r(Kt);il=o(_r,"Sharded checkpoints"),_r.forEach(s),Bo.forEach(s),xa=p(e),_t=i(e,"P",{});var yr=r(_t);rl=o(yr,"It\u2019s possible your model is so big that even a single copy won\u2019t fit in RAM. That doesn\u2019t mean it can\u2019t be loaded: if you have one or several GPUs, this is more memory available to store your model. In this case, it\u2019s better if your checkpoint is split in several smaller files that we call checkpoint shards."),yr.forEach(s),Ua=p(e),yt=i(e,"P",{});var gr=r(yt);hl=o(gr,"\u{1F917} Accelerate will handle sharded checkpoints as long as you follow the following format: your checkpoint should be in a folder, with several files containing the partial state dicts, and there should be an index in the JSON format that contains a dictionary mapping parameter names to the file containing their weights. For instance we could have a folder containing:"),gr.forEach(s),Aa=p(e),_(He.$$.fragment,e),Ca=p(e),gt=i(e,"P",{});var $r=r(gt);cl=o($r,"with index.json being the following file:"),$r.forEach(s),qa=p(e),_(Ne.$$.fragment,e),Ba=p(e),O=i(e,"P",{});var N=r(O);pl=o(N,"and "),Xt=i(N,"CODE",{});var br=r(Xt);dl=o(br,"first_state_dict.bin"),br.forEach(s),fl=o(N," containing the weights for "),Zt=i(N,"CODE",{});var kr=r(Zt);ml=o(kr,'"linear1.weight"'),kr.forEach(s),ul=o(N," and "),es=i(N,"CODE",{});var Er=r(es);vl=o(Er,'"linear1.bias"'),Er.forEach(s),wl=o(N,", "),ts=i(N,"CODE",{});var Pr=r(ts);_l=o(Pr,"second_state_dict.bin"),Pr.forEach(s),yl=o(N," the ones for "),ss=i(N,"CODE",{});var jr=r(ss);gl=o(jr,'"linear2.weight"'),jr.forEach(s),$l=o(N," and "),as=i(N,"CODE",{});var Gr=r(as);bl=o(Gr,'"linear2.bias"'),Gr.forEach(s),N.forEach(s),Ia=p(e),oe=i(e,"H3",{class:!0});var Io=r(oe);ye=i(Io,"A",{id:!0,class:!0,href:!0});var xr=r(ye);os=i(xr,"SPAN",{});var Ur=r(os);_(Fe.$$.fragment,Ur),Ur.forEach(s),xr.forEach(s),kl=p(Io),ls=i(Io,"SPAN",{});var Ar=r(ls);El=o(Ar,"Loading weights"),Ar.forEach(s),Io.forEach(s),Ta=p(e),ge=i(e,"P",{});var To=r(ge);Pl=o(To,"The second tool \u{1F917} Accelerate introduces is a function "),$t=i(To,"A",{href:!0});var Cr=r($t);jl=o(Cr,"load_checkpoint_and_dispatch()"),Cr.forEach(s),Gl=o(To,", that will allow you to load a checkpoint inside your empty model. This supports full checkpoints (a single file containing the whole state dict) as well as sharded checkpoints. It will also automatically dispatch those weights across the devices you have available (GPUs, CPU RAM), so if you are loading a sharded checkpoint, the maximum RAM usage will be the size of the biggest shard."),To.forEach(s),Oa=p(e),$e=i(e,"P",{});var Oo=r($e);xl=o(Oo,"Here is how we can use this to load the "),Ye=i(Oo,"A",{href:!0,rel:!0});var qr=r(Ye);Ul=o(qr,"GPT-J-6B"),qr.forEach(s),Al=o(Oo," model. You clone the sharded version of this model with:"),Oo.forEach(s),Da=p(e),_(Je.$$.fragment,e),Ma=p(e),bt=i(e,"P",{});var Br=r(bt);Cl=o(Br,"then we can initialize the model with"),Br.forEach(s),za=p(e),_(Qe.$$.fragment,e),La=p(e),kt=i(e,"P",{});var Ir=r(kt);ql=o(Ir,"and load the checkpoint we just downloaded with:"),Ir.forEach(s),Ra=p(e),_(Ve.$$.fragment,e),Sa=p(e),be=i(e,"P",{});var Do=r(be);Bl=o(Do,"By passing "),ns=i(Do,"CODE",{});var Tr=r(ns);Il=o(Tr,'device_map="auto"'),Tr.forEach(s),Tl=o(Do,", we tell \u{1F917} Accelerate to determine automatically where to put each layer of the model depending on the available resources:"),Do.forEach(s),Wa=p(e),J=i(e,"UL",{});var Mt=r(J);is=i(Mt,"LI",{});var Or=r(is);Ol=o(Or,"first we use the maximum space available on the GPU(s)"),Or.forEach(s),Dl=p(Mt),rs=i(Mt,"LI",{});var Dr=r(rs);Ml=o(Dr,"if we still need space, we store the remaining weights on the CPU"),Dr.forEach(s),zl=p(Mt),hs=i(Mt,"LI",{});var Mr=r(hs);Ll=o(Mr,"if there is not enough RAM, we store the remaining weights on the hard drive as memory-mapped tensors"),Mr.forEach(s),Mt.forEach(s),Ha=p(e),le=i(e,"P",{});var pa=r(le);cs=i(pa,"CODE",{});var zr=r(cs);Rl=o(zr,'no_split_module_classes=["GPTJBlock"]'),zr.forEach(s),Sl=o(pa," indicates that the modules that are "),ps=i(pa,"CODE",{});var Lr=r(ps);Wl=o(Lr,"GPTJBlock"),Lr.forEach(s),Hl=o(pa," should not be split on different devices. You should set here all blocks that include a residual connection of some kind."),pa.forEach(s),Na=p(e),Q=i(e,"P",{});var zt=r(Q);Nl=o(zt,"You can see the "),ds=i(zt,"CODE",{});var Rr=r(ds);Fl=o(Rr,"device_map"),Rr.forEach(s),Yl=o(zt," that \u{1F917} Accelerate picked by accessing the "),fs=i(zt,"CODE",{});var Sr=r(fs);Jl=o(Sr,"hf_device_map"),Sr.forEach(s),Ql=o(zt," attribute of your model:"),zt.forEach(s),Fa=p(e),_(Ke.$$.fragment,e),Ya=p(e),_(Xe.$$.fragment,e),Ja=p(e),ke=i(e,"P",{});var Mo=r(ke);Vl=o(Mo,"You can also design your "),ms=i(Mo,"CODE",{});var Wr=r(ms);Kl=o(Wr,"device_map"),Wr.forEach(s),Xl=o(Mo," yourself, if you prefer to explicitly decide where each layer should be. In this case, the command above becomes:"),Mo.forEach(s),Qa=p(e),_(Ze.$$.fragment,e),Va=p(e),ne=i(e,"H3",{class:!0});var zo=r(ne);Ee=i(zo,"A",{id:!0,class:!0,href:!0});var Hr=r(Ee);us=i(Hr,"SPAN",{});var Nr=r(us);_(et.$$.fragment,Nr),Nr.forEach(s),Hr.forEach(s),Zl=p(zo),vs=i(zo,"SPAN",{});var Fr=r(vs);en=o(Fr,"Run the model"),Fr.forEach(s),zo.forEach(s),Ka=p(e),Et=i(e,"P",{});var Yr=r(Et);tn=o(Yr,"Now that we have done this, our model lies across several devices, and maybe the hard drive. But it can still be used as a regular PyTorch model:"),Yr.forEach(s),Xa=p(e),_(tt.$$.fragment,e),Za=p(e),Pt=i(e,"P",{});var Jr=r(Pt);sn=o(Jr,"Behind the scenes, \u{1F917} Accelerate added hooks to the model, so that:"),Jr.forEach(s),eo=p(e),V=i(e,"UL",{});var Lt=r(V);ws=i(Lt,"LI",{});var Qr=r(ws);an=o(Qr,"at each layer, the inputs are put on the right device (so even if your model is spread across several GPUs, it works)"),Qr.forEach(s),on=p(Lt),_s=i(Lt,"LI",{});var Vr=r(_s);ln=o(Vr,"for the weights offloaded on the CPU, they are put on a GPU just before the forward pass, and cleaned up just after"),Vr.forEach(s),nn=p(Lt),ys=i(Lt,"LI",{});var Kr=r(ys);rn=o(Kr,"for the weights offloaded on the hard drive, they are loaded in RAM then put on a GPU just before the forward pass, and cleaned up just after"),Kr.forEach(s),Lt.forEach(s),to=p(e),jt=i(e,"P",{});var Xr=r(jt);hn=o(Xr,"This way, you model can run for inference even if it doesn\u2019t fit on one of the GPUs or the CPU RAM!"),Xr.forEach(s),so=p(e),_(Pe.$$.fragment,e),ao=p(e),ie=i(e,"H3",{class:!0});var Lo=r(ie);je=i(Lo,"A",{id:!0,class:!0,href:!0});var Zr=r(je);gs=i(Zr,"SPAN",{});var eh=r(gs);_(st.$$.fragment,eh),eh.forEach(s),Zr.forEach(s),cn=p(Lo),$s=i(Lo,"SPAN",{});var th=r($s);pn=o(th,"Designing a device map"),th.forEach(s),Lo.forEach(s),oo=p(e),M=i(e,"P",{});var Y=r(M);dn=o(Y,"You can let \u{1F917} Accelerate handle the device map computation by setting "),bs=i(Y,"CODE",{});var sh=r(bs);fn=o(sh,"device_map"),sh.forEach(s),mn=o(Y," to one of the supported options ("),ks=i(Y,"CODE",{});var ah=r(ks);un=o(ah,'"auto"'),ah.forEach(s),vn=o(Y,", "),Es=i(Y,"CODE",{});var oh=r(Es);wn=o(oh,'"balanced"'),oh.forEach(s),_n=o(Y,", "),Ps=i(Y,"CODE",{});var lh=r(Ps);yn=o(lh,'"balanced_low_0"'),lh.forEach(s),gn=o(Y,", "),js=i(Y,"CODE",{});var nh=r(js);$n=o(nh,'"sequential"'),nh.forEach(s),bn=o(Y,") or create one yourself, if you want more control over where each layer should go."),Y.forEach(s),lo=p(e),_(Ge.$$.fragment,e),no=p(e),Gt=i(e,"P",{});var ih=r(Gt);kn=o(ih,"All the options will produce the same result when you don\u2019t have enough GPU memory to accommodate the whole model (which is to fit everything that can on the GPU, then offload weights on the CPU or even on the disk if there is not enough RAM)."),ih.forEach(s),io=p(e),xt=i(e,"P",{});var rh=r(xt);En=o(rh,"When you have more GPU memory available than the model size, here the difference between each option:"),rh.forEach(s),ro=p(e),K=i(e,"UL",{});var Rt=r(K);xe=i(Rt,"LI",{});var da=r(xe);Gs=i(da,"CODE",{});var hh=r(Gs);Pn=o(hh,'"auto"'),hh.forEach(s),jn=o(da," and "),xs=i(da,"CODE",{});var ch=r(xs);Gn=o(ch,'"balanced"'),ch.forEach(s),xn=o(da," evenly split the model on all available GPUs, making it possible for you to use a batch size greater than 1."),da.forEach(s),Un=p(Rt),Ue=i(Rt,"LI",{});var fa=r(Ue);Us=i(fa,"CODE",{});var ph=r(Us);An=o(ph,'"balanced_low_0"'),ph.forEach(s),Cn=o(fa," evenly splits the model on all GPUs except the first one, and only puts on GPU 0 what does not fit on the others. This option is great when you need to use GPU 0 for some processing of the outputs, like when using the "),As=i(fa,"CODE",{});var dh=r(As);qn=o(dh,"generate"),dh.forEach(s),Bn=o(fa," function for Transformers models"),fa.forEach(s),In=p(Rt),Ut=i(Rt,"LI",{});var Zi=r(Ut);Cs=i(Zi,"CODE",{});var fh=r(Cs);Tn=o(fh,'"sequential"'),fh.forEach(s),On=o(Zi," will fit what it can on GPU 0, then move on GPU 1 and so forth (so won\u2019t use the last GPUs if it doesn\u2019t need to)."),Zi.forEach(s),Rt.forEach(s),ho=p(e),_(Ae.$$.fragment,e),co=p(e),j=i(e,"P",{});var B=r(j);Dn=o(B,"First note that you can limit the memory used on each GPU by using the "),qs=i(B,"CODE",{});var mh=r(qs);Mn=o(mh,"max_memory"),mh.forEach(s),zn=o(B," argument (available in "),Bs=i(B,"CODE",{});var uh=r(Bs);Ln=o(uh,"infer_auto_device_map()"),uh.forEach(s),Rn=o(B," and in all functions using it). When setting "),Is=i(B,"CODE",{});var vh=r(Is);Sn=o(vh,"max_memory"),vh.forEach(s),Wn=o(B,", you should pass along a dictionary containing the GPU identifiers (for instance "),Ts=i(B,"CODE",{});var wh=r(Ts);Hn=o(wh,"0"),wh.forEach(s),Nn=o(B,", "),Os=i(B,"CODE",{});var _h=r(Os);Fn=o(_h,"1"),_h.forEach(s),Yn=o(B," etc.) and the "),Ds=i(B,"CODE",{});var yh=r(Ds);Jn=o(yh,'"cpu"'),yh.forEach(s),Qn=o(B," key for the maximum RAM you want used for CPU offload. The values can either be an integer (in bytes) or a string representing a number with its unit, such as "),Ms=i(B,"CODE",{});var gh=r(Ms);Vn=o(gh,'"10GiB"'),gh.forEach(s),Kn=o(B," or "),zs=i(B,"CODE",{});var $h=r(zs);Xn=o($h,'"10GB"'),$h.forEach(s),Zn=o(B,"."),B.forEach(s),po=p(e),At=i(e,"P",{});var bh=r(At);ei=o(bh,"Here is an example where we don\u2019t want to use more than 10GiB on each of two GPUs and no more than 30GiB of CPU RAM for the model weights:"),bh.forEach(s),fo=p(e),_(at.$$.fragment,e),mo=p(e),_(Ce.$$.fragment,e),uo=p(e),qe=i(e,"P",{});var Ro=r(qe);ti=o(Ro,"Additionally, if you do some additional operations with your outputs without placing them back on the CPU (for instance inside the "),Ls=i(Ro,"CODE",{});var kh=r(Ls);si=o(kh,"generate"),kh.forEach(s),ai=o(Ro," method of Transformers) and if you placed your inputs on a GPU, that GPU will consume more memory than the others (Accelerate always place the output back to the device of the input). Therefore if you would like to optimize the maximum batch size and you have many GPUs, give the first GPU less memory. For example, with BLOOM-176B on 8x80 A100 setup the close to ideal map is:"),Ro.forEach(s),vo=p(e),_(ot.$$.fragment,e),wo=p(e),Ct=i(e,"P",{});var Eh=r(Ct);oi=o(Eh,"as you can see we gave the remaining 7 GPUs ~50% more memory than GPU 0."),Eh.forEach(s),_o=p(e),G=i(e,"P",{});var I=r(G);li=o(I,"If you opt to fully design the "),Rs=i(I,"CODE",{});var Ph=r(Rs);ni=o(Ph,"device_map"),Ph.forEach(s),ii=o(I," yourself, it should be a dictionary with keys being module names of your model and values being a valid device identifier (for instance an integer for the GPUs) or "),Ss=i(I,"CODE",{});var jh=r(Ss);ri=o(jh,'"cpu"'),jh.forEach(s),hi=o(I," for CPU offload, "),Ws=i(I,"CODE",{});var Gh=r(Ws);ci=o(Gh,'"disk"'),Gh.forEach(s),pi=o(I," for disk offload. The keys need to cover the whole model, you can then define your device map as you wish: for instance if your model has two blocks (let\u2019s say "),Hs=i(I,"CODE",{});var xh=r(Hs);di=o(xh,"block1"),xh.forEach(s),fi=o(I," and "),Ns=i(I,"CODE",{});var Uh=r(Ns);mi=o(Uh,"block2"),Uh.forEach(s),ui=o(I,") which each contain three linear layers (let\u2019s say "),Fs=i(I,"CODE",{});var Ah=r(Fs);vi=o(Ah,"linear1"),Ah.forEach(s),wi=o(I,", "),Ys=i(I,"CODE",{});var Ch=r(Ys);_i=o(Ch,"linear2"),Ch.forEach(s),yi=o(I," and "),Js=i(I,"CODE",{});var qh=r(Js);gi=o(qh,"linear3"),qh.forEach(s),$i=o(I,"), a valid device map can be:"),I.forEach(s),yo=p(e),_(lt.$$.fragment,e),go=p(e),qt=i(e,"P",{});var Bh=r(qt);bi=o(Bh,"another one that is valid could be:"),Bh.forEach(s),$o=p(e),_(nt.$$.fragment,e),bo=p(e),Bt=i(e,"P",{});var Ih=r(Bt);ki=o(Ih,"On the other hand, this one is not valid as it does not cover every parameter of the model:"),Ih.forEach(s),ko=p(e),_(it.$$.fragment,e),Eo=p(e),_(Be.$$.fragment,e),Po=p(e),re=i(e,"H2",{class:!0});var So=r(re);Ie=i(So,"A",{id:!0,class:!0,href:!0});var Th=r(Ie);Qs=i(Th,"SPAN",{});var Oh=r(Qs);_(rt.$$.fragment,Oh),Oh.forEach(s),Th.forEach(s),Ei=p(So),Vs=i(So,"SPAN",{});var Dh=r(Vs);Pi=o(Dh,"Limits and further development"),Dh.forEach(s),So.forEach(s),jo=p(e),It=i(e,"P",{});var Mh=r(It);ji=o(Mh,"We are aware of the current limitations in the API:"),Mh.forEach(s),Go=p(e),q=i(e,"UL",{});var W=r(q);Ks=i(W,"LI",{});var zh=r(Ks);Gi=o(zh,"While this could theoretically work on just one CPU with potential disk offload, you need at least one GPU to run this API. This will be fixed in further development."),zh.forEach(s),xi=p(W),X=i(W,"LI",{});var ct=r(X);Xs=i(ct,"CODE",{});var Lh=r(Xs);Ui=o(Lh,"infer_auto_device_map()"),Lh.forEach(s),Ai=o(ct," (or "),Zs=i(ct,"CODE",{});var Rh=r(Zs);Ci=o(Rh,'device_map="auto"'),Rh.forEach(s),qi=o(ct," in "),Tt=i(ct,"A",{href:!0});var Sh=r(Tt);Bi=o(Sh,"load_checkpoint_and_dispatch()"),Sh.forEach(s),Ii=o(ct,") tries to maximize GPU and CPU RAM it sees available when you execute it. While PyTorch is very good at managing GPU RAM efficiently (and giving it back when not needed), it\u2019s not entirely true with Python and CPU RAM. Therefore, an automatically computed device map might be too intense on the CPU. Move a few modules to the disk device if you get crashes due to lack of RAM."),ct.forEach(s),Ti=p(W),Z=i(W,"LI",{});var pt=r(Z);ea=i(pt,"CODE",{});var Wh=r(ea);Oi=o(Wh,"infer_auto_device_map()"),Wh.forEach(s),Di=o(pt," (or "),ta=i(pt,"CODE",{});var Hh=r(ta);Mi=o(Hh,'device_map="auto"'),Hh.forEach(s),zi=o(pt," in "),Ot=i(pt,"A",{href:!0});var Nh=r(Ot);Li=o(Nh,"load_checkpoint_and_dispatch()"),Nh.forEach(s),Ri=o(pt,") attributes devices sequentially (to avoid moving things back and forth) so if your first layer is bigger than the size of the GPU you have, it will end up with everything on the CPU/Disk."),pt.forEach(s),Si=p(W),Te=i(W,"LI",{});var ma=r(Te);Dt=i(ma,"A",{href:!0});var Fh=r(Dt);Wi=o(Fh,"load_checkpoint_and_dispatch()"),Fh.forEach(s),Hi=o(ma," and "),sa=i(ma,"CODE",{});var Yh=r(sa);Ni=o(Yh,"load_checkpoint_in_model()"),Yh.forEach(s),Fi=o(ma," do not perform any check on the correctness of your state dict compared to your model at the moment (this will be fixed in a future version), so you may get some weird errors if trying to load a checkpoint with mismatched or missing keys."),ma.forEach(s),Yi=p(W),aa=i(W,"LI",{});var Jh=r(aa);Ji=o(Jh,"The model parallelism used when your model is split on several GPUs is naive and not optimized, meaning that only one GPU works at a given time and the other sits idle."),Jh.forEach(s),Qi=p(W),oa=i(W,"LI",{});var Qh=r(oa);Vi=o(Qh,"When weights are offloaded on the CPU/hard drive, there is no pre-fetching (yet, we will work on this for future versions) which means the weights are put on the GPU when they are needed and not before."),Qh.forEach(s),Ki=p(W),la=i(W,"LI",{});var Vh=r(la);Xi=o(Vh,"Hard-drive offloading might be very slow if the hardware you run on does not have fast communication between disk and CPU (like NVMes)."),Vh.forEach(s),W.forEach(s),this.h()},h(){m(d,"name","hf:doc:metadata"),m(d,"content",JSON.stringify(uc)),m(u,"id","handling-big-models"),m(u,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(u,"href","#handling-big-models"),m(f,"class","relative group"),m(fe,"id","how-the-process-works-a-quick-overview"),m(fe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(fe,"href","#how-the-process-works-a-quick-overview"),m(ee,"class","relative group"),m(me,"id","how-the-process-works-working-with-code"),m(me,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(me,"href","#how-the-process-works-working-with-code"),m(te,"class","relative group"),m(ue,"id","instantiating-an-empty-model"),m(ue,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(ue,"href","#instantiating-an-empty-model"),m(se,"class","relative group"),m(ut,"href","/docs/accelerate/v0.14.0/en/package_reference/big_modeling#accelerate.init_empty_weights"),m(_e,"id","sharded-checkpoints"),m(_e,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(_e,"href","#sharded-checkpoints"),m(ae,"class","relative group"),m(ye,"id","loading-weights"),m(ye,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(ye,"href","#loading-weights"),m(oe,"class","relative group"),m($t,"href","/docs/accelerate/v0.14.0/en/package_reference/big_modeling#accelerate.load_checkpoint_and_dispatch"),m(Ye,"href","https://huggingface.co/EleutherAI/gpt-j-6B"),m(Ye,"rel","nofollow"),m(Ee,"id","run-the-model"),m(Ee,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(Ee,"href","#run-the-model"),m(ne,"class","relative group"),m(je,"id","designing-a-device-map"),m(je,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(je,"href","#designing-a-device-map"),m(ie,"class","relative group"),m(Ie,"id","limits-and-further-development"),m(Ie,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(Ie,"href","#limits-and-further-development"),m(re,"class","relative group"),m(Tt,"href","/docs/accelerate/v0.14.0/en/package_reference/big_modeling#accelerate.load_checkpoint_and_dispatch"),m(Ot,"href","/docs/accelerate/v0.14.0/en/package_reference/big_modeling#accelerate.load_checkpoint_and_dispatch"),m(Dt,"href","/docs/accelerate/v0.14.0/en/package_reference/big_modeling#accelerate.load_checkpoint_and_dispatch")},m(e,l){t(document.head,d),h(e,v,l),h(e,f,l),t(f,u),t(u,U),y(k,U,null),t(f,E),t(f,C),t(C,z),h(e,F,l),h(e,R,l),t(R,A),h(e,T,l),y(S,e,l),h(e,L,l),h(e,P,l),t(P,ft),h(e,Oe,l),h(e,H,l),t(H,pe),t(pe,Wo),t(H,Ho),t(H,St),t(St,No),t(H,Fo),t(H,Wt),t(Wt,Yo),h(e,ua,l),h(e,mt,l),t(mt,Jo),h(e,va,l),y(de,e,l),h(e,wa,l),h(e,ee,l),t(ee,fe),t(fe,Ht),y(De,Ht,null),t(ee,Qo),t(ee,Nt),t(Nt,Vo),h(e,_a,l),y(Me,e,l),h(e,ya,l),h(e,te,l),t(te,me),t(me,Ft),y(ze,Ft,null),t(te,Ko),t(te,Yt),t(Yt,Xo),h(e,ga,l),h(e,se,l),t(se,ue),t(ue,Jt),y(Le,Jt,null),t(se,Zo),t(se,Qt),t(Qt,el),h(e,$a,l),h(e,ve,l),t(ve,tl),t(ve,ut),t(ut,sl),t(ve,al),h(e,ba,l),y(Re,e,l),h(e,ka,l),h(e,vt,l),t(vt,ol),h(e,Ea,l),y(Se,e,l),h(e,Pa,l),h(e,wt,l),t(wt,ll),h(e,ja,l),y(we,e,l),h(e,Ga,l),h(e,ae,l),t(ae,_e),t(_e,Vt),y(We,Vt,null),t(ae,nl),t(ae,Kt),t(Kt,il),h(e,xa,l),h(e,_t,l),t(_t,rl),h(e,Ua,l),h(e,yt,l),t(yt,hl),h(e,Aa,l),y(He,e,l),h(e,Ca,l),h(e,gt,l),t(gt,cl),h(e,qa,l),y(Ne,e,l),h(e,Ba,l),h(e,O,l),t(O,pl),t(O,Xt),t(Xt,dl),t(O,fl),t(O,Zt),t(Zt,ml),t(O,ul),t(O,es),t(es,vl),t(O,wl),t(O,ts),t(ts,_l),t(O,yl),t(O,ss),t(ss,gl),t(O,$l),t(O,as),t(as,bl),h(e,Ia,l),h(e,oe,l),t(oe,ye),t(ye,os),y(Fe,os,null),t(oe,kl),t(oe,ls),t(ls,El),h(e,Ta,l),h(e,ge,l),t(ge,Pl),t(ge,$t),t($t,jl),t(ge,Gl),h(e,Oa,l),h(e,$e,l),t($e,xl),t($e,Ye),t(Ye,Ul),t($e,Al),h(e,Da,l),y(Je,e,l),h(e,Ma,l),h(e,bt,l),t(bt,Cl),h(e,za,l),y(Qe,e,l),h(e,La,l),h(e,kt,l),t(kt,ql),h(e,Ra,l),y(Ve,e,l),h(e,Sa,l),h(e,be,l),t(be,Bl),t(be,ns),t(ns,Il),t(be,Tl),h(e,Wa,l),h(e,J,l),t(J,is),t(is,Ol),t(J,Dl),t(J,rs),t(rs,Ml),t(J,zl),t(J,hs),t(hs,Ll),h(e,Ha,l),h(e,le,l),t(le,cs),t(cs,Rl),t(le,Sl),t(le,ps),t(ps,Wl),t(le,Hl),h(e,Na,l),h(e,Q,l),t(Q,Nl),t(Q,ds),t(ds,Fl),t(Q,Yl),t(Q,fs),t(fs,Jl),t(Q,Ql),h(e,Fa,l),y(Ke,e,l),h(e,Ya,l),y(Xe,e,l),h(e,Ja,l),h(e,ke,l),t(ke,Vl),t(ke,ms),t(ms,Kl),t(ke,Xl),h(e,Qa,l),y(Ze,e,l),h(e,Va,l),h(e,ne,l),t(ne,Ee),t(Ee,us),y(et,us,null),t(ne,Zl),t(ne,vs),t(vs,en),h(e,Ka,l),h(e,Et,l),t(Et,tn),h(e,Xa,l),y(tt,e,l),h(e,Za,l),h(e,Pt,l),t(Pt,sn),h(e,eo,l),h(e,V,l),t(V,ws),t(ws,an),t(V,on),t(V,_s),t(_s,ln),t(V,nn),t(V,ys),t(ys,rn),h(e,to,l),h(e,jt,l),t(jt,hn),h(e,so,l),y(Pe,e,l),h(e,ao,l),h(e,ie,l),t(ie,je),t(je,gs),y(st,gs,null),t(ie,cn),t(ie,$s),t($s,pn),h(e,oo,l),h(e,M,l),t(M,dn),t(M,bs),t(bs,fn),t(M,mn),t(M,ks),t(ks,un),t(M,vn),t(M,Es),t(Es,wn),t(M,_n),t(M,Ps),t(Ps,yn),t(M,gn),t(M,js),t(js,$n),t(M,bn),h(e,lo,l),y(Ge,e,l),h(e,no,l),h(e,Gt,l),t(Gt,kn),h(e,io,l),h(e,xt,l),t(xt,En),h(e,ro,l),h(e,K,l),t(K,xe),t(xe,Gs),t(Gs,Pn),t(xe,jn),t(xe,xs),t(xs,Gn),t(xe,xn),t(K,Un),t(K,Ue),t(Ue,Us),t(Us,An),t(Ue,Cn),t(Ue,As),t(As,qn),t(Ue,Bn),t(K,In),t(K,Ut),t(Ut,Cs),t(Cs,Tn),t(Ut,On),h(e,ho,l),y(Ae,e,l),h(e,co,l),h(e,j,l),t(j,Dn),t(j,qs),t(qs,Mn),t(j,zn),t(j,Bs),t(Bs,Ln),t(j,Rn),t(j,Is),t(Is,Sn),t(j,Wn),t(j,Ts),t(Ts,Hn),t(j,Nn),t(j,Os),t(Os,Fn),t(j,Yn),t(j,Ds),t(Ds,Jn),t(j,Qn),t(j,Ms),t(Ms,Vn),t(j,Kn),t(j,zs),t(zs,Xn),t(j,Zn),h(e,po,l),h(e,At,l),t(At,ei),h(e,fo,l),y(at,e,l),h(e,mo,l),y(Ce,e,l),h(e,uo,l),h(e,qe,l),t(qe,ti),t(qe,Ls),t(Ls,si),t(qe,ai),h(e,vo,l),y(ot,e,l),h(e,wo,l),h(e,Ct,l),t(Ct,oi),h(e,_o,l),h(e,G,l),t(G,li),t(G,Rs),t(Rs,ni),t(G,ii),t(G,Ss),t(Ss,ri),t(G,hi),t(G,Ws),t(Ws,ci),t(G,pi),t(G,Hs),t(Hs,di),t(G,fi),t(G,Ns),t(Ns,mi),t(G,ui),t(G,Fs),t(Fs,vi),t(G,wi),t(G,Ys),t(Ys,_i),t(G,yi),t(G,Js),t(Js,gi),t(G,$i),h(e,yo,l),y(lt,e,l),h(e,go,l),h(e,qt,l),t(qt,bi),h(e,$o,l),y(nt,e,l),h(e,bo,l),h(e,Bt,l),t(Bt,ki),h(e,ko,l),y(it,e,l),h(e,Eo,l),y(Be,e,l),h(e,Po,l),h(e,re,l),t(re,Ie),t(Ie,Qs),y(rt,Qs,null),t(re,Ei),t(re,Vs),t(Vs,Pi),h(e,jo,l),h(e,It,l),t(It,ji),h(e,Go,l),h(e,q,l),t(q,Ks),t(Ks,Gi),t(q,xi),t(q,X),t(X,Xs),t(Xs,Ui),t(X,Ai),t(X,Zs),t(Zs,Ci),t(X,qi),t(X,Tt),t(Tt,Bi),t(X,Ii),t(q,Ti),t(q,Z),t(Z,ea),t(ea,Oi),t(Z,Di),t(Z,ta),t(ta,Mi),t(Z,zi),t(Z,Ot),t(Ot,Li),t(Z,Ri),t(q,Si),t(q,Te),t(Te,Dt),t(Dt,Wi),t(Te,Hi),t(Te,sa),t(sa,Ni),t(Te,Fi),t(q,Yi),t(q,aa),t(aa,Ji),t(q,Qi),t(q,oa),t(oa,Vi),t(q,Ki),t(q,la),t(la,Xi),xo=!0},p(e,[l]){const ht={};l&2&&(ht.$$scope={dirty:l,ctx:e}),de.$set(ht);const na={};l&2&&(na.$$scope={dirty:l,ctx:e}),we.$set(na);const ia={};l&2&&(ia.$$scope={dirty:l,ctx:e}),Pe.$set(ia);const ra={};l&2&&(ra.$$scope={dirty:l,ctx:e}),Ge.$set(ra);const ha={};l&2&&(ha.$$scope={dirty:l,ctx:e}),Ae.$set(ha);const ca={};l&2&&(ca.$$scope={dirty:l,ctx:e}),Ce.$set(ca);const he={};l&2&&(he.$$scope={dirty:l,ctx:e}),Be.$set(he)},i(e){xo||(g(k.$$.fragment,e),g(S.$$.fragment,e),g(de.$$.fragment,e),g(De.$$.fragment,e),g(Me.$$.fragment,e),g(ze.$$.fragment,e),g(Le.$$.fragment,e),g(Re.$$.fragment,e),g(Se.$$.fragment,e),g(we.$$.fragment,e),g(We.$$.fragment,e),g(He.$$.fragment,e),g(Ne.$$.fragment,e),g(Fe.$$.fragment,e),g(Je.$$.fragment,e),g(Qe.$$.fragment,e),g(Ve.$$.fragment,e),g(Ke.$$.fragment,e),g(Xe.$$.fragment,e),g(Ze.$$.fragment,e),g(et.$$.fragment,e),g(tt.$$.fragment,e),g(Pe.$$.fragment,e),g(st.$$.fragment,e),g(Ge.$$.fragment,e),g(Ae.$$.fragment,e),g(at.$$.fragment,e),g(Ce.$$.fragment,e),g(ot.$$.fragment,e),g(lt.$$.fragment,e),g(nt.$$.fragment,e),g(it.$$.fragment,e),g(Be.$$.fragment,e),g(rt.$$.fragment,e),xo=!0)},o(e){$(k.$$.fragment,e),$(S.$$.fragment,e),$(de.$$.fragment,e),$(De.$$.fragment,e),$(Me.$$.fragment,e),$(ze.$$.fragment,e),$(Le.$$.fragment,e),$(Re.$$.fragment,e),$(Se.$$.fragment,e),$(we.$$.fragment,e),$(We.$$.fragment,e),$(He.$$.fragment,e),$(Ne.$$.fragment,e),$(Fe.$$.fragment,e),$(Je.$$.fragment,e),$(Qe.$$.fragment,e),$(Ve.$$.fragment,e),$(Ke.$$.fragment,e),$(Xe.$$.fragment,e),$(Ze.$$.fragment,e),$(et.$$.fragment,e),$(tt.$$.fragment,e),$(Pe.$$.fragment,e),$(st.$$.fragment,e),$(Ge.$$.fragment,e),$(Ae.$$.fragment,e),$(at.$$.fragment,e),$(Ce.$$.fragment,e),$(ot.$$.fragment,e),$(lt.$$.fragment,e),$(nt.$$.fragment,e),$(it.$$.fragment,e),$(Be.$$.fragment,e),$(rt.$$.fragment,e),xo=!1},d(e){s(d),e&&s(v),e&&s(f),b(k),e&&s(F),e&&s(R),e&&s(T),b(S,e),e&&s(L),e&&s(P),e&&s(Oe),e&&s(H),e&&s(ua),e&&s(mt),e&&s(va),b(de,e),e&&s(wa),e&&s(ee),b(De),e&&s(_a),b(Me,e),e&&s(ya),e&&s(te),b(ze),e&&s(ga),e&&s(se),b(Le),e&&s($a),e&&s(ve),e&&s(ba),b(Re,e),e&&s(ka),e&&s(vt),e&&s(Ea),b(Se,e),e&&s(Pa),e&&s(wt),e&&s(ja),b(we,e),e&&s(Ga),e&&s(ae),b(We),e&&s(xa),e&&s(_t),e&&s(Ua),e&&s(yt),e&&s(Aa),b(He,e),e&&s(Ca),e&&s(gt),e&&s(qa),b(Ne,e),e&&s(Ba),e&&s(O),e&&s(Ia),e&&s(oe),b(Fe),e&&s(Ta),e&&s(ge),e&&s(Oa),e&&s($e),e&&s(Da),b(Je,e),e&&s(Ma),e&&s(bt),e&&s(za),b(Qe,e),e&&s(La),e&&s(kt),e&&s(Ra),b(Ve,e),e&&s(Sa),e&&s(be),e&&s(Wa),e&&s(J),e&&s(Ha),e&&s(le),e&&s(Na),e&&s(Q),e&&s(Fa),b(Ke,e),e&&s(Ya),b(Xe,e),e&&s(Ja),e&&s(ke),e&&s(Qa),b(Ze,e),e&&s(Va),e&&s(ne),b(et),e&&s(Ka),e&&s(Et),e&&s(Xa),b(tt,e),e&&s(Za),e&&s(Pt),e&&s(eo),e&&s(V),e&&s(to),e&&s(jt),e&&s(so),b(Pe,e),e&&s(ao),e&&s(ie),b(st),e&&s(oo),e&&s(M),e&&s(lo),b(Ge,e),e&&s(no),e&&s(Gt),e&&s(io),e&&s(xt),e&&s(ro),e&&s(K),e&&s(ho),b(Ae,e),e&&s(co),e&&s(j),e&&s(po),e&&s(At),e&&s(fo),b(at,e),e&&s(mo),b(Ce,e),e&&s(uo),e&&s(qe),e&&s(vo),b(ot,e),e&&s(wo),e&&s(Ct),e&&s(_o),e&&s(G),e&&s(yo),b(lt,e),e&&s(go),e&&s(qt),e&&s($o),b(nt,e),e&&s(bo),e&&s(Bt),e&&s(ko),b(it,e),e&&s(Eo),b(Be,e),e&&s(Po),e&&s(re),b(rt),e&&s(jo),e&&s(It),e&&s(Go),e&&s(q)}}}const uc={local:"handling-big-models",sections:[{local:"how-the-process-works-a-quick-overview",title:"How the Process Works: A Quick Overview"},{local:"how-the-process-works-working-with-code",sections:[{local:"instantiating-an-empty-model",title:"Instantiating an empty model"},{local:"sharded-checkpoints",title:"Sharded checkpoints"},{local:"loading-weights",title:"Loading weights"}],title:"How the Process Works: Working with Code"}],title:"Handling big models"};function vc(x){return ac(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class $c extends Zh{constructor(d){super();ec(this,d,vc,mc,tc,{})}}export{$c as default,uc as metadata};
