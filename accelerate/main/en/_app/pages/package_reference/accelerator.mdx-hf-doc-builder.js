import{S as O_,i as N_,s as C_,e as a,k as l,w as $,t as s,M as q_,c as o,d as r,m as i,a as n,x as b,h as c,b as d,G as e,g as u,y,q as w,o as E,B as A,v as U_,L as Ls}from"../../chunks/vendor-hf-doc-builder.js";import{T as Kt}from"../../chunks/Tip-hf-doc-builder.js";import{D as P}from"../../chunks/Docstring-hf-doc-builder.js";import{C as L}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as C}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{E as Is}from"../../chunks/ExampleCodeBlock-hf-doc-builder.js";function V_(D){let h,x;return{c(){h=a("p"),x=s("Step three is optional, but considered a best practice.")},l(v){h=o(v,"P",{});var g=n(h);x=c(g,"Step three is optional, but considered a best practice."),g.forEach(r)},m(v,g){u(v,h,g),e(h,x)},d(v){v&&r(h)}}}function M_(D){let h,x;return{c(){h=a("p"),x=s("Step five is mandatory when using distributed evaluation")},l(v){h=o(v,"P",{});var g=n(h);x=c(g,"Step five is mandatory when using distributed evaluation"),g.forEach(r)},m(v,g){u(v,h,g),e(h,x)},d(v){v&&r(h)}}}function G_(D){let h,x,v,g,j;return g=new L({props:{code:`from accelerate import Accelerator

accelerator = Accelerator(gradient_accumulation_steps=2)
dataloader, model, optimizer, scheduler = accelerator.prepare(dataloader, model, optimizer, scheduler)

with accelerator.accumulate():
    for input, output in dataloader:
        outputs = model(input)
        loss = loss_func(outputs)
        loss.backward()
        optimizer.step()
        scheduler.step()
        optimizer.zero_grad()`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerator

<span class="hljs-meta">&gt;&gt;&gt; </span>accelerator = Accelerator(gradient_accumulation_steps=<span class="hljs-number">2</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>dataloader, model, optimizer, scheduler = accelerator.prepare(dataloader, model, optimizer, scheduler)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> accelerator.accumulate():
<span class="hljs-meta">... </span>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">input</span>, output <span class="hljs-keyword">in</span> dataloader:
<span class="hljs-meta">... </span>        outputs = model(<span class="hljs-built_in">input</span>)
<span class="hljs-meta">... </span>        loss = loss_func(outputs)
<span class="hljs-meta">... </span>        loss.backward()
<span class="hljs-meta">... </span>        optimizer.step()
<span class="hljs-meta">... </span>        scheduler.step()
<span class="hljs-meta">... </span>        optimizer.zero_grad()`}}),{c(){h=a("p"),x=s("Example:"),v=l(),$(g.$$.fragment)},l(m){h=o(m,"P",{});var k=n(h);x=c(k,"Example:"),k.forEach(r),v=i(m),b(g.$$.fragment,m)},m(m,k){u(m,h,k),e(h,x),u(m,v,k),y(g,m,k),j=!0},p:Ls,i(m){j||(w(g.$$.fragment,m),j=!0)},o(m){E(g.$$.fragment,m),j=!1},d(m){m&&r(h),m&&r(v),A(g,m)}}}function R_(D){let h,x,v,g,j;return g=new L({props:{code:`from accelerate import Accelerator

accelerator = Accelerator(gradient_accumulation_steps=2)
dataloader, model, optimizer, scheduler = accelerator.prepare(dataloader, model, optimizer, scheduler)

for (input, target) in dataloader:
    optimizer.zero_grad()
    output = model(input)
    loss = loss_func(output, target)
    accelerator.backward(loss)
    if accelerator.sync_gradients:
        accelerator.clip_grad_norm_(model.parameters(), max_grad_norm)
    optimizer.step()`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerator

<span class="hljs-meta">&gt;&gt;&gt; </span>accelerator = Accelerator(gradient_accumulation_steps=<span class="hljs-number">2</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>dataloader, model, optimizer, scheduler = accelerator.prepare(dataloader, model, optimizer, scheduler)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> (<span class="hljs-built_in">input</span>, target) <span class="hljs-keyword">in</span> dataloader:
<span class="hljs-meta">... </span>    optimizer.zero_grad()
<span class="hljs-meta">... </span>    output = model(<span class="hljs-built_in">input</span>)
<span class="hljs-meta">... </span>    loss = loss_func(output, target)
<span class="hljs-meta">... </span>    accelerator.backward(loss)
<span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> accelerator.sync_gradients:
<span class="hljs-meta">... </span>        accelerator.clip_grad_norm_(model.parameters(), max_grad_norm)
<span class="hljs-meta">... </span>    optimizer.step()`}}),{c(){h=a("p"),x=s("Example:"),v=l(),$(g.$$.fragment)},l(m){h=o(m,"P",{});var k=n(h);x=c(k,"Example:"),k.forEach(r),v=i(m),b(g.$$.fragment,m)},m(m,k){u(m,h,k),e(h,x),u(m,v,k),y(g,m,k),j=!0},p:Ls,i(m){j||(w(g.$$.fragment,m),j=!0)},o(m){E(g.$$.fragment,m),j=!1},d(m){m&&r(h),m&&r(v),A(g,m)}}}function W_(D){let h,x,v,g,j;return g=new L({props:{code:`from accelerate import Accelerator

accelerator = Accelerator(gradient_accumulation_steps=2)
dataloader, model, optimizer, scheduler = accelerator.prepare(dataloader, model, optimizer, scheduler)

for (input, target) in dataloader:
    optimizer.zero_grad()
    output = model(input)
    loss = loss_func(output, target)
    accelerator.backward(loss)
    if accelerator.sync_gradients:
        accelerator.clip_grad_value_(model.parameters(), clip_value)
    optimizer.step()`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerator

<span class="hljs-meta">&gt;&gt;&gt; </span>accelerator = Accelerator(gradient_accumulation_steps=<span class="hljs-number">2</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>dataloader, model, optimizer, scheduler = accelerator.prepare(dataloader, model, optimizer, scheduler)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> (<span class="hljs-built_in">input</span>, target) <span class="hljs-keyword">in</span> dataloader:
<span class="hljs-meta">... </span>    optimizer.zero_grad()
<span class="hljs-meta">... </span>    output = model(<span class="hljs-built_in">input</span>)
<span class="hljs-meta">... </span>    loss = loss_func(output, target)
<span class="hljs-meta">... </span>    accelerator.backward(loss)
<span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> accelerator.sync_gradients:
<span class="hljs-meta">... </span>        accelerator.clip_grad_value_(model.parameters(), clip_value)
<span class="hljs-meta">... </span>    optimizer.step()`}}),{c(){h=a("p"),x=s("Example:"),v=l(),$(g.$$.fragment)},l(m){h=o(m,"P",{});var k=n(h);x=c(k,"Example:"),k.forEach(r),v=i(m),b(g.$$.fragment,m)},m(m,k){u(m,h,k),e(h,x),u(m,v,k),y(g,m,k),j=!0},p:Ls,i(m){j||(w(g.$$.fragment,m),j=!0)},o(m){E(g.$$.fragment,m),j=!1},d(m){m&&r(h),m&&r(v),A(g,m)}}}function F_(D){let h,x,v,g;return{c(){h=a("p"),x=a("code"),v=s("join_uneven_inputs"),g=s(` is only supported for Distributed Data Parallel training on multiple GPUs. For any other
configuration, this method will have no effect.`)},l(j){h=o(j,"P",{});var m=n(h);x=o(m,"CODE",{});var k=n(x);v=c(k,"join_uneven_inputs"),k.forEach(r),g=c(m,` is only supported for Distributed Data Parallel training on multiple GPUs. For any other
configuration, this method will have no effect.`),m.forEach(r)},m(j,m){u(j,h,m),e(h,x),e(x,v),e(h,g)},d(j){j&&r(h)}}}function H_(D){let h,x,v,g,j;return{c(){h=a("p"),x=s("Overidding "),v=a("code"),g=s("even_batches"),j=s(" will not affect iterable-style data loaders.")},l(m){h=o(m,"P",{});var k=n(h);x=c(k,"Overidding "),v=o(k,"CODE",{});var I=n(v);g=c(I,"even_batches"),I.forEach(r),j=c(k," will not affect iterable-style data loaders."),k.forEach(r)},m(m,k){u(m,h,k),e(h,x),e(h,v),e(v,g),e(h,j)},d(m){m&&r(h)}}}function Y_(D){let h,x,v,g,j;return g=new L({props:{code:`from accelerate import Accelerator

accelerator = Accelerator(even_batches=True)
ddp_model, optimizer, dataloader = accelerator.prepare(model, optimizer, dataloader)

with accelerator.join_uneven_inputs([ddp_model], even_batches=False):
    for input, output in dataloader:
        outputs = model(input)
        loss = loss_func(outputs)
        loss.backward()
        optimizer.step()
        optimizer.zero_grad()`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerator

<span class="hljs-meta">&gt;&gt;&gt; </span>accelerator = Accelerator(even_batches=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>ddp_model, optimizer, dataloader = accelerator.prepare(model, optimizer, dataloader)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> accelerator.join_uneven_inputs([ddp_model], even_batches=<span class="hljs-literal">False</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">input</span>, output <span class="hljs-keyword">in</span> dataloader:
<span class="hljs-meta">... </span>        outputs = model(<span class="hljs-built_in">input</span>)
<span class="hljs-meta">... </span>        loss = loss_func(outputs)
<span class="hljs-meta">... </span>        loss.backward()
<span class="hljs-meta">... </span>        optimizer.step()
<span class="hljs-meta">... </span>        optimizer.zero_grad()`}}),{c(){h=a("p"),x=s("Example:"),v=l(),$(g.$$.fragment)},l(m){h=o(m,"P",{});var k=n(h);x=c(k,"Example:"),k.forEach(r),v=i(m),b(g.$$.fragment,m)},m(m,k){u(m,h,k),e(h,x),u(m,v,k),y(g,m,k),j=!0},p:Ls,i(m){j||(w(g.$$.fragment,m),j=!0)},o(m){E(g.$$.fragment,m),j=!1},d(m){m&&r(h),m&&r(v),A(g,m)}}}function B_(D){let h,x,v,g,j;return{c(){h=a("p"),x=s("Should only be used in conjunction with "),v=a("a"),g=s("Accelerator.save_state()"),j=s("."),this.h()},l(m){h=o(m,"P",{});var k=n(h);x=c(k,"Should only be used in conjunction with "),v=o(k,"A",{href:!0});var I=n(v);g=c(I,"Accelerator.save_state()"),I.forEach(r),j=c(k,"."),k.forEach(r),this.h()},h(){d(v,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.save_state")},m(m,k){u(m,h,k),e(h,x),e(h,v),e(v,g),e(h,j)},d(m){m&&r(h)}}}function J_(D){let h,x,v,g,j;return g=new L({props:{code:`from accelerate import Accelerator

accelerator = Accelerator()
dataloader, model, optimizer = accelerator.prepare(dataloader, model, optimizer)
input_a = next(iter(dataloader))
input_b = next(iter(dataloader))

with accelerator.no_sync():
    outputs = model(input_a)
    loss = loss_func(outputs)
    accelerator.backward(loss)
    # No synchronization across processes, only accumulate gradients
outputs = model(input_b)
accelerator.backward(loss)
# Synchronization across all processes
optimizer.step()
optimizer.zero_grad()`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerator

<span class="hljs-meta">&gt;&gt;&gt; </span>accelerator = Accelerator()
<span class="hljs-meta">&gt;&gt;&gt; </span>dataloader, model, optimizer = accelerator.prepare(dataloader, model, optimizer)
<span class="hljs-meta">&gt;&gt;&gt; </span>input_a = <span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(dataloader))
<span class="hljs-meta">&gt;&gt;&gt; </span>input_b = <span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(dataloader))

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> accelerator.no_sync():
<span class="hljs-meta">... </span>    outputs = model(input_a)
<span class="hljs-meta">... </span>    loss = loss_func(outputs)
<span class="hljs-meta">... </span>    accelerator.backward(loss)
<span class="hljs-meta">... </span>    <span class="hljs-comment"># No synchronization across processes, only accumulate gradients</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(input_b)
<span class="hljs-meta">&gt;&gt;&gt; </span>accelerator.backward(loss)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Synchronization across all processes</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>optimizer.step()
<span class="hljs-meta">&gt;&gt;&gt; </span>optimizer.zero_grad()`}}),{c(){h=a("p"),x=s("Example:"),v=l(),$(g.$$.fragment)},l(m){h=o(m,"P",{});var k=n(h);x=c(k,"Example:"),k.forEach(r),v=i(m),b(g.$$.fragment,m)},m(m,k){u(m,h,k),e(h,x),u(m,v,k),y(g,m,k),j=!0},p:Ls,i(m){j||(w(g.$$.fragment,m),j=!0)},o(m){E(g.$$.fragment,m),j=!1},d(m){m&&r(h),m&&r(v),A(g,m)}}}function K_(D){let h,x;return{c(){h=a("p"),x=s("You don\u2019t need to prepare a model if you only use it for inference without any kind of mixed precision")},l(v){h=o(v,"P",{});var g=n(h);x=c(g,"You don\u2019t need to prepare a model if you only use it for inference without any kind of mixed precision"),g.forEach(r)},m(v,g){u(v,h,g),e(h,x)},d(v){v&&r(h)}}}function Q_(D){let h,x,v,g,j,m,k,I,oe,Pe,q;return{c(){h=a("p"),x=s("Every "),v=a("code"),g=s("object"),j=s(" must have a "),m=a("code"),k=s("load_state_dict"),I=s(" and "),oe=a("code"),Pe=s("state_dict"),q=s(" function to be stored.")},l(ne){h=o(ne,"P",{});var S=n(h);x=c(S,"Every "),v=o(S,"CODE",{});var ja=n(v);g=c(ja,"object"),ja.forEach(r),j=c(S," must have a "),m=o(S,"CODE",{});var Pa=n(m);k=c(Pa,"load_state_dict"),Pa.forEach(r),I=c(S," and "),oe=o(S,"CODE",{});var Qt=n(oe);Pe=c(Qt,"state_dict"),Qt.forEach(r),q=c(S," function to be stored."),S.forEach(r)},m(ne,S){u(ne,h,S),e(h,x),e(h,v),e(v,g),e(h,j),e(h,m),e(m,k),e(h,I),e(h,oe),e(oe,Pe),e(h,q)},d(ne){ne&&r(h)}}}function X_(D){let h,x;return{c(){h=a("p"),x=s(`Should only be used when wanting to save a checkpoint during training and restoring the state in the same
environment.`)},l(v){h=o(v,"P",{});var g=n(h);x=c(g,`Should only be used when wanting to save a checkpoint during training and restoring the state in the same
environment.`),g.forEach(r)},m(v,g){u(v,h,g),e(h,x)},d(v){v&&r(h)}}}function Z_(D){let h,x,v,g,j,m,k,I,oe,Pe,q,ne,S,ja,Pa,Qt,se,De,mo,Xt,Sl,uo,Il,Os,Da,Ll,Ns,W,ce,Ol,Ta,Nl,Cl,fo,ql,Ul,Vl,Zt,Ml,za,Gl,Rl,Wl,M,Fl,go,Hl,Yl,_o,Bl,Jl,vo,Kl,Ql,Cs,Te,qs,le,ze,Xl,$o,Zl,ei,bo,ti,ri,Sa,ai,Ia,oi,Us,Se,Vs,Ie,ni,yo,si,ci,Ms,ie,Le,wo,er,li,Eo,ii,Gs,de,Oe,Ao,tr,di,ko,pi,Rs,pe,xo,hi,mi,La,ui,fi,Ws,rr,Fs,he,Ne,jo,ar,gi,Po,_i,Hs,me,Ce,Do,or,vi,To,$i,Ys,qe,bi,zo,yi,wi,Bs,nr,Js,Ue,Ei,Oa,Ai,ki,Ks,sr,Qs,ue,Ve,So,cr,xi,Io,ji,Xs,Me,Pi,Lo,Di,Ti,Zs,lr,ec,Ge,zi,Na,Si,Ii,tc,ir,rc,fe,Re,Oo,dr,Li,No,Oi,ac,Ca,Ni,oc,pr,nc,hr,sc,ge,We,Co,mr,Ci,qo,qi,cc,Fe,Ui,qa,Vi,Mi,lc,_e,He,Uo,ur,Gi,Vo,Ri,ic,Ye,Wi,Ua,Fi,Hi,dc,fr,pc,F,Yi,Va,Bi,Ji,Mo,Ki,Qi,hc,gr,mc,ve,Be,Go,_r,Xi,Ro,Zi,uc,N,ed,Je,td,Wo,rd,ad,od,Fo,nd,sd,Ke,cd,Ho,ld,id,dd,Yo,pd,fc,$e,Qe,Bo,vr,hd,Jo,md,gc,Xe,ud,Ma,fd,gd,_c,$r,vc,be,Ze,Ko,br,_d,Qo,vd,$c,f,yr,$d,Xo,bd,yd,Zo,en,wd,Ed,T,et,tn,Ad,kd,rn,xd,jd,Pd,tt,an,Dd,Td,Ga,zd,Sd,Id,rt,on,Ld,Od,nn,Nd,Cd,qd,at,sn,Ud,Vd,cn,Md,Gd,Rd,ot,ln,Wd,Fd,dn,Hd,Yd,Bd,nt,pn,Jd,Kd,hn,Qd,Xd,Zd,st,mn,ep,tp,un,rp,ap,op,ct,fn,np,sp,Ra,cp,lp,ip,lt,gn,dp,pp,_n,hp,mp,up,it,vn,fp,gp,$n,_p,vp,$p,H,wr,bp,bn,yp,wp,dt,Ep,pt,Er,Ap,yn,kp,xp,Y,Ar,jp,ye,Pp,wn,Dp,Tp,En,zp,Sp,Ip,kr,Lp,An,Op,Np,Cp,ht,xr,qp,jr,Up,kn,Vp,Mp,Gp,B,Pr,Rp,Dr,Wp,xn,Fp,Hp,Yp,mt,Bp,J,Tr,Jp,zr,Kp,jn,Qp,Xp,Zp,ut,eh,ft,Sr,th,Pn,rh,ah,gt,Ir,oh,Dn,nh,sh,K,Lr,ch,Or,lh,Tn,ih,dh,ph,zn,hh,mh,_t,Nr,uh,Cr,fh,Sn,gh,_h,vh,vt,qr,$h,Ur,bh,Wa,yh,wh,Eh,$t,Vr,Ah,G,kh,In,xh,jh,Ln,Ph,Dh,On,Th,zh,Sh,bt,Mr,Ih,Gr,Lh,Nn,Oh,Nh,Ch,O,Rr,qh,Wr,Uh,Cn,Vh,Mh,Gh,yt,Rh,wt,Wh,Et,Fh,Q,Fr,Hh,qn,Yh,Bh,At,Jh,X,Hr,Kh,Un,Qh,Xh,Vn,Zh,em,kt,Yr,tm,we,rm,Mn,am,om,Gn,nm,sm,cm,Z,Br,lm,Rn,im,dm,Wn,pm,hm,U,Jr,mm,Kr,um,Fn,fm,gm,_m,Qr,vm,Hn,$m,bm,ym,xt,wm,jt,Xr,Em,Yn,Am,km,Pt,Zr,xm,Bn,jm,Pm,Dt,ea,Dm,Jn,Tm,zm,Tt,ta,Sm,Kn,Im,Lm,zt,ra,Om,Qn,Nm,Cm,St,aa,qm,Xn,Um,Vm,ee,oa,Mm,na,Gm,Zn,Rm,Wm,Fm,It,Hm,Lt,sa,Ym,ca,Bm,Fa,Jm,Km,Qm,Ot,la,Xm,ia,Zm,Ha,eu,tu,ru,Nt,da,au,pa,ou,Ya,nu,su,cu,Ct,ha,lu,ma,iu,Ba,du,pu,hu,qt,ua,mu,fa,uu,es,fu,gu,_u,te,ga,vu,Ee,$u,ts,bu,yu,rs,wu,Eu,Au,as,ku,xu,V,_a,ju,R,Pu,os,Du,Tu,ns,zu,Su,ss,Iu,Lu,Ou,cs,Nu,Cu,Ut,qu,Vt,va,Uu,$a,Vu,ls,Mu,Gu,Ru,re,ba,Wu,is,Fu,Hu,Mt,Yu,Gt,ya,Bu,ds,Ju,Ku,Rt,wa,Qu,Ae,Xu,ps,Zu,ef,Ja,tf,rf,af,Wt,Ea,of,hs,nf,bc;return m=new C({}),Xt=new C({}),Te=new Kt({props:{$$slots:{default:[V_]},$$scope:{ctx:D}}}),Se=new Kt({props:{warning:!0,$$slots:{default:[M_]},$$scope:{ctx:D}}}),er=new C({}),tr=new C({}),rr=new L({props:{code:`- print("My thing I want to print!")
+ accelerator.print("My thing I want to print!")`,highlighted:`<span class="hljs-deletion">- print(&quot;My thing I want to print!&quot;)</span>
<span class="hljs-addition">+ accelerator.print(&quot;My thing I want to print!&quot;)</span>`}}),ar=new C({}),or=new C({}),nr=new L({props:{code:`if accelerator.is_local_main_process:
    do_thing_once_per_server()`,highlighted:`<span class="hljs-keyword">if</span> accelerator.is_local_main_process:
    do_thing_once_per_server()`}}),sr=new L({props:{code:`@accelerator.on_local_main_process
def do_my_thing():
    "Something done once per server"
    do_thing_once_per_server()`,highlighted:`<span class="hljs-meta">@accelerator.on_local_main_process</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">do_my_thing</span>():
    <span class="hljs-string">&quot;Something done once per server&quot;</span>
    do_thing_once_per_server()`}}),cr=new C({}),lr=new L({props:{code:`if accelerator.is_main_process:
    do_thing_once()`,highlighted:`<span class="hljs-keyword">if</span> accelerator.is_main_process:
    do_thing_once()`}}),ir=new L({props:{code:`@accelerator.on_main_process
def do_my_thing():
    "Something done once per server"
    do_thing_once()`,highlighted:`<span class="hljs-meta">@accelerator.on_main_process</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">do_my_thing</span>():
    <span class="hljs-string">&quot;Something done once per server&quot;</span>
    do_thing_once()`}}),dr=new C({}),pr=new L({props:{code:`@accelerator.on_local_process(local_process_idx=0)
def do_my_thing():
    "Something done on process index 0 on each server"
    do_thing_on_index_zero_on_each_server()`,highlighted:`<span class="hljs-meta">@accelerator.on_local_process(<span class="hljs-params">local_process_idx=<span class="hljs-number">0</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">do_my_thing</span>():
    <span class="hljs-string">&quot;Something done on process index 0 on each server&quot;</span>
    do_thing_on_index_zero_on_each_server()`}}),hr=new L({props:{code:`@accelerator.on_process(process_index=0)
def do_my_thing():
    "Something done on process index 0"
    do_thing_on_index_zero()`,highlighted:`<span class="hljs-meta">@accelerator.on_process(<span class="hljs-params">process_index=<span class="hljs-number">0</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">do_my_thing</span>():
    <span class="hljs-string">&quot;Something done on process index 0&quot;</span>
    do_thing_on_index_zero()`}}),mr=new C({}),ur=new C({}),fr=new L({props:{code:`model = MyModel()
model = accelerator.prepare(model)
# Unwrap
model = accelerator.unwrap_model(model)`,highlighted:`model = MyModel()
model = accelerator.prepare(model)
<span class="hljs-comment"># Unwrap</span>
model = accelerator.unwrap_model(model)`}}),gr=new L({props:{code:`  state_dict = model.state_dict()
- torch.save(state_dict, "my_state.pkl")
+ accelerator.save(state_dict, "my_state.pkl")`,highlighted:`  state_dict = model.state_dict()
<span class="hljs-deletion">- torch.save(state_dict, &quot;my_state.pkl&quot;)</span>
<span class="hljs-addition">+ accelerator.save(state_dict, &quot;my_state.pkl&quot;)</span>`}}),_r=new C({}),vr=new C({}),$r=new L({props:{code:`- accelerator = Accelerator()
+ accelerator = Accelerator(gradient_accumulation_steps=2)

  for (input, label) in training_dataloader:
+     with accelerator.accumulate(model):
          predictions = model(input)
          loss = loss_function(predictions, labels)
          accelerator.backward(loss)
          optimizer.step()
          scheduler.step()
          optimizer.zero_grad()`,highlighted:`<span class="hljs-deletion">- accelerator = Accelerator()</span>
<span class="hljs-addition">+ accelerator = Accelerator(gradient_accumulation_steps=2)</span>

  for (input, label) in training_dataloader:
<span class="hljs-addition">+     with accelerator.accumulate(model):</span>
          predictions = model(input)
          loss = loss_function(predictions, labels)
          accelerator.backward(loss)
          optimizer.step()
          scheduler.step()
          optimizer.zero_grad()`}}),br=new C({}),yr=new P({props:{name:"class accelerate.Accelerator",anchor:"accelerate.Accelerator",parameters:[{name:"device_placement",val:": bool = True"},{name:"split_batches",val:": bool = False"},{name:"fp16",val:": bool = None"},{name:"mixed_precision",val:": typing.Union[accelerate.utils.dataclasses.PrecisionType, str] = None"},{name:"gradient_accumulation_steps",val:": int = 1"},{name:"cpu",val:": bool = False"},{name:"deepspeed_plugin",val:": DeepSpeedPlugin = None"},{name:"fsdp_plugin",val:": FullyShardedDataParallelPlugin = None"},{name:"megatron_lm_plugin",val:": MegatronLMPlugin = None"},{name:"rng_types",val:": typing.Union[typing.List[typing.Union[str, accelerate.utils.dataclasses.RNGType]], NoneType] = None"},{name:"log_with",val:": typing.Union[typing.List[typing.Union[str, accelerate.utils.dataclasses.LoggerType, accelerate.tracking.GeneralTracker]], NoneType] = None"},{name:"logging_dir",val:": typing.Union[str, os.PathLike, NoneType] = None"},{name:"dispatch_batches",val:": typing.Optional[bool] = None"},{name:"even_batches",val:": bool = True"},{name:"step_scheduler_with_optimizer",val:": bool = True"},{name:"kwargs_handlers",val:": typing.Optional[typing.List[accelerate.utils.dataclasses.KwargsHandler]] = None"},{name:"dynamo_backend",val:": typing.Union[accelerate.utils.dataclasses.DynamoBackend, str] = None"}],parametersDescription:[{anchor:"accelerate.Accelerator.device_placement",description:`<strong>device_placement</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not the accelerator should put objects on device (tensors yielded by the dataloader, model,
etc&#x2026;).`,name:"device_placement"},{anchor:"accelerate.Accelerator.split_batches",description:`<strong>split_batches</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not the accelerator should split the batches yielded by the dataloaders across the devices. If
<code>True</code> the actual batch size used will be the same on any kind of distributed processes, but it must be a
round multiple of the <code>num_processes</code> you are using. If <code>False</code>, actual batch size used will be the one set
in your script multiplied by the number of processes.`,name:"split_batches"},{anchor:"accelerate.Accelerator.mixed_precision",description:`<strong>mixed_precision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Whether or not to use mixed precision training (fp16 or bfloat16). Choose from &#x2018;no&#x2019;,&#x2018;fp16&#x2019;,&#x2018;bf16&#x2019;. Will
default to the value in the environment variable <code>MIXED_PRECISION</code>, which will use the default value in the
accelerate config of the current system or the flag passed with the <code>accelerate.launch</code> command. &#x2018;fp16&#x2019;
requires pytorch 1.6 or higher. &#x2018;bf16&#x2019; requires pytorch 1.10 or higher.`,name:"mixed_precision"},{anchor:"accelerate.Accelerator.gradient_accumulation_steps",description:`<strong>gradient_accumulation_steps</strong> (<code>int</code>, <em>optional</em>, default to 1) &#x2014;
The number of steps that should pass before gradients are accumulated. A number &gt; 1 should be combined with
<code>Accelerator.accumulate</code>.`,name:"gradient_accumulation_steps"},{anchor:"accelerate.Accelerator.cpu",description:`<strong>cpu</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to force the script to execute on CPU. Will ignore GPU available if set to <code>True</code> and force
the execution on one process only.`,name:"cpu"},{anchor:"accelerate.Accelerator.deepspeed_plugin",description:`<strong>deepspeed_plugin</strong> (<code>DeepSpeedPlugin</code>, <em>optional</em>) &#x2014;
Tweak your DeepSpeed related args using this argument. This argument is optional and can be configured
directly using <em>accelerate config</em>`,name:"deepspeed_plugin"},{anchor:"accelerate.Accelerator.fsdp_plugin",description:`<strong>fsdp_plugin</strong> (<code>FullyShardedDataParallelPlugin</code>, <em>optional</em>) &#x2014;
Tweak your FSDP related args using this argument. This argument is optional and can be configured directly
using <em>accelerate config</em>`,name:"fsdp_plugin"},{anchor:"accelerate.Accelerator.megatron_lm_plugin",description:`<strong>megatron_lm_plugin</strong> (<code>MegatronLMPlugin</code>, <em>optional</em>) &#x2014;
Tweak your MegatronLM related args using this argument. This argument is optional and can be configured
directly using <em>accelerate config</em>`,name:"megatron_lm_plugin"},{anchor:"accelerate.Accelerator.rng_types",description:`<strong>rng_types</strong> (list of <code>str</code> or <code>RNGType</code>) &#x2014;
The list of random number generators to synchronize at the beginning of each iteration in your prepared
dataloaders. Should be one or several of:</p>
<ul>
<li><code>&quot;torch&quot;</code>: the base torch random number generator</li>
<li><code>&quot;cuda&quot;</code>: the CUDA random number generator (GPU only)</li>
<li><code>&quot;xla&quot;</code>: the XLA random number generator (TPU only)</li>
<li><code>&quot;generator&quot;</code>: the <code>torch.Generator</code> of the sampler (or batch sampler if there is no sampler in your
dataloader) or of the iterable dataset (if it exists) if the underlying dataset is of that type.</li>
</ul>
<p>Will default to <code>[&quot;torch&quot;]</code> for PyTorch versions &lt;=1.5.1 and <code>[&quot;generator&quot;]</code> for PyTorch versions &gt;= 1.6.`,name:"rng_types"},{anchor:"accelerate.Accelerator.log_with",description:`<strong>log_with</strong> (list of <code>str</code>, <a href="/docs/accelerate/main/en/package_reference/utilities#accelerate.utils.LoggerType">LoggerType</a> or <a href="/docs/accelerate/main/en/package_reference/tracking#accelerate.tracking.GeneralTracker">GeneralTracker</a>, <em>optional</em>) &#x2014;
A list of loggers to be setup for experiment tracking. Should be one or several of:</p>
<ul>
<li><code>&quot;all&quot;</code></li>
<li><code>&quot;tensorboard&quot;</code></li>
<li><code>&quot;wandb&quot;</code></li>
<li><code>&quot;comet_ml&quot;</code>
If <code>&quot;all&quot;</code> is selected, will pick up all available trackers in the environment and initialize them. Can
also accept implementations of <code>GeneralTracker</code> for custom trackers, and can be combined with <code>&quot;all&quot;</code>.</li>
</ul>`,name:"log_with"},{anchor:"accelerate.Accelerator.logging_dir",description:`<strong>logging_dir</strong> (<code>str</code>, <code>os.PathLike</code>, <em>optional</em>) &#x2014;
A path to a directory for storing logs of locally-compatible loggers.`,name:"logging_dir"},{anchor:"accelerate.Accelerator.dispatch_batches",description:`<strong>dispatch_batches</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
If set to <code>True</code>, the dataloader prepared by the Accelerator is only iterated through on the main process
and then the batches are split and broadcast to each process. Will default to <code>True</code> for <code>DataLoader</code> whose
underlying dataset is an <code>IterableDataset</code>, <code>False</code> otherwise.`,name:"dispatch_batches"},{anchor:"accelerate.Accelerator.even_batches",description:`<strong>even_batches</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
If set to <code>True</code>, in cases where the total batch size across all processes does not exactly divide the
dataset, samples at the start of the dataset will be duplicated so the batch can be divided equally among
all workers.`,name:"even_batches"},{anchor:"accelerate.Accelerator.step_scheduler_with_optimizer",description:"<strong>step_scheduler_with_optimizer</strong> (<code>bool</code>, *optional<code>, defaults to </code>True<code>) -- Set </code>True<code>if the learning rate scheduler is stepped at the same time as the optimizer,</code>False` if only\ndone under certain circumstances (at the end of each epoch, for instance).",name:"step_scheduler_with_optimizer"},{anchor:"accelerate.Accelerator.kwargs_handlers",description:`<strong>kwargs_handlers</strong> (<code>List[KwargHandler]</code>, <em>optional</em>) &#x2014;
A list of <code>KwargHandler</code> to customize how the objects related to distributed training or mixed precision
are created. See <a href="kwargs">kwargs</a> for more information.`,name:"kwargs_handlers"},{anchor:"accelerate.Accelerator.dynamo_backend",description:`<strong>dynamo_backend</strong> (<code>str</code> or <code>DynamoBackend</code>, <em>optional</em>, defaults to <code>&quot;no&quot;</code>) &#x2014;
Set to one of the possible dynamo backends to optimize your training with torch dynamo.`,name:"dynamo_backend"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L101"}}),wr=new P({props:{name:"accumulate",anchor:"accelerate.Accelerator.accumulate",parameters:[{name:"model",val:""}],parametersDescription:[{anchor:"accelerate.Accelerator.accumulate.model",description:`<strong>model</strong> (<code>torch.nn.Module</code>) &#x2014;
PyTorch Module that was prepared with <code>Accelerator.prepare</code>`,name:"model"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L587"}}),dt=new Is({props:{anchor:"accelerate.Accelerator.accumulate.example",$$slots:{default:[G_]},$$scope:{ctx:D}}}),Er=new P({props:{name:"autocast",anchor:"accelerate.Accelerator.autocast",parameters:[],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1816"}}),Ar=new P({props:{name:"backward",anchor:"accelerate.Accelerator.backward",parameters:[{name:"loss",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1278"}}),xr=new P({props:{name:"clear",anchor:"accelerate.Accelerator.clear",parameters:[],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1724"}}),Pr=new P({props:{name:"clip_grad_norm_",anchor:"accelerate.Accelerator.clip_grad_norm_",parameters:[{name:"parameters",val:""},{name:"max_norm",val:""},{name:"norm_type",val:" = 2"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1317",returnDescription:`
<p>Total norm of the parameter gradients (viewed as a single vector).</p>
`,returnType:`
<p><code>torch.Tensor</code></p>
`}}),mt=new Is({props:{anchor:"accelerate.Accelerator.clip_grad_norm_.example",$$slots:{default:[R_]},$$scope:{ctx:D}}}),Tr=new P({props:{name:"clip_grad_value_",anchor:"accelerate.Accelerator.clip_grad_value_",parameters:[{name:"parameters",val:""},{name:"clip_value",val:""}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1355"}}),ut=new Is({props:{anchor:"accelerate.Accelerator.clip_grad_value_.example",$$slots:{default:[W_]},$$scope:{ctx:D}}}),Sr=new P({props:{name:"end_training",anchor:"accelerate.Accelerator.end_training",parameters:[],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1554"}}),Ir=new P({props:{name:"free_memory",anchor:"accelerate.Accelerator.free_memory",parameters:[],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1711"}}),Lr=new P({props:{name:"gather",anchor:"accelerate.Accelerator.gather",parameters:[{name:"tensor",val:""}],parametersDescription:[{anchor:"accelerate.Accelerator.gather.tensor",description:`<strong>tensor</strong> (<code>torch.Tensor</code>, or a nested tuple/list/dictionary of <code>torch.Tensor</code>) &#x2014;
The tensors to gather across all processes.`,name:"tensor"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1382",returnDescription:`
<p>The gathered tensor(s). Note that the
first dimension of the result is <em>num_processes</em> multiplied by the first dimension of the input tensors.</p>
`,returnType:`
<p><code>torch.Tensor</code>, or a nested tuple/list/dictionary of <code>torch.Tensor</code></p>
`}}),Nr=new P({props:{name:"gather_for_metrics",anchor:"accelerate.Accelerator.gather_for_metrics",parameters:[{name:"tensor",val:""}],parametersDescription:[{anchor:"accelerate.Accelerator.gather_for_metrics.tensor",description:`<strong>tensor</strong> (<code>torch.Tensor</code>, or a nested tuple/list/dictionary of <code>torch.Tensor</code>) &#x2014;
The tensors for calculating metrics across all processes.`,name:"tensor"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1400"}}),qr=new P({props:{name:"get_state_dict",anchor:"accelerate.Accelerator.get_state_dict",parameters:[{name:"model",val:""},{name:"unwrap",val:" = True"}],parametersDescription:[{anchor:"accelerate.Accelerator.get_state_dict.model",description:`<strong>model</strong> (<code>torch.nn.Module</code>) &#x2014;
A PyTorch model sent through <a href="/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.prepare">Accelerator.prepare()</a>`,name:"model"},{anchor:"accelerate.Accelerator.get_state_dict.unwrap",description:`<strong>unwrap</strong> (<code>bool</code>, <em>optional</em>, defaults to True) &#x2014;
Whether to return the original underlying state_dict of <code>model</code> or to return the wrapped state_dict`,name:"unwrap"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1756"}}),Vr=new P({props:{name:"get_tracker",anchor:"accelerate.Accelerator.get_tracker",parameters:[{name:"name",val:": str"}],parametersDescription:[{anchor:"accelerate.Accelerator.get_tracker.name",description:`<strong>name</strong> (<code>str</code>) &#x2014;
The name of a tracker, corresponding to the <code>.name</code> property.`,name:"name"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1520"}}),Mr=new P({props:{name:"init_trackers",anchor:"accelerate.Accelerator.init_trackers",parameters:[{name:"project_name",val:": str"},{name:"config",val:": typing.Optional[dict] = None"},{name:"init_kwargs",val:": typing.Optional[dict] = {}"}],parametersDescription:[{anchor:"accelerate.Accelerator.init_trackers.project_name",description:`<strong>project_name</strong> (<code>str</code>) &#x2014;
The name of the project. All trackers will save their data based on this`,name:"project_name"},{anchor:"accelerate.Accelerator.init_trackers.config",description:`<strong>config</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Optional starting configuration to be logged.`,name:"config"},{anchor:"accelerate.Accelerator.init_trackers.init_kwargs",description:`<strong>init_kwargs</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
A nested dictionary of kwargs to be passed to a specific tracker&#x2019;s <code>__init__</code> function. Should be
formatted like so:`,name:"init_kwargs"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1485"}}),Rr=new P({props:{name:"join_uneven_inputs",anchor:"accelerate.Accelerator.join_uneven_inputs",parameters:[{name:"joinables",val:""},{name:"even_batches",val:" = None"}],parametersDescription:[{anchor:"accelerate.Accelerator.join_uneven_inputs.joinables",description:`<strong>joinables</strong> (<code>List[torch.distributed.algorithms.Joinable]</code>) &#x2014;
A list of models or optimizers that subclass <code>torch.distributed.algorithms.Joinable</code>. Most commonly, a
PyTorch Module that was prepared with <code>Accelerator.prepare</code> for DistributedDataParallel training.`,name:"joinables"},{anchor:"accelerate.Accelerator.join_uneven_inputs.even_batches",description:`<strong>even_batches</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
If set, this will override the value of <code>even_batches</code> set in the <code>Accelerator</code>. If it is not provided,
the default <code>Accelerator</code> value wil be used.`,name:"even_batches"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L623"}}),yt=new Kt({props:{warning:!0,$$slots:{default:[F_]},$$scope:{ctx:D}}}),wt=new Kt({props:{warning:!0,$$slots:{default:[H_]},$$scope:{ctx:D}}}),Et=new Is({props:{anchor:"accelerate.Accelerator.join_uneven_inputs.example",$$slots:{default:[Y_]},$$scope:{ctx:D}}}),Fr=new P({props:{name:"load_state",anchor:"accelerate.Accelerator.load_state",parameters:[{name:"input_dir",val:": str"}],parametersDescription:[{anchor:"accelerate.Accelerator.load_state.input_dir",description:`<strong>input_dir</strong> (<code>str</code> or <code>os.PathLike</code>) &#x2014;
The name of the folder all relevant weights and states were saved in.`,name:"input_dir"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1640"}}),At=new Kt({props:{$$slots:{default:[B_]},$$scope:{ctx:D}}}),Hr=new P({props:{name:"local_main_process_first",anchor:"accelerate.Accelerator.local_main_process_first",parameters:[],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L524"}}),Yr=new P({props:{name:"log",anchor:"accelerate.Accelerator.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"},{name:"log_kwargs",val:": typing.Optional[dict] = {}"}],parametersDescription:[{anchor:"accelerate.Accelerator.log.values",description:`<strong>values</strong> (<code>dict</code>) &#x2014;
Values should be a dictionary-like object containing only types <code>int</code>, <code>float</code>, or <code>str</code>.`,name:"values"},{anchor:"accelerate.Accelerator.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"},{anchor:"accelerate.Accelerator.log.log_kwargs",description:`<strong>log_kwargs</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
A nested dictionary of kwargs to be passed to a specific tracker&#x2019;s <code>log</code> function. Should be formatted
like so:`,name:"log_kwargs"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1534"}}),Br=new P({props:{name:"main_process_first",anchor:"accelerate.Accelerator.main_process_first",parameters:[],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L515"}}),Jr=new P({props:{name:"no_sync",anchor:"accelerate.Accelerator.no_sync",parameters:[{name:"model",val:""}],parametersDescription:[{anchor:"accelerate.Accelerator.no_sync.model",description:`<strong>model</strong> (<code>torch.nn.Module</code>) &#x2014;
PyTorch Module that was prepared with <code>Accelerator.prepare</code>`,name:"model"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L533"}}),xt=new Is({props:{anchor:"accelerate.Accelerator.no_sync.example",$$slots:{default:[J_]},$$scope:{ctx:D}}}),Xr=new P({props:{name:"on_last_process",anchor:"accelerate.Accelerator.on_last_process",parameters:[{name:"func",val:""}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L464"}}),Zr=new P({props:{name:"on_local_main_process",anchor:"accelerate.Accelerator.on_local_main_process",parameters:[{name:"func",val:""}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L452"}}),ea=new P({props:{name:"on_local_process",anchor:"accelerate.Accelerator.on_local_process",parameters:[{name:"local_process_idx",val:""}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L491"}}),ta=new P({props:{name:"on_main_process",anchor:"accelerate.Accelerator.on_main_process",parameters:[{name:"func",val:""}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L440"}}),ra=new P({props:{name:"on_process",anchor:"accelerate.Accelerator.on_process",parameters:[{name:"process_idx",val:""}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L476"}}),aa=new P({props:{name:"pad_across_processes",anchor:"accelerate.Accelerator.pad_across_processes",parameters:[{name:"tensor",val:""},{name:"dim",val:" = 0"},{name:"pad_index",val:" = 0"},{name:"pad_first",val:" = False"}],parametersDescription:[{anchor:"accelerate.Accelerator.pad_across_processes.tensor",description:`<strong>tensor</strong> (nested list/tuple/dictionary of <code>torch.Tensor</code>) &#x2014;
The data to gather.`,name:"tensor"},{anchor:"accelerate.Accelerator.pad_across_processes.dim",description:`<strong>dim</strong> (<code>int</code>, <em>optional</em>, defaults to 0) &#x2014;
The dimension on which to pad.`,name:"dim"},{anchor:"accelerate.Accelerator.pad_across_processes.pad_index",description:`<strong>pad_index</strong> (<code>int</code>, <em>optional</em>, defaults to 0) &#x2014;
The value with which to pad.`,name:"pad_index"},{anchor:"accelerate.Accelerator.pad_across_processes.pad_first",description:`<strong>pad_first</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to pad at the beginning or the end.`,name:"pad_first"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1450"}}),oa=new P({props:{name:"prepare",anchor:"accelerate.Accelerator.prepare",parameters:[{name:"*args",val:""},{name:"device_placement",val:" = None"}],parametersDescription:[{anchor:"accelerate.Accelerator.prepare.*args",description:`<strong>*args</strong> (list of objects) &#x2014;
Any of the following type of objects:</p>
<ul>
<li><code>torch.utils.data.DataLoader</code>: PyTorch Dataloader</li>
<li><code>torch.nn.Module</code>: PyTorch Module</li>
<li><code>torch.optim.Optimizer</code>: PyTorch Optimizer</li>
<li><code>torch.optim.lr_scheduler._LRScheduler</code>: PyTorch LR Scheduler</li>
</ul>`,name:"*args"},{anchor:"accelerate.Accelerator.prepare.device_placement",description:`<strong>device_placement</strong> (<code>List[bool]</code>, <em>optional</em>) &#x2014;
Used to customize whether automatic device placement should be performed for each object passed. Needs
to be a list of the same length as <code>args</code>.`,name:"device_placement"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L780"}}),It=new Kt({props:{$$slots:{default:[K_]},$$scope:{ctx:D}}}),sa=new P({props:{name:"prepare_data_loader",anchor:"accelerate.Accelerator.prepare_data_loader",parameters:[{name:"data_loader",val:": DataLoader"},{name:"device_placement",val:" = None"}],parametersDescription:[{anchor:"accelerate.Accelerator.prepare_data_loader.data_loader",description:`<strong>data_loader</strong> (<code>torch.utils.data.DataLoader</code>) &#x2014;
A vanilla PyTorch DataLoader to prepare`,name:"data_loader"},{anchor:"accelerate.Accelerator.prepare_data_loader.device_placement",description:`<strong>device_placement</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to place the batches on the proper device in the prepared dataloader. Will default to
<code>self.device_placement</code>.`,name:"device_placement"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1209"}}),la=new P({props:{name:"prepare_model",anchor:"accelerate.Accelerator.prepare_model",parameters:[{name:"model",val:": Module"},{name:"device_placement",val:" = None"}],parametersDescription:[{anchor:"accelerate.Accelerator.prepare_model.model",description:`<strong>model</strong> (<code>torch.nn.Module</code>) &#x2014;
A PyTorch model to prepare. You don&#x2019;t need to prepare a model if it is used only for inference without
any kind of mixed precision`,name:"model"},{anchor:"accelerate.Accelerator.prepare_model.device_placement",description:`<strong>device_placement</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to place the model on the proper device. Will default to <code>self.device_placement</code>.`,name:"device_placement"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L878"}}),da=new P({props:{name:"prepare_optimizer",anchor:"accelerate.Accelerator.prepare_optimizer",parameters:[{name:"optimizer",val:": Optimizer"},{name:"device_placement",val:" = None"}],parametersDescription:[{anchor:"accelerate.Accelerator.prepare_optimizer.optimizer",description:`<strong>optimizer</strong> (<code>torch.optim.Optimizer</code>) &#x2014;
A vanilla PyTorch optimizer to prepare`,name:"optimizer"},{anchor:"accelerate.Accelerator.prepare_optimizer.device_placement",description:`<strong>device_placement</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to place the optimizer on the proper device. Will default to <code>self.device_placement</code>.`,name:"device_placement"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1237"}}),ha=new P({props:{name:"prepare_scheduler",anchor:"accelerate.Accelerator.prepare_scheduler",parameters:[{name:"scheduler",val:": _LRScheduler"}],parametersDescription:[{anchor:"accelerate.Accelerator.prepare_scheduler.scheduler",description:`<strong>scheduler</strong> (<code>torch.optim.lr_scheduler._LRScheduler</code>) &#x2014;
A vanilla PyTorch scheduler to prepare`,name:"scheduler"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1254"}}),ua=new P({props:{name:"print",anchor:"accelerate.Accelerator.print",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L710"}}),ga=new P({props:{name:"reduce",anchor:"accelerate.Accelerator.reduce",parameters:[{name:"tensor",val:""},{name:"reduction",val:" = 'sum'"}],parametersDescription:[{anchor:"accelerate.Accelerator.reduce.tensor",description:`<strong>tensor</strong> (<code>torch.Tensor</code>, or a nested tuple/list/dictionary of <code>torch.Tensor</code>) &#x2014;
The tensors to reduce across all processes.`,name:"tensor"},{anchor:"accelerate.Accelerator.reduce.reduction",description:`<strong>reduction</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201C;sum&#x201D;) &#x2014;
A reduction type, can be one of &#x2018;sum&#x2019;, &#x2018;mean&#x2019;, or &#x2018;none&#x2019;. If &#x2018;none&#x2019;, will not perform any operation.`,name:"reduction"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1432",returnDescription:`
<p>The reduced tensor(s).</p>
`,returnType:`
<p><code>torch.Tensor</code>, or a nested tuple/list/dictionary of <code>torch.Tensor</code></p>
`}}),_a=new P({props:{name:"register_for_checkpointing",anchor:"accelerate.Accelerator.register_for_checkpointing",parameters:[{name:"*objects",val:""}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1792"}}),Ut=new Kt({props:{$$slots:{default:[Q_]},$$scope:{ctx:D}}}),va=new P({props:{name:"save",anchor:"accelerate.Accelerator.save",parameters:[{name:"obj",val:""},{name:"f",val:""}],parametersDescription:[{anchor:"accelerate.Accelerator.save.f",description:`<strong>f</strong> (<code>str</code> or <code>os.PathLike</code>) &#x2014;
Where to save the content of <code>obj</code>.`,name:"f"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1563"}}),ba=new P({props:{name:"save_state",anchor:"accelerate.Accelerator.save_state",parameters:[{name:"output_dir",val:": str"}],parametersDescription:[{anchor:"accelerate.Accelerator.save_state.output_dir",description:`<strong>output_dir</strong> (<code>str</code> or <code>os.PathLike</code>) &#x2014;
The name of the folder to save all relevant weights and states.`,name:"output_dir"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1574"}}),Mt=new Kt({props:{$$slots:{default:[X_]},$$scope:{ctx:D}}}),ya=new P({props:{name:"unscale_gradients",anchor:"accelerate.Accelerator.unscale_gradients",parameters:[{name:"optimizer",val:" = None"}],parametersDescription:[{anchor:"accelerate.Accelerator.unscale_gradients.optimizer",description:`<strong>optimizer</strong> (<code>torch.optim.Optimizer</code> or <code>List[torch.optim.Optimizer]</code>, <em>optional</em>) &#x2014;
The optimizer(s) for which to unscale gradients. If not set, will unscale gradients on all optimizers
that were passed to <a href="/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.prepare">prepare()</a>.`,name:"optimizer"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1297"}}),wa=new P({props:{name:"unwrap_model",anchor:"accelerate.Accelerator.unwrap_model",parameters:[{name:"model",val:""}],parametersDescription:[{anchor:"accelerate.Accelerator.unwrap_model.model",description:`<strong>model</strong> (<code>torch.nn.Module</code>) &#x2014;
The model to unwrap.`,name:"model"}],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1467"}}),Ea=new P({props:{name:"wait_for_everyone",anchor:"accelerate.Accelerator.wait_for_everyone",parameters:[],source:"https://github.com/huggingface/accelerate/blob/main/src/accelerate/accelerator.py#L1478"}}),{c(){h=a("meta"),x=l(),v=a("h1"),g=a("a"),j=a("span"),$(m.$$.fragment),k=l(),I=a("span"),oe=s("Accelerator"),Pe=l(),q=a("p"),ne=s("The "),S=a("a"),ja=s("Accelerator"),Pa=s(` is the main class provided by \u{1F917} Accelerate.
It serves at the main entrypoint for the API.`),Qt=l(),se=a("h2"),De=a("a"),mo=a("span"),$(Xt.$$.fragment),Sl=l(),uo=a("span"),Il=s("Quick adaptation of your code"),Os=l(),Da=a("p"),Ll=s("To quickly adapt your script to work on any kind of setup with \u{1F917} Accelerate just:"),Ns=l(),W=a("ol"),ce=a("li"),Ol=s("Initialize an "),Ta=a("a"),Nl=s("Accelerator"),Cl=s(" object (that we will call "),fo=a("code"),ql=s("accelerator"),Ul=s(" throughout this page) as early as possible in your script."),Vl=l(),Zt=a("li"),Ml=s("Pass your dataloader(s), model(s), optimizer(s), and scheduler(s) to the "),za=a("a"),Gl=s("prepare()"),Rl=s(" method."),Wl=l(),M=a("li"),Fl=s("Remove all the "),go=a("code"),Hl=s(".cuda()"),Yl=s(" or "),_o=a("code"),Bl=s(".to(device)"),Jl=s(" from your code and let the "),vo=a("code"),Kl=s("accelerator"),Ql=s(" handle the device placement for you."),Cs=l(),$(Te.$$.fragment),qs=l(),le=a("ol"),ze=a("li"),Xl=s("Replace "),$o=a("code"),Zl=s("loss.backward()"),ei=s(" in your code with "),bo=a("code"),ti=s("accelerator.backward(loss)"),ri=l(),Sa=a("li"),ai=s("Gather your predictions and labels before storing them or using them for metric computation using "),Ia=a("a"),oi=s("gather()"),Us=l(),$(Se.$$.fragment),Vs=l(),Ie=a("p"),ni=s(`In most cases this is all that is needed. The next section lists a few more advanced use cases and nice features
you should search for and replace by the corresponding methods of your `),yo=a("code"),si=s("accelerator"),ci=s(":"),Ms=l(),ie=a("h2"),Le=a("a"),wo=a("span"),$(er.$$.fragment),li=l(),Eo=a("span"),ii=s("Advanced recommendations"),Gs=l(),de=a("h3"),Oe=a("a"),Ao=a("span"),$(tr.$$.fragment),di=l(),ko=a("span"),pi=s("Printing"),Rs=l(),pe=a("p"),xo=a("code"),hi=s("print"),mi=s(" statements should be replaced by "),La=a("a"),ui=s("print()"),fi=s(" to be printed once per process"),Ws=l(),$(rr.$$.fragment),Fs=l(),he=a("h3"),Ne=a("a"),jo=a("span"),$(ar.$$.fragment),gi=l(),Po=a("span"),_i=s("Executing processes"),Hs=l(),me=a("h4"),Ce=a("a"),Do=a("span"),$(or.$$.fragment),vi=l(),To=a("span"),$i=s("Once on a single server"),Ys=l(),qe=a("p"),bi=s("For statements that should be executed once per server, use "),zo=a("code"),yi=s("is_local_main_process"),wi=s(":"),Bs=l(),$(nr.$$.fragment),Js=l(),Ue=a("p"),Ei=s("A function can be wrapped using the "),Oa=a("a"),Ai=s("on_local_main_process()"),ki=s(` function to achieve the same
behavior on a function\u2019s execution:`),Ks=l(),$(sr.$$.fragment),Qs=l(),ue=a("h4"),Ve=a("a"),So=a("span"),$(cr.$$.fragment),xi=l(),Io=a("span"),ji=s("Only ever once across all servers"),Xs=l(),Me=a("p"),Pi=s("For statements that should only ever be executed once, use "),Lo=a("code"),Di=s("is_main_process"),Ti=s(":"),Zs=l(),$(lr.$$.fragment),ec=l(),Ge=a("p"),zi=s("A function can be wrapped using the "),Na=a("a"),Si=s("on_main_process()"),Ii=s(` function to achieve the same
behavior on a function\u2019s execution:`),tc=l(),$(ir.$$.fragment),rc=l(),fe=a("h4"),Re=a("a"),Oo=a("span"),$(dr.$$.fragment),Li=l(),No=a("span"),Oi=s("On specific processes"),ac=l(),Ca=a("p"),Ni=s(`If a function should be ran on a specific overall or local process index, there are similar decorators
to achieve this:`),oc=l(),$(pr.$$.fragment),nc=l(),$(hr.$$.fragment),sc=l(),ge=a("h3"),We=a("a"),Co=a("span"),$(mr.$$.fragment),Ci=l(),qo=a("span"),qi=s("Synchronicity control"),cc=l(),Fe=a("p"),Ui=s("Use "),qa=a("a"),Vi=s("wait_for_everyone()"),Mi=s(" to make sure all processes join that point before continuing. (Useful before a model save for instance)"),lc=l(),_e=a("h3"),He=a("a"),Uo=a("span"),$(ur.$$.fragment),Gi=l(),Vo=a("span"),Ri=s("Saving and loading"),ic=l(),Ye=a("p"),Wi=s("Use "),Ua=a("a"),Fi=s("unwrap_model()"),Hi=s(" before saving to remove all special model wrappers added during the distributed process."),dc=l(),$(fr.$$.fragment),pc=l(),F=a("p"),Yi=s("Use "),Va=a("a"),Bi=s("save()"),Ji=s(" instead of "),Mo=a("code"),Ki=s("torch.save"),Qi=s(":"),hc=l(),$(gr.$$.fragment),mc=l(),ve=a("h3"),Be=a("a"),Go=a("span"),$(_r.$$.fragment),Xi=l(),Ro=a("span"),Zi=s("Operations"),uc=l(),N=a("p"),ed=s("Use "),Je=a("a"),td=s("clip"),Wo=a("em"),rd=s("grad_norm"),ad=s("()"),od=s(" instead of "),Fo=a("code"),nd=s("torch.nn.utils.clip_grad_norm_"),sd=s(" and "),Ke=a("a"),cd=s("clip"),Ho=a("em"),ld=s("grad_value"),id=s("()"),dd=s(" instead of "),Yo=a("code"),pd=s("torch.nn.utils.clip_grad_value"),fc=l(),$e=a("h3"),Qe=a("a"),Bo=a("span"),$(vr.$$.fragment),hd=l(),Jo=a("span"),md=s("Gradient Accumulation"),gc=l(),Xe=a("p"),ud=s("To perform gradient accumulation use "),Ma=a("a"),fd=s("accumulate()"),gd=s(` and specify a gradient_accumulation_steps.
This will also automatically ensure the gradients are synced or unsynced when on
multi-device training, check if the step should actually be performed, and auto-scale the loss:`),_c=l(),$($r.$$.fragment),vc=l(),be=a("h2"),Ze=a("a"),Ko=a("span"),$(br.$$.fragment),_d=l(),Qo=a("span"),vd=s("Overall API documentation:"),$c=l(),f=a("div"),$(yr.$$.fragment),$d=l(),Xo=a("p"),bd=s("Creates an instance of an accelerator for distributed training (on multi-GPU, TPU) or mixed precision training."),yd=l(),Zo=a("p"),en=a("strong"),wd=s("Available attributes:"),Ed=l(),T=a("ul"),et=a("li"),tn=a("strong"),Ad=s("device"),kd=s(" ("),rn=a("code"),xd=s("torch.device"),jd=s(") \u2014 The device to use."),Pd=l(),tt=a("li"),an=a("strong"),Dd=s("distributed_type"),Td=s(" ("),Ga=a("a"),zd=s("DistributedType"),Sd=s(") \u2014 The distributed training configuration."),Id=l(),rt=a("li"),on=a("strong"),Ld=s("local_process_index"),Od=s(" ("),nn=a("code"),Nd=s("int"),Cd=s(") \u2014 The process index on the current machine."),qd=l(),at=a("li"),sn=a("strong"),Ud=s("mixed_precision"),Vd=s(" ("),cn=a("code"),Md=s("str"),Gd=s(") \u2014 The configured mixed precision mode."),Rd=l(),ot=a("li"),ln=a("strong"),Wd=s("num_processes"),Fd=s(" ("),dn=a("code"),Hd=s("int"),Yd=s(") \u2014 The total number of processes used for training."),Bd=l(),nt=a("li"),pn=a("strong"),Jd=s("optimizer_step_was_skipped"),Kd=s(" ("),hn=a("code"),Qd=s("bool"),Xd=s(`) \u2014 Whether or not the optimizer update was skipped (because of
gradient overflow in mixed precision), in which
case the learning rate should not be changed.`),Zd=l(),st=a("li"),mn=a("strong"),ep=s("process_index"),tp=s(" ("),un=a("code"),rp=s("int"),ap=s(") \u2014 The overall index of the current process among all processes."),op=l(),ct=a("li"),fn=a("strong"),np=s("state"),sp=s(" ("),Ra=a("a"),cp=s("AcceleratorState"),lp=s(") \u2014 The distributed setup state."),ip=l(),lt=a("li"),gn=a("strong"),dp=s("sync_gradients"),pp=s(" ("),_n=a("code"),hp=s("bool"),mp=s(") \u2014 Whether the gradients are currently being synced across all processes."),up=l(),it=a("li"),vn=a("strong"),fp=s("use_distributed"),gp=s(" ("),$n=a("code"),_p=s("bool"),vp=s(") \u2014 Whether the current configuration is for distributed training."),$p=l(),H=a("div"),$(wr.$$.fragment),bp=l(),bn=a("p"),yp=s("A context manager that will lightly wrap around and perform gradient accumulation automatically"),wp=l(),$(dt.$$.fragment),Ep=l(),pt=a("div"),$(Er.$$.fragment),Ap=l(),yn=a("p"),kp=s(`Will apply automatic mixed-precision inside the block inside this context manager, if it is enabled. Nothing
different will happen otherwise.`),xp=l(),Y=a("div"),$(Ar.$$.fragment),jp=l(),ye=a("p"),Pp=s("Scales the gradients in accordance to "),wn=a("code"),Dp=s("Accelerator.gradient_accumulation_steps"),Tp=s(` and calls the correct
`),En=a("code"),zp=s("backward()"),Sp=s(" based on the configuration."),Ip=l(),kr=a("p"),Lp=s("Should be used in lieu of "),An=a("code"),Op=s("loss.backward()"),Np=s("."),Cp=l(),ht=a("div"),$(xr.$$.fragment),qp=l(),jr=a("p"),Up=s("Alias for "),kn=a("code"),Vp=s("Accelerate.free_memory"),Mp=s(`, releases all references to the internal objects stored and call the
garbage collector. You should call this method between two trainings with different models/optimizers.`),Gp=l(),B=a("div"),$(Pr.$$.fragment),Rp=l(),Dr=a("p"),Wp=s("Should be used in place of "),xn=a("code"),Fp=s("torch.nn.utils.clip_grad_norm_"),Hp=s("."),Yp=l(),$(mt.$$.fragment),Bp=l(),J=a("div"),$(Tr.$$.fragment),Jp=l(),zr=a("p"),Kp=s("Should be used in place of "),jn=a("code"),Qp=s("torch.nn.utils.clip_grad_value_"),Xp=s("."),Zp=l(),$(ut.$$.fragment),eh=l(),ft=a("div"),$(Sr.$$.fragment),th=l(),Pn=a("p"),rh=s(`Runs any special end training behaviors, such as stopping trackers on the main process only. Should always be
called at the end of your script if using experiment tracking.`),ah=l(),gt=a("div"),$(Ir.$$.fragment),oh=l(),Dn=a("p"),nh=s(`Will release all references to the internal objects stored and call the garbage collector. You should call this
method between two trainings with different models/optimizers.`),sh=l(),K=a("div"),$(Lr.$$.fragment),ch=l(),Or=a("p"),lh=s("Gather the values in "),Tn=a("em"),ih=s("tensor"),dh=s(` across all processes and concatenate them on the first dimension. Useful to
regroup the predictions from all processes when doing evaluation.`),ph=l(),zn=a("p"),hh=s(`Note:
This gather happens in all processes.`),mh=l(),_t=a("div"),$(Nr.$$.fragment),uh=l(),Cr=a("p"),fh=s("Gathers "),Sn=a("code"),gh=s("tensor"),_h=s(` and potentially drops duplicates in the last batch if on a distributed system. Should be used
for gathering the inputs and targets for metric calculation.`),vh=l(),vt=a("div"),$(qr.$$.fragment),$h=l(),Ur=a("p"),bh=s("Returns the state dictionary of a model sent through "),Wa=a("a"),yh=s("Accelerator.prepare()"),wh=s(" in full precision"),Eh=l(),$t=a("div"),$(Vr.$$.fragment),Ah=l(),G=a("p"),kh=s("Returns a "),In=a("code"),xh=s("tracker"),jh=s(" from "),Ln=a("code"),Ph=s("self.trackers"),Dh=s(" based on "),On=a("code"),Th=s("name"),zh=s(" on the main process only."),Sh=l(),bt=a("div"),$(Mr.$$.fragment),Ih=l(),Gr=a("p"),Lh=s("Initializes a run for all trackers stored in "),Nn=a("code"),Oh=s("self.log_with"),Nh=s(", potentially with starting configurations"),Ch=l(),O=a("div"),$(Rr.$$.fragment),qh=l(),Wr=a("p"),Uh=s(`A context manager that facilitates distributed training or evaluation on uneven inputs, which acts as a wrapper
around `),Cn=a("code"),Vh=s("torch.distributed.algorithms.join"),Mh=s(`. This is useful when the total batch size does not evenly divide the
length of the dataset.`),Gh=l(),$(yt.$$.fragment),Rh=l(),$(wt.$$.fragment),Wh=l(),$(Et.$$.fragment),Fh=l(),Q=a("div"),$(Fr.$$.fragment),Hh=l(),qn=a("p"),Yh=s("Loads the current states of the model, optimizer, scaler, RNG generators, and registered objects."),Bh=l(),$(At.$$.fragment),Jh=l(),X=a("div"),$(Hr.$$.fragment),Kh=l(),Un=a("p"),Qh=s("Lets the local main process go inside a with block."),Xh=l(),Vn=a("p"),Zh=s("The other processes will enter the with block after the main process exits."),em=l(),kt=a("div"),$(Yr.$$.fragment),tm=l(),we=a("p"),rm=s("Logs "),Mn=a("code"),am=s("values"),om=s(" to all stored trackers in "),Gn=a("code"),nm=s("self.trackers"),sm=s(" on the main process only."),cm=l(),Z=a("div"),$(Br.$$.fragment),lm=l(),Rn=a("p"),im=s("Lets the main process go first inside a with block."),dm=l(),Wn=a("p"),pm=s("The other processes will enter the with block after the main process exits."),hm=l(),U=a("div"),$(Jr.$$.fragment),mm=l(),Kr=a("p"),um=s(`A context manager to disable gradient synchronizations across DDP processes by calling
`),Fn=a("code"),fm=s("torch.nn.parallel.DistributedDataParallel.no_sync"),gm=s("."),_m=l(),Qr=a("p"),vm=s("If "),Hn=a("code"),$m=s("model"),bm=s(" is not in DDP, this context manager does nothing"),ym=l(),$(xt.$$.fragment),wm=l(),jt=a("div"),$(Xr.$$.fragment),Em=l(),Yn=a("p"),Am=s("A decorator that will run the decorated function on the last process only."),km=l(),Pt=a("div"),$(Zr.$$.fragment),xm=l(),Bn=a("p"),jm=s("A decorator that will run the decorated function on the local main process only."),Pm=l(),Dt=a("div"),$(ea.$$.fragment),Dm=l(),Jn=a("p"),Tm=s("A decorator that will run the decorated function on a given local process index only."),zm=l(),Tt=a("div"),$(ta.$$.fragment),Sm=l(),Kn=a("p"),Im=s("A decorator that will run the decorated function on the main process only."),Lm=l(),zt=a("div"),$(ra.$$.fragment),Om=l(),Qn=a("p"),Nm=s("A decorator that will run the decorated function on a given process index only."),Cm=l(),St=a("div"),$(aa.$$.fragment),qm=l(),Xn=a("p"),Um=s(`Recursively pad the tensors in a nested list/tuple/dictionary of tensors from all devices to the same size so
they can safely be gathered.`),Vm=l(),ee=a("div"),$(oa.$$.fragment),Mm=l(),na=a("p"),Gm=s("Prepare all objects passed in "),Zn=a("code"),Rm=s("args"),Wm=s(` for distributed training and mixed precision, then return them in the same
order.`),Fm=l(),$(It.$$.fragment),Hm=l(),Lt=a("div"),$(sa.$$.fragment),Ym=l(),ca=a("p"),Bm=s(`Prepares a PyTorch DataLoader for training in any distributed setup. It is recommended to use
`),Fa=a("a"),Jm=s("Accelerator.prepare()"),Km=s(" instead."),Qm=l(),Ot=a("div"),$(la.$$.fragment),Xm=l(),ia=a("p"),Zm=s(`Prepares a PyTorch model for training in any distributed setup. It is recommended to use
`),Ha=a("a"),eu=s("Accelerator.prepare()"),tu=s(" instead."),ru=l(),Nt=a("div"),$(da.$$.fragment),au=l(),pa=a("p"),ou=s(`Prepares a PyTorch Optimizer for training in any distributed setup. It is recommended to use
`),Ya=a("a"),nu=s("Accelerator.prepare()"),su=s(" instead."),cu=l(),Ct=a("div"),$(ha.$$.fragment),lu=l(),ma=a("p"),iu=s(`Prepares a PyTorch Scheduler for training in any distributed setup. It is recommended to use
`),Ba=a("a"),du=s("Accelerator.prepare()"),pu=s(" instead."),hu=l(),qt=a("div"),$(ua.$$.fragment),mu=l(),fa=a("p"),uu=s("Use in replacement of "),es=a("code"),fu=s("print()"),gu=s(" to only print once per server."),_u=l(),te=a("div"),$(ga.$$.fragment),vu=l(),Ee=a("p"),$u=s("Reduce the values in "),ts=a("em"),bu=s("tensor"),yu=s(" across all processes based on "),rs=a("em"),wu=s("reduction"),Eu=s("."),Au=l(),as=a("p"),ku=s(`Note:
All processes get the reduced value.`),xu=l(),V=a("div"),$(_a.$$.fragment),ju=l(),R=a("p"),Pu=s("Makes note of "),os=a("code"),Du=s("objects"),Tu=s(" and will save or load them in during "),ns=a("code"),zu=s("save_state"),Su=s(" or "),ss=a("code"),Iu=s("load_state"),Lu=s("."),Ou=l(),cs=a("p"),Nu=s(`These should be utilized when the state is being loaded or saved in the same script. It is not designed to be
used in different scripts`),Cu=l(),$(Ut.$$.fragment),qu=l(),Vt=a("div"),$(va.$$.fragment),Uu=l(),$a=a("p"),Vu=s("Save the object passed to disk once per machine. Use in place of "),ls=a("code"),Mu=s("torch.save"),Gu=s("."),Ru=l(),re=a("div"),$(ba.$$.fragment),Wu=l(),is=a("p"),Fu=s("Saves the current states of the model, optimizer, scaler, RNG generators, and registered objects."),Hu=l(),$(Mt.$$.fragment),Yu=l(),Gt=a("div"),$(ya.$$.fragment),Bu=l(),ds=a("p"),Ju=s("Unscale the gradients in mixed precision training with AMP. This is a noop in all other settings."),Ku=l(),Rt=a("div"),$(wa.$$.fragment),Qu=l(),Ae=a("p"),Xu=s("Unwraps the "),ps=a("code"),Zu=s("model"),ef=s(" from the additional layer possible added by "),Ja=a("a"),tf=s("prepare()"),rf=s(`. Useful before saving
the model.`),af=l(),Wt=a("div"),$(Ea.$$.fragment),of=l(),hs=a("p"),nf=s(`Will stop the execution of the current process until every other process has reached that point (so this does
nothing when the script is only run in one process). Useful to do before saving a model.`),this.h()},l(t){const p=q_('[data-svelte="svelte-1phssyn"]',document.head);h=o(p,"META",{name:!0,content:!0}),p.forEach(r),x=i(t),v=o(t,"H1",{class:!0});var Aa=n(v);g=o(Aa,"A",{id:!0,class:!0,href:!0});var ms=n(g);j=o(ms,"SPAN",{});var us=n(j);b(m.$$.fragment,us),us.forEach(r),ms.forEach(r),k=i(Aa),I=o(Aa,"SPAN",{});var fs=n(I);oe=c(fs,"Accelerator"),fs.forEach(r),Aa.forEach(r),Pe=i(t),q=o(t,"P",{});var ka=n(q);ne=c(ka,"The "),S=o(ka,"A",{href:!0});var gs=n(S);ja=c(gs,"Accelerator"),gs.forEach(r),Pa=c(ka,` is the main class provided by \u{1F917} Accelerate.
It serves at the main entrypoint for the API.`),ka.forEach(r),Qt=i(t),se=o(t,"H2",{class:!0});var xa=n(se);De=o(xa,"A",{id:!0,class:!0,href:!0});var _s=n(De);mo=o(_s,"SPAN",{});var vs=n(mo);b(Xt.$$.fragment,vs),vs.forEach(r),_s.forEach(r),Sl=i(xa),uo=o(xa,"SPAN",{});var $s=n(uo);Il=c($s,"Quick adaptation of your code"),$s.forEach(r),xa.forEach(r),Os=i(t),Da=o(t,"P",{});var bs=n(Da);Ll=c(bs,"To quickly adapt your script to work on any kind of setup with \u{1F917} Accelerate just:"),bs.forEach(r),Ns=i(t),W=o(t,"OL",{});var ke=n(W);ce=o(ke,"LI",{});var xe=n(ce);Ol=c(xe,"Initialize an "),Ta=o(xe,"A",{href:!0});var cf=n(Ta);Nl=c(cf,"Accelerator"),cf.forEach(r),Cl=c(xe," object (that we will call "),fo=o(xe,"CODE",{});var lf=n(fo);ql=c(lf,"accelerator"),lf.forEach(r),Ul=c(xe," throughout this page) as early as possible in your script."),xe.forEach(r),Vl=i(ke),Zt=o(ke,"LI",{});var yc=n(Zt);Ml=c(yc,"Pass your dataloader(s), model(s), optimizer(s), and scheduler(s) to the "),za=o(yc,"A",{href:!0});var df=n(za);Gl=c(df,"prepare()"),df.forEach(r),Rl=c(yc," method."),yc.forEach(r),Wl=i(ke),M=o(ke,"LI",{});var Ft=n(M);Fl=c(Ft,"Remove all the "),go=o(Ft,"CODE",{});var pf=n(go);Hl=c(pf,".cuda()"),pf.forEach(r),Yl=c(Ft," or "),_o=o(Ft,"CODE",{});var hf=n(_o);Bl=c(hf,".to(device)"),hf.forEach(r),Jl=c(Ft," from your code and let the "),vo=o(Ft,"CODE",{});var mf=n(vo);Kl=c(mf,"accelerator"),mf.forEach(r),Ql=c(Ft," handle the device placement for you."),Ft.forEach(r),ke.forEach(r),Cs=i(t),b(Te.$$.fragment,t),qs=i(t),le=o(t,"OL",{start:!0});var wc=n(le);ze=o(wc,"LI",{});var ys=n(ze);Xl=c(ys,"Replace "),$o=o(ys,"CODE",{});var uf=n($o);Zl=c(uf,"loss.backward()"),uf.forEach(r),ei=c(ys," in your code with "),bo=o(ys,"CODE",{});var ff=n(bo);ti=c(ff,"accelerator.backward(loss)"),ff.forEach(r),ys.forEach(r),ri=i(wc),Sa=o(wc,"LI",{});var sf=n(Sa);ai=c(sf,"Gather your predictions and labels before storing them or using them for metric computation using "),Ia=o(sf,"A",{href:!0});var gf=n(Ia);oi=c(gf,"gather()"),gf.forEach(r),sf.forEach(r),wc.forEach(r),Us=i(t),b(Se.$$.fragment,t),Vs=i(t),Ie=o(t,"P",{});var Ec=n(Ie);ni=c(Ec,`In most cases this is all that is needed. The next section lists a few more advanced use cases and nice features
you should search for and replace by the corresponding methods of your `),yo=o(Ec,"CODE",{});var _f=n(yo);si=c(_f,"accelerator"),_f.forEach(r),ci=c(Ec,":"),Ec.forEach(r),Ms=i(t),ie=o(t,"H2",{class:!0});var Ac=n(ie);Le=o(Ac,"A",{id:!0,class:!0,href:!0});var vf=n(Le);wo=o(vf,"SPAN",{});var $f=n(wo);b(er.$$.fragment,$f),$f.forEach(r),vf.forEach(r),li=i(Ac),Eo=o(Ac,"SPAN",{});var bf=n(Eo);ii=c(bf,"Advanced recommendations"),bf.forEach(r),Ac.forEach(r),Gs=i(t),de=o(t,"H3",{class:!0});var kc=n(de);Oe=o(kc,"A",{id:!0,class:!0,href:!0});var yf=n(Oe);Ao=o(yf,"SPAN",{});var wf=n(Ao);b(tr.$$.fragment,wf),wf.forEach(r),yf.forEach(r),di=i(kc),ko=o(kc,"SPAN",{});var Ef=n(ko);pi=c(Ef,"Printing"),Ef.forEach(r),kc.forEach(r),Rs=i(t),pe=o(t,"P",{});var ws=n(pe);xo=o(ws,"CODE",{});var Af=n(xo);hi=c(Af,"print"),Af.forEach(r),mi=c(ws," statements should be replaced by "),La=o(ws,"A",{href:!0});var kf=n(La);ui=c(kf,"print()"),kf.forEach(r),fi=c(ws," to be printed once per process"),ws.forEach(r),Ws=i(t),b(rr.$$.fragment,t),Fs=i(t),he=o(t,"H3",{class:!0});var xc=n(he);Ne=o(xc,"A",{id:!0,class:!0,href:!0});var xf=n(Ne);jo=o(xf,"SPAN",{});var jf=n(jo);b(ar.$$.fragment,jf),jf.forEach(r),xf.forEach(r),gi=i(xc),Po=o(xc,"SPAN",{});var Pf=n(Po);_i=c(Pf,"Executing processes"),Pf.forEach(r),xc.forEach(r),Hs=i(t),me=o(t,"H4",{class:!0});var jc=n(me);Ce=o(jc,"A",{id:!0,class:!0,href:!0});var Df=n(Ce);Do=o(Df,"SPAN",{});var Tf=n(Do);b(or.$$.fragment,Tf),Tf.forEach(r),Df.forEach(r),vi=i(jc),To=o(jc,"SPAN",{});var zf=n(To);$i=c(zf,"Once on a single server"),zf.forEach(r),jc.forEach(r),Ys=i(t),qe=o(t,"P",{});var Pc=n(qe);bi=c(Pc,"For statements that should be executed once per server, use "),zo=o(Pc,"CODE",{});var Sf=n(zo);yi=c(Sf,"is_local_main_process"),Sf.forEach(r),wi=c(Pc,":"),Pc.forEach(r),Bs=i(t),b(nr.$$.fragment,t),Js=i(t),Ue=o(t,"P",{});var Dc=n(Ue);Ei=c(Dc,"A function can be wrapped using the "),Oa=o(Dc,"A",{href:!0});var If=n(Oa);Ai=c(If,"on_local_main_process()"),If.forEach(r),ki=c(Dc,` function to achieve the same
behavior on a function\u2019s execution:`),Dc.forEach(r),Ks=i(t),b(sr.$$.fragment,t),Qs=i(t),ue=o(t,"H4",{class:!0});var Tc=n(ue);Ve=o(Tc,"A",{id:!0,class:!0,href:!0});var Lf=n(Ve);So=o(Lf,"SPAN",{});var Of=n(So);b(cr.$$.fragment,Of),Of.forEach(r),Lf.forEach(r),xi=i(Tc),Io=o(Tc,"SPAN",{});var Nf=n(Io);ji=c(Nf,"Only ever once across all servers"),Nf.forEach(r),Tc.forEach(r),Xs=i(t),Me=o(t,"P",{});var zc=n(Me);Pi=c(zc,"For statements that should only ever be executed once, use "),Lo=o(zc,"CODE",{});var Cf=n(Lo);Di=c(Cf,"is_main_process"),Cf.forEach(r),Ti=c(zc,":"),zc.forEach(r),Zs=i(t),b(lr.$$.fragment,t),ec=i(t),Ge=o(t,"P",{});var Sc=n(Ge);zi=c(Sc,"A function can be wrapped using the "),Na=o(Sc,"A",{href:!0});var qf=n(Na);Si=c(qf,"on_main_process()"),qf.forEach(r),Ii=c(Sc,` function to achieve the same
behavior on a function\u2019s execution:`),Sc.forEach(r),tc=i(t),b(ir.$$.fragment,t),rc=i(t),fe=o(t,"H4",{class:!0});var Ic=n(fe);Re=o(Ic,"A",{id:!0,class:!0,href:!0});var Uf=n(Re);Oo=o(Uf,"SPAN",{});var Vf=n(Oo);b(dr.$$.fragment,Vf),Vf.forEach(r),Uf.forEach(r),Li=i(Ic),No=o(Ic,"SPAN",{});var Mf=n(No);Oi=c(Mf,"On specific processes"),Mf.forEach(r),Ic.forEach(r),ac=i(t),Ca=o(t,"P",{});var Gf=n(Ca);Ni=c(Gf,`If a function should be ran on a specific overall or local process index, there are similar decorators
to achieve this:`),Gf.forEach(r),oc=i(t),b(pr.$$.fragment,t),nc=i(t),b(hr.$$.fragment,t),sc=i(t),ge=o(t,"H3",{class:!0});var Lc=n(ge);We=o(Lc,"A",{id:!0,class:!0,href:!0});var Rf=n(We);Co=o(Rf,"SPAN",{});var Wf=n(Co);b(mr.$$.fragment,Wf),Wf.forEach(r),Rf.forEach(r),Ci=i(Lc),qo=o(Lc,"SPAN",{});var Ff=n(qo);qi=c(Ff,"Synchronicity control"),Ff.forEach(r),Lc.forEach(r),cc=i(t),Fe=o(t,"P",{});var Oc=n(Fe);Ui=c(Oc,"Use "),qa=o(Oc,"A",{href:!0});var Hf=n(qa);Vi=c(Hf,"wait_for_everyone()"),Hf.forEach(r),Mi=c(Oc," to make sure all processes join that point before continuing. (Useful before a model save for instance)"),Oc.forEach(r),lc=i(t),_e=o(t,"H3",{class:!0});var Nc=n(_e);He=o(Nc,"A",{id:!0,class:!0,href:!0});var Yf=n(He);Uo=o(Yf,"SPAN",{});var Bf=n(Uo);b(ur.$$.fragment,Bf),Bf.forEach(r),Yf.forEach(r),Gi=i(Nc),Vo=o(Nc,"SPAN",{});var Jf=n(Vo);Ri=c(Jf,"Saving and loading"),Jf.forEach(r),Nc.forEach(r),ic=i(t),Ye=o(t,"P",{});var Cc=n(Ye);Wi=c(Cc,"Use "),Ua=o(Cc,"A",{href:!0});var Kf=n(Ua);Fi=c(Kf,"unwrap_model()"),Kf.forEach(r),Hi=c(Cc," before saving to remove all special model wrappers added during the distributed process."),Cc.forEach(r),dc=i(t),b(fr.$$.fragment,t),pc=i(t),F=o(t,"P",{});var Ka=n(F);Yi=c(Ka,"Use "),Va=o(Ka,"A",{href:!0});var Qf=n(Va);Bi=c(Qf,"save()"),Qf.forEach(r),Ji=c(Ka," instead of "),Mo=o(Ka,"CODE",{});var Xf=n(Mo);Ki=c(Xf,"torch.save"),Xf.forEach(r),Qi=c(Ka,":"),Ka.forEach(r),hc=i(t),b(gr.$$.fragment,t),mc=i(t),ve=o(t,"H3",{class:!0});var qc=n(ve);Be=o(qc,"A",{id:!0,class:!0,href:!0});var Zf=n(Be);Go=o(Zf,"SPAN",{});var eg=n(Go);b(_r.$$.fragment,eg),eg.forEach(r),Zf.forEach(r),Xi=i(qc),Ro=o(qc,"SPAN",{});var tg=n(Ro);Zi=c(tg,"Operations"),tg.forEach(r),qc.forEach(r),uc=i(t),N=o(t,"P",{});var je=n(N);ed=c(je,"Use "),Je=o(je,"A",{href:!0});var Uc=n(Je);td=c(Uc,"clip"),Wo=o(Uc,"EM",{});var rg=n(Wo);rd=c(rg,"grad_norm"),rg.forEach(r),ad=c(Uc,"()"),Uc.forEach(r),od=c(je," instead of "),Fo=o(je,"CODE",{});var ag=n(Fo);nd=c(ag,"torch.nn.utils.clip_grad_norm_"),ag.forEach(r),sd=c(je," and "),Ke=o(je,"A",{href:!0});var Vc=n(Ke);cd=c(Vc,"clip"),Ho=o(Vc,"EM",{});var og=n(Ho);ld=c(og,"grad_value"),og.forEach(r),id=c(Vc,"()"),Vc.forEach(r),dd=c(je," instead of "),Yo=o(je,"CODE",{});var ng=n(Yo);pd=c(ng,"torch.nn.utils.clip_grad_value"),ng.forEach(r),je.forEach(r),fc=i(t),$e=o(t,"H3",{class:!0});var Mc=n($e);Qe=o(Mc,"A",{id:!0,class:!0,href:!0});var sg=n(Qe);Bo=o(sg,"SPAN",{});var cg=n(Bo);b(vr.$$.fragment,cg),cg.forEach(r),sg.forEach(r),hd=i(Mc),Jo=o(Mc,"SPAN",{});var lg=n(Jo);md=c(lg,"Gradient Accumulation"),lg.forEach(r),Mc.forEach(r),gc=i(t),Xe=o(t,"P",{});var Gc=n(Xe);ud=c(Gc,"To perform gradient accumulation use "),Ma=o(Gc,"A",{href:!0});var ig=n(Ma);fd=c(ig,"accumulate()"),ig.forEach(r),gd=c(Gc,` and specify a gradient_accumulation_steps.
This will also automatically ensure the gradients are synced or unsynced when on
multi-device training, check if the step should actually be performed, and auto-scale the loss:`),Gc.forEach(r),_c=i(t),b($r.$$.fragment,t),vc=i(t),be=o(t,"H2",{class:!0});var Rc=n(be);Ze=o(Rc,"A",{id:!0,class:!0,href:!0});var dg=n(Ze);Ko=o(dg,"SPAN",{});var pg=n(Ko);b(br.$$.fragment,pg),pg.forEach(r),dg.forEach(r),_d=i(Rc),Qo=o(Rc,"SPAN",{});var hg=n(Qo);vd=c(hg,"Overall API documentation:"),hg.forEach(r),Rc.forEach(r),$c=i(t),f=o(t,"DIV",{class:!0});var _=n(f);b(yr.$$.fragment,_),$d=i(_),Xo=o(_,"P",{});var mg=n(Xo);bd=c(mg,"Creates an instance of an accelerator for distributed training (on multi-GPU, TPU) or mixed precision training."),mg.forEach(r),yd=i(_),Zo=o(_,"P",{});var ug=n(Zo);en=o(ug,"STRONG",{});var fg=n(en);wd=c(fg,"Available attributes:"),fg.forEach(r),ug.forEach(r),Ed=i(_),T=o(_,"UL",{});var z=n(T);et=o(z,"LI",{});var Es=n(et);tn=o(Es,"STRONG",{});var gg=n(tn);Ad=c(gg,"device"),gg.forEach(r),kd=c(Es," ("),rn=o(Es,"CODE",{});var _g=n(rn);xd=c(_g,"torch.device"),_g.forEach(r),jd=c(Es,") \u2014 The device to use."),Es.forEach(r),Pd=i(z),tt=o(z,"LI",{});var As=n(tt);an=o(As,"STRONG",{});var vg=n(an);Dd=c(vg,"distributed_type"),vg.forEach(r),Td=c(As," ("),Ga=o(As,"A",{href:!0});var $g=n(Ga);zd=c($g,"DistributedType"),$g.forEach(r),Sd=c(As,") \u2014 The distributed training configuration."),As.forEach(r),Id=i(z),rt=o(z,"LI",{});var ks=n(rt);on=o(ks,"STRONG",{});var bg=n(on);Ld=c(bg,"local_process_index"),bg.forEach(r),Od=c(ks," ("),nn=o(ks,"CODE",{});var yg=n(nn);Nd=c(yg,"int"),yg.forEach(r),Cd=c(ks,") \u2014 The process index on the current machine."),ks.forEach(r),qd=i(z),at=o(z,"LI",{});var xs=n(at);sn=o(xs,"STRONG",{});var wg=n(sn);Ud=c(wg,"mixed_precision"),wg.forEach(r),Vd=c(xs," ("),cn=o(xs,"CODE",{});var Eg=n(cn);Md=c(Eg,"str"),Eg.forEach(r),Gd=c(xs,") \u2014 The configured mixed precision mode."),xs.forEach(r),Rd=i(z),ot=o(z,"LI",{});var js=n(ot);ln=o(js,"STRONG",{});var Ag=n(ln);Wd=c(Ag,"num_processes"),Ag.forEach(r),Fd=c(js," ("),dn=o(js,"CODE",{});var kg=n(dn);Hd=c(kg,"int"),kg.forEach(r),Yd=c(js,") \u2014 The total number of processes used for training."),js.forEach(r),Bd=i(z),nt=o(z,"LI",{});var Ps=n(nt);pn=o(Ps,"STRONG",{});var xg=n(pn);Jd=c(xg,"optimizer_step_was_skipped"),xg.forEach(r),Kd=c(Ps," ("),hn=o(Ps,"CODE",{});var jg=n(hn);Qd=c(jg,"bool"),jg.forEach(r),Xd=c(Ps,`) \u2014 Whether or not the optimizer update was skipped (because of
gradient overflow in mixed precision), in which
case the learning rate should not be changed.`),Ps.forEach(r),Zd=i(z),st=o(z,"LI",{});var Ds=n(st);mn=o(Ds,"STRONG",{});var Pg=n(mn);ep=c(Pg,"process_index"),Pg.forEach(r),tp=c(Ds," ("),un=o(Ds,"CODE",{});var Dg=n(un);rp=c(Dg,"int"),Dg.forEach(r),ap=c(Ds,") \u2014 The overall index of the current process among all processes."),Ds.forEach(r),op=i(z),ct=o(z,"LI",{});var Ts=n(ct);fn=o(Ts,"STRONG",{});var Tg=n(fn);np=c(Tg,"state"),Tg.forEach(r),sp=c(Ts," ("),Ra=o(Ts,"A",{href:!0});var zg=n(Ra);cp=c(zg,"AcceleratorState"),zg.forEach(r),lp=c(Ts,") \u2014 The distributed setup state."),Ts.forEach(r),ip=i(z),lt=o(z,"LI",{});var zs=n(lt);gn=o(zs,"STRONG",{});var Sg=n(gn);dp=c(Sg,"sync_gradients"),Sg.forEach(r),pp=c(zs," ("),_n=o(zs,"CODE",{});var Ig=n(_n);hp=c(Ig,"bool"),Ig.forEach(r),mp=c(zs,") \u2014 Whether the gradients are currently being synced across all processes."),zs.forEach(r),up=i(z),it=o(z,"LI",{});var Ss=n(it);vn=o(Ss,"STRONG",{});var Lg=n(vn);fp=c(Lg,"use_distributed"),Lg.forEach(r),gp=c(Ss," ("),$n=o(Ss,"CODE",{});var Og=n($n);_p=c(Og,"bool"),Og.forEach(r),vp=c(Ss,") \u2014 Whether the current configuration is for distributed training."),Ss.forEach(r),z.forEach(r),$p=i(_),H=o(_,"DIV",{class:!0});var Qa=n(H);b(wr.$$.fragment,Qa),bp=i(Qa),bn=o(Qa,"P",{});var Ng=n(bn);yp=c(Ng,"A context manager that will lightly wrap around and perform gradient accumulation automatically"),Ng.forEach(r),wp=i(Qa),b(dt.$$.fragment,Qa),Qa.forEach(r),Ep=i(_),pt=o(_,"DIV",{class:!0});var Wc=n(pt);b(Er.$$.fragment,Wc),Ap=i(Wc),yn=o(Wc,"P",{});var Cg=n(yn);kp=c(Cg,`Will apply automatic mixed-precision inside the block inside this context manager, if it is enabled. Nothing
different will happen otherwise.`),Cg.forEach(r),Wc.forEach(r),xp=i(_),Y=o(_,"DIV",{class:!0});var Xa=n(Y);b(Ar.$$.fragment,Xa),jp=i(Xa),ye=o(Xa,"P",{});var Za=n(ye);Pp=c(Za,"Scales the gradients in accordance to "),wn=o(Za,"CODE",{});var qg=n(wn);Dp=c(qg,"Accelerator.gradient_accumulation_steps"),qg.forEach(r),Tp=c(Za,` and calls the correct
`),En=o(Za,"CODE",{});var Ug=n(En);zp=c(Ug,"backward()"),Ug.forEach(r),Sp=c(Za," based on the configuration."),Za.forEach(r),Ip=i(Xa),kr=o(Xa,"P",{});var Fc=n(kr);Lp=c(Fc,"Should be used in lieu of "),An=o(Fc,"CODE",{});var Vg=n(An);Op=c(Vg,"loss.backward()"),Vg.forEach(r),Np=c(Fc,"."),Fc.forEach(r),Xa.forEach(r),Cp=i(_),ht=o(_,"DIV",{class:!0});var Hc=n(ht);b(xr.$$.fragment,Hc),qp=i(Hc),jr=o(Hc,"P",{});var Yc=n(jr);Up=c(Yc,"Alias for "),kn=o(Yc,"CODE",{});var Mg=n(kn);Vp=c(Mg,"Accelerate.free_memory"),Mg.forEach(r),Mp=c(Yc,`, releases all references to the internal objects stored and call the
garbage collector. You should call this method between two trainings with different models/optimizers.`),Yc.forEach(r),Hc.forEach(r),Gp=i(_),B=o(_,"DIV",{class:!0});var eo=n(B);b(Pr.$$.fragment,eo),Rp=i(eo),Dr=o(eo,"P",{});var Bc=n(Dr);Wp=c(Bc,"Should be used in place of "),xn=o(Bc,"CODE",{});var Gg=n(xn);Fp=c(Gg,"torch.nn.utils.clip_grad_norm_"),Gg.forEach(r),Hp=c(Bc,"."),Bc.forEach(r),Yp=i(eo),b(mt.$$.fragment,eo),eo.forEach(r),Bp=i(_),J=o(_,"DIV",{class:!0});var to=n(J);b(Tr.$$.fragment,to),Jp=i(to),zr=o(to,"P",{});var Jc=n(zr);Kp=c(Jc,"Should be used in place of "),jn=o(Jc,"CODE",{});var Rg=n(jn);Qp=c(Rg,"torch.nn.utils.clip_grad_value_"),Rg.forEach(r),Xp=c(Jc,"."),Jc.forEach(r),Zp=i(to),b(ut.$$.fragment,to),to.forEach(r),eh=i(_),ft=o(_,"DIV",{class:!0});var Kc=n(ft);b(Sr.$$.fragment,Kc),th=i(Kc),Pn=o(Kc,"P",{});var Wg=n(Pn);rh=c(Wg,`Runs any special end training behaviors, such as stopping trackers on the main process only. Should always be
called at the end of your script if using experiment tracking.`),Wg.forEach(r),Kc.forEach(r),ah=i(_),gt=o(_,"DIV",{class:!0});var Qc=n(gt);b(Ir.$$.fragment,Qc),oh=i(Qc),Dn=o(Qc,"P",{});var Fg=n(Dn);nh=c(Fg,`Will release all references to the internal objects stored and call the garbage collector. You should call this
method between two trainings with different models/optimizers.`),Fg.forEach(r),Qc.forEach(r),sh=i(_),K=o(_,"DIV",{class:!0});var ro=n(K);b(Lr.$$.fragment,ro),ch=i(ro),Or=o(ro,"P",{});var Xc=n(Or);lh=c(Xc,"Gather the values in "),Tn=o(Xc,"EM",{});var Hg=n(Tn);ih=c(Hg,"tensor"),Hg.forEach(r),dh=c(Xc,` across all processes and concatenate them on the first dimension. Useful to
regroup the predictions from all processes when doing evaluation.`),Xc.forEach(r),ph=i(ro),zn=o(ro,"P",{});var Yg=n(zn);hh=c(Yg,`Note:
This gather happens in all processes.`),Yg.forEach(r),ro.forEach(r),mh=i(_),_t=o(_,"DIV",{class:!0});var Zc=n(_t);b(Nr.$$.fragment,Zc),uh=i(Zc),Cr=o(Zc,"P",{});var el=n(Cr);fh=c(el,"Gathers "),Sn=o(el,"CODE",{});var Bg=n(Sn);gh=c(Bg,"tensor"),Bg.forEach(r),_h=c(el,` and potentially drops duplicates in the last batch if on a distributed system. Should be used
for gathering the inputs and targets for metric calculation.`),el.forEach(r),Zc.forEach(r),vh=i(_),vt=o(_,"DIV",{class:!0});var tl=n(vt);b(qr.$$.fragment,tl),$h=i(tl),Ur=o(tl,"P",{});var rl=n(Ur);bh=c(rl,"Returns the state dictionary of a model sent through "),Wa=o(rl,"A",{href:!0});var Jg=n(Wa);yh=c(Jg,"Accelerator.prepare()"),Jg.forEach(r),wh=c(rl," in full precision"),rl.forEach(r),tl.forEach(r),Eh=i(_),$t=o(_,"DIV",{class:!0});var al=n($t);b(Vr.$$.fragment,al),Ah=i(al),G=o(al,"P",{});var Ht=n(G);kh=c(Ht,"Returns a "),In=o(Ht,"CODE",{});var Kg=n(In);xh=c(Kg,"tracker"),Kg.forEach(r),jh=c(Ht," from "),Ln=o(Ht,"CODE",{});var Qg=n(Ln);Ph=c(Qg,"self.trackers"),Qg.forEach(r),Dh=c(Ht," based on "),On=o(Ht,"CODE",{});var Xg=n(On);Th=c(Xg,"name"),Xg.forEach(r),zh=c(Ht," on the main process only."),Ht.forEach(r),al.forEach(r),Sh=i(_),bt=o(_,"DIV",{class:!0});var ol=n(bt);b(Mr.$$.fragment,ol),Ih=i(ol),Gr=o(ol,"P",{});var nl=n(Gr);Lh=c(nl,"Initializes a run for all trackers stored in "),Nn=o(nl,"CODE",{});var Zg=n(Nn);Oh=c(Zg,"self.log_with"),Zg.forEach(r),Nh=c(nl,", potentially with starting configurations"),nl.forEach(r),ol.forEach(r),Ch=i(_),O=o(_,"DIV",{class:!0});var ae=n(O);b(Rr.$$.fragment,ae),qh=i(ae),Wr=o(ae,"P",{});var sl=n(Wr);Uh=c(sl,`A context manager that facilitates distributed training or evaluation on uneven inputs, which acts as a wrapper
around `),Cn=o(sl,"CODE",{});var e_=n(Cn);Vh=c(e_,"torch.distributed.algorithms.join"),e_.forEach(r),Mh=c(sl,`. This is useful when the total batch size does not evenly divide the
length of the dataset.`),sl.forEach(r),Gh=i(ae),b(yt.$$.fragment,ae),Rh=i(ae),b(wt.$$.fragment,ae),Wh=i(ae),b(Et.$$.fragment,ae),ae.forEach(r),Fh=i(_),Q=o(_,"DIV",{class:!0});var ao=n(Q);b(Fr.$$.fragment,ao),Hh=i(ao),qn=o(ao,"P",{});var t_=n(qn);Yh=c(t_,"Loads the current states of the model, optimizer, scaler, RNG generators, and registered objects."),t_.forEach(r),Bh=i(ao),b(At.$$.fragment,ao),ao.forEach(r),Jh=i(_),X=o(_,"DIV",{class:!0});var oo=n(X);b(Hr.$$.fragment,oo),Kh=i(oo),Un=o(oo,"P",{});var r_=n(Un);Qh=c(r_,"Lets the local main process go inside a with block."),r_.forEach(r),Xh=i(oo),Vn=o(oo,"P",{});var a_=n(Vn);Zh=c(a_,"The other processes will enter the with block after the main process exits."),a_.forEach(r),oo.forEach(r),em=i(_),kt=o(_,"DIV",{class:!0});var cl=n(kt);b(Yr.$$.fragment,cl),tm=i(cl),we=o(cl,"P",{});var no=n(we);rm=c(no,"Logs "),Mn=o(no,"CODE",{});var o_=n(Mn);am=c(o_,"values"),o_.forEach(r),om=c(no," to all stored trackers in "),Gn=o(no,"CODE",{});var n_=n(Gn);nm=c(n_,"self.trackers"),n_.forEach(r),sm=c(no," on the main process only."),no.forEach(r),cl.forEach(r),cm=i(_),Z=o(_,"DIV",{class:!0});var so=n(Z);b(Br.$$.fragment,so),lm=i(so),Rn=o(so,"P",{});var s_=n(Rn);im=c(s_,"Lets the main process go first inside a with block."),s_.forEach(r),dm=i(so),Wn=o(so,"P",{});var c_=n(Wn);pm=c(c_,"The other processes will enter the with block after the main process exits."),c_.forEach(r),so.forEach(r),hm=i(_),U=o(_,"DIV",{class:!0});var Yt=n(U);b(Jr.$$.fragment,Yt),mm=i(Yt),Kr=o(Yt,"P",{});var ll=n(Kr);um=c(ll,`A context manager to disable gradient synchronizations across DDP processes by calling
`),Fn=o(ll,"CODE",{});var l_=n(Fn);fm=c(l_,"torch.nn.parallel.DistributedDataParallel.no_sync"),l_.forEach(r),gm=c(ll,"."),ll.forEach(r),_m=i(Yt),Qr=o(Yt,"P",{});var il=n(Qr);vm=c(il,"If "),Hn=o(il,"CODE",{});var i_=n(Hn);$m=c(i_,"model"),i_.forEach(r),bm=c(il," is not in DDP, this context manager does nothing"),il.forEach(r),ym=i(Yt),b(xt.$$.fragment,Yt),Yt.forEach(r),wm=i(_),jt=o(_,"DIV",{class:!0});var dl=n(jt);b(Xr.$$.fragment,dl),Em=i(dl),Yn=o(dl,"P",{});var d_=n(Yn);Am=c(d_,"A decorator that will run the decorated function on the last process only."),d_.forEach(r),dl.forEach(r),km=i(_),Pt=o(_,"DIV",{class:!0});var pl=n(Pt);b(Zr.$$.fragment,pl),xm=i(pl),Bn=o(pl,"P",{});var p_=n(Bn);jm=c(p_,"A decorator that will run the decorated function on the local main process only."),p_.forEach(r),pl.forEach(r),Pm=i(_),Dt=o(_,"DIV",{class:!0});var hl=n(Dt);b(ea.$$.fragment,hl),Dm=i(hl),Jn=o(hl,"P",{});var h_=n(Jn);Tm=c(h_,"A decorator that will run the decorated function on a given local process index only."),h_.forEach(r),hl.forEach(r),zm=i(_),Tt=o(_,"DIV",{class:!0});var ml=n(Tt);b(ta.$$.fragment,ml),Sm=i(ml),Kn=o(ml,"P",{});var m_=n(Kn);Im=c(m_,"A decorator that will run the decorated function on the main process only."),m_.forEach(r),ml.forEach(r),Lm=i(_),zt=o(_,"DIV",{class:!0});var ul=n(zt);b(ra.$$.fragment,ul),Om=i(ul),Qn=o(ul,"P",{});var u_=n(Qn);Nm=c(u_,"A decorator that will run the decorated function on a given process index only."),u_.forEach(r),ul.forEach(r),Cm=i(_),St=o(_,"DIV",{class:!0});var fl=n(St);b(aa.$$.fragment,fl),qm=i(fl),Xn=o(fl,"P",{});var f_=n(Xn);Um=c(f_,`Recursively pad the tensors in a nested list/tuple/dictionary of tensors from all devices to the same size so
they can safely be gathered.`),f_.forEach(r),fl.forEach(r),Vm=i(_),ee=o(_,"DIV",{class:!0});var co=n(ee);b(oa.$$.fragment,co),Mm=i(co),na=o(co,"P",{});var gl=n(na);Gm=c(gl,"Prepare all objects passed in "),Zn=o(gl,"CODE",{});var g_=n(Zn);Rm=c(g_,"args"),g_.forEach(r),Wm=c(gl,` for distributed training and mixed precision, then return them in the same
order.`),gl.forEach(r),Fm=i(co),b(It.$$.fragment,co),co.forEach(r),Hm=i(_),Lt=o(_,"DIV",{class:!0});var _l=n(Lt);b(sa.$$.fragment,_l),Ym=i(_l),ca=o(_l,"P",{});var vl=n(ca);Bm=c(vl,`Prepares a PyTorch DataLoader for training in any distributed setup. It is recommended to use
`),Fa=o(vl,"A",{href:!0});var __=n(Fa);Jm=c(__,"Accelerator.prepare()"),__.forEach(r),Km=c(vl," instead."),vl.forEach(r),_l.forEach(r),Qm=i(_),Ot=o(_,"DIV",{class:!0});var $l=n(Ot);b(la.$$.fragment,$l),Xm=i($l),ia=o($l,"P",{});var bl=n(ia);Zm=c(bl,`Prepares a PyTorch model for training in any distributed setup. It is recommended to use
`),Ha=o(bl,"A",{href:!0});var v_=n(Ha);eu=c(v_,"Accelerator.prepare()"),v_.forEach(r),tu=c(bl," instead."),bl.forEach(r),$l.forEach(r),ru=i(_),Nt=o(_,"DIV",{class:!0});var yl=n(Nt);b(da.$$.fragment,yl),au=i(yl),pa=o(yl,"P",{});var wl=n(pa);ou=c(wl,`Prepares a PyTorch Optimizer for training in any distributed setup. It is recommended to use
`),Ya=o(wl,"A",{href:!0});var $_=n(Ya);nu=c($_,"Accelerator.prepare()"),$_.forEach(r),su=c(wl," instead."),wl.forEach(r),yl.forEach(r),cu=i(_),Ct=o(_,"DIV",{class:!0});var El=n(Ct);b(ha.$$.fragment,El),lu=i(El),ma=o(El,"P",{});var Al=n(ma);iu=c(Al,`Prepares a PyTorch Scheduler for training in any distributed setup. It is recommended to use
`),Ba=o(Al,"A",{href:!0});var b_=n(Ba);du=c(b_,"Accelerator.prepare()"),b_.forEach(r),pu=c(Al," instead."),Al.forEach(r),El.forEach(r),hu=i(_),qt=o(_,"DIV",{class:!0});var kl=n(qt);b(ua.$$.fragment,kl),mu=i(kl),fa=o(kl,"P",{});var xl=n(fa);uu=c(xl,"Use in replacement of "),es=o(xl,"CODE",{});var y_=n(es);fu=c(y_,"print()"),y_.forEach(r),gu=c(xl," to only print once per server."),xl.forEach(r),kl.forEach(r),_u=i(_),te=o(_,"DIV",{class:!0});var lo=n(te);b(ga.$$.fragment,lo),vu=i(lo),Ee=o(lo,"P",{});var io=n(Ee);$u=c(io,"Reduce the values in "),ts=o(io,"EM",{});var w_=n(ts);bu=c(w_,"tensor"),w_.forEach(r),yu=c(io," across all processes based on "),rs=o(io,"EM",{});var E_=n(rs);wu=c(E_,"reduction"),E_.forEach(r),Eu=c(io,"."),io.forEach(r),Au=i(lo),as=o(lo,"P",{});var A_=n(as);ku=c(A_,`Note:
All processes get the reduced value.`),A_.forEach(r),lo.forEach(r),xu=i(_),V=o(_,"DIV",{class:!0});var Bt=n(V);b(_a.$$.fragment,Bt),ju=i(Bt),R=o(Bt,"P",{});var Jt=n(R);Pu=c(Jt,"Makes note of "),os=o(Jt,"CODE",{});var k_=n(os);Du=c(k_,"objects"),k_.forEach(r),Tu=c(Jt," and will save or load them in during "),ns=o(Jt,"CODE",{});var x_=n(ns);zu=c(x_,"save_state"),x_.forEach(r),Su=c(Jt," or "),ss=o(Jt,"CODE",{});var j_=n(ss);Iu=c(j_,"load_state"),j_.forEach(r),Lu=c(Jt,"."),Jt.forEach(r),Ou=i(Bt),cs=o(Bt,"P",{});var P_=n(cs);Nu=c(P_,`These should be utilized when the state is being loaded or saved in the same script. It is not designed to be
used in different scripts`),P_.forEach(r),Cu=i(Bt),b(Ut.$$.fragment,Bt),Bt.forEach(r),qu=i(_),Vt=o(_,"DIV",{class:!0});var jl=n(Vt);b(va.$$.fragment,jl),Uu=i(jl),$a=o(jl,"P",{});var Pl=n($a);Vu=c(Pl,"Save the object passed to disk once per machine. Use in place of "),ls=o(Pl,"CODE",{});var D_=n(ls);Mu=c(D_,"torch.save"),D_.forEach(r),Gu=c(Pl,"."),Pl.forEach(r),jl.forEach(r),Ru=i(_),re=o(_,"DIV",{class:!0});var po=n(re);b(ba.$$.fragment,po),Wu=i(po),is=o(po,"P",{});var T_=n(is);Fu=c(T_,"Saves the current states of the model, optimizer, scaler, RNG generators, and registered objects."),T_.forEach(r),Hu=i(po),b(Mt.$$.fragment,po),po.forEach(r),Yu=i(_),Gt=o(_,"DIV",{class:!0});var Dl=n(Gt);b(ya.$$.fragment,Dl),Bu=i(Dl),ds=o(Dl,"P",{});var z_=n(ds);Ju=c(z_,"Unscale the gradients in mixed precision training with AMP. This is a noop in all other settings."),z_.forEach(r),Dl.forEach(r),Ku=i(_),Rt=o(_,"DIV",{class:!0});var Tl=n(Rt);b(wa.$$.fragment,Tl),Qu=i(Tl),Ae=o(Tl,"P",{});var ho=n(Ae);Xu=c(ho,"Unwraps the "),ps=o(ho,"CODE",{});var S_=n(ps);Zu=c(S_,"model"),S_.forEach(r),ef=c(ho," from the additional layer possible added by "),Ja=o(ho,"A",{href:!0});var I_=n(Ja);tf=c(I_,"prepare()"),I_.forEach(r),rf=c(ho,`. Useful before saving
the model.`),ho.forEach(r),Tl.forEach(r),af=i(_),Wt=o(_,"DIV",{class:!0});var zl=n(Wt);b(Ea.$$.fragment,zl),of=i(zl),hs=o(zl,"P",{});var L_=n(hs);nf=c(L_,`Will stop the execution of the current process until every other process has reached that point (so this does
nothing when the script is only run in one process). Useful to do before saving a model.`),L_.forEach(r),zl.forEach(r),_.forEach(r),this.h()},h(){d(h,"name","hf:doc:metadata"),d(h,"content",JSON.stringify(ev)),d(g,"id","accelerator"),d(g,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(g,"href","#accelerator"),d(v,"class","relative group"),d(S,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator"),d(De,"id","quick-adaptation-of-your-code"),d(De,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(De,"href","#quick-adaptation-of-your-code"),d(se,"class","relative group"),d(Ta,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator"),d(za,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.prepare"),d(Ia,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.gather"),d(le,"start","4"),d(Le,"id","advanced-recommendations"),d(Le,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Le,"href","#advanced-recommendations"),d(ie,"class","relative group"),d(Oe,"id","printing"),d(Oe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Oe,"href","#printing"),d(de,"class","relative group"),d(La,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.print"),d(Ne,"id","executing-processes"),d(Ne,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Ne,"href","#executing-processes"),d(he,"class","relative group"),d(Ce,"id","once-on-a-single-server"),d(Ce,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Ce,"href","#once-on-a-single-server"),d(me,"class","relative group"),d(Oa,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.on_local_main_process"),d(Ve,"id","only-ever-once-across-all-servers"),d(Ve,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Ve,"href","#only-ever-once-across-all-servers"),d(ue,"class","relative group"),d(Na,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.on_main_process"),d(Re,"id","on-specific-processes"),d(Re,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Re,"href","#on-specific-processes"),d(fe,"class","relative group"),d(We,"id","synchronicity-control"),d(We,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(We,"href","#synchronicity-control"),d(ge,"class","relative group"),d(qa,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.wait_for_everyone"),d(He,"id","saving-and-loading"),d(He,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(He,"href","#saving-and-loading"),d(_e,"class","relative group"),d(Ua,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.unwrap_model"),d(Va,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.save"),d(Be,"id","operations"),d(Be,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Be,"href","#operations"),d(ve,"class","relative group"),d(Je,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.clip_grad_norm_"),d(Ke,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.clip_grad_value_"),d(Qe,"id","gradient-accumulation"),d(Qe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Qe,"href","#gradient-accumulation"),d($e,"class","relative group"),d(Ma,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.accumulate"),d(Ze,"id","accelerate.Accelerator"),d(Ze,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Ze,"href","#accelerate.Accelerator"),d(be,"class","relative group"),d(Ga,"href","/docs/accelerate/main/en/package_reference/utilities#accelerate.DistributedType"),d(Ra,"href","/docs/accelerate/main/en/package_reference/state#accelerate.state.AcceleratorState"),d(H,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(pt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Y,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ht,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(B,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(J,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ft,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(gt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(K,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(_t,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Wa,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.prepare"),d(vt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d($t,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(bt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(O,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(X,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(kt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(U,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(jt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Pt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Dt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Tt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(zt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(St,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Fa,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.prepare"),d(Lt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ha,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.prepare"),d(Ot,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ya,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.prepare"),d(Nt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ba,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.prepare"),d(Ct,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(qt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(te,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(V,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Vt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(re,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Gt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ja,"href","/docs/accelerate/main/en/package_reference/accelerator#accelerate.Accelerator.prepare"),d(Rt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Wt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(f,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,p){e(document.head,h),u(t,x,p),u(t,v,p),e(v,g),e(g,j),y(m,j,null),e(v,k),e(v,I),e(I,oe),u(t,Pe,p),u(t,q,p),e(q,ne),e(q,S),e(S,ja),e(q,Pa),u(t,Qt,p),u(t,se,p),e(se,De),e(De,mo),y(Xt,mo,null),e(se,Sl),e(se,uo),e(uo,Il),u(t,Os,p),u(t,Da,p),e(Da,Ll),u(t,Ns,p),u(t,W,p),e(W,ce),e(ce,Ol),e(ce,Ta),e(Ta,Nl),e(ce,Cl),e(ce,fo),e(fo,ql),e(ce,Ul),e(W,Vl),e(W,Zt),e(Zt,Ml),e(Zt,za),e(za,Gl),e(Zt,Rl),e(W,Wl),e(W,M),e(M,Fl),e(M,go),e(go,Hl),e(M,Yl),e(M,_o),e(_o,Bl),e(M,Jl),e(M,vo),e(vo,Kl),e(M,Ql),u(t,Cs,p),y(Te,t,p),u(t,qs,p),u(t,le,p),e(le,ze),e(ze,Xl),e(ze,$o),e($o,Zl),e(ze,ei),e(ze,bo),e(bo,ti),e(le,ri),e(le,Sa),e(Sa,ai),e(Sa,Ia),e(Ia,oi),u(t,Us,p),y(Se,t,p),u(t,Vs,p),u(t,Ie,p),e(Ie,ni),e(Ie,yo),e(yo,si),e(Ie,ci),u(t,Ms,p),u(t,ie,p),e(ie,Le),e(Le,wo),y(er,wo,null),e(ie,li),e(ie,Eo),e(Eo,ii),u(t,Gs,p),u(t,de,p),e(de,Oe),e(Oe,Ao),y(tr,Ao,null),e(de,di),e(de,ko),e(ko,pi),u(t,Rs,p),u(t,pe,p),e(pe,xo),e(xo,hi),e(pe,mi),e(pe,La),e(La,ui),e(pe,fi),u(t,Ws,p),y(rr,t,p),u(t,Fs,p),u(t,he,p),e(he,Ne),e(Ne,jo),y(ar,jo,null),e(he,gi),e(he,Po),e(Po,_i),u(t,Hs,p),u(t,me,p),e(me,Ce),e(Ce,Do),y(or,Do,null),e(me,vi),e(me,To),e(To,$i),u(t,Ys,p),u(t,qe,p),e(qe,bi),e(qe,zo),e(zo,yi),e(qe,wi),u(t,Bs,p),y(nr,t,p),u(t,Js,p),u(t,Ue,p),e(Ue,Ei),e(Ue,Oa),e(Oa,Ai),e(Ue,ki),u(t,Ks,p),y(sr,t,p),u(t,Qs,p),u(t,ue,p),e(ue,Ve),e(Ve,So),y(cr,So,null),e(ue,xi),e(ue,Io),e(Io,ji),u(t,Xs,p),u(t,Me,p),e(Me,Pi),e(Me,Lo),e(Lo,Di),e(Me,Ti),u(t,Zs,p),y(lr,t,p),u(t,ec,p),u(t,Ge,p),e(Ge,zi),e(Ge,Na),e(Na,Si),e(Ge,Ii),u(t,tc,p),y(ir,t,p),u(t,rc,p),u(t,fe,p),e(fe,Re),e(Re,Oo),y(dr,Oo,null),e(fe,Li),e(fe,No),e(No,Oi),u(t,ac,p),u(t,Ca,p),e(Ca,Ni),u(t,oc,p),y(pr,t,p),u(t,nc,p),y(hr,t,p),u(t,sc,p),u(t,ge,p),e(ge,We),e(We,Co),y(mr,Co,null),e(ge,Ci),e(ge,qo),e(qo,qi),u(t,cc,p),u(t,Fe,p),e(Fe,Ui),e(Fe,qa),e(qa,Vi),e(Fe,Mi),u(t,lc,p),u(t,_e,p),e(_e,He),e(He,Uo),y(ur,Uo,null),e(_e,Gi),e(_e,Vo),e(Vo,Ri),u(t,ic,p),u(t,Ye,p),e(Ye,Wi),e(Ye,Ua),e(Ua,Fi),e(Ye,Hi),u(t,dc,p),y(fr,t,p),u(t,pc,p),u(t,F,p),e(F,Yi),e(F,Va),e(Va,Bi),e(F,Ji),e(F,Mo),e(Mo,Ki),e(F,Qi),u(t,hc,p),y(gr,t,p),u(t,mc,p),u(t,ve,p),e(ve,Be),e(Be,Go),y(_r,Go,null),e(ve,Xi),e(ve,Ro),e(Ro,Zi),u(t,uc,p),u(t,N,p),e(N,ed),e(N,Je),e(Je,td),e(Je,Wo),e(Wo,rd),e(Je,ad),e(N,od),e(N,Fo),e(Fo,nd),e(N,sd),e(N,Ke),e(Ke,cd),e(Ke,Ho),e(Ho,ld),e(Ke,id),e(N,dd),e(N,Yo),e(Yo,pd),u(t,fc,p),u(t,$e,p),e($e,Qe),e(Qe,Bo),y(vr,Bo,null),e($e,hd),e($e,Jo),e(Jo,md),u(t,gc,p),u(t,Xe,p),e(Xe,ud),e(Xe,Ma),e(Ma,fd),e(Xe,gd),u(t,_c,p),y($r,t,p),u(t,vc,p),u(t,be,p),e(be,Ze),e(Ze,Ko),y(br,Ko,null),e(be,_d),e(be,Qo),e(Qo,vd),u(t,$c,p),u(t,f,p),y(yr,f,null),e(f,$d),e(f,Xo),e(Xo,bd),e(f,yd),e(f,Zo),e(Zo,en),e(en,wd),e(f,Ed),e(f,T),e(T,et),e(et,tn),e(tn,Ad),e(et,kd),e(et,rn),e(rn,xd),e(et,jd),e(T,Pd),e(T,tt),e(tt,an),e(an,Dd),e(tt,Td),e(tt,Ga),e(Ga,zd),e(tt,Sd),e(T,Id),e(T,rt),e(rt,on),e(on,Ld),e(rt,Od),e(rt,nn),e(nn,Nd),e(rt,Cd),e(T,qd),e(T,at),e(at,sn),e(sn,Ud),e(at,Vd),e(at,cn),e(cn,Md),e(at,Gd),e(T,Rd),e(T,ot),e(ot,ln),e(ln,Wd),e(ot,Fd),e(ot,dn),e(dn,Hd),e(ot,Yd),e(T,Bd),e(T,nt),e(nt,pn),e(pn,Jd),e(nt,Kd),e(nt,hn),e(hn,Qd),e(nt,Xd),e(T,Zd),e(T,st),e(st,mn),e(mn,ep),e(st,tp),e(st,un),e(un,rp),e(st,ap),e(T,op),e(T,ct),e(ct,fn),e(fn,np),e(ct,sp),e(ct,Ra),e(Ra,cp),e(ct,lp),e(T,ip),e(T,lt),e(lt,gn),e(gn,dp),e(lt,pp),e(lt,_n),e(_n,hp),e(lt,mp),e(T,up),e(T,it),e(it,vn),e(vn,fp),e(it,gp),e(it,$n),e($n,_p),e(it,vp),e(f,$p),e(f,H),y(wr,H,null),e(H,bp),e(H,bn),e(bn,yp),e(H,wp),y(dt,H,null),e(f,Ep),e(f,pt),y(Er,pt,null),e(pt,Ap),e(pt,yn),e(yn,kp),e(f,xp),e(f,Y),y(Ar,Y,null),e(Y,jp),e(Y,ye),e(ye,Pp),e(ye,wn),e(wn,Dp),e(ye,Tp),e(ye,En),e(En,zp),e(ye,Sp),e(Y,Ip),e(Y,kr),e(kr,Lp),e(kr,An),e(An,Op),e(kr,Np),e(f,Cp),e(f,ht),y(xr,ht,null),e(ht,qp),e(ht,jr),e(jr,Up),e(jr,kn),e(kn,Vp),e(jr,Mp),e(f,Gp),e(f,B),y(Pr,B,null),e(B,Rp),e(B,Dr),e(Dr,Wp),e(Dr,xn),e(xn,Fp),e(Dr,Hp),e(B,Yp),y(mt,B,null),e(f,Bp),e(f,J),y(Tr,J,null),e(J,Jp),e(J,zr),e(zr,Kp),e(zr,jn),e(jn,Qp),e(zr,Xp),e(J,Zp),y(ut,J,null),e(f,eh),e(f,ft),y(Sr,ft,null),e(ft,th),e(ft,Pn),e(Pn,rh),e(f,ah),e(f,gt),y(Ir,gt,null),e(gt,oh),e(gt,Dn),e(Dn,nh),e(f,sh),e(f,K),y(Lr,K,null),e(K,ch),e(K,Or),e(Or,lh),e(Or,Tn),e(Tn,ih),e(Or,dh),e(K,ph),e(K,zn),e(zn,hh),e(f,mh),e(f,_t),y(Nr,_t,null),e(_t,uh),e(_t,Cr),e(Cr,fh),e(Cr,Sn),e(Sn,gh),e(Cr,_h),e(f,vh),e(f,vt),y(qr,vt,null),e(vt,$h),e(vt,Ur),e(Ur,bh),e(Ur,Wa),e(Wa,yh),e(Ur,wh),e(f,Eh),e(f,$t),y(Vr,$t,null),e($t,Ah),e($t,G),e(G,kh),e(G,In),e(In,xh),e(G,jh),e(G,Ln),e(Ln,Ph),e(G,Dh),e(G,On),e(On,Th),e(G,zh),e(f,Sh),e(f,bt),y(Mr,bt,null),e(bt,Ih),e(bt,Gr),e(Gr,Lh),e(Gr,Nn),e(Nn,Oh),e(Gr,Nh),e(f,Ch),e(f,O),y(Rr,O,null),e(O,qh),e(O,Wr),e(Wr,Uh),e(Wr,Cn),e(Cn,Vh),e(Wr,Mh),e(O,Gh),y(yt,O,null),e(O,Rh),y(wt,O,null),e(O,Wh),y(Et,O,null),e(f,Fh),e(f,Q),y(Fr,Q,null),e(Q,Hh),e(Q,qn),e(qn,Yh),e(Q,Bh),y(At,Q,null),e(f,Jh),e(f,X),y(Hr,X,null),e(X,Kh),e(X,Un),e(Un,Qh),e(X,Xh),e(X,Vn),e(Vn,Zh),e(f,em),e(f,kt),y(Yr,kt,null),e(kt,tm),e(kt,we),e(we,rm),e(we,Mn),e(Mn,am),e(we,om),e(we,Gn),e(Gn,nm),e(we,sm),e(f,cm),e(f,Z),y(Br,Z,null),e(Z,lm),e(Z,Rn),e(Rn,im),e(Z,dm),e(Z,Wn),e(Wn,pm),e(f,hm),e(f,U),y(Jr,U,null),e(U,mm),e(U,Kr),e(Kr,um),e(Kr,Fn),e(Fn,fm),e(Kr,gm),e(U,_m),e(U,Qr),e(Qr,vm),e(Qr,Hn),e(Hn,$m),e(Qr,bm),e(U,ym),y(xt,U,null),e(f,wm),e(f,jt),y(Xr,jt,null),e(jt,Em),e(jt,Yn),e(Yn,Am),e(f,km),e(f,Pt),y(Zr,Pt,null),e(Pt,xm),e(Pt,Bn),e(Bn,jm),e(f,Pm),e(f,Dt),y(ea,Dt,null),e(Dt,Dm),e(Dt,Jn),e(Jn,Tm),e(f,zm),e(f,Tt),y(ta,Tt,null),e(Tt,Sm),e(Tt,Kn),e(Kn,Im),e(f,Lm),e(f,zt),y(ra,zt,null),e(zt,Om),e(zt,Qn),e(Qn,Nm),e(f,Cm),e(f,St),y(aa,St,null),e(St,qm),e(St,Xn),e(Xn,Um),e(f,Vm),e(f,ee),y(oa,ee,null),e(ee,Mm),e(ee,na),e(na,Gm),e(na,Zn),e(Zn,Rm),e(na,Wm),e(ee,Fm),y(It,ee,null),e(f,Hm),e(f,Lt),y(sa,Lt,null),e(Lt,Ym),e(Lt,ca),e(ca,Bm),e(ca,Fa),e(Fa,Jm),e(ca,Km),e(f,Qm),e(f,Ot),y(la,Ot,null),e(Ot,Xm),e(Ot,ia),e(ia,Zm),e(ia,Ha),e(Ha,eu),e(ia,tu),e(f,ru),e(f,Nt),y(da,Nt,null),e(Nt,au),e(Nt,pa),e(pa,ou),e(pa,Ya),e(Ya,nu),e(pa,su),e(f,cu),e(f,Ct),y(ha,Ct,null),e(Ct,lu),e(Ct,ma),e(ma,iu),e(ma,Ba),e(Ba,du),e(ma,pu),e(f,hu),e(f,qt),y(ua,qt,null),e(qt,mu),e(qt,fa),e(fa,uu),e(fa,es),e(es,fu),e(fa,gu),e(f,_u),e(f,te),y(ga,te,null),e(te,vu),e(te,Ee),e(Ee,$u),e(Ee,ts),e(ts,bu),e(Ee,yu),e(Ee,rs),e(rs,wu),e(Ee,Eu),e(te,Au),e(te,as),e(as,ku),e(f,xu),e(f,V),y(_a,V,null),e(V,ju),e(V,R),e(R,Pu),e(R,os),e(os,Du),e(R,Tu),e(R,ns),e(ns,zu),e(R,Su),e(R,ss),e(ss,Iu),e(R,Lu),e(V,Ou),e(V,cs),e(cs,Nu),e(V,Cu),y(Ut,V,null),e(f,qu),e(f,Vt),y(va,Vt,null),e(Vt,Uu),e(Vt,$a),e($a,Vu),e($a,ls),e(ls,Mu),e($a,Gu),e(f,Ru),e(f,re),y(ba,re,null),e(re,Wu),e(re,is),e(is,Fu),e(re,Hu),y(Mt,re,null),e(f,Yu),e(f,Gt),y(ya,Gt,null),e(Gt,Bu),e(Gt,ds),e(ds,Ju),e(f,Ku),e(f,Rt),y(wa,Rt,null),e(Rt,Qu),e(Rt,Ae),e(Ae,Xu),e(Ae,ps),e(ps,Zu),e(Ae,ef),e(Ae,Ja),e(Ja,tf),e(Ae,rf),e(f,af),e(f,Wt),y(Ea,Wt,null),e(Wt,of),e(Wt,hs),e(hs,nf),bc=!0},p(t,[p]){const Aa={};p&2&&(Aa.$$scope={dirty:p,ctx:t}),Te.$set(Aa);const ms={};p&2&&(ms.$$scope={dirty:p,ctx:t}),Se.$set(ms);const us={};p&2&&(us.$$scope={dirty:p,ctx:t}),dt.$set(us);const fs={};p&2&&(fs.$$scope={dirty:p,ctx:t}),mt.$set(fs);const ka={};p&2&&(ka.$$scope={dirty:p,ctx:t}),ut.$set(ka);const gs={};p&2&&(gs.$$scope={dirty:p,ctx:t}),yt.$set(gs);const xa={};p&2&&(xa.$$scope={dirty:p,ctx:t}),wt.$set(xa);const _s={};p&2&&(_s.$$scope={dirty:p,ctx:t}),Et.$set(_s);const vs={};p&2&&(vs.$$scope={dirty:p,ctx:t}),At.$set(vs);const $s={};p&2&&($s.$$scope={dirty:p,ctx:t}),xt.$set($s);const bs={};p&2&&(bs.$$scope={dirty:p,ctx:t}),It.$set(bs);const ke={};p&2&&(ke.$$scope={dirty:p,ctx:t}),Ut.$set(ke);const xe={};p&2&&(xe.$$scope={dirty:p,ctx:t}),Mt.$set(xe)},i(t){bc||(w(m.$$.fragment,t),w(Xt.$$.fragment,t),w(Te.$$.fragment,t),w(Se.$$.fragment,t),w(er.$$.fragment,t),w(tr.$$.fragment,t),w(rr.$$.fragment,t),w(ar.$$.fragment,t),w(or.$$.fragment,t),w(nr.$$.fragment,t),w(sr.$$.fragment,t),w(cr.$$.fragment,t),w(lr.$$.fragment,t),w(ir.$$.fragment,t),w(dr.$$.fragment,t),w(pr.$$.fragment,t),w(hr.$$.fragment,t),w(mr.$$.fragment,t),w(ur.$$.fragment,t),w(fr.$$.fragment,t),w(gr.$$.fragment,t),w(_r.$$.fragment,t),w(vr.$$.fragment,t),w($r.$$.fragment,t),w(br.$$.fragment,t),w(yr.$$.fragment,t),w(wr.$$.fragment,t),w(dt.$$.fragment,t),w(Er.$$.fragment,t),w(Ar.$$.fragment,t),w(xr.$$.fragment,t),w(Pr.$$.fragment,t),w(mt.$$.fragment,t),w(Tr.$$.fragment,t),w(ut.$$.fragment,t),w(Sr.$$.fragment,t),w(Ir.$$.fragment,t),w(Lr.$$.fragment,t),w(Nr.$$.fragment,t),w(qr.$$.fragment,t),w(Vr.$$.fragment,t),w(Mr.$$.fragment,t),w(Rr.$$.fragment,t),w(yt.$$.fragment,t),w(wt.$$.fragment,t),w(Et.$$.fragment,t),w(Fr.$$.fragment,t),w(At.$$.fragment,t),w(Hr.$$.fragment,t),w(Yr.$$.fragment,t),w(Br.$$.fragment,t),w(Jr.$$.fragment,t),w(xt.$$.fragment,t),w(Xr.$$.fragment,t),w(Zr.$$.fragment,t),w(ea.$$.fragment,t),w(ta.$$.fragment,t),w(ra.$$.fragment,t),w(aa.$$.fragment,t),w(oa.$$.fragment,t),w(It.$$.fragment,t),w(sa.$$.fragment,t),w(la.$$.fragment,t),w(da.$$.fragment,t),w(ha.$$.fragment,t),w(ua.$$.fragment,t),w(ga.$$.fragment,t),w(_a.$$.fragment,t),w(Ut.$$.fragment,t),w(va.$$.fragment,t),w(ba.$$.fragment,t),w(Mt.$$.fragment,t),w(ya.$$.fragment,t),w(wa.$$.fragment,t),w(Ea.$$.fragment,t),bc=!0)},o(t){E(m.$$.fragment,t),E(Xt.$$.fragment,t),E(Te.$$.fragment,t),E(Se.$$.fragment,t),E(er.$$.fragment,t),E(tr.$$.fragment,t),E(rr.$$.fragment,t),E(ar.$$.fragment,t),E(or.$$.fragment,t),E(nr.$$.fragment,t),E(sr.$$.fragment,t),E(cr.$$.fragment,t),E(lr.$$.fragment,t),E(ir.$$.fragment,t),E(dr.$$.fragment,t),E(pr.$$.fragment,t),E(hr.$$.fragment,t),E(mr.$$.fragment,t),E(ur.$$.fragment,t),E(fr.$$.fragment,t),E(gr.$$.fragment,t),E(_r.$$.fragment,t),E(vr.$$.fragment,t),E($r.$$.fragment,t),E(br.$$.fragment,t),E(yr.$$.fragment,t),E(wr.$$.fragment,t),E(dt.$$.fragment,t),E(Er.$$.fragment,t),E(Ar.$$.fragment,t),E(xr.$$.fragment,t),E(Pr.$$.fragment,t),E(mt.$$.fragment,t),E(Tr.$$.fragment,t),E(ut.$$.fragment,t),E(Sr.$$.fragment,t),E(Ir.$$.fragment,t),E(Lr.$$.fragment,t),E(Nr.$$.fragment,t),E(qr.$$.fragment,t),E(Vr.$$.fragment,t),E(Mr.$$.fragment,t),E(Rr.$$.fragment,t),E(yt.$$.fragment,t),E(wt.$$.fragment,t),E(Et.$$.fragment,t),E(Fr.$$.fragment,t),E(At.$$.fragment,t),E(Hr.$$.fragment,t),E(Yr.$$.fragment,t),E(Br.$$.fragment,t),E(Jr.$$.fragment,t),E(xt.$$.fragment,t),E(Xr.$$.fragment,t),E(Zr.$$.fragment,t),E(ea.$$.fragment,t),E(ta.$$.fragment,t),E(ra.$$.fragment,t),E(aa.$$.fragment,t),E(oa.$$.fragment,t),E(It.$$.fragment,t),E(sa.$$.fragment,t),E(la.$$.fragment,t),E(da.$$.fragment,t),E(ha.$$.fragment,t),E(ua.$$.fragment,t),E(ga.$$.fragment,t),E(_a.$$.fragment,t),E(Ut.$$.fragment,t),E(va.$$.fragment,t),E(ba.$$.fragment,t),E(Mt.$$.fragment,t),E(ya.$$.fragment,t),E(wa.$$.fragment,t),E(Ea.$$.fragment,t),bc=!1},d(t){r(h),t&&r(x),t&&r(v),A(m),t&&r(Pe),t&&r(q),t&&r(Qt),t&&r(se),A(Xt),t&&r(Os),t&&r(Da),t&&r(Ns),t&&r(W),t&&r(Cs),A(Te,t),t&&r(qs),t&&r(le),t&&r(Us),A(Se,t),t&&r(Vs),t&&r(Ie),t&&r(Ms),t&&r(ie),A(er),t&&r(Gs),t&&r(de),A(tr),t&&r(Rs),t&&r(pe),t&&r(Ws),A(rr,t),t&&r(Fs),t&&r(he),A(ar),t&&r(Hs),t&&r(me),A(or),t&&r(Ys),t&&r(qe),t&&r(Bs),A(nr,t),t&&r(Js),t&&r(Ue),t&&r(Ks),A(sr,t),t&&r(Qs),t&&r(ue),A(cr),t&&r(Xs),t&&r(Me),t&&r(Zs),A(lr,t),t&&r(ec),t&&r(Ge),t&&r(tc),A(ir,t),t&&r(rc),t&&r(fe),A(dr),t&&r(ac),t&&r(Ca),t&&r(oc),A(pr,t),t&&r(nc),A(hr,t),t&&r(sc),t&&r(ge),A(mr),t&&r(cc),t&&r(Fe),t&&r(lc),t&&r(_e),A(ur),t&&r(ic),t&&r(Ye),t&&r(dc),A(fr,t),t&&r(pc),t&&r(F),t&&r(hc),A(gr,t),t&&r(mc),t&&r(ve),A(_r),t&&r(uc),t&&r(N),t&&r(fc),t&&r($e),A(vr),t&&r(gc),t&&r(Xe),t&&r(_c),A($r,t),t&&r(vc),t&&r(be),A(br),t&&r($c),t&&r(f),A(yr),A(wr),A(dt),A(Er),A(Ar),A(xr),A(Pr),A(mt),A(Tr),A(ut),A(Sr),A(Ir),A(Lr),A(Nr),A(qr),A(Vr),A(Mr),A(Rr),A(yt),A(wt),A(Et),A(Fr),A(At),A(Hr),A(Yr),A(Br),A(Jr),A(xt),A(Xr),A(Zr),A(ea),A(ta),A(ra),A(aa),A(oa),A(It),A(sa),A(la),A(da),A(ha),A(ua),A(ga),A(_a),A(Ut),A(va),A(ba),A(Mt),A(ya),A(wa),A(Ea)}}}const ev={local:"accelerator",sections:[{local:"quick-adaptation-of-your-code",title:"Quick adaptation of your code"},{local:"advanced-recommendations",sections:[{local:"printing",title:"Printing"},{local:"executing-processes",sections:[{local:"once-on-a-single-server",title:"Once on a single server"},{local:"only-ever-once-across-all-servers",title:"Only ever once across all servers"},{local:"on-specific-processes",title:"On specific processes"}],title:"Executing processes"},{local:"synchronicity-control",title:"Synchronicity control"},{local:"saving-and-loading",title:"Saving and loading"},{local:"operations",title:"Operations"},{local:"gradient-accumulation",title:"Gradient Accumulation"}],title:"Advanced recommendations"},{local:"accelerate.Accelerator",title:"Overall API documentation:"}],title:"Accelerator"};function tv(D){return U_(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class lv extends O_{constructor(h){super();N_(this,h,tv,Z_,C_,{})}}export{lv as default,ev as metadata};
