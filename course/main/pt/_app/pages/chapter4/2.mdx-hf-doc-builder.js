import{S as ms,i as cs,s as ps,e as u,k as g,w as N,t as m,M as us,c as d,d as s,m as $,x as P,a as b,h as c,b as q,N as rs,G as o,g as p,y as S,o as w,p as ns,q as M,B as R,v as ds,n as ls}from"../../chunks/vendor-hf-doc-builder.js";import{T as fs}from"../../chunks/Tip-hf-doc-builder.js";import{I as bs}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{C as re}from"../../chunks/CodeBlock-hf-doc-builder.js";import{D as is}from"../../chunks/DocNotebookDropdown-hf-doc-builder.js";import{F as hs}from"../../chunks/FrameworkSwitchCourse-hf-doc-builder.js";function ks(C){let r,l;return r=new is({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter4/section2_tf.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter4/section2_tf.ipynb"}]}}),{c(){N(r.$$.fragment)},l(a){P(r.$$.fragment,a)},m(a,x){S(r,a,x),l=!0},i(a){l||(M(r.$$.fragment,a),l=!0)},o(a){w(r.$$.fragment,a),l=!1},d(a){R(r,a)}}}function _s(C){let r,l;return r=new is({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter4/section2_pt.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter4/section2_pt.ipynb"}]}}),{c(){N(r.$$.fragment)},l(a){P(r.$$.fragment,a)},m(a,x){S(r,a,x),l=!0},i(a){l||(M(r.$$.fragment,a),l=!0)},o(a){w(r.$$.fragment,a),l=!1},d(a){R(r,a)}}}function gs(C){let r,l,a,x,h,_,T,v,j,A,L,E,f,k;return r=new re({props:{code:`from transformers import CamembertTokenizer, TFCamembertForMaskedLM

tokenizer = CamembertTokenizer.from_pretrained("camembert-base")
model = TFCamembertForMaskedLM.from_pretrained("camembert-base")`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> CamembertTokenizer, TFCamembertForMaskedLM

tokenizer = CamembertTokenizer.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)
model = TFCamembertForMaskedLM.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)`}}),f=new re({props:{code:`from transformers import AutoTokenizer, TFAutoModelForMaskedLM

tokenizer = AutoTokenizer.from_pretrained("camembert-base")
model = TFAutoModelForMaskedLM.from_pretrained("camembert-base")`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, TFAutoModelForMaskedLM

tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)
model = TFAutoModelForMaskedLM.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)`}}),{c(){N(r.$$.fragment),l=g(),a=u("p"),x=m("No entanto, recomendamos a utiliza\xE7\xE3o das classes "),h=u("a"),_=u("code"),T=m("TFAuto*"),v=m(", pois estas s\xE3o por arquitetura de projeto - agn\xF3stica. Enquanto a amostra de c\xF3digo anterior limita os usu\xE1rios a checkpoint carreg\xE1veis na arquitetura CamemBERT, a utiliza\xE7\xE3o das classes "),j=u("code"),A=m("TFAuto*"),L=m(" torna a troca de checkpoint simples:"),E=g(),N(f.$$.fragment),this.h()},l(t){P(r.$$.fragment,t),l=$(t),a=d(t,"P",{});var i=b(a);x=c(i,"No entanto, recomendamos a utiliza\xE7\xE3o das classes "),h=d(i,"A",{href:!0,rel:!0});var V=b(h);_=d(V,"CODE",{});var B=b(_);T=c(B,"TFAuto*"),B.forEach(s),V.forEach(s),v=c(i,", pois estas s\xE3o por arquitetura de projeto - agn\xF3stica. Enquanto a amostra de c\xF3digo anterior limita os usu\xE1rios a checkpoint carreg\xE1veis na arquitetura CamemBERT, a utiliza\xE7\xE3o das classes "),j=d(i,"CODE",{});var y=b(j);A=c(y,"TFAuto*"),y.forEach(s),L=c(i," torna a troca de checkpoint simples:"),i.forEach(s),E=$(t),P(f.$$.fragment,t),this.h()},h(){q(h,"href","https://huggingface.co/transformers/model_doc/auto.html?highlight=auto#auto-classes"),q(h,"rel","nofollow")},m(t,i){S(r,t,i),p(t,l,i),p(t,a,i),o(a,x),o(a,h),o(h,_),o(_,T),o(a,v),o(a,j),o(j,A),o(a,L),p(t,E,i),S(f,t,i),k=!0},i(t){k||(M(r.$$.fragment,t),M(f.$$.fragment,t),k=!0)},o(t){w(r.$$.fragment,t),w(f.$$.fragment,t),k=!1},d(t){R(r,t),t&&s(l),t&&s(a),t&&s(E),R(f,t)}}}function $s(C){let r,l,a,x,h,_,T,v,j,A,L,E,f,k;return r=new re({props:{code:`from transformers import CamembertTokenizer, CamembertForMaskedLM

tokenizer = CamembertTokenizer.from_pretrained("camembert-base")
model = CamembertForMaskedLM.from_pretrained("camembert-base")`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> CamembertTokenizer, CamembertForMaskedLM

tokenizer = CamembertTokenizer.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)
model = CamembertForMaskedLM.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)`}}),f=new re({props:{code:`from transformers import AutoTokenizer, AutoModelForMaskedLM

tokenizer = AutoTokenizer.from_pretrained("camembert-base")
model = AutoModelForMaskedLM.from_pretrained("camembert-base")`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForMaskedLM

tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)
model = AutoModelForMaskedLM.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)`}}),{c(){N(r.$$.fragment),l=g(),a=u("p"),x=m("No entanto, recomendamos a utiliza\xE7\xE3o das classes "),h=u("a"),_=u("code"),T=m("Auto*"),v=m(", pois estas s\xE3o por arquitetura de projeto - agn\xF3stica. Enquanto a amostra de c\xF3digo anterior limita os usu\xE1rios a checkpoint carreg\xE1veis na arquitetura CamemBERT, a utiliza\xE7\xE3o das classes "),j=u("code"),A=m("Auto*"),L=m(" torna a troca de checkpoint simples:"),E=g(),N(f.$$.fragment),this.h()},l(t){P(r.$$.fragment,t),l=$(t),a=d(t,"P",{});var i=b(a);x=c(i,"No entanto, recomendamos a utiliza\xE7\xE3o das classes "),h=d(i,"A",{href:!0,rel:!0});var V=b(h);_=d(V,"CODE",{});var B=b(_);T=c(B,"Auto*"),B.forEach(s),V.forEach(s),v=c(i,", pois estas s\xE3o por arquitetura de projeto - agn\xF3stica. Enquanto a amostra de c\xF3digo anterior limita os usu\xE1rios a checkpoint carreg\xE1veis na arquitetura CamemBERT, a utiliza\xE7\xE3o das classes "),j=d(i,"CODE",{});var y=b(j);A=c(y,"Auto*"),y.forEach(s),L=c(i," torna a troca de checkpoint simples:"),i.forEach(s),E=$(t),P(f.$$.fragment,t),this.h()},h(){q(h,"href","https://huggingface.co/transformers/model_doc/auto.html?highlight=auto#auto-classes"),q(h,"rel","nofollow")},m(t,i){S(r,t,i),p(t,l,i),p(t,a,i),o(a,x),o(a,h),o(h,_),o(_,T),o(a,v),o(a,j),o(j,A),o(a,L),p(t,E,i),S(f,t,i),k=!0},i(t){k||(M(r.$$.fragment,t),M(f.$$.fragment,t),k=!0)},o(t){w(r.$$.fragment,t),w(f.$$.fragment,t),k=!1},d(t){R(r,t),t&&s(l),t&&s(a),t&&s(E),R(f,t)}}}function xs(C){let r;return{c(){r=m("Ao utilizar um modelo pr\xE9-treinado, certifique-se de verificar como ele foi treinado, em quais datasets, seus limites e seus enviesamentos. Todas estas informa\xE7\xF5es devem ser indicadas em seu modelo de cart\xE3o.")},l(l){r=c(l,"Ao utilizar um modelo pr\xE9-treinado, certifique-se de verificar como ele foi treinado, em quais datasets, seus limites e seus enviesamentos. Todas estas informa\xE7\xF5es devem ser indicadas em seu modelo de cart\xE3o.")},m(l,a){p(l,r,a)},d(l){l&&s(r)}}}function qs(C){let r,l,a,x,h,_,T,v,j,A,L,E,f,k,t,i,V,B,y,ve,fe,U,J,Be,be,F,je,ne,we,Me,le,Ee,ze,ie,Ce,Te,he,K,ke,Q,_e,z,Ae,me,ye,Fe,ce,Le,De,pe,Oe,Ne,ue,Pe,Se,ge,W,X,Ie,$e,se,Re,xe,D,O,ae,G,qe;a=new hs({props:{fw:C[0]}}),v=new bs({});const Ve=[_s,ks],Y=[];function Ge(e,n){return e[0]==="pt"?0:1}f=Ge(C),k=Y[f]=Ve[f](C),K=new re({props:{code:`from transformers import pipeline

camembert_fill_mask = pipeline("fill-mask", model="camembert-base")
results = camembert_fill_mask("Le camembert est <mask> :)")`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

camembert_fill_mask = pipeline(<span class="hljs-string">&quot;fill-mask&quot;</span>, model=<span class="hljs-string">&quot;camembert-base&quot;</span>)
results = camembert_fill_mask(<span class="hljs-string">&quot;Le camembert est &lt;mask&gt; :)&quot;</span>)`}}),Q=new re({props:{code:`[
  {'sequence': 'Le camembert est d\xE9licieux :)', 'score': 0.49091005325317383, 'token': 7200, 'token_str': 'd\xE9licieux'}, 
  {'sequence': 'Le camembert est excellent :)', 'score': 0.1055697426199913, 'token': 2183, 'token_str': 'excellent'}, 
  {'sequence': 'Le camembert est succulent :)', 'score': 0.03453313186764717, 'token': 26202, 'token_str': 'succulent'}, 
  {'sequence': 'Le camembert est meilleur :)', 'score': 0.0330314114689827, 'token': 528, 'token_str': 'meilleur'}, 
  {'sequence': 'Le camembert est parfait :)', 'score': 0.03007650189101696, 'token': 1654, 'token_str': 'parfait'}
]`,highlighted:`[
  {<span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;Le camembert est d\xE9licieux :)&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.49091005325317383</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">7200</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;d\xE9licieux&#x27;</span>}, 
  {<span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;Le camembert est excellent :)&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.1055697426199913</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">2183</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;excellent&#x27;</span>}, 
  {<span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;Le camembert est succulent :)&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.03453313186764717</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">26202</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;succulent&#x27;</span>}, 
  {<span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;Le camembert est meilleur :)&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.0330314114689827</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">528</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;meilleur&#x27;</span>}, 
  {<span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;Le camembert est parfait :)&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.03007650189101696</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">1654</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;parfait&#x27;</span>}
]`}});const He=[$s,gs],Z=[];function Ue(e,n){return e[0]==="pt"?0:1}return D=Ue(C),O=Z[D]=He[D](C),G=new fs({props:{$$slots:{default:[xs]},$$scope:{ctx:C}}}),{c(){r=u("meta"),l=g(),N(a.$$.fragment),x=g(),h=u("h1"),_=u("a"),T=u("span"),N(v.$$.fragment),j=g(),A=u("span"),L=m("Usando modelos pr\xE9-treinados"),E=g(),k.c(),t=g(),i=u("p"),V=m("O Model Hub torna simples a sele\xE7\xE3o do modelo apropriado, de modo que o uso em qualquer biblioteca pode ser feito em algumas linhas de c\xF3digo. Vamos dar uma olhada em como realmente usar um desses modelos, e como contribuir de volta \xE0 comunidade."),B=g(),y=u("p"),ve=m("Digamos que estamos \xE0 procura de um modelo baseado na l\xEDngua francesa que possa realizar o enchimento de m\xE1scara."),fe=g(),U=u("div"),J=u("img"),be=g(),F=u("p"),je=m("Selecionamos o checkpoint "),ne=u("code"),we=m("camembert-base"),Me=m(" para experiment\xE1-lo. O identificador "),le=u("code"),Ee=m("camembert-base"),ze=m(" \xE9 tudo o que precisamos para come\xE7ar a utiliz\xE1-lo! Como voc\xEA j\xE1 viu nos cap\xEDtulos anteriores, podemos instanci\xE1-lo utilizando a fun\xE7\xE3o "),ie=u("code"),Ce=m("pipeline()"),Te=m(":"),he=g(),N(K.$$.fragment),ke=g(),N(Q.$$.fragment),_e=g(),z=u("p"),Ae=m("Como voc\xEA pode ver, carregar um modelo dentro de um pipeline \xE9 extremamente simples. A \xFAnica coisa que voc\xEA precisa estar atento \xE9 que o checkpoint escolhido \xE9 adequado para a tarefa para a qual ele ser\xE1 utilizado. Por exemplo, aqui estamos carregando o checkpoint "),me=u("code"),ye=m("camembert-base"),Fe=m(" no pipeline "),ce=u("code"),Le=m("fill-mask"),De=m(", o que \xE9 completamente bom. Mas se carreg\xE1ssemos este checkpoint no pipeline de "),pe=u("code"),Oe=m("text-classification"),Ne=m(", os resultados n\xE3o fariam sentido porque a head da "),ue=u("code"),Pe=m("camembert-base"),Se=m(" n\xE3o \xE9 adequado para esta tarefa! Recomendamos a utiliza\xE7\xE3o do seletor de tarefas na interface do Hub de abra\xE7o facial a fim de selecionar os checkpoints apropriados:"),ge=g(),W=u("div"),X=u("img"),$e=g(),se=u("p"),Re=m("Voc\xEA tamb\xE9m pode instanciar o checkpoint usando diretamente a arquitetura modelo:"),xe=g(),O.c(),ae=g(),N(G.$$.fragment),this.h()},l(e){const n=us('[data-svelte="svelte-1phssyn"]',document.head);r=d(n,"META",{name:!0,content:!0}),n.forEach(s),l=$(e),P(a.$$.fragment,e),x=$(e),h=d(e,"H1",{class:!0});var ee=b(h);_=d(ee,"A",{id:!0,class:!0,href:!0});var te=b(_);T=d(te,"SPAN",{});var oe=b(T);P(v.$$.fragment,oe),oe.forEach(s),te.forEach(s),j=$(ee),A=d(ee,"SPAN",{});var de=b(A);L=c(de,"Usando modelos pr\xE9-treinados"),de.forEach(s),ee.forEach(s),E=$(e),k.l(e),t=$(e),i=d(e,"P",{});var Je=b(i);V=c(Je,"O Model Hub torna simples a sele\xE7\xE3o do modelo apropriado, de modo que o uso em qualquer biblioteca pode ser feito em algumas linhas de c\xF3digo. Vamos dar uma olhada em como realmente usar um desses modelos, e como contribuir de volta \xE0 comunidade."),Je.forEach(s),B=$(e),y=d(e,"P",{});var Ke=b(y);ve=c(Ke,"Digamos que estamos \xE0 procura de um modelo baseado na l\xEDngua francesa que possa realizar o enchimento de m\xE1scara."),Ke.forEach(s),fe=$(e),U=d(e,"DIV",{class:!0});var Qe=b(U);J=d(Qe,"IMG",{src:!0,alt:!0,width:!0}),Qe.forEach(s),be=$(e),F=d(e,"P",{});var H=b(F);je=c(H,"Selecionamos o checkpoint "),ne=d(H,"CODE",{});var We=b(ne);we=c(We,"camembert-base"),We.forEach(s),Me=c(H," para experiment\xE1-lo. O identificador "),le=d(H,"CODE",{});var Xe=b(le);Ee=c(Xe,"camembert-base"),Xe.forEach(s),ze=c(H," \xE9 tudo o que precisamos para come\xE7ar a utiliz\xE1-lo! Como voc\xEA j\xE1 viu nos cap\xEDtulos anteriores, podemos instanci\xE1-lo utilizando a fun\xE7\xE3o "),ie=d(H,"CODE",{});var Ye=b(ie);Ce=c(Ye,"pipeline()"),Ye.forEach(s),Te=c(H,":"),H.forEach(s),he=$(e),P(K.$$.fragment,e),ke=$(e),P(Q.$$.fragment,e),_e=$(e),z=d(e,"P",{});var I=b(z);Ae=c(I,"Como voc\xEA pode ver, carregar um modelo dentro de um pipeline \xE9 extremamente simples. A \xFAnica coisa que voc\xEA precisa estar atento \xE9 que o checkpoint escolhido \xE9 adequado para a tarefa para a qual ele ser\xE1 utilizado. Por exemplo, aqui estamos carregando o checkpoint "),me=d(I,"CODE",{});var Ze=b(me);ye=c(Ze,"camembert-base"),Ze.forEach(s),Fe=c(I," no pipeline "),ce=d(I,"CODE",{});var es=b(ce);Le=c(es,"fill-mask"),es.forEach(s),De=c(I,", o que \xE9 completamente bom. Mas se carreg\xE1ssemos este checkpoint no pipeline de "),pe=d(I,"CODE",{});var ss=b(pe);Oe=c(ss,"text-classification"),ss.forEach(s),Ne=c(I,", os resultados n\xE3o fariam sentido porque a head da "),ue=d(I,"CODE",{});var as=b(ue);Pe=c(as,"camembert-base"),as.forEach(s),Se=c(I," n\xE3o \xE9 adequado para esta tarefa! Recomendamos a utiliza\xE7\xE3o do seletor de tarefas na interface do Hub de abra\xE7o facial a fim de selecionar os checkpoints apropriados:"),I.forEach(s),ge=$(e),W=d(e,"DIV",{class:!0});var ts=b(W);X=d(ts,"IMG",{src:!0,alt:!0,width:!0}),ts.forEach(s),$e=$(e),se=d(e,"P",{});var os=b(se);Re=c(os,"Voc\xEA tamb\xE9m pode instanciar o checkpoint usando diretamente a arquitetura modelo:"),os.forEach(s),xe=$(e),O.l(e),ae=$(e),P(G.$$.fragment,e),this.h()},h(){q(r,"name","hf:doc:metadata"),q(r,"content",JSON.stringify(vs)),q(_,"id","usando-modelos-prtreinados"),q(_,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),q(_,"href","#usando-modelos-prtreinados"),q(h,"class","relative group"),rs(J.src,Be="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter4/camembert.gif")||q(J,"src",Be),q(J,"alt","Selecting the Camembert model."),q(J,"width","80%"),q(U,"class","flex justify-center"),rs(X.src,Ie="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter4/tasks.png")||q(X,"src",Ie),q(X,"alt","The task selector on the web interface."),q(X,"width","80%"),q(W,"class","flex justify-center")},m(e,n){o(document.head,r),p(e,l,n),S(a,e,n),p(e,x,n),p(e,h,n),o(h,_),o(_,T),S(v,T,null),o(h,j),o(h,A),o(A,L),p(e,E,n),Y[f].m(e,n),p(e,t,n),p(e,i,n),o(i,V),p(e,B,n),p(e,y,n),o(y,ve),p(e,fe,n),p(e,U,n),o(U,J),p(e,be,n),p(e,F,n),o(F,je),o(F,ne),o(ne,we),o(F,Me),o(F,le),o(le,Ee),o(F,ze),o(F,ie),o(ie,Ce),o(F,Te),p(e,he,n),S(K,e,n),p(e,ke,n),S(Q,e,n),p(e,_e,n),p(e,z,n),o(z,Ae),o(z,me),o(me,ye),o(z,Fe),o(z,ce),o(ce,Le),o(z,De),o(z,pe),o(pe,Oe),o(z,Ne),o(z,ue),o(ue,Pe),o(z,Se),p(e,ge,n),p(e,W,n),o(W,X),p(e,$e,n),p(e,se,n),o(se,Re),p(e,xe,n),Z[D].m(e,n),p(e,ae,n),S(G,e,n),qe=!0},p(e,[n]){const ee={};n&1&&(ee.fw=e[0]),a.$set(ee);let te=f;f=Ge(e),f!==te&&(ls(),w(Y[te],1,1,()=>{Y[te]=null}),ns(),k=Y[f],k||(k=Y[f]=Ve[f](e),k.c()),M(k,1),k.m(t.parentNode,t));let oe=D;D=Ue(e),D!==oe&&(ls(),w(Z[oe],1,1,()=>{Z[oe]=null}),ns(),O=Z[D],O||(O=Z[D]=He[D](e),O.c()),M(O,1),O.m(ae.parentNode,ae));const de={};n&2&&(de.$$scope={dirty:n,ctx:e}),G.$set(de)},i(e){qe||(M(a.$$.fragment,e),M(v.$$.fragment,e),M(k),M(K.$$.fragment,e),M(Q.$$.fragment,e),M(O),M(G.$$.fragment,e),qe=!0)},o(e){w(a.$$.fragment,e),w(v.$$.fragment,e),w(k),w(K.$$.fragment,e),w(Q.$$.fragment,e),w(O),w(G.$$.fragment,e),qe=!1},d(e){s(r),e&&s(l),R(a,e),e&&s(x),e&&s(h),R(v),e&&s(E),Y[f].d(e),e&&s(t),e&&s(i),e&&s(B),e&&s(y),e&&s(fe),e&&s(U),e&&s(be),e&&s(F),e&&s(he),R(K,e),e&&s(ke),R(Q,e),e&&s(_e),e&&s(z),e&&s(ge),e&&s(W),e&&s($e),e&&s(se),e&&s(xe),Z[D].d(e),e&&s(ae),R(G,e)}}}const vs={local:"usando-modelos-prtreinados",title:"Usando modelos pr\xE9-treinados"};function js(C,r,l){let a="pt";return ds(()=>{const x=new URLSearchParams(window.location.search);l(0,a=x.get("fw")||"pt")}),[a]}class As extends ms{constructor(r){super();cs(this,r,js,qs,ps,{})}}export{As as default,vs as metadata};
