import{S as gq,i as qq,s as xq,e as o,t as n,k as d,w,c as r,a as l,h as a,d as t,m as c,x as j,g as i,G as s,y as E,q as h,o as v,B as k,b as C,U as $q,M as wq,V as jq,N as kc,p as wn,v as Eq,n as jn}from"../../chunks/vendor-hf-doc-builder.js";import{T as yc}from"../../chunks/Tip-hf-doc-builder.js";import{Y as Cc}from"../../chunks/Youtube-hf-doc-builder.js";import{I as qs}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{C as z}from"../../chunks/CodeBlock-hf-doc-builder.js";import{D as vq}from"../../chunks/DocNotebookDropdown-hf-doc-builder.js";import{F as kq}from"../../chunks/FrameworkSwitchCourse-hf-doc-builder.js";function yq(R){let p,b;return p=new vq({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter7/section7_tf.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter7/section7_tf.ipynb"}]}}),{c(){w(p.$$.fragment)},l(f){j(p.$$.fragment,f)},m(f,y){E(p,f,y),b=!0},i(f){b||(h(p.$$.fragment,f),b=!0)},o(f){v(p.$$.fragment,f),b=!1},d(f){k(p,f)}}}function Cq(R){let p,b;return p=new vq({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter7/section7_pt.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter7/section7_pt.ipynb"}]}}),{c(){w(p.$$.fragment)},l(f){j(p.$$.fragment,f)},m(f,y){E(p,f,y),b=!0},i(f){b||(h(p.$$.fragment,f),b=!0)},o(f){v(p.$$.fragment,f),b=!1},d(f){k(p,f)}}}function Pq(R){let p,b,f,y,S,g,q,x,_,M,$,A,T,I;return{c(){p=o("p"),b=n("\u{1F4A1} Les mod\xE8les bas\xE9 que sur l\u2019encodeur comme BERT ont tendance \xE0 \xEAtre excellents pour extraire les r\xE9ponses \xE0 des questions factuelles comme \xAB Qui a invent\xE9 l\u2019architecture Transformer ? \xBB mais ne sont pas tr\xE8s performants lorsqu\u2019on leur pose des questions ouvertes comme \xAB Pourquoi le ciel est-il bleu ? \xBB. Dans ces cas plus difficiles, les mod\xE8les encodeurs-d\xE9codeurs comme le T5 et BART sont g\xE9n\xE9ralement utilis\xE9s pour synth\xE9tiser les informations d\u2019une mani\xE8re assez similaire au "),f=o("a"),y=n("r\xE9sum\xE9 de texte"),S=n(". Si vous \xEAtes int\xE9ress\xE9 par ce type de r\xE9ponse aux questions "),g=o("em"),q=n("g\xE9n\xE9ratives"),x=n(", nous vous recommandons de consulter notre "),_=o("a"),M=n("d\xE9mo"),$=n(" bas\xE9e sur le "),A=o("a"),T=n("jeu de donn\xE9es ELI5"),I=n("."),this.h()},l(D){p=r(D,"P",{});var P=l(p);b=a(P,"\u{1F4A1} Les mod\xE8les bas\xE9 que sur l\u2019encodeur comme BERT ont tendance \xE0 \xEAtre excellents pour extraire les r\xE9ponses \xE0 des questions factuelles comme \xAB Qui a invent\xE9 l\u2019architecture Transformer ? \xBB mais ne sont pas tr\xE8s performants lorsqu\u2019on leur pose des questions ouvertes comme \xAB Pourquoi le ciel est-il bleu ? \xBB. Dans ces cas plus difficiles, les mod\xE8les encodeurs-d\xE9codeurs comme le T5 et BART sont g\xE9n\xE9ralement utilis\xE9s pour synth\xE9tiser les informations d\u2019une mani\xE8re assez similaire au "),f=r(P,"A",{href:!0});var V=l(f);y=a(V,"r\xE9sum\xE9 de texte"),V.forEach(t),S=a(P,". Si vous \xEAtes int\xE9ress\xE9 par ce type de r\xE9ponse aux questions "),g=r(P,"EM",{});var L=l(g);q=a(L,"g\xE9n\xE9ratives"),L.forEach(t),x=a(P,", nous vous recommandons de consulter notre "),_=r(P,"A",{href:!0,rel:!0});var O=l(_);M=a(O,"d\xE9mo"),O.forEach(t),$=a(P," bas\xE9e sur le "),A=r(P,"A",{href:!0,rel:!0});var N=l(A);T=a(N,"jeu de donn\xE9es ELI5"),N.forEach(t),I=a(P,"."),P.forEach(t),this.h()},h(){C(f,"href","/course/fr/chapter7/5"),C(_,"href","https://yjernite.github.io/lfqa.html"),C(_,"rel","nofollow"),C(A,"href","https://huggingface.co/datasets/eli5"),C(A,"rel","nofollow")},m(D,P){i(D,p,P),s(p,b),s(p,f),s(f,y),s(p,S),s(p,g),s(g,q),s(p,x),s(p,_),s(_,M),s(p,$),s(p,A),s(A,T),s(p,I)},d(D){D&&t(p)}}}function Aq(R){let p,b,f,y,S,g,q,x,_,M,$,A,T,I,D,P,V;return{c(){p=o("p"),b=n("\u270F\uFE0F "),f=o("strong"),y=n("A votre tour !"),S=n(" En utilisant l\u2019architecture XLNet, le "),g=o("em"),q=n("padding"),x=n(" est appliqu\xE9 \xE0 gauche et la question et le contexte sont intervertis. Adaptez tout le code que nous venons de voir \xE0 l\u2019architecture XLNet (et ajoutez "),_=o("code"),M=n("padding=True"),$=n("). Soyez conscient que le token "),A=o("code"),T=n("[CLS]"),I=n(" peut ne pas \xEAtre \xE0 la position 0 avec le "),D=o("em"),P=n("padding"),V=n(" appliqu\xE9.")},l(L){p=r(L,"P",{});var O=l(p);b=a(O,"\u270F\uFE0F "),f=r(O,"STRONG",{});var N=l(f);y=a(N,"A votre tour !"),N.forEach(t),S=a(O," En utilisant l\u2019architecture XLNet, le "),g=r(O,"EM",{});var U=l(g);q=a(U,"padding"),U.forEach(t),x=a(O," est appliqu\xE9 \xE0 gauche et la question et le contexte sont intervertis. Adaptez tout le code que nous venons de voir \xE0 l\u2019architecture XLNet (et ajoutez "),_=r(O,"CODE",{});var Q=l(_);M=a(Q,"padding=True"),Q.forEach(t),$=a(O,"). Soyez conscient que le token "),A=r(O,"CODE",{});var J=l(A);T=a(J,"[CLS]"),J.forEach(t),I=a(O," peut ne pas \xEAtre \xE0 la position 0 avec le "),D=r(O,"EM",{});var H=l(D);P=a(H,"padding"),H.forEach(t),V=a(O," appliqu\xE9."),O.forEach(t)},m(L,O){i(L,p,O),s(p,b),s(p,f),s(f,y),s(p,S),s(p,g),s(g,q),s(p,x),s(p,_),s(_,M),s(p,$),s(p,A),s(A,T),s(p,I),s(p,D),s(D,P),s(p,V)},d(L){L&&t(p)}}}function Sq(R){let p,b,f,y,S,g,q,x,_,M,$,A,T,I,D,P;return y=new qs({}),{c(){p=o("h2"),b=o("a"),f=o("span"),w(y.$$.fragment),S=d(),g=o("span"),q=o("i"),x=n("Finetuner"),_=n(" fin du mod\xE8le avec Keras"),M=d(),$=o("p"),A=n("Le code d\u2019entra\xEEnement de cet exemple ressemblera beaucoup au code des sections pr\xE9c\xE9dentes, mais le calcul de la m\xE9trique sera un d\xE9fi unique. Puisque nous avons rembourr\xE9 tous les \xE9chantillons \xE0 la longueur maximale que nous avons d\xE9finie, il n\u2019y a pas de collateur de donn\xE9es \xE0 d\xE9finir. Ainsi le calcul de la m\xE9trique est vraiment la seule chose dont nous devons nous soucier. La partie la plus difficile sera de post-traiter les pr\xE9dictions du mod\xE8le en \xE9tendues de texte dans les exemples originaux. Une fois que nous aurons fait cela, la m\xE9trique de la biblioth\xE8que \u{1F917} "),T=o("em"),I=n("Datasets"),D=n(" fera le gros du travail pour nous."),this.h()},l(V){p=r(V,"H2",{class:!0});var L=l(p);b=r(L,"A",{id:!0,class:!0,href:!0});var O=l(b);f=r(O,"SPAN",{});var N=l(f);j(y.$$.fragment,N),N.forEach(t),O.forEach(t),S=c(L),g=r(L,"SPAN",{});var U=l(g);q=r(U,"I",{});var Q=l(q);x=a(Q,"Finetuner"),Q.forEach(t),_=a(U," fin du mod\xE8le avec Keras"),U.forEach(t),L.forEach(t),M=c(V),$=r(V,"P",{});var J=l($);A=a(J,"Le code d\u2019entra\xEEnement de cet exemple ressemblera beaucoup au code des sections pr\xE9c\xE9dentes, mais le calcul de la m\xE9trique sera un d\xE9fi unique. Puisque nous avons rembourr\xE9 tous les \xE9chantillons \xE0 la longueur maximale que nous avons d\xE9finie, il n\u2019y a pas de collateur de donn\xE9es \xE0 d\xE9finir. Ainsi le calcul de la m\xE9trique est vraiment la seule chose dont nous devons nous soucier. La partie la plus difficile sera de post-traiter les pr\xE9dictions du mod\xE8le en \xE9tendues de texte dans les exemples originaux. Une fois que nous aurons fait cela, la m\xE9trique de la biblioth\xE8que \u{1F917} "),T=r(J,"EM",{});var H=l(T);I=a(H,"Datasets"),H.forEach(t),D=a(J," fera le gros du travail pour nous."),J.forEach(t),this.h()},h(){C(b,"id","ifinetuneri-fin-du-modle-avec-keras"),C(b,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),C(b,"href","#ifinetuneri-fin-du-modle-avec-keras"),C(p,"class","relative group")},m(V,L){i(V,p,L),s(p,b),s(b,f),E(y,f,null),s(p,S),s(p,g),s(g,q),s(q,x),s(g,_),i(V,M,L),i(V,$,L),s($,A),s($,T),s(T,I),s($,D),P=!0},i(V){P||(h(y.$$.fragment,V),P=!0)},o(V){v(y.$$.fragment,V),P=!1},d(V){V&&t(p),k(y),V&&t(M),V&&t($)}}}function Mq(R){let p,b,f,y,S,g,q,x,_,M,$,A,T,I,D,P,V,L,O,N,U;return y=new qs({}),{c(){p=o("h2"),b=o("a"),f=o("span"),w(y.$$.fragment),S=d(),g=o("span"),q=o("i"),x=n("Finetuner"),_=n(" le mod\xE8le avec l'API "),M=o("code"),$=n("Trainer"),A=d(),T=o("p"),I=n("Le code d\u2019entra\xEEnement pour cet exemple ressemblera beaucoup au code des sections pr\xE9c\xE9dentes mais le calcul de la m\xE9trique avec la fonction "),D=o("code"),P=n("compute_metrics()"),V=n(" sera un d\xE9fi unique. Puisque nous avons rembourr\xE9 tous les \xE9chantillons \xE0 la longueur maximale que nous avons d\xE9finie, il n\u2019y a pas de collateur de donn\xE9es \xE0 d\xE9finir. Ainsi le calcul de la m\xE9trique est vraiment la seule chose dont nous devons nous soucier. La partie la plus difficile sera de post-traiter les pr\xE9dictions du mod\xE8le en \xE9tendues de texte dans les exemples originaux. Une fois que nous aurons fait cela, la m\xE9trique de la biblioth\xE8que \u{1F917} "),L=o("em"),O=n("Datasets"),N=n(" fera le gros du travail pour nous."),this.h()},l(Q){p=r(Q,"H2",{class:!0});var J=l(p);b=r(J,"A",{id:!0,class:!0,href:!0});var H=l(b);f=r(H,"SPAN",{});var G=l(f);j(y.$$.fragment,G),G.forEach(t),H.forEach(t),S=c(J),g=r(J,"SPAN",{});var ee=l(g);q=r(ee,"I",{});var Z=l(q);x=a(Z,"Finetuner"),Z.forEach(t),_=a(ee," le mod\xE8le avec l'API "),M=r(ee,"CODE",{});var F=l(M);$=a(F,"Trainer"),F.forEach(t),ee.forEach(t),J.forEach(t),A=c(Q),T=r(Q,"P",{});var X=l(T);I=a(X,"Le code d\u2019entra\xEEnement pour cet exemple ressemblera beaucoup au code des sections pr\xE9c\xE9dentes mais le calcul de la m\xE9trique avec la fonction "),D=r(X,"CODE",{});var re=l(D);P=a(re,"compute_metrics()"),re.forEach(t),V=a(X," sera un d\xE9fi unique. Puisque nous avons rembourr\xE9 tous les \xE9chantillons \xE0 la longueur maximale que nous avons d\xE9finie, il n\u2019y a pas de collateur de donn\xE9es \xE0 d\xE9finir. Ainsi le calcul de la m\xE9trique est vraiment la seule chose dont nous devons nous soucier. La partie la plus difficile sera de post-traiter les pr\xE9dictions du mod\xE8le en \xE9tendues de texte dans les exemples originaux. Une fois que nous aurons fait cela, la m\xE9trique de la biblioth\xE8que \u{1F917} "),L=r(X,"EM",{});var se=l(L);O=a(se,"Datasets"),se.forEach(t),N=a(X," fera le gros du travail pour nous."),X.forEach(t),this.h()},h(){C(b,"id","ifinetuneri-le-modle-avec-lapi-trainer"),C(b,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),C(b,"href","#ifinetuneri-le-modle-avec-lapi-trainer"),C(p,"class","relative group")},m(Q,J){i(Q,p,J),s(p,b),s(b,f),E(y,f,null),s(p,S),s(p,g),s(g,q),s(q,x),s(g,_),s(g,M),s(M,$),i(Q,A,J),i(Q,T,J),s(T,I),s(T,D),s(D,P),s(T,V),s(T,L),s(L,O),s(T,N),U=!0},i(Q){U||(h(y.$$.fragment,Q),U=!0)},o(Q){v(y.$$.fragment,Q),U=!1},d(Q){Q&&t(p),k(y),Q&&t(A),Q&&t(T)}}}function zq(R){let p,b;return p=new Cc({props:{id:"VN67ZpN33Ss"}}),{c(){w(p.$$.fragment)},l(f){j(p.$$.fragment,f)},m(f,y){E(p,f,y),b=!0},i(f){b||(h(p.$$.fragment,f),b=!0)},o(f){v(p.$$.fragment,f),b=!1},d(f){k(p,f)}}}function Dq(R){let p,b;return p=new Cc({props:{id:"BNy08iIWVJM"}}),{c(){w(p.$$.fragment)},l(f){j(p.$$.fragment,f)},m(f,y){E(p,f,y),b=!0},i(f){b||(h(p.$$.fragment,f),b=!0)},o(f){v(p.$$.fragment,f),b=!1},d(f){k(p,f)}}}function Tq(R){let p,b,f,y,S,g,q;return p=new z({props:{code:`import tensorflow as tf
from transformers import TFAutoModelForQuestionAnswering

eval_set_for_model = eval_set.remove_columns(["example_id", "offset_mapping"])
eval_set_for_model.set_format("numpy")

batch = {k: eval_set_for_model[k] for k in eval_set_for_model.column_names}
trained_model = TFAutoModelForQuestionAnswering.from_pretrained(trained_checkpoint)

outputs = trained_model(**batch)`,highlighted:`<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModelForQuestionAnswering

eval_set_for_model = eval_set.remove_columns([<span class="hljs-string">&quot;example_id&quot;</span>, <span class="hljs-string">&quot;offset_mapping&quot;</span>])
eval_set_for_model.set_format(<span class="hljs-string">&quot;numpy&quot;</span>)

batch = {k: eval_set_for_model[k] <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> eval_set_for_model.column_names}
trained_model = TFAutoModelForQuestionAnswering.from_pretrained(trained_checkpoint)

outputs = trained_model(**batch)`}}),g=new z({props:{code:`start_logits = outputs.start_logits.numpy()
end_logits = outputs.end_logits.numpy()`,highlighted:`start_logits = outputs.start_logits.numpy()
end_logits = outputs.end_logits.numpy()`}}),{c(){w(p.$$.fragment),b=d(),f=o("p"),y=n("Pour faciliter l\u2019exp\xE9rimentation, nous allons convertir ces sorties en tableaux NumPy :"),S=d(),w(g.$$.fragment)},l(x){j(p.$$.fragment,x),b=c(x),f=r(x,"P",{});var _=l(f);y=a(_,"Pour faciliter l\u2019exp\xE9rimentation, nous allons convertir ces sorties en tableaux NumPy :"),_.forEach(t),S=c(x),j(g.$$.fragment,x)},m(x,_){E(p,x,_),i(x,b,_),i(x,f,_),s(f,y),i(x,S,_),E(g,x,_),q=!0},i(x){q||(h(p.$$.fragment,x),h(g.$$.fragment,x),q=!0)},o(x){v(p.$$.fragment,x),v(g.$$.fragment,x),q=!1},d(x){k(p,x),x&&t(b),x&&t(f),x&&t(S),k(g,x)}}}function Lq(R){let p,b,f,y,S,g,q,x,_,M;return p=new z({props:{code:`import torch
from transformers import AutoModelForQuestionAnswering

eval_set_for_model = eval_set.remove_columns(["example_id", "offset_mapping"])
eval_set_for_model.set_format("torch")

device = torch.device("cuda") if torch.cuda.is_available() else torch.device("cpu")
batch = {k: eval_set_for_model[k].to(device) for k in eval_set_for_model.column_names}
trained_model = AutoModelForQuestionAnswering.from_pretrained(trained_checkpoint).to(
    device
)

with torch.no_grad():
    outputs = trained_model(**batch)`,highlighted:`<span class="hljs-keyword">import</span> torch
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForQuestionAnswering

eval_set_for_model = eval_set.remove_columns([<span class="hljs-string">&quot;example_id&quot;</span>, <span class="hljs-string">&quot;offset_mapping&quot;</span>])
eval_set_for_model.set_format(<span class="hljs-string">&quot;torch&quot;</span>)

device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span>) <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> torch.device(<span class="hljs-string">&quot;cpu&quot;</span>)
batch = {k: eval_set_for_model[k].to(device) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> eval_set_for_model.column_names}
trained_model = AutoModelForQuestionAnswering.from_pretrained(trained_checkpoint).to(
    device
)

<span class="hljs-keyword">with</span> torch.no_grad():
    outputs = trained_model(**batch)`}}),_=new z({props:{code:`start_logits = outputs.start_logits.cpu().numpy()
end_logits = outputs.end_logits.cpu().numpy()`,highlighted:`start_logits = outputs.start_logits.cpu().numpy()
end_logits = outputs.end_logits.cpu().numpy()`}}),{c(){w(p.$$.fragment),b=d(),f=o("p"),y=n("Puisque "),S=o("code"),g=n("Trainer"),q=n(" nous donne les pr\xE9dictions sous forme de tableaux NumPy, nous r\xE9cup\xE9rons les logits de d\xE9but et de fin et les convertissons dans ce format :"),x=d(),w(_.$$.fragment)},l($){j(p.$$.fragment,$),b=c($),f=r($,"P",{});var A=l(f);y=a(A,"Puisque "),S=r(A,"CODE",{});var T=l(S);g=a(T,"Trainer"),T.forEach(t),q=a(A," nous donne les pr\xE9dictions sous forme de tableaux NumPy, nous r\xE9cup\xE9rons les logits de d\xE9but et de fin et les convertissons dans ce format :"),A.forEach(t),x=c($),j(_.$$.fragment,$)},m($,A){E(p,$,A),i($,b,A),i($,f,A),s(f,y),s(f,S),s(S,g),s(f,q),i($,x,A),E(_,$,A),M=!0},i($){M||(h(p.$$.fragment,$),h(_.$$.fragment,$),M=!0)},o($){v(p.$$.fragment,$),v(_.$$.fragment,$),M=!1},d($){k(p,$),$&&t(b),$&&t(f),$&&t(x),k(_,$)}}}function Nq(R){let p,b,f,y,S;return{c(){p=o("p"),b=n("Maintenant, mettons tout ce que nous venons de faire dans une fonction "),f=o("code"),y=n("compute_metrics()"),S=n(" que nous utiliserons apr\xE8s avoir entra\xEEn\xE9 notre mod\xE8le. Nous aurons besoin de passer un peu plus que juste les logits de sortie, car nous devons chercher dans le jeu de donn\xE9es des caract\xE9ristiques pour le d\xE9calage et dans le jeu de donn\xE9es des exemples pour les contextes originaux :")},l(g){p=r(g,"P",{});var q=l(p);b=a(q,"Maintenant, mettons tout ce que nous venons de faire dans une fonction "),f=r(q,"CODE",{});var x=l(f);y=a(x,"compute_metrics()"),x.forEach(t),S=a(q," que nous utiliserons apr\xE8s avoir entra\xEEn\xE9 notre mod\xE8le. Nous aurons besoin de passer un peu plus que juste les logits de sortie, car nous devons chercher dans le jeu de donn\xE9es des caract\xE9ristiques pour le d\xE9calage et dans le jeu de donn\xE9es des exemples pour les contextes originaux :"),q.forEach(t)},m(g,q){i(g,p,q),s(p,b),s(p,f),s(f,y),s(p,S)},d(g){g&&t(p)}}}function Oq(R){let p,b,f,y,S,g,q,x,_,M,$,A,T,I,D,P,V,L,O,N,U,Q,J;return{c(){p=o("p"),b=n("Maintenant, mettons tout ce que nous venons de faire dans une fonction "),f=o("code"),y=n("compute_metrics()"),S=n(" que nous utiliserons dans le "),g=o("code"),q=n("Trainer"),x=n(". Normalement, cette fonction "),_=o("code"),M=n("compute_metrics()"),$=n(" re\xE7oit seulement un "),A=o("em"),T=n("tuple"),I=d(),D=o("code"),P=n("eval_preds"),V=n(" avec les logits et les \xE9tiquettes. Ici, nous aurons besoin d\u2019un peu plus, car nous devons chercher dans le jeu de donn\xE9es des caract\xE9ristiques pour le d\xE9calage et dans le jeu de donn\xE9es des exemples pour les contextes originaux. Ainsi nous ne serons pas en mesure d\u2019utiliser cette fonction pour obtenir des r\xE9sultats d\u2019\xE9valuation standards pendant l\u2019entra\xEEnement. Nous ne l\u2019utiliserons qu\u2019\xE0 la fin de l\u2019entra\xEEnement pour v\xE9rifier les r\xE9sultats."),L=d(),O=o("p"),N=n("La fonction "),U=o("code"),Q=n("compute_metrics()"),J=n(" regroupe les m\xEAmes \xE9tapes que pr\xE9c\xE9demment. Nous ajoutons juste une petite v\xE9rification au cas o\xF9 nous ne trouverions aucune r\xE9ponse valide (dans ce cas nous pr\xE9disons une cha\xEEne vide).")},l(H){p=r(H,"P",{});var G=l(p);b=a(G,"Maintenant, mettons tout ce que nous venons de faire dans une fonction "),f=r(G,"CODE",{});var ee=l(f);y=a(ee,"compute_metrics()"),ee.forEach(t),S=a(G," que nous utiliserons dans le "),g=r(G,"CODE",{});var Z=l(g);q=a(Z,"Trainer"),Z.forEach(t),x=a(G,". Normalement, cette fonction "),_=r(G,"CODE",{});var F=l(_);M=a(F,"compute_metrics()"),F.forEach(t),$=a(G," re\xE7oit seulement un "),A=r(G,"EM",{});var X=l(A);T=a(X,"tuple"),X.forEach(t),I=c(G),D=r(G,"CODE",{});var re=l(D);P=a(re,"eval_preds"),re.forEach(t),V=a(G," avec les logits et les \xE9tiquettes. Ici, nous aurons besoin d\u2019un peu plus, car nous devons chercher dans le jeu de donn\xE9es des caract\xE9ristiques pour le d\xE9calage et dans le jeu de donn\xE9es des exemples pour les contextes originaux. Ainsi nous ne serons pas en mesure d\u2019utiliser cette fonction pour obtenir des r\xE9sultats d\u2019\xE9valuation standards pendant l\u2019entra\xEEnement. Nous ne l\u2019utiliserons qu\u2019\xE0 la fin de l\u2019entra\xEEnement pour v\xE9rifier les r\xE9sultats."),G.forEach(t),L=c(H),O=r(H,"P",{});var se=l(O);N=a(se,"La fonction "),U=r(se,"CODE",{});var K=l(U);Q=a(K,"compute_metrics()"),K.forEach(t),J=a(se," regroupe les m\xEAmes \xE9tapes que pr\xE9c\xE9demment. Nous ajoutons juste une petite v\xE9rification au cas o\xF9 nous ne trouverions aucune r\xE9ponse valide (dans ce cas nous pr\xE9disons une cha\xEEne vide)."),se.forEach(t)},m(H,G){i(H,p,G),s(p,b),s(p,f),s(f,y),s(p,S),s(p,g),s(g,q),s(p,x),s(p,_),s(_,M),s(p,$),s(p,A),s(A,T),s(p,I),s(p,D),s(D,P),s(p,V),i(H,L,G),i(H,O,G),s(O,N),s(O,U),s(U,Q),s(O,J)},d(H){H&&t(p),H&&t(L),H&&t(O)}}}function Bq(R){let p,b,f,y,S,g,q,x;return q=new z({props:{code:"model = TFAutoModelForQuestionAnswering.from_pretrained(model_checkpoint)",highlighted:"model = TFAutoModelForQuestionAnswering.from_pretrained(model_checkpoint)"}}),{c(){p=o("p"),b=n("Nous sommes maintenant pr\xEAts \xE0 entra\xEEner notre mod\xE8le. Cr\xE9ons-le en utilisant la classe "),f=o("code"),y=n("TFAutoModelForQuestionAnswering"),S=n(" comme pr\xE9c\xE9demment :"),g=d(),w(q.$$.fragment)},l(_){p=r(_,"P",{});var M=l(p);b=a(M,"Nous sommes maintenant pr\xEAts \xE0 entra\xEEner notre mod\xE8le. Cr\xE9ons-le en utilisant la classe "),f=r(M,"CODE",{});var $=l(f);y=a($,"TFAutoModelForQuestionAnswering"),$.forEach(t),S=a(M," comme pr\xE9c\xE9demment :"),M.forEach(t),g=c(_),j(q.$$.fragment,_)},m(_,M){i(_,p,M),s(p,b),s(p,f),s(f,y),s(p,S),i(_,g,M),E(q,_,M),x=!0},i(_){x||(h(q.$$.fragment,_),x=!0)},o(_){v(q.$$.fragment,_),x=!1},d(_){_&&t(p),_&&t(g),k(q,_)}}}function Fq(R){let p,b,f,y,S,g,q,x;return q=new z({props:{code:"model = AutoModelForQuestionAnswering.from_pretrained(model_checkpoint)",highlighted:"model = AutoModelForQuestionAnswering.from_pretrained(model_checkpoint)"}}),{c(){p=o("p"),b=n("Nous sommes maintenant pr\xEAts \xE0 entra\xEEner notre mod\xE8le. Cr\xE9ons-le en utilisant la classe "),f=o("code"),y=n("AutoModelForQuestionAnswering"),S=n(" comme pr\xE9c\xE9demment :"),g=d(),w(q.$$.fragment)},l(_){p=r(_,"P",{});var M=l(p);b=a(M,"Nous sommes maintenant pr\xEAts \xE0 entra\xEEner notre mod\xE8le. Cr\xE9ons-le en utilisant la classe "),f=r(M,"CODE",{});var $=l(f);y=a($,"AutoModelForQuestionAnswering"),$.forEach(t),S=a(M," comme pr\xE9c\xE9demment :"),M.forEach(t),g=c(_),j(q.$$.fragment,_)},m(_,M){i(_,p,M),s(p,b),s(p,f),s(f,y),s(p,S),i(_,g,M),E(q,_,M),x=!0},i(_){x||(h(q.$$.fragment,_),x=!0)},o(_){v(q.$$.fragment,_),x=!1},d(_){_&&t(p),_&&t(g),k(q,_)}}}function Iq(R){let p,b,f,y,S,g,q,x,_,M,$,A,T,I,D,P,V,L,O,N,U,Q,J,H,G,ee,Z;return y=new z({props:{code:`from transformers import DefaultDataCollator

data_collator = DefaultDataCollator(return_tensors="tf")`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DefaultDataCollator

data_collator = DefaultDataCollator(return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)`}}),_=new z({props:{code:`tf_train_dataset = train_dataset.to_tf_dataset(
    columns=[
        "input_ids",
        "start_positions",
        "end_positions",
        "attention_mask",
        "token_type_ids",
    ],
    collate_fn=data_collator,
    shuffle=True,
    batch_size=16,
)
tf_eval_dataset = validation_dataset.to_tf_dataset(
    columns=["input_ids", "attention_mask", "token_type_ids"],
    collate_fn=data_collator,
    shuffle=False,
    batch_size=16,
)`,highlighted:`tf_train_dataset = train_dataset.to_tf_dataset(
    columns=[
        <span class="hljs-string">&quot;input_ids&quot;</span>,
        <span class="hljs-string">&quot;start_positions&quot;</span>,
        <span class="hljs-string">&quot;end_positions&quot;</span>,
        <span class="hljs-string">&quot;attention_mask&quot;</span>,
        <span class="hljs-string">&quot;token_type_ids&quot;</span>,
    ],
    collate_fn=data_collator,
    shuffle=<span class="hljs-literal">True</span>,
    batch_size=<span class="hljs-number">16</span>,
)
tf_eval_dataset = validation_dataset.to_tf_dataset(
    columns=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
    collate_fn=data_collator,
    shuffle=<span class="hljs-literal">False</span>,
    batch_size=<span class="hljs-number">16</span>,
)`}}),I=new z({props:{code:`from transformers import create_optimizer
from transformers.keras_callbacks import PushToHubCallback
import tensorflow as tf

# Le nombre d'\xE9tapes d'entra\xEEnement est le nombre d'\xE9chantillons dans le jeu de donn\xE9es, divis\xE9 par la taille du batch,
# puis multipli\xE9 par le nombre total d'\xE9poques. Notez que le jeu de donn\xE9es tf_train_dataset est ici un tf.data.Dataset,
# et non le jeu de donn\xE9es original donc son len() est d\xE9j\xE0 num_samples // batch_size.
num_train_epochs = 3
num_train_steps = len(tf_train_dataset) * num_train_epochs
optimizer, schedule = create_optimizer(
    init_lr=2e-5,
    num_warmup_steps=0,
    num_train_steps=num_train_steps,
    weight_decay_rate=0.01,
)
model.compile(optimizer=optimizer)

# Entra\xEEner en mixed-precision float16
tf.keras.mixed_precision.set_global_policy("mixed_float16")`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> create_optimizer
<span class="hljs-keyword">from</span> transformers.keras_callbacks <span class="hljs-keyword">import</span> PushToHubCallback
<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-comment"># Le nombre d&#x27;\xE9tapes d&#x27;entra\xEEnement est le nombre d&#x27;\xE9chantillons dans le jeu de donn\xE9es, divis\xE9 par la taille du batch,</span>
<span class="hljs-comment"># puis multipli\xE9 par le nombre total d&#x27;\xE9poques. Notez que le jeu de donn\xE9es tf_train_dataset est ici un tf.data.Dataset,</span>
<span class="hljs-comment"># et non le jeu de donn\xE9es original donc son len() est d\xE9j\xE0 num_samples // batch_size.</span>
num_train_epochs = <span class="hljs-number">3</span>
num_train_steps = <span class="hljs-built_in">len</span>(tf_train_dataset) * num_train_epochs
optimizer, schedule = create_optimizer(
    init_lr=<span class="hljs-number">2e-5</span>,
    num_warmup_steps=<span class="hljs-number">0</span>,
    num_train_steps=num_train_steps,
    weight_decay_rate=<span class="hljs-number">0.01</span>,
)
model.<span class="hljs-built_in">compile</span>(optimizer=optimizer)

<span class="hljs-comment"># Entra\xEEner en mixed-precision float16</span>
tf.keras.mixed_precision.set_global_policy(<span class="hljs-string">&quot;mixed_float16&quot;</span>)`}}),{c(){p=o("p"),b=n("Maintenant que c\u2019est fait, nous pouvons cr\xE9er nos jeux de donn\xE9es TensorFlow. Nous pouvons utiliser le simple collateur de donn\xE9es par d\xE9faut cette fois-ci :"),f=d(),w(y.$$.fragment),S=d(),g=o("p"),q=n("Et maintenant nous cr\xE9ons les jeux de donn\xE9es comme d\u2019habitude."),x=d(),w(_.$$.fragment),M=d(),$=o("p"),A=n("Ensuite, nous configurons nos hyperparam\xE8tres d\u2019entra\xEEnement et compilons notre mod\xE8le :"),T=d(),w(I.$$.fragment),D=d(),P=o("p"),V=n("Enfin, nous sommes pr\xEAts \xE0 entra\xEEner avec "),L=o("code"),O=n("model.fit()"),N=n(". Nous utilisons un "),U=o("code"),Q=n("PushToHubCallback"),J=n(" pour t\xE9l\xE9charger le mod\xE8le sur le "),H=o("em"),G=n("Hub"),ee=n(" apr\xE8s chaque \xE9poque.")},l(F){p=r(F,"P",{});var X=l(p);b=a(X,"Maintenant que c\u2019est fait, nous pouvons cr\xE9er nos jeux de donn\xE9es TensorFlow. Nous pouvons utiliser le simple collateur de donn\xE9es par d\xE9faut cette fois-ci :"),X.forEach(t),f=c(F),j(y.$$.fragment,F),S=c(F),g=r(F,"P",{});var re=l(g);q=a(re,"Et maintenant nous cr\xE9ons les jeux de donn\xE9es comme d\u2019habitude."),re.forEach(t),x=c(F),j(_.$$.fragment,F),M=c(F),$=r(F,"P",{});var se=l($);A=a(se,"Ensuite, nous configurons nos hyperparam\xE8tres d\u2019entra\xEEnement et compilons notre mod\xE8le :"),se.forEach(t),T=c(F),j(I.$$.fragment,F),D=c(F),P=r(F,"P",{});var K=l(P);V=a(K,"Enfin, nous sommes pr\xEAts \xE0 entra\xEEner avec "),L=r(K,"CODE",{});var le=l(L);O=a(le,"model.fit()"),le.forEach(t),N=a(K,". Nous utilisons un "),U=r(K,"CODE",{});var Ce=l(U);Q=a(Ce,"PushToHubCallback"),Ce.forEach(t),J=a(K," pour t\xE9l\xE9charger le mod\xE8le sur le "),H=r(K,"EM",{});var ye=l(H);G=a(ye,"Hub"),ye.forEach(t),ee=a(K," apr\xE8s chaque \xE9poque."),K.forEach(t)},m(F,X){i(F,p,X),s(p,b),i(F,f,X),E(y,F,X),i(F,S,X),i(F,g,X),s(g,q),i(F,x,X),E(_,F,X),i(F,M,X),i(F,$,X),s($,A),i(F,T,X),E(I,F,X),i(F,D,X),i(F,P,X),s(P,V),s(P,L),s(L,O),s(P,N),s(P,U),s(U,Q),s(P,J),s(P,H),s(H,G),s(P,ee),Z=!0},i(F){Z||(h(y.$$.fragment,F),h(_.$$.fragment,F),h(I.$$.fragment,F),Z=!0)},o(F){v(y.$$.fragment,F),v(_.$$.fragment,F),v(I.$$.fragment,F),Z=!1},d(F){F&&t(p),F&&t(f),k(y,F),F&&t(S),F&&t(g),F&&t(x),k(_,F),F&&t(M),F&&t($),F&&t(T),k(I,F),F&&t(D),F&&t(P)}}}function Vq(R){let p,b,f,y,S,g,q,x,_,M,$,A,T,I,D,P,V,L,O,N,U,Q,J,H,G,ee,Z,F,X,re,se,K,le,Ce,ye,ie,xs,Fe,ue,$s,ls;return se=new z({props:{code:`from transformers import TrainingArguments

args = TrainingArguments(
    "bert-finetuned-squad",
    evaluation_strategy="no",
    save_strategy="epoch",
    learning_rate=2e-5,
    num_train_epochs=3,
    weight_decay=0.01,
    fp16=True,
    push_to_hub=True,
)`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

args = TrainingArguments(
    <span class="hljs-string">&quot;bert-finetuned-squad&quot;</span>,
    evaluation_strategy=<span class="hljs-string">&quot;no&quot;</span>,
    save_strategy=<span class="hljs-string">&quot;epoch&quot;</span>,
    learning_rate=<span class="hljs-number">2e-5</span>,
    num_train_epochs=<span class="hljs-number">3</span>,
    weight_decay=<span class="hljs-number">0.01</span>,
    fp16=<span class="hljs-literal">True</span>,
    push_to_hub=<span class="hljs-literal">True</span>,
)`}}),{c(){p=o("p"),b=n("Une fois ceci fait, nous pouvons d\xE9finir nos "),f=o("code"),y=n("TrainingArguments"),S=n(". Comme nous l\u2019avons dit lorsque nous avons d\xE9fini notre fonction pour calculer la m\xE9trique, nous ne serons pas en mesure d\u2019avoir une boucle d\u2019\xE9valuation standard \xE0 cause de la signature de la fonction "),g=o("code"),q=n("compute_metrics()"),x=n(". Nous pourrions \xE9crire notre propre sous-classe de "),_=o("code"),M=n("Trainer"),$=n(" pour faire cela (une approche que vous pouvez trouver dans le "),A=o("a"),T=n("script d\u2019exemple de r\xE9ponse aux questions"),I=n("), mais c\u2019est un peu trop long pour cette section. A la place, nous n\u2019\xE9valuerons le mod\xE8le qu\u2019\xE0 la fin de l\u2019entra\xEEnement et nous vous montrerons comment faire une \xE9valuation cela dans le paragraphe \xAB Une boucle d\u2019entra\xEEnement personnalis\xE9e \xBB ci-dessous."),D=d(),P=o("p"),V=n("C\u2019est l\xE0 que l\u2019API "),L=o("code"),O=n("Trainer"),N=n(" montre ses limites et que la biblioth\xE8que \u{1F917} "),U=o("em"),Q=n("Accelerate"),J=n(" brille : personnaliser la classe pour un cas d\u2019utilisation sp\xE9cifique peut \xEAtre p\xE9nible, mais modifier une boucle d\u2019entra\xEEnement est facile."),H=d(),G=o("p"),ee=n("Jetons un coup d\u2019\u0153il \xE0 notre "),Z=o("code"),F=n("TrainingArguments"),X=n(" :"),re=d(),w(se.$$.fragment),K=d(),le=o("p"),Ce=n("Nous avons d\xE9j\xE0 vu la plupart d\u2019entre eux. Nous d\xE9finissons quelques hyperparam\xE8tres (comme le taux d\u2019apprentissage, le nombre d\u2019\xE9poques d\u2019entra\xEEnement, un taux de d\xE9croissance des poids) et nous indiquons que nous voulons sauvegarder le mod\xE8le \xE0 la fin de chaque \xE9poque, sauter l\u2019\xE9valuation, et t\xE9l\xE9charger nos r\xE9sultats vers le "),ye=o("em"),ie=n("Hub"),xs=n(". Nous activons \xE9galement l\u2019entra\xEEnement en pr\xE9cision mixte avec "),Fe=o("code"),ue=n("fp16=True"),$s=n(", car cela peut acc\xE9l\xE9rer l\u2019entra\xEEnement sur un GPU r\xE9cent."),this.h()},l(W){p=r(W,"P",{});var Y=l(p);b=a(Y,"Une fois ceci fait, nous pouvons d\xE9finir nos "),f=r(Y,"CODE",{});var ws=l(f);y=a(ws,"TrainingArguments"),ws.forEach(t),S=a(Y,". Comme nous l\u2019avons dit lorsque nous avons d\xE9fini notre fonction pour calculer la m\xE9trique, nous ne serons pas en mesure d\u2019avoir une boucle d\u2019\xE9valuation standard \xE0 cause de la signature de la fonction "),g=r(Y,"CODE",{});var Bt=l(g);q=a(Bt,"compute_metrics()"),Bt.forEach(t),x=a(Y,". Nous pourrions \xE9crire notre propre sous-classe de "),_=r(Y,"CODE",{});var js=l(_);M=a(js,"Trainer"),js.forEach(t),$=a(Y," pour faire cela (une approche que vous pouvez trouver dans le "),A=r(Y,"A",{href:!0,rel:!0});var Ie=l(A);T=a(Ie,"script d\u2019exemple de r\xE9ponse aux questions"),Ie.forEach(t),I=a(Y,"), mais c\u2019est un peu trop long pour cette section. A la place, nous n\u2019\xE9valuerons le mod\xE8le qu\u2019\xE0 la fin de l\u2019entra\xEEnement et nous vous montrerons comment faire une \xE9valuation cela dans le paragraphe \xAB Une boucle d\u2019entra\xEEnement personnalis\xE9e \xBB ci-dessous."),Y.forEach(t),D=c(W),P=r(W,"P",{});var Ve=l(P);V=a(Ve,"C\u2019est l\xE0 que l\u2019API "),L=r(Ve,"CODE",{});var Es=l(L);O=a(Es,"Trainer"),Es.forEach(t),N=a(Ve," montre ses limites et que la biblioth\xE8que \u{1F917} "),U=r(Ve,"EM",{});var he=l(U);Q=a(he,"Accelerate"),he.forEach(t),J=a(Ve," brille : personnaliser la classe pour un cas d\u2019utilisation sp\xE9cifique peut \xEAtre p\xE9nible, mais modifier une boucle d\u2019entra\xEEnement est facile."),Ve.forEach(t),H=c(W),G=r(W,"P",{});var He=l(G);ee=a(He,"Jetons un coup d\u2019\u0153il \xE0 notre "),Z=r(He,"CODE",{});var pe=l(Z);F=a(pe,"TrainingArguments"),pe.forEach(t),X=a(He," :"),He.forEach(t),re=c(W),j(se.$$.fragment,W),K=c(W),le=r(W,"P",{});var ve=l(le);Ce=a(ve,"Nous avons d\xE9j\xE0 vu la plupart d\u2019entre eux. Nous d\xE9finissons quelques hyperparam\xE8tres (comme le taux d\u2019apprentissage, le nombre d\u2019\xE9poques d\u2019entra\xEEnement, un taux de d\xE9croissance des poids) et nous indiquons que nous voulons sauvegarder le mod\xE8le \xE0 la fin de chaque \xE9poque, sauter l\u2019\xE9valuation, et t\xE9l\xE9charger nos r\xE9sultats vers le "),ye=r(ve,"EM",{});var Ue=l(ye);ie=a(Ue,"Hub"),Ue.forEach(t),xs=a(ve,". Nous activons \xE9galement l\u2019entra\xEEnement en pr\xE9cision mixte avec "),Fe=r(ve,"CODE",{});var Re=l(Fe);ue=a(Re,"fp16=True"),Re.forEach(t),$s=a(ve,", car cela peut acc\xE9l\xE9rer l\u2019entra\xEEnement sur un GPU r\xE9cent."),ve.forEach(t),this.h()},h(){C(A,"href","https://github.com/huggingface/transformers/blob/master/examples/pytorch/question-answering/trainer_qa.py"),C(A,"rel","nofollow")},m(W,Y){i(W,p,Y),s(p,b),s(p,f),s(f,y),s(p,S),s(p,g),s(g,q),s(p,x),s(p,_),s(_,M),s(p,$),s(p,A),s(A,T),s(p,I),i(W,D,Y),i(W,P,Y),s(P,V),s(P,L),s(L,O),s(P,N),s(P,U),s(U,Q),s(P,J),i(W,H,Y),i(W,G,Y),s(G,ee),s(G,Z),s(Z,F),s(G,X),i(W,re,Y),E(se,W,Y),i(W,K,Y),i(W,le,Y),s(le,Ce),s(le,ye),s(ye,ie),s(le,xs),s(le,Fe),s(Fe,ue),s(le,$s),ls=!0},i(W){ls||(h(se.$$.fragment,W),ls=!0)},o(W){v(se.$$.fragment,W),ls=!1},d(W){W&&t(p),W&&t(D),W&&t(P),W&&t(H),W&&t(G),W&&t(re),k(se,W),W&&t(K),W&&t(le)}}}function Hq(R){let p,b;return p=new z({props:{code:`from transformers.keras_callbacks import PushToHubCallback

callback = PushToHubCallback(output_dir="bert-finetuned-squad", tokenizer=tokenizer)

# Nous allons faire la validation apr\xE8s, donc pas de validation au milieu de l'entra\xEEnement.
model.fit(tf_train_dataset, callbacks=[callback], epochs=num_train_epochs)`,highlighted:`<span class="hljs-keyword">from</span> transformers.keras_callbacks <span class="hljs-keyword">import</span> PushToHubCallback

callback = PushToHubCallback(output_dir=<span class="hljs-string">&quot;bert-finetuned-squad&quot;</span>, tokenizer=tokenizer)

<span class="hljs-comment"># Nous allons faire la validation apr\xE8s, donc pas de validation au milieu de l&#x27;entra\xEEnement.</span>
model.fit(tf_train_dataset, callbacks=[callback], epochs=num_train_epochs)`}}),{c(){w(p.$$.fragment)},l(f){j(p.$$.fragment,f)},m(f,y){E(p,f,y),b=!0},i(f){b||(h(p.$$.fragment,f),b=!0)},o(f){v(p.$$.fragment,f),b=!1},d(f){k(p,f)}}}function Uq(R){let p,b,f,y,S,g,q,x,_,M;return p=new yc({props:{$$slots:{default:[Rq]},$$scope:{ctx:R}}}),_=new z({props:{code:`from transformers import Trainer

trainer = Trainer(
    model=model,
    args=args,
    train_dataset=train_dataset,
    eval_dataset=validation_dataset,
    tokenizer=tokenizer,
)
trainer.train()`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Trainer

trainer = Trainer(
    model=model,
    args=args,
    train_dataset=train_dataset,
    eval_dataset=validation_dataset,
    tokenizer=tokenizer,
)
trainer.train()`}}),{c(){w(p.$$.fragment),b=d(),f=o("p"),y=n("Enfin, nous passons tout \xE0 la classe "),S=o("code"),g=n("Trainer"),q=n(" et lan\xE7ons l\u2019entra\xEEnement :"),x=d(),w(_.$$.fragment)},l($){j(p.$$.fragment,$),b=c($),f=r($,"P",{});var A=l(f);y=a(A,"Enfin, nous passons tout \xE0 la classe "),S=r(A,"CODE",{});var T=l(S);g=a(T,"Trainer"),T.forEach(t),q=a(A," et lan\xE7ons l\u2019entra\xEEnement :"),A.forEach(t),x=c($),j(_.$$.fragment,$)},m($,A){E(p,$,A),i($,b,A),i($,f,A),s(f,y),s(f,S),s(S,g),s(f,q),i($,x,A),E(_,$,A),M=!0},i($){M||(h(p.$$.fragment,$),h(_.$$.fragment,$),M=!0)},o($){v(p.$$.fragment,$),v(_.$$.fragment,$),M=!1},d($){k(p,$),$&&t(b),$&&t(f),$&&t(x),k(_,$)}}}function Rq(R){let p,b,f,y,S;return{c(){p=o("p"),b=n("\u{1F4A1} Si le r\xE9pertoire de sortie que vous utilisez existe, il doit \xEAtre un clone local du d\xE9p\xF4t vers lequel vous voulez pousser (donc d\xE9finissez un nouveau nom si vous obtenez une erreur lors de la d\xE9finition de votre "),f=o("code"),y=n("Trainer"),S=n(").")},l(g){p=r(g,"P",{});var q=l(p);b=a(q,"\u{1F4A1} Si le r\xE9pertoire de sortie que vous utilisez existe, il doit \xEAtre un clone local du d\xE9p\xF4t vers lequel vous voulez pousser (donc d\xE9finissez un nouveau nom si vous obtenez une erreur lors de la d\xE9finition de votre "),f=r(q,"CODE",{});var x=l(f);y=a(x,"Trainer"),x.forEach(t),S=a(q,")."),q.forEach(t)},m(g,q){i(g,p,q),s(p,b),s(p,f),s(f,y),s(p,S)},d(g){g&&t(p)}}}function Qq(R){let p,b,f,y,S,g,q,x,_,M,$,A,T,I;return T=new z({props:{code:`predictions = model.predict(tf_eval_dataset)
compute_metrics(
    predictions["start_logits"],
    predictions["end_logits"],
    validation_dataset,
    raw_datasets["validation"],
)`,highlighted:`predictions = model.predict(tf_eval_dataset)
compute_metrics(
    predictions[<span class="hljs-string">&quot;start_logits&quot;</span>],
    predictions[<span class="hljs-string">&quot;end_logits&quot;</span>],
    validation_dataset,
    raw_datasets[<span class="hljs-string">&quot;validation&quot;</span>],
)`}}),{c(){p=o("p"),b=n("Une fois l\u2019entra\xEEnement termin\xE9, nous pouvons enfin \xE9valuer notre mod\xE8le (et prier pour ne pas avoir d\xE9pens\xE9 tout ce temps de calcul pour rien). La m\xE9thode "),f=o("code"),y=n("predict()"),S=n(" de notre "),g=o("code"),q=n("model"),x=n(" se chargera d\u2019obtenir les pr\xE9dictions, et puisque nous avons fait tout le travail difficile de d\xE9finir une fonction "),_=o("code"),M=n("compute_metrics()"),$=n(" plus t\xF4t, nous pouvons obtenir nos r\xE9sultats en une seule ligne :"),A=d(),w(T.$$.fragment)},l(D){p=r(D,"P",{});var P=l(p);b=a(P,"Une fois l\u2019entra\xEEnement termin\xE9, nous pouvons enfin \xE9valuer notre mod\xE8le (et prier pour ne pas avoir d\xE9pens\xE9 tout ce temps de calcul pour rien). La m\xE9thode "),f=r(P,"CODE",{});var V=l(f);y=a(V,"predict()"),V.forEach(t),S=a(P," de notre "),g=r(P,"CODE",{});var L=l(g);q=a(L,"model"),L.forEach(t),x=a(P," se chargera d\u2019obtenir les pr\xE9dictions, et puisque nous avons fait tout le travail difficile de d\xE9finir une fonction "),_=r(P,"CODE",{});var O=l(_);M=a(O,"compute_metrics()"),O.forEach(t),$=a(P," plus t\xF4t, nous pouvons obtenir nos r\xE9sultats en une seule ligne :"),P.forEach(t),A=c(D),j(T.$$.fragment,D)},m(D,P){i(D,p,P),s(p,b),s(p,f),s(f,y),s(p,S),s(p,g),s(g,q),s(p,x),s(p,_),s(_,M),s(p,$),i(D,A,P),E(T,D,P),I=!0},i(D){I||(h(T.$$.fragment,D),I=!0)},o(D){v(T.$$.fragment,D),I=!1},d(D){D&&t(p),D&&t(A),k(T,D)}}}function Gq(R){let p,b,f,y,S,g,q,x,_,M,$,A,T,I,D,P,V;return P=new z({props:{code:`predictions, _ = trainer.predict(validation_dataset)
start_logits, end_logits = predictions
compute_metrics(start_logits, end_logits, validation_dataset, raw_datasets["validation"])`,highlighted:`predictions, _ = trainer.predict(validation_dataset)
start_logits, end_logits = predictions
compute_metrics(start_logits, end_logits, validation_dataset, raw_datasets[<span class="hljs-string">&quot;validation&quot;</span>])`}}),{c(){p=o("p"),b=n("Une fois l\u2019entra\xEEnement termin\xE9, nous pouvons enfin \xE9valuer notre mod\xE8le (et prier pour ne pas avoir d\xE9pens\xE9 tout ce temps de calcul pour rien). La m\xE9thode "),f=o("code"),y=n("predict()"),S=n(" du "),g=o("code"),q=n("Trainer"),x=n(" retournera un "),_=o("em"),M=n("tuple"),$=n(" o\xF9 les premiers \xE9l\xE9ments seront les pr\xE9dictions du mod\xE8le (ici une paire avec les logits de d\xE9but et de fin). Nous envoyons ceci \xE0 notre fonction "),A=o("code"),T=n("compute_metrics()"),I=n(" :"),D=d(),w(P.$$.fragment)},l(L){p=r(L,"P",{});var O=l(p);b=a(O,"Une fois l\u2019entra\xEEnement termin\xE9, nous pouvons enfin \xE9valuer notre mod\xE8le (et prier pour ne pas avoir d\xE9pens\xE9 tout ce temps de calcul pour rien). La m\xE9thode "),f=r(O,"CODE",{});var N=l(f);y=a(N,"predict()"),N.forEach(t),S=a(O," du "),g=r(O,"CODE",{});var U=l(g);q=a(U,"Trainer"),U.forEach(t),x=a(O," retournera un "),_=r(O,"EM",{});var Q=l(_);M=a(Q,"tuple"),Q.forEach(t),$=a(O," o\xF9 les premiers \xE9l\xE9ments seront les pr\xE9dictions du mod\xE8le (ici une paire avec les logits de d\xE9but et de fin). Nous envoyons ceci \xE0 notre fonction "),A=r(O,"CODE",{});var J=l(A);T=a(J,"compute_metrics()"),J.forEach(t),I=a(O," :"),O.forEach(t),D=c(L),j(P.$$.fragment,L)},m(L,O){i(L,p,O),s(p,b),s(p,f),s(f,y),s(p,S),s(p,g),s(g,q),s(p,x),s(p,_),s(_,M),s(p,$),s(p,A),s(A,T),s(p,I),i(L,D,O),E(P,L,O),V=!0},i(L){V||(h(P.$$.fragment,L),V=!0)},o(L){v(P.$$.fragment,L),V=!1},d(L){L&&t(p),L&&t(D),k(P,L)}}}function _q(R){let p,b,f,y,S,g,q,x,_,M,$,A,T,I,D,P,V,L,O;return q=new z({props:{code:'trainer.push_to_hub(commit_message="Training complete")',highlighted:'trainer.push_to_hub(commit_message=<span class="hljs-string">&quot;Training complete&quot;</span>)'}}),A=new z({props:{code:"'https://huggingface.co/sgugger/bert-finetuned-squad/commit/9dcee1fbc25946a6ed4bb32efb1bd71d5fa90b68'",highlighted:'<span class="hljs-string">&#x27;https://huggingface.co/sgugger/bert-finetuned-squad/commit/9dcee1fbc25946a6ed4bb32efb1bd71d5fa90b68&#x27;</span>'}}),{c(){p=o("p"),b=n("Enfin, nous utilisons la m\xE9thode "),f=o("code"),y=n("push_to_hub()"),S=n(" pour nous assurer que nous t\xE9l\xE9chargeons la derni\xE8re version du mod\xE8le :"),g=d(),w(q.$$.fragment),x=d(),_=o("p"),M=n("Cela renvoie l\u2019URL du commit qu\u2019il vient de faire, si vous voulez l\u2019inspecter :"),$=d(),w(A.$$.fragment),T=d(),I=o("p"),D=n("Le "),P=o("code"),V=n("Trainer"),L=n(" r\xE9dige \xE9galement une carte de mod\xE8le avec tous les r\xE9sultats de l\u2019\xE9valuation et la t\xE9l\xE9charge.")},l(N){p=r(N,"P",{});var U=l(p);b=a(U,"Enfin, nous utilisons la m\xE9thode "),f=r(U,"CODE",{});var Q=l(f);y=a(Q,"push_to_hub()"),Q.forEach(t),S=a(U," pour nous assurer que nous t\xE9l\xE9chargeons la derni\xE8re version du mod\xE8le :"),U.forEach(t),g=c(N),j(q.$$.fragment,N),x=c(N),_=r(N,"P",{});var J=l(_);M=a(J,"Cela renvoie l\u2019URL du commit qu\u2019il vient de faire, si vous voulez l\u2019inspecter :"),J.forEach(t),$=c(N),j(A.$$.fragment,N),T=c(N),I=r(N,"P",{});var H=l(I);D=a(H,"Le "),P=r(H,"CODE",{});var G=l(P);V=a(G,"Trainer"),G.forEach(t),L=a(H," r\xE9dige \xE9galement une carte de mod\xE8le avec tous les r\xE9sultats de l\u2019\xE9valuation et la t\xE9l\xE9charge."),H.forEach(t)},m(N,U){i(N,p,U),s(p,b),s(p,f),s(f,y),s(p,S),i(N,g,U),E(q,N,U),i(N,x,U),i(N,_,U),s(_,M),i(N,$,U),E(A,N,U),i(N,T,U),i(N,I,U),s(I,D),s(I,P),s(P,V),s(I,L),O=!0},i(N){O||(h(q.$$.fragment,N),h(A.$$.fragment,N),O=!0)},o(N){v(q.$$.fragment,N),v(A.$$.fragment,N),O=!1},d(N){N&&t(p),N&&t(g),k(q,N),N&&t(x),N&&t(_),N&&t($),k(A,N),N&&t(T),N&&t(I)}}}function Wq(R){let p,b,f,y,S;return{c(){p=o("p"),b=n("\u270F\uFE0F "),f=o("strong"),y=n("A votre tour"),S=n(" Essayez un autre mod\xE8le pour voir s\u2019il est plus performant pour cette t\xE2che !")},l(g){p=r(g,"P",{});var q=l(p);b=a(q,"\u270F\uFE0F "),f=r(q,"STRONG",{});var x=l(f);y=a(x,"A votre tour"),x.forEach(t),S=a(q," Essayez un autre mod\xE8le pour voir s\u2019il est plus performant pour cette t\xE2che !"),q.forEach(t)},m(g,q){i(g,p,q),s(p,b),s(p,f),s(f,y),s(p,S)},d(g){g&&t(p)}}}function hq(R){let p,b,f,y,S,g,q,x,_,M,$,A,T,I,D,P,V,L,O,N,U,Q,J,H,G,ee,Z,F,X,re,se,K,le,Ce,ye,ie,xs,Fe,ue,$s,ls,W,Y,ws,Bt,js,Ie,Ve,Es,he,He,pe,ve,Ue,Re,mo,Ft,Js,En,be,fo,is,_o,ho,ks,Xs,ta,te,us,Qe,kn,Ks,yn,Cn,vo,It,ys,bo,Ys,go,qo,Vt,Zs,na,Cs,xo,aa,ps,oa,et,Pn,me,ra,Pe,$o,An,Sn,wo,Mn,zn,jo,la,Ps,As,de,st,Ht,oe,Eo,tt,ko,yo,nt,Co,Po,at,Ao,So,ot,Mo,zo,Ut,rt,ia,ds,ua,Rt,pa,cs,lt,Qt,Ge,Do,Gt,it,da,ms,ca,Wt,ma,We,Ae,Jt,Oe,fa,Je,To,Xt,Kt,Lo,Dn,je,Ss,ut,Yt,Zt,No,_a,ce,Ms,pt,dt,Oo,ct,Bo,ha,fs,va,zs,Fo,ge,Io,Tn,ba,Ds,Ln,Nn,Vo,On,ga,mt,en,ne,Ho,sn,tn,Uo,nn,ft,qa,Xe,Ro,Bn,_t,Qo,xa,_s,$a,ae,Fn,In,Go,Vn,Hn,Wo,wa,hs,ja,ht,an,Ke,Jo,vt,Xo,Ko,bt,Yo,Zo,on,gt,Ea,qt,Ye,ka,vs,ya,xt,Ts,Se,er,Un,Ca;return M=new qs({}),Z=new qs({}),he=new z({props:{code:`from torch.utils.data import DataLoader
from transformers import default_data_collator

train_dataset.set_format("torch")
validation_set = validation_dataset.remove_columns(["example_id", "offset_mapping"])
validation_set.set_format("torch")

train_dataloader = DataLoader(
    train_dataset,
    shuffle=True,
    collate_fn=default_data_collator,
    batch_size=8,
)
eval_dataloader = DataLoader(
    validation_set, collate_fn=default_data_collator, batch_size=8
)`,highlighted:`<span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> default_data_collator

train_dataset.set_format(<span class="hljs-string">&quot;torch&quot;</span>)
validation_set = validation_dataset.remove_columns([<span class="hljs-string">&quot;example_id&quot;</span>, <span class="hljs-string">&quot;offset_mapping&quot;</span>])
validation_set.set_format(<span class="hljs-string">&quot;torch&quot;</span>)

train_dataloader = DataLoader(
    train_dataset,
    shuffle=<span class="hljs-literal">True</span>,
    collate_fn=default_data_collator,
    batch_size=<span class="hljs-number">8</span>,
)
eval_dataloader = DataLoader(
    validation_set, collate_fn=default_data_collator, batch_size=<span class="hljs-number">8</span>
)`}}),Js=new z({props:{code:"model = AutoModelForQuestionAnswering.from_pretrained(model_checkpoint)",highlighted:"model = AutoModelForQuestionAnswering.from_pretrained(model_checkpoint)"}}),Xs=new z({props:{code:`from torch.optim import AdamW

optimizer = AdamW(model.parameters(), lr=2e-5)`,highlighted:`<span class="hljs-keyword">from</span> torch.optim <span class="hljs-keyword">import</span> AdamW

optimizer = AdamW(model.parameters(), lr=<span class="hljs-number">2e-5</span>)`}}),me=new z({props:{code:`from accelerate import Accelerator

accelerator = Accelerator(fp16=True)
model, optimizer, train_dataloader, eval_dataloader = accelerator.prepare(
    model, optimizer, train_dataloader, eval_dataloader
)`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerator

accelerator = Accelerator(fp16=<span class="hljs-literal">True</span>)
model, optimizer, train_dataloader, eval_dataloader = accelerator.prepare(
    model, optimizer, train_dataloader, eval_dataloader
)`}}),Ps=new z({props:{code:`from transformers import get_scheduler

num_train_epochs = 3
num_update_steps_per_epoch = len(train_dataloader)
num_training_steps = num_train_epochs * num_update_steps_per_epoch

lr_scheduler = get_scheduler(
    "linear",
    optimizer=optimizer,
    num_warmup_steps=0,
    num_training_steps=num_training_steps,
)`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> get_scheduler

num_train_epochs = <span class="hljs-number">3</span>
num_update_steps_per_epoch = <span class="hljs-built_in">len</span>(train_dataloader)
num_training_steps = num_train_epochs * num_update_steps_per_epoch

lr_scheduler = get_scheduler(
    <span class="hljs-string">&quot;linear&quot;</span>,
    optimizer=optimizer,
    num_warmup_steps=<span class="hljs-number">0</span>,
    num_training_steps=num_training_steps,
)`}}),rt=new z({props:{code:`from huggingface_hub import Repository, get_full_repo_name

model_name = "bert-finetuned-squad-accelerate"
repo_name = get_full_repo_name(model_name)
repo_name`,highlighted:`<span class="hljs-keyword">from</span> huggingface_hub <span class="hljs-keyword">import</span> Repository, get_full_repo_name

model_name = <span class="hljs-string">&quot;bert-finetuned-squad-accelerate&quot;</span>
repo_name = get_full_repo_name(model_name)
repo_name`}}),ds=new z({props:{code:"'sgugger/bert-finetuned-squad-accelerate'",highlighted:'<span class="hljs-string">&#x27;sgugger/bert-finetuned-squad-accelerate&#x27;</span>'}}),lt=new z({props:{code:`output_dir = "bert-finetuned-squad-accelerate"
repo = Repository(output_dir, clone_from=repo_name)`,highlighted:`output_dir = <span class="hljs-string">&quot;bert-finetuned-squad-accelerate&quot;</span>
repo = Repository(output_dir, clone_from=repo_name)`}}),Oe=new qs({}),ft=new z({props:{code:`from tqdm.auto import tqdm
import torch

progress_bar = tqdm(range(num_training_steps))

for epoch in range(num_train_epochs):
    # Entra\xEEnement
    model.train()
    for step, batch in enumerate(train_dataloader):
        outputs = model(**batch)
        loss = outputs.loss
        accelerator.backward(loss)

        optimizer.step()
        lr_scheduler.step()
        optimizer.zero_grad()
        progress_bar.update(1)

    # Evaluation
    model.eval()
    start_logits = []
    end_logits = []
    accelerator.print("Evaluation!")
    for batch in tqdm(eval_dataloader):
        with torch.no_grad():
            outputs = model(**batch)

        start_logits.append(accelerator.gather(outputs.start_logits).cpu().numpy())
        end_logits.append(accelerator.gather(outputs.end_logits).cpu().numpy())

    start_logits = np.concatenate(start_logits)
    end_logits = np.concatenate(end_logits)
    start_logits = start_logits[: len(validation_dataset)]
    end_logits = end_logits[: len(validation_dataset)]

    metrics = compute_metrics(
        start_logits, end_logits, validation_dataset, raw_datasets["validation"]
    )
    print(f"epoch {epoch}:", metrics)

    # Sauvegarder et t\xE9l\xE9charger
    accelerator.wait_for_everyone()
    unwrapped_model = accelerator.unwrap_model(model)
    unwrapped_model.save_pretrained(output_dir, save_function=accelerator.save)
    if accelerator.is_main_process:
        tokenizer.save_pretrained(output_dir)
        repo.push_to_hub(
            commit_message=f"Training in progress epoch {epoch}", blocking=False
        )`,highlighted:`<span class="hljs-keyword">from</span> tqdm.auto <span class="hljs-keyword">import</span> tqdm
<span class="hljs-keyword">import</span> torch

progress_bar = tqdm(<span class="hljs-built_in">range</span>(num_training_steps))

<span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_train_epochs):
    <span class="hljs-comment"># Entra\xEEnement</span>
    model.train()
    <span class="hljs-keyword">for</span> step, batch <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_dataloader):
        outputs = model(**batch)
        loss = outputs.loss
        accelerator.backward(loss)

        optimizer.step()
        lr_scheduler.step()
        optimizer.zero_grad()
        progress_bar.update(<span class="hljs-number">1</span>)

    <span class="hljs-comment"># Evaluation</span>
    model.<span class="hljs-built_in">eval</span>()
    start_logits = []
    end_logits = []
    accelerator.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Evaluation!&quot;</span>)
    <span class="hljs-keyword">for</span> batch <span class="hljs-keyword">in</span> tqdm(eval_dataloader):
        <span class="hljs-keyword">with</span> torch.no_grad():
            outputs = model(**batch)

        start_logits.append(accelerator.gather(outputs.start_logits).cpu().numpy())
        end_logits.append(accelerator.gather(outputs.end_logits).cpu().numpy())

    start_logits = np.concatenate(start_logits)
    end_logits = np.concatenate(end_logits)
    start_logits = start_logits[: <span class="hljs-built_in">len</span>(validation_dataset)]
    end_logits = end_logits[: <span class="hljs-built_in">len</span>(validation_dataset)]

    metrics = compute_metrics(
        start_logits, end_logits, validation_dataset, raw_datasets[<span class="hljs-string">&quot;validation&quot;</span>]
    )
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;epoch <span class="hljs-subst">{epoch}</span>:&quot;</span>, metrics)

    <span class="hljs-comment"># Sauvegarder et t\xE9l\xE9charger</span>
    accelerator.wait_for_everyone()
    unwrapped_model = accelerator.unwrap_model(model)
    unwrapped_model.save_pretrained(output_dir, save_function=accelerator.save)
    <span class="hljs-keyword">if</span> accelerator.is_main_process:
        tokenizer.save_pretrained(output_dir)
        repo.push_to_hub(
            commit_message=<span class="hljs-string">f&quot;Training in progress epoch <span class="hljs-subst">{epoch}</span>&quot;</span>, blocking=<span class="hljs-literal">False</span>
        )`}}),_s=new z({props:{code:`accelerator.wait_for_everyone()
unwrapped_model = accelerator.unwrap_model(model)
unwrapped_model.save_pretrained(output_dir, save_function=accelerator.save)`,highlighted:`accelerator.wait_for_everyone()
unwrapped_model = accelerator.unwrap_model(model)
unwrapped_model.save_pretrained(output_dir, save_function=accelerator.save)`}}),{c(){p=o("p"),b=n("Si vous voulez plonger un peu plus profond\xE9ment dans la boucle d\u2019entra\xEEnement, nous allons maintenant vous montrer comment faire la m\xEAme chose en utilisant \u{1F917} "),f=o("em"),y=n("Accelerate"),S=n("."),g=d(),q=o("h2"),x=o("a"),_=o("span"),w(M.$$.fragment),$=d(),A=o("span"),T=n("Une boucle d'entra\xEEnement personnalis\xE9e"),I=d(),D=o("p"),P=n("Jetons maintenant un coup d\u2019\u0153il \xE0 la boucle d\u2019entra\xEEnement compl\xE8te, afin que vous puissiez facilement personnaliser les parties dont vous avez besoin. Elle ressemblera beaucoup \xE0 la boucle d\u2019entra\xEEnement du "),V=o("a"),L=n("chapitre 3"),O=n(", \xE0 l\u2019exception de la boucle d\u2019\xE9valuation. Nous serons en mesure d\u2019\xE9valuer le mod\xE8le r\xE9guli\xE8rement puisque nous ne sommes plus contraints par la classe "),N=o("code"),U=n("Trainer"),Q=n("."),J=d(),H=o("h3"),G=o("a"),ee=o("span"),w(Z.$$.fragment),F=d(),X=o("span"),re=n("Pr\xE9parer tout pour l'entra\xEEnement"),se=d(),K=o("p"),le=n("Tout d\u2019abord, nous devons construire le "),Ce=o("code"),ye=n("DataLoader"),ie=n("s \xE0 partir de nos jeux de donn\xE9es. Nous d\xE9finissons le format de ces jeux de donn\xE9es \xE0 "),xs=o("code"),Fe=n('"torch"'),ue=n(" et supprimons les colonnes dans le jeu de validation qui ne sont pas utilis\xE9es par le mod\xE8le. Ensuite, nous pouvons utiliser le "),$s=o("code"),ls=n("default_data_collator"),W=n(" fourni par \u{1F917} "),Y=o("em"),ws=n("Transformers"),Bt=n(" comme "),js=o("code"),Ie=n("collate_fn"),Ve=n(" et m\xE9langer l\u2019ensemble d\u2019entra\xEEnement mais pas celui de validation :"),Es=d(),w(he.$$.fragment),He=d(),pe=o("p"),ve=n("Ensuite, nous r\xE9instantifions notre mod\xE8le afin de nous assurer que nous ne poursuivons pas le "),Ue=o("em"),Re=n("finetuning"),mo=n(" pr\xE9c\xE9dent et que nous repartons du mod\xE8le BERT pr\xE9-entra\xEEn\xE9 :"),Ft=d(),w(Js.$$.fragment),En=d(),be=o("p"),fo=n("Ensuite, nous aurons besoin d\u2019un optimiseur. Comme d\u2019habitude, nous utilisons le classique "),is=o("code"),_o=n("AdamW"),ho=n(", qui est comme Adam mais avec une correction dans la fa\xE7on dont le taux de d\xE9croissance des poids est appliqu\xE9 :"),ks=d(),w(Xs.$$.fragment),ta=d(),te=o("p"),us=n("Une fois que nous avons tous ces objets, nous pouvons les envoyer \xE0 la m\xE9thode "),Qe=o("code"),kn=n("accelerator.prepare()"),Ks=n(". Rappelez-vous que si vous voulez entra\xEEner sur des TPUs dans un "),yn=o("em"),Cn=n("notebook"),vo=n(" Colab, vous devrez d\xE9placer tout ce code dans une fonction d\u2019entra\xEEnement, et qui ne devrait pas ex\xE9cuter une cellule qui instancie un "),It=o("code"),ys=n("Accelerator"),bo=n(". Nous pouvons forcer l\u2019entra\xEEnement en pr\xE9cision mixte en passant l\u2019argument "),Ys=o("code"),go=n("fp16=True"),qo=n(" \xE0 "),Vt=o("code"),Zs=n("Accelerator"),na=n(" (ou, si vous ex\xE9cutez le code comme un script, assurez-vous de remplir la \u{1F917} "),Cs=o("em"),xo=n("Accelerate"),aa=d(),ps=o("code"),oa=n("config"),et=n(" de mani\xE8re appropri\xE9e)."),Pn=d(),w(me.$$.fragment),ra=d(),Pe=o("p"),$o=n("Comme vous devez le savoir depuis les sections pr\xE9c\xE9dentes, nous ne pouvons utiliser la longueur de "),An=o("code"),Sn=n("train_dataloader"),wo=n(" pour calculer le nombre d\u2019\xE9tapes d\u2019entra\xEEnement qu\u2019apr\xE8s qu\u2019il soit pass\xE9 par la m\xE9thode "),Mn=o("code"),zn=n("accelerator.prepare()"),jo=n(". Nous utilisons le m\xEAme programme lin\xE9aire que dans les sections pr\xE9c\xE9dentes :"),la=d(),w(Ps.$$.fragment),As=d(),de=o("p"),st=n("Pour pousser notre mod\xE8le vers le "),Ht=o("em"),oe=n("Hub"),Eo=n(", nous aurons besoin de cr\xE9er un objet "),tt=o("code"),ko=n("Repository"),yo=n(" dans un dossier de travail. Tout d\u2019abord, connectez-vous au "),nt=o("em"),Co=n("Hub"),Po=n(", si vous n\u2019\xEAtes pas d\xE9j\xE0 connect\xE9. Nous d\xE9terminerons le nom du d\xE9p\xF4t \xE0 partir de l\u2019identifiant du mod\xE8le que nous voulons donner \xE0 notre mod\xE8le (n\u2019h\xE9sitez pas \xE0 remplacer le "),at=o("code"),Ao=n("repo_name"),So=n(" par votre propre choix. Il doit juste contenir votre nom d\u2019utilisateur, ce que fait la fonction "),ot=o("code"),Mo=n("get_full_repo_name()"),zo=n(") :"),Ut=d(),w(rt.$$.fragment),ia=d(),w(ds.$$.fragment),ua=d(),Rt=o("p"),pa=n("Ensuite, nous pouvons cloner ce d\xE9p\xF4t dans un dossier local. S\u2019il existe d\xE9j\xE0, ce dossier local doit \xEAtre un clone du d\xE9p\xF4t avec lequel nous travaillons :"),cs=d(),w(lt.$$.fragment),Qt=d(),Ge=o("p"),Do=n("Nous pouvons maintenant t\xE9l\xE9charger tout ce que nous sauvegardons dans "),Gt=o("code"),it=n("output_dir"),da=n(" en appelant la m\xE9thode "),ms=o("code"),ca=n("repo.push_to_hub()"),Wt=n(". Cela nous aidera \xE0 t\xE9l\xE9charger les mod\xE8les interm\xE9diaires \xE0 la fin de chaque \xE9poque."),ma=d(),We=o("h2"),Ae=o("a"),Jt=o("span"),w(Oe.$$.fragment),fa=d(),Je=o("span"),To=n("Boucle d'entra\xEEnement"),Xt=d(),Kt=o("p"),Lo=n("Nous sommes maintenant pr\xEAts \xE0 \xE9crire la boucle d\u2019entra\xEEnement compl\xE8te. Apr\xE8s avoir d\xE9fini une barre de progression pour suivre l\u2019\xE9volution de l\u2019entra\xEEnement, la boucle comporte trois parties :"),Dn=d(),je=o("ul"),Ss=o("li"),ut=n("l\u2019entra\xEEnement \xE0 proprement dit, qui est l\u2019it\xE9ration classique sur le "),Yt=o("code"),Zt=n("train_dataloader"),No=n(", passage en avant du mod\xE8le, puis passage en arri\xE8re et \xE9tape d\u2019optimisation."),_a=d(),ce=o("li"),Ms=n("l\u2019\xE9valuation, dans laquelle nous rassemblons toutes les valeurs pour "),pt=o("code"),dt=n("start_logits"),Oo=n(" et "),ct=o("code"),Bo=n("end_logits"),ha=n(" avant de les convertir en tableaux NumPy. Une fois la boucle d\u2019\xE9valuation termin\xE9e, nous concat\xE9nons tous les r\xE9sultats. Notez que nous devons tronquer car "),fs=o("code"),va=n("Accelerator"),zs=n(" peut avoir ajout\xE9 quelques \xE9chantillons \xE0 la fin pour s\u2019assurer que nous avons le m\xEAme nombre d\u2019exemples dans chaque processus."),Fo=d(),ge=o("li"),Io=n("sauvegarde et t\xE9l\xE9chargement, o\xF9 nous sauvegardons d\u2019abord le mod\xE8le et le "),Tn=o("em"),ba=n("tokenizer"),Ds=n(", puis appelons "),Ln=o("code"),Nn=n("repo.push_to_hub()"),Vo=n(". Comme nous l\u2019avons fait auparavant, nous utilisons l\u2019argument "),On=o("code"),ga=n("blocking=False"),mt=n(" pour dire \xE0 la biblioth\xE8que \u{1F917} "),en=o("em"),ne=n("Hub"),Ho=n(" de pousser dans un processus asynchrone. De cette fa\xE7on, l\u2019entra\xEEnement continue normalement et cette (longue) instruction est ex\xE9cut\xE9e en arri\xE8re-plan."),sn=d(),tn=o("p"),Uo=n("Voici le code complet de la boucle d\u2019entra\xEEnement :"),nn=d(),w(ft.$$.fragment),qa=d(),Xe=o("p"),Ro=n("Au cas o\xF9 ce serait la premi\xE8re fois que vous verriez un mod\xE8le enregistr\xE9 avec \u{1F917} "),Bn=o("em"),_t=n("Accelerate"),Qo=n(", prenons un moment pour inspecter les trois lignes de code qui l\u2019accompagnent :"),xa=d(),w(_s.$$.fragment),$a=d(),ae=o("p"),Fn=n("La premi\xE8re ligne est explicite : elle indique \xE0 tous les processus d\u2019attendre que tout le monde soit \xE0 ce stade avant de continuer. C\u2019est pour s\u2019assurer que nous avons le m\xEAme mod\xE8le dans chaque processus avant de sauvegarder. Ensuite, nous prenons le "),In=o("code"),Go=n("unwrapped_model"),Vn=n(", qui est le mod\xE8le de base que nous avons d\xE9fini. La m\xE9thode "),Hn=o("code"),Wo=n("accelerator.prepare()"),wa=n(" modifie le mod\xE8le pour qu\u2019il fonctionne dans l\u2019entra\xEEnement distribu\xE9. Donc il n\u2019aura plus la m\xE9thode "),hs=o("code"),ja=n("save_pretrained()"),ht=n(" car la m\xE9thode "),an=o("code"),Ke=n("accelerator.unwrap_model()"),Jo=n(" annule cette \xE9tape. Enfin, nous appelons "),vt=o("code"),Xo=n("save_pretrained()"),Ko=n(" mais nous disons \xE0 cette m\xE9thode d\u2019utiliser "),bt=o("code"),Yo=n("accelerator.save()"),Zo=n(" au lieu de "),on=o("code"),gt=n("torch.save()"),Ea=n("."),qt=d(),Ye=o("p"),ka=n("Une fois ceci fait, vous devriez avoir un mod\xE8le qui produit des r\xE9sultats assez similaires \xE0 celui entra\xEEn\xE9 avec "),vs=o("code"),ya=n("Trainer"),xt=n(". Vous pouvez v\xE9rifier le mod\xE8le que nous avons entra\xEEn\xE9 en utilisant ce code \xE0 "),Ts=o("a"),Se=o("em"),er=n("huggingface-course/bert-finetuned-squad-accelerate"),Un=n(". Et si vous voulez tester des modifications de la boucle d\u2019entra\xEEnement, vous pouvez les impl\xE9menter directement en modifiant le code ci-dessus !"),this.h()},l(m){p=r(m,"P",{});var B=l(p);b=a(B,"Si vous voulez plonger un peu plus profond\xE9ment dans la boucle d\u2019entra\xEEnement, nous allons maintenant vous montrer comment faire la m\xEAme chose en utilisant \u{1F917} "),f=r(B,"EM",{});var il=l(f);y=a(il,"Accelerate"),il.forEach(t),S=a(B,"."),B.forEach(t),g=c(m),q=r(m,"H2",{class:!0});var Pa=l(q);x=r(Pa,"A",{id:!0,class:!0,href:!0});var sr=l(x);_=r(sr,"SPAN",{});var Ls=l(_);j(M.$$.fragment,Ls),Ls.forEach(t),sr.forEach(t),$=c(Pa),A=r(Pa,"SPAN",{});var rn=l(A);T=a(rn,"Une boucle d'entra\xEEnement personnalis\xE9e"),rn.forEach(t),Pa.forEach(t),I=c(m),D=r(m,"P",{});var Rn=l(D);P=a(Rn,"Jetons maintenant un coup d\u2019\u0153il \xE0 la boucle d\u2019entra\xEEnement compl\xE8te, afin que vous puissiez facilement personnaliser les parties dont vous avez besoin. Elle ressemblera beaucoup \xE0 la boucle d\u2019entra\xEEnement du "),V=r(Rn,"A",{href:!0});var ul=l(V);L=a(ul,"chapitre 3"),ul.forEach(t),O=a(Rn,", \xE0 l\u2019exception de la boucle d\u2019\xE9valuation. Nous serons en mesure d\u2019\xE9valuer le mod\xE8le r\xE9guli\xE8rement puisque nous ne sommes plus contraints par la classe "),N=r(Rn,"CODE",{});var ln=l(N);U=a(ln,"Trainer"),ln.forEach(t),Q=a(Rn,"."),Rn.forEach(t),J=c(m),H=r(m,"H3",{class:!0});var tr=l(H);G=r(tr,"A",{id:!0,class:!0,href:!0});var nr=l(G);ee=r(nr,"SPAN",{});var bs=l(ee);j(Z.$$.fragment,bs),bs.forEach(t),nr.forEach(t),F=c(tr),X=r(tr,"SPAN",{});var pl=l(X);re=a(pl,"Pr\xE9parer tout pour l'entra\xEEnement"),pl.forEach(t),tr.forEach(t),se=c(m),K=r(m,"P",{});var qe=l(K);le=a(qe,"Tout d\u2019abord, nous devons construire le "),Ce=r(qe,"CODE",{});var dl=l(Ce);ye=a(dl,"DataLoader"),dl.forEach(t),ie=a(qe,"s \xE0 partir de nos jeux de donn\xE9es. Nous d\xE9finissons le format de ces jeux de donn\xE9es \xE0 "),xs=r(qe,"CODE",{});var cl=l(xs);Fe=a(cl,'"torch"'),cl.forEach(t),ue=a(qe," et supprimons les colonnes dans le jeu de validation qui ne sont pas utilis\xE9es par le mod\xE8le. Ensuite, nous pouvons utiliser le "),$s=r(qe,"CODE",{});var Aa=l($s);ls=a(Aa,"default_data_collator"),Aa.forEach(t),W=a(qe," fourni par \u{1F917} "),Y=r(qe,"EM",{});var ml=l(Y);ws=a(ml,"Transformers"),ml.forEach(t),Bt=a(qe," comme "),js=r(qe,"CODE",{});var fl=l(js);Ie=a(fl,"collate_fn"),fl.forEach(t),Ve=a(qe," et m\xE9langer l\u2019ensemble d\u2019entra\xEEnement mais pas celui de validation :"),qe.forEach(t),Es=c(m),j(he.$$.fragment,m),He=c(m),pe=r(m,"P",{});var Qn=l(pe);ve=a(Qn,"Ensuite, nous r\xE9instantifions notre mod\xE8le afin de nous assurer que nous ne poursuivons pas le "),Ue=r(Qn,"EM",{});var $t=l(Ue);Re=a($t,"finetuning"),$t.forEach(t),mo=a(Qn," pr\xE9c\xE9dent et que nous repartons du mod\xE8le BERT pr\xE9-entra\xEEn\xE9 :"),Qn.forEach(t),Ft=c(m),j(Js.$$.fragment,m),En=c(m),be=r(m,"P",{});var Sa=l(be);fo=a(Sa,"Ensuite, nous aurons besoin d\u2019un optimiseur. Comme d\u2019habitude, nous utilisons le classique "),is=r(Sa,"CODE",{});var Ma=l(is);_o=a(Ma,"AdamW"),Ma.forEach(t),ho=a(Sa,", qui est comme Adam mais avec une correction dans la fa\xE7on dont le taux de d\xE9croissance des poids est appliqu\xE9 :"),Sa.forEach(t),ks=c(m),j(Xs.$$.fragment,m),ta=c(m),te=r(m,"P",{});var fe=l(te);us=a(fe,"Une fois que nous avons tous ces objets, nous pouvons les envoyer \xE0 la m\xE9thode "),Qe=r(fe,"CODE",{});var _l=l(Qe);kn=a(_l,"accelerator.prepare()"),_l.forEach(t),Ks=a(fe,". Rappelez-vous que si vous voulez entra\xEEner sur des TPUs dans un "),yn=r(fe,"EM",{});var ar=l(yn);Cn=a(ar,"notebook"),ar.forEach(t),vo=a(fe," Colab, vous devrez d\xE9placer tout ce code dans une fonction d\u2019entra\xEEnement, et qui ne devrait pas ex\xE9cuter une cellule qui instancie un "),It=r(fe,"CODE",{});var Be=l(It);ys=a(Be,"Accelerator"),Be.forEach(t),bo=a(fe,". Nous pouvons forcer l\u2019entra\xEEnement en pr\xE9cision mixte en passant l\u2019argument "),Ys=r(fe,"CODE",{});var Gn=l(Ys);go=a(Gn,"fp16=True"),Gn.forEach(t),qo=a(fe," \xE0 "),Vt=r(fe,"CODE",{});var za=l(Vt);Zs=a(za,"Accelerator"),za.forEach(t),na=a(fe," (ou, si vous ex\xE9cutez le code comme un script, assurez-vous de remplir la \u{1F917} "),Cs=r(fe,"EM",{});var hl=l(Cs);xo=a(hl,"Accelerate"),hl.forEach(t),aa=c(fe),ps=r(fe,"CODE",{});var vl=l(ps);oa=a(vl,"config"),vl.forEach(t),et=a(fe," de mani\xE8re appropri\xE9e)."),fe.forEach(t),Pn=c(m),j(me.$$.fragment,m),ra=c(m),Pe=r(m,"P",{});var un=l(Pe);$o=a(un,"Comme vous devez le savoir depuis les sections pr\xE9c\xE9dentes, nous ne pouvons utiliser la longueur de "),An=r(un,"CODE",{});var Wn=l(An);Sn=a(Wn,"train_dataloader"),Wn.forEach(t),wo=a(un," pour calculer le nombre d\u2019\xE9tapes d\u2019entra\xEEnement qu\u2019apr\xE8s qu\u2019il soit pass\xE9 par la m\xE9thode "),Mn=r(un,"CODE",{});var Da=l(Mn);zn=a(Da,"accelerator.prepare()"),Da.forEach(t),jo=a(un,". Nous utilisons le m\xEAme programme lin\xE9aire que dans les sections pr\xE9c\xE9dentes :"),un.forEach(t),la=c(m),j(Ps.$$.fragment,m),As=c(m),de=r(m,"P",{});var Me=l(de);st=a(Me,"Pour pousser notre mod\xE8le vers le "),Ht=r(Me,"EM",{});var bl=l(Ht);oe=a(bl,"Hub"),bl.forEach(t),Eo=a(Me,", nous aurons besoin de cr\xE9er un objet "),tt=r(Me,"CODE",{});var gl=l(tt);ko=a(gl,"Repository"),gl.forEach(t),yo=a(Me," dans un dossier de travail. Tout d\u2019abord, connectez-vous au "),nt=r(Me,"EM",{});var wt=l(nt);Co=a(wt,"Hub"),wt.forEach(t),Po=a(Me,", si vous n\u2019\xEAtes pas d\xE9j\xE0 connect\xE9. Nous d\xE9terminerons le nom du d\xE9p\xF4t \xE0 partir de l\u2019identifiant du mod\xE8le que nous voulons donner \xE0 notre mod\xE8le (n\u2019h\xE9sitez pas \xE0 remplacer le "),at=r(Me,"CODE",{});var Ta=l(at);Ao=a(Ta,"repo_name"),Ta.forEach(t),So=a(Me," par votre propre choix. Il doit juste contenir votre nom d\u2019utilisateur, ce que fait la fonction "),ot=r(Me,"CODE",{});var ql=l(ot);Mo=a(ql,"get_full_repo_name()"),ql.forEach(t),zo=a(Me,") :"),Me.forEach(t),Ut=c(m),j(rt.$$.fragment,m),ia=c(m),j(ds.$$.fragment,m),ua=c(m),Rt=r(m,"P",{});var xl=l(Rt);pa=a(xl,"Ensuite, nous pouvons cloner ce d\xE9p\xF4t dans un dossier local. S\u2019il existe d\xE9j\xE0, ce dossier local doit \xEAtre un clone du d\xE9p\xF4t avec lequel nous travaillons :"),xl.forEach(t),cs=c(m),j(lt.$$.fragment,m),Qt=c(m),Ge=r(m,"P",{});var Ns=l(Ge);Do=a(Ns,"Nous pouvons maintenant t\xE9l\xE9charger tout ce que nous sauvegardons dans "),Gt=r(Ns,"CODE",{});var $l=l(Gt);it=a($l,"output_dir"),$l.forEach(t),da=a(Ns," en appelant la m\xE9thode "),ms=r(Ns,"CODE",{});var wl=l(ms);ca=a(wl,"repo.push_to_hub()"),wl.forEach(t),Wt=a(Ns,". Cela nous aidera \xE0 t\xE9l\xE9charger les mod\xE8les interm\xE9diaires \xE0 la fin de chaque \xE9poque."),Ns.forEach(t),ma=c(m),We=r(m,"H2",{class:!0});var La=l(We);Ae=r(La,"A",{id:!0,class:!0,href:!0});var gs=l(Ae);Jt=r(gs,"SPAN",{});var Na=l(Jt);j(Oe.$$.fragment,Na),Na.forEach(t),gs.forEach(t),fa=c(La),Je=r(La,"SPAN",{});var jl=l(Je);To=a(jl,"Boucle d'entra\xEEnement"),jl.forEach(t),La.forEach(t),Xt=c(m),Kt=r(m,"P",{});var El=l(Kt);Lo=a(El,"Nous sommes maintenant pr\xEAts \xE0 \xE9crire la boucle d\u2019entra\xEEnement compl\xE8te. Apr\xE8s avoir d\xE9fini une barre de progression pour suivre l\u2019\xE9volution de l\u2019entra\xEEnement, la boucle comporte trois parties :"),El.forEach(t),Dn=c(m),je=r(m,"UL",{});var Os=l(je);Ss=r(Os,"LI",{});var Oa=l(Ss);ut=a(Oa,"l\u2019entra\xEEnement \xE0 proprement dit, qui est l\u2019it\xE9ration classique sur le "),Yt=r(Oa,"CODE",{});var kl=l(Yt);Zt=a(kl,"train_dataloader"),kl.forEach(t),No=a(Oa,", passage en avant du mod\xE8le, puis passage en arri\xE8re et \xE9tape d\u2019optimisation."),Oa.forEach(t),_a=c(Os),ce=r(Os,"LI",{});var Ze=l(ce);Ms=a(Ze,"l\u2019\xE9valuation, dans laquelle nous rassemblons toutes les valeurs pour "),pt=r(Ze,"CODE",{});var yl=l(pt);dt=a(yl,"start_logits"),yl.forEach(t),Oo=a(Ze," et "),ct=r(Ze,"CODE",{});var Cl=l(ct);Bo=a(Cl,"end_logits"),Cl.forEach(t),ha=a(Ze," avant de les convertir en tableaux NumPy. Une fois la boucle d\u2019\xE9valuation termin\xE9e, nous concat\xE9nons tous les r\xE9sultats. Notez que nous devons tronquer car "),fs=r(Ze,"CODE",{});var or=l(fs);va=a(or,"Accelerator"),or.forEach(t),zs=a(Ze," peut avoir ajout\xE9 quelques \xE9chantillons \xE0 la fin pour s\u2019assurer que nous avons le m\xEAme nombre d\u2019exemples dans chaque processus."),Ze.forEach(t),Fo=c(Os),ge=r(Os,"LI",{});var Ee=l(ge);Io=a(Ee,"sauvegarde et t\xE9l\xE9chargement, o\xF9 nous sauvegardons d\u2019abord le mod\xE8le et le "),Tn=r(Ee,"EM",{});var rr=l(Tn);ba=a(rr,"tokenizer"),rr.forEach(t),Ds=a(Ee,", puis appelons "),Ln=r(Ee,"CODE",{});var pn=l(Ln);Nn=a(pn,"repo.push_to_hub()"),pn.forEach(t),Vo=a(Ee,". Comme nous l\u2019avons fait auparavant, nous utilisons l\u2019argument "),On=r(Ee,"CODE",{});var lr=l(On);ga=a(lr,"blocking=False"),lr.forEach(t),mt=a(Ee," pour dire \xE0 la biblioth\xE8que \u{1F917} "),en=r(Ee,"EM",{});var xe=l(en);ne=a(xe,"Hub"),xe.forEach(t),Ho=a(Ee," de pousser dans un processus asynchrone. De cette fa\xE7on, l\u2019entra\xEEnement continue normalement et cette (longue) instruction est ex\xE9cut\xE9e en arri\xE8re-plan."),Ee.forEach(t),Os.forEach(t),sn=c(m),tn=r(m,"P",{});var Pl=l(tn);Uo=a(Pl,"Voici le code complet de la boucle d\u2019entra\xEEnement :"),Pl.forEach(t),nn=c(m),j(ft.$$.fragment,m),qa=c(m),Xe=r(m,"P",{});var dn=l(Xe);Ro=a(dn,"Au cas o\xF9 ce serait la premi\xE8re fois que vous verriez un mod\xE8le enregistr\xE9 avec \u{1F917} "),Bn=r(dn,"EM",{});var Al=l(Bn);_t=a(Al,"Accelerate"),Al.forEach(t),Qo=a(dn,", prenons un moment pour inspecter les trois lignes de code qui l\u2019accompagnent :"),dn.forEach(t),xa=c(m),j(_s.$$.fragment,m),$a=c(m),ae=r(m,"P",{});var _e=l(ae);Fn=a(_e,"La premi\xE8re ligne est explicite : elle indique \xE0 tous les processus d\u2019attendre que tout le monde soit \xE0 ce stade avant de continuer. C\u2019est pour s\u2019assurer que nous avons le m\xEAme mod\xE8le dans chaque processus avant de sauvegarder. Ensuite, nous prenons le "),In=r(_e,"CODE",{});var Ba=l(In);Go=a(Ba,"unwrapped_model"),Ba.forEach(t),Vn=a(_e,", qui est le mod\xE8le de base que nous avons d\xE9fini. La m\xE9thode "),Hn=r(_e,"CODE",{});var Sl=l(Hn);Wo=a(Sl,"accelerator.prepare()"),Sl.forEach(t),wa=a(_e," modifie le mod\xE8le pour qu\u2019il fonctionne dans l\u2019entra\xEEnement distribu\xE9. Donc il n\u2019aura plus la m\xE9thode "),hs=r(_e,"CODE",{});var Ml=l(hs);ja=a(Ml,"save_pretrained()"),Ml.forEach(t),ht=a(_e," car la m\xE9thode "),an=r(_e,"CODE",{});var Fa=l(an);Ke=a(Fa,"accelerator.unwrap_model()"),Fa.forEach(t),Jo=a(_e," annule cette \xE9tape. Enfin, nous appelons "),vt=r(_e,"CODE",{});var zl=l(vt);Xo=a(zl,"save_pretrained()"),zl.forEach(t),Ko=a(_e," mais nous disons \xE0 cette m\xE9thode d\u2019utiliser "),bt=r(_e,"CODE",{});var Dl=l(bt);Yo=a(Dl,"accelerator.save()"),Dl.forEach(t),Zo=a(_e," au lieu de "),on=r(_e,"CODE",{});var Ia=l(on);gt=a(Ia,"torch.save()"),Ia.forEach(t),Ea=a(_e,"."),_e.forEach(t),qt=c(m),Ye=r(m,"P",{});var cn=l(Ye);ka=a(cn,"Une fois ceci fait, vous devriez avoir un mod\xE8le qui produit des r\xE9sultats assez similaires \xE0 celui entra\xEEn\xE9 avec "),vs=r(cn,"CODE",{});var Tl=l(vs);ya=a(Tl,"Trainer"),Tl.forEach(t),xt=a(cn,". Vous pouvez v\xE9rifier le mod\xE8le que nous avons entra\xEEn\xE9 en utilisant ce code \xE0 "),Ts=r(cn,"A",{href:!0,rel:!0});var Va=l(Ts);Se=r(Va,"EM",{});var Ll=l(Se);er=a(Ll,"huggingface-course/bert-finetuned-squad-accelerate"),Ll.forEach(t),Va.forEach(t),Un=a(cn,". Et si vous voulez tester des modifications de la boucle d\u2019entra\xEEnement, vous pouvez les impl\xE9menter directement en modifiant le code ci-dessus !"),cn.forEach(t),this.h()},h(){C(x,"id","une-boucle-dentranement-personnalise"),C(x,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),C(x,"href","#une-boucle-dentranement-personnalise"),C(q,"class","relative group"),C(V,"href","/course/fr/chapter3/4"),C(G,"id","prparer-tout-pour-lentranement"),C(G,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),C(G,"href","#prparer-tout-pour-lentranement"),C(H,"class","relative group"),C(Ae,"id","boucle-dentranement"),C(Ae,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),C(Ae,"href","#boucle-dentranement"),C(We,"class","relative group"),C(Ts,"href","https://huggingface.co/huggingface-course/bert-finetuned-squad-accelerate"),C(Ts,"rel","nofollow")},m(m,B){i(m,p,B),s(p,b),s(p,f),s(f,y),s(p,S),i(m,g,B),i(m,q,B),s(q,x),s(x,_),E(M,_,null),s(q,$),s(q,A),s(A,T),i(m,I,B),i(m,D,B),s(D,P),s(D,V),s(V,L),s(D,O),s(D,N),s(N,U),s(D,Q),i(m,J,B),i(m,H,B),s(H,G),s(G,ee),E(Z,ee,null),s(H,F),s(H,X),s(X,re),i(m,se,B),i(m,K,B),s(K,le),s(K,Ce),s(Ce,ye),s(K,ie),s(K,xs),s(xs,Fe),s(K,ue),s(K,$s),s($s,ls),s(K,W),s(K,Y),s(Y,ws),s(K,Bt),s(K,js),s(js,Ie),s(K,Ve),i(m,Es,B),E(he,m,B),i(m,He,B),i(m,pe,B),s(pe,ve),s(pe,Ue),s(Ue,Re),s(pe,mo),i(m,Ft,B),E(Js,m,B),i(m,En,B),i(m,be,B),s(be,fo),s(be,is),s(is,_o),s(be,ho),i(m,ks,B),E(Xs,m,B),i(m,ta,B),i(m,te,B),s(te,us),s(te,Qe),s(Qe,kn),s(te,Ks),s(te,yn),s(yn,Cn),s(te,vo),s(te,It),s(It,ys),s(te,bo),s(te,Ys),s(Ys,go),s(te,qo),s(te,Vt),s(Vt,Zs),s(te,na),s(te,Cs),s(Cs,xo),s(te,aa),s(te,ps),s(ps,oa),s(te,et),i(m,Pn,B),E(me,m,B),i(m,ra,B),i(m,Pe,B),s(Pe,$o),s(Pe,An),s(An,Sn),s(Pe,wo),s(Pe,Mn),s(Mn,zn),s(Pe,jo),i(m,la,B),E(Ps,m,B),i(m,As,B),i(m,de,B),s(de,st),s(de,Ht),s(Ht,oe),s(de,Eo),s(de,tt),s(tt,ko),s(de,yo),s(de,nt),s(nt,Co),s(de,Po),s(de,at),s(at,Ao),s(de,So),s(de,ot),s(ot,Mo),s(de,zo),i(m,Ut,B),E(rt,m,B),i(m,ia,B),E(ds,m,B),i(m,ua,B),i(m,Rt,B),s(Rt,pa),i(m,cs,B),E(lt,m,B),i(m,Qt,B),i(m,Ge,B),s(Ge,Do),s(Ge,Gt),s(Gt,it),s(Ge,da),s(Ge,ms),s(ms,ca),s(Ge,Wt),i(m,ma,B),i(m,We,B),s(We,Ae),s(Ae,Jt),E(Oe,Jt,null),s(We,fa),s(We,Je),s(Je,To),i(m,Xt,B),i(m,Kt,B),s(Kt,Lo),i(m,Dn,B),i(m,je,B),s(je,Ss),s(Ss,ut),s(Ss,Yt),s(Yt,Zt),s(Ss,No),s(je,_a),s(je,ce),s(ce,Ms),s(ce,pt),s(pt,dt),s(ce,Oo),s(ce,ct),s(ct,Bo),s(ce,ha),s(ce,fs),s(fs,va),s(ce,zs),s(je,Fo),s(je,ge),s(ge,Io),s(ge,Tn),s(Tn,ba),s(ge,Ds),s(ge,Ln),s(Ln,Nn),s(ge,Vo),s(ge,On),s(On,ga),s(ge,mt),s(ge,en),s(en,ne),s(ge,Ho),i(m,sn,B),i(m,tn,B),s(tn,Uo),i(m,nn,B),E(ft,m,B),i(m,qa,B),i(m,Xe,B),s(Xe,Ro),s(Xe,Bn),s(Bn,_t),s(Xe,Qo),i(m,xa,B),E(_s,m,B),i(m,$a,B),i(m,ae,B),s(ae,Fn),s(ae,In),s(In,Go),s(ae,Vn),s(ae,Hn),s(Hn,Wo),s(ae,wa),s(ae,hs),s(hs,ja),s(ae,ht),s(ae,an),s(an,Ke),s(ae,Jo),s(ae,vt),s(vt,Xo),s(ae,Ko),s(ae,bt),s(bt,Yo),s(ae,Zo),s(ae,on),s(on,gt),s(ae,Ea),i(m,qt,B),i(m,Ye,B),s(Ye,ka),s(Ye,vs),s(vs,ya),s(Ye,xt),s(Ye,Ts),s(Ts,Se),s(Se,er),s(Ye,Un),Ca=!0},i(m){Ca||(h(M.$$.fragment,m),h(Z.$$.fragment,m),h(he.$$.fragment,m),h(Js.$$.fragment,m),h(Xs.$$.fragment,m),h(me.$$.fragment,m),h(Ps.$$.fragment,m),h(rt.$$.fragment,m),h(ds.$$.fragment,m),h(lt.$$.fragment,m),h(Oe.$$.fragment,m),h(ft.$$.fragment,m),h(_s.$$.fragment,m),Ca=!0)},o(m){v(M.$$.fragment,m),v(Z.$$.fragment,m),v(he.$$.fragment,m),v(Js.$$.fragment,m),v(Xs.$$.fragment,m),v(me.$$.fragment,m),v(Ps.$$.fragment,m),v(rt.$$.fragment,m),v(ds.$$.fragment,m),v(lt.$$.fragment,m),v(Oe.$$.fragment,m),v(ft.$$.fragment,m),v(_s.$$.fragment,m),Ca=!1},d(m){m&&t(p),m&&t(g),m&&t(q),k(M),m&&t(I),m&&t(D),m&&t(J),m&&t(H),k(Z),m&&t(se),m&&t(K),m&&t(Es),k(he,m),m&&t(He),m&&t(pe),m&&t(Ft),k(Js,m),m&&t(En),m&&t(be),m&&t(ks),k(Xs,m),m&&t(ta),m&&t(te),m&&t(Pn),k(me,m),m&&t(ra),m&&t(Pe),m&&t(la),k(Ps,m),m&&t(As),m&&t(de),m&&t(Ut),k(rt,m),m&&t(ia),k(ds,m),m&&t(ua),m&&t(Rt),m&&t(cs),k(lt,m),m&&t(Qt),m&&t(Ge),m&&t(ma),m&&t(We),k(Oe),m&&t(Xt),m&&t(Kt),m&&t(Dn),m&&t(je),m&&t(sn),m&&t(tn),m&&t(nn),k(ft,m),m&&t(qa),m&&t(Xe),m&&t(xa),k(_s,m),m&&t($a),m&&t(ae),m&&t(qt),m&&t(Ye)}}}function Jq(R){let p,b,f,y,S,g,q,x,_,M,$,A,T,I,D,P,V,L,O,N,U,Q,J,H,G,ee,Z,F,X,re,se,K,le,Ce,ye,ie,xs,Fe,ue,$s,ls,W,Y,ws,Bt,js,Ie,Ve,Es,he,He,pe,ve,Ue,Re,mo,Ft,Js,En,be,fo,is,_o,ho,ks,Xs,ta,te,us,Qe,kn,Ks,yn,Cn,vo,It,ys,bo,Ys,go,qo,Vt,Zs,na,Cs,xo,aa,ps,oa,et,Pn,me,ra,Pe,$o,An,Sn,wo,Mn,zn,jo,la,Ps,As,de,st,Ht,oe,Eo,tt,ko,yo,nt,Co,Po,at,Ao,So,ot,Mo,zo,Ut,rt,ia,ds,ua,Rt,pa,cs,lt,Qt,Ge,Do,Gt,it,da,ms,ca,Wt,ma,We,Ae,Jt,Oe,fa,Je,To,Xt,Kt,Lo,Dn,je,Ss,ut,Yt,Zt,No,_a,ce,Ms,pt,dt,Oo,ct,Bo,ha,fs,va,zs,Fo,ge,Io,Tn,ba,Ds,Ln,Nn,Vo,On,ga,mt,en,ne,Ho,sn,tn,Uo,nn,ft,qa,Xe,Ro,Bn,_t,Qo,xa,_s,$a,ae,Fn,In,Go,Vn,Hn,Wo,wa,hs,ja,ht,an,Ke,Jo,vt,Xo,Ko,bt,Yo,Zo,on,gt,Ea,qt,Ye,ka,vs,ya,xt,Ts,Se,er,Un,Ca,m,B,il,Pa,sr,Ls,rn,Rn,ul,ln,tr,nr,bs,pl,qe,dl,cl,Aa,ml,fl,Qn,$t,Sa,Ma,fe,_l,ar,Be,Gn,za,hl,vl,un,Wn,Da,Me,bl,gl,wt,Ta,ql,xl,Ns,$l,wl,La,gs,Na,jl,El,Os,Oa,kl,Ze,yl,Cl,or,Ee,rr,pn,lr,xe,Pl,dn,Al,_e,Ba,Sl,Ml,Fa,zl,Dl,Ia,cn,Tl,Va,Ll,Pc,_p,ze,Ac,Si,Sc,Mc,Mi,zc,Dc,Nl,Tc,Lc,zi,Nc,Oc,Di,Bc,Fc,hp,ir,vp,ur,bp,De,Ic,Ti,Vc,Hc,Li,Uc,Rc,Ni,Qc,Gc,Oi,Wc,Jc,Bi,Xc,Kc,gp,pr,qp,dr,xp,Ol,Yc,$p,cr,wp,mr,jp,Bl,Zc,Ep,Fl,em,kp,Ha,Il,Fi,sm,tm,nm,es,Ii,am,om,Vi,rm,lm,Hi,im,um,Ui,pm,dm,Ri,cm,mm,yp,Te,fm,Qi,_m,hm,Gi,vm,bm,Wi,gm,qm,Ji,xm,$m,Xi,wm,jm,Cp,Le,Em,Ki,km,ym,Yi,Cm,Pm,Zi,Am,Sm,eu,Mm,zm,su,Dm,Tm,Pp,fr,Ap,_r,Sp,mn,Lm,tu,Nm,Om,nu,Bm,Fm,Mp,hr,zp,vr,Dp,Ua,Im,au,Vm,Hm,Tp,br,Lp,gr,Np,Vl,Um,Op,Ra,Bp,Hl,Rm,Fp,qr,Ip,Ul,Qm,Vp,fn,Gm,ou,Wm,Jm,ru,Xm,Km,Hp,xr,Up,$r,Rp,Rl,Ym,Qp,Jn,Qa,lu,wr,Zm,iu,ef,Gp,Ga,sf,uu,tf,nf,Wp,ke,af,pu,of,rf,du,lf,uf,cu,pf,df,mu,cf,mf,fu,ff,_f,_u,hf,vf,Jp,jr,Xp,Ql,bf,Kp,Er,Yp,kr,Zp,Gl,gf,ed,Wl,qf,sd,jt,Et,Jl,Xn,Wa,hu,yr,xf,vu,$f,td,kt,yt,Xl,_n,wf,bu,jf,Ef,Kl,kf,yf,nd,Bs,Cr,Cf,gu,Pf,Af,Sf,qu,Mf,zf,Pr,Df,xu,Tf,Lf,Nf,Kn,Of,$u,Bf,Ff,wu,If,Vf,ad,ss,Hf,ju,Uf,Rf,Eu,Qf,Gf,ku,Wf,Jf,od,bq='<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>\u2061</mo><mo stretchy="false">(</mo><mi>a</mi><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>log</mi><mo>\u2061</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>+</mo><mi>log</mi><mo>\u2061</mo><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\log(ab) = \\log(a) + \\log(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">ab</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>',rd,ld,Fs,Xf,yu,Kf,Yf,Cu,Zf,e_,Pu,s_,t_,id,Ar,ud,Ja,n_,Au,a_,o_,pd,Sr,dd,Xa,r_,Su,l_,i_,cd,Ct,Pt,Yl,ts,u_,Mu,p_,d_,zu,c_,m_,Du,f_,__,Tu,h_,v_,md,Mr,fd,Ka,b_,Lu,g_,q_,_d,hn,Nu,x_,$_,Ou,w_,j_,zr,E_,Bu,k_,y_,hd,Zl,C_,vd,Dr,bd,Ya,P_,Fu,A_,S_,gd,Tr,qd,ei,M_,xd,Lr,$d,si,z_,wd,Nr,jd,Or,Ed,ti,D_,kd,Br,yd,Fr,Cd,vn,T_,Ir,L_,N_,Iu,O_,B_,Pd,ni,Vr,Ad,ai,F_,Sd,Hr,Md,Ur,zd,Za,I_,Vu,V_,H_,Dd,Yn,eo,Hu,Rr,U_,oi,Uu,R_,Q_,Td,At,St,ri,so,G_,Ru,W_,J_,Ld,Is,X_,Qu,K_,Y_,Gu,Z_,eh,Wu,sh,th,Nd,Qr,Od,to,nh,Ju,ah,oh,Bd,Gr,Fd,Mt,zt,li,ns,rh,Xu,lh,ih,Ku,uh,ph,Yu,dh,ch,Zu,mh,fh,Id,Dt,Tt,ii,bn,_h,ep,hh,vh,sp,bh,gh,Vd,Lt,Nt,ui,Wr,Hd,pi,qh,Ud,di,Vs,xh,tp,$h,wh,np,jh,Eh,ap,kh,yh,Rd,no,Qd,ci,Zn,ao,op,Jr,Ch,mi,Ph,rp,Ah,Gd,as,Sh,lp,Mh,zh,ip,Dh,Th,up,Lh,Nh,pp,Oh,Bh,Wd,Xr,Jd,Kr,Xd,fi,Fh,Kd;f=new kq({props:{fw:R[0]}}),x=new qs({});const Qh=[Cq,yq],Yr=[];function Gh(e,u){return e[0]==="pt"?0:1}T=Gh(R),I=Yr[T]=Qh[T](R),Q=new Cc({props:{id:"ajPx5LwJD-I"}}),he=new yc({props:{$$slots:{default:[Pq]},$$scope:{ctx:R}}}),Re=new qs({}),Ks=new qs({}),Zs=new z({props:{code:`from datasets import load_dataset

raw_datasets = load_dataset("squad")`,highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

raw_datasets = load_dataset(<span class="hljs-string">&quot;squad&quot;</span>)`}}),ps=new z({props:{code:"raw_datasets",highlighted:"raw_datasets"}}),et=new z({props:{code:`DatasetDict({
    train: Dataset({
        features: ['id', 'title', 'context', 'question', 'answers'],
        num_rows: 87599
    })
    validation: Dataset({
        features: ['id', 'title', 'context', 'question', 'answers'],
        num_rows: 10570
    })
})`,highlighted:`DatasetDict({
    train: Dataset({
        features: [<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;context&#x27;</span>, <span class="hljs-string">&#x27;question&#x27;</span>, <span class="hljs-string">&#x27;answers&#x27;</span>],
        num_rows: <span class="hljs-number">87599</span>
    })
    validation: Dataset({
        features: [<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;context&#x27;</span>, <span class="hljs-string">&#x27;question&#x27;</span>, <span class="hljs-string">&#x27;answers&#x27;</span>],
        num_rows: <span class="hljs-number">10570</span>
    })
})`}}),As=new z({props:{code:`print("Context: ", raw_datasets["train"][0]["context"])
print("Question: ", raw_datasets["train"][0]["question"])
print("Answer: ", raw_datasets["train"][0]["answers"])`,highlighted:`<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Context: &quot;</span>, raw_datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;context&quot;</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Question: &quot;</span>, raw_datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;question&quot;</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Answer: &quot;</span>, raw_datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;answers&quot;</span>])`}}),st=new z({props:{code:`Context: 'Architecturally, the school has a Catholic character. Atop the Main Building\\'s gold dome is a golden statue of the Virgin Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend "Venite Ad Me Omnes". Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858. At the end of the main drive (and in a direct line that connects through 3 statues and the Gold Dome), is a simple, modern stone statue of Mary.'
# Sur le plan architectural, l'\xE9cole a un caract\xE8re catholique. Au sommet du d\xF4me dor\xE9 du b\xE2timent principal se trouve une statue dor\xE9e de la Vierge Marie. Imm\xE9diatement devant le b\xE2timent principal et face \xE0 lui, se trouve une statue en cuivre du Christ, les bras lev\xE9s, avec la l\xE9gende "Venite Ad Me Omnes". \xC0 c\xF4t\xE9 du b\xE2timent principal se trouve la basilique du Sacr\xE9-C\u0153ur. Imm\xE9diatement derri\xE8re la basilique se trouve la Grotte, un lieu marial de pri\xE8re et de r\xE9flexion. Il s'agit d'une r\xE9plique de la grotte de Lourdes, en France, o\xF9 la Vierge Marie serait apparue \xE0 Sainte Bernadette Soubirous en 1858. Au bout de l'all\xE9e principale (et dans une ligne directe qui passe par 3 statues et le D\xF4me d'or), se trouve une statue de pierre simple et moderne de Marie'.
Question: 'To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France?' 
# A qui la Vierge Marie serait-elle apparue en 1858 \xE0 Lourdes, en France ?
Answer: {'text': ['Saint Bernadette Soubirous'], 'answer_start': [515]}`,highlighted:`Context: <span class="hljs-string">&#x27;Architecturally, the school has a Catholic character. Atop the Main Building\\&#x27;s gold dome is a golden statue of the Virgin Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend &quot;Venite Ad Me Omnes&quot;. Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858. At the end of the main drive (and in a direct line that connects through 3 statues and the Gold Dome), is a simple, modern stone statue of Mary.&#x27;</span>
<span class="hljs-comment"># Sur le plan architectural, l&#x27;\xE9cole a un caract\xE8re catholique. Au sommet du d\xF4me dor\xE9 du b\xE2timent principal se trouve une statue dor\xE9e de la Vierge Marie. Imm\xE9diatement devant le b\xE2timent principal et face \xE0 lui, se trouve une statue en cuivre du Christ, les bras lev\xE9s, avec la l\xE9gende &quot;Venite Ad Me Omnes&quot;. \xC0 c\xF4t\xE9 du b\xE2timent principal se trouve la basilique du Sacr\xE9-C\u0153ur. Imm\xE9diatement derri\xE8re la basilique se trouve la Grotte, un lieu marial de pri\xE8re et de r\xE9flexion. Il s&#x27;agit d&#x27;une r\xE9plique de la grotte de Lourdes, en France, o\xF9 la Vierge Marie serait apparue \xE0 Sainte Bernadette Soubirous en 1858. Au bout de l&#x27;all\xE9e principale (et dans une ligne directe qui passe par 3 statues et le D\xF4me d&#x27;or), se trouve une statue de pierre simple et moderne de Marie&#x27;.</span>
Question: <span class="hljs-string">&#x27;To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France?&#x27;</span> 
<span class="hljs-comment"># A qui la Vierge Marie serait-elle apparue en 1858 \xE0 Lourdes, en France ?</span>
Answer: {<span class="hljs-string">&#x27;text&#x27;</span>: [<span class="hljs-string">&#x27;Saint Bernadette Soubirous&#x27;</span>], <span class="hljs-string">&#x27;answer_start&#x27;</span>: [<span class="hljs-number">515</span>]}`}}),it=new z({props:{code:'raw_datasets["train"].filter(lambda x: len(x["answers"]["text"]) != 1)',highlighted:'raw_datasets[<span class="hljs-string">&quot;train&quot;</span>].<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">len</span>(x[<span class="hljs-string">&quot;answers&quot;</span>][<span class="hljs-string">&quot;text&quot;</span>]) != <span class="hljs-number">1</span>)'}}),ms=new z({props:{code:`Dataset({
    features: ['id', 'title', 'context', 'question', 'answers'],
    num_rows: 0
})`,highlighted:`Dataset({
    features: [<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;context&#x27;</span>, <span class="hljs-string">&#x27;question&#x27;</span>, <span class="hljs-string">&#x27;answers&#x27;</span>],
    num_rows: <span class="hljs-number">0</span>
})`}}),Ae=new z({props:{code:`print(raw_datasets["validation"][0]["answers"])
print(raw_datasets["validation"][2]["answers"])`,highlighted:`<span class="hljs-built_in">print</span>(raw_datasets[<span class="hljs-string">&quot;validation&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;answers&quot;</span>])
<span class="hljs-built_in">print</span>(raw_datasets[<span class="hljs-string">&quot;validation&quot;</span>][<span class="hljs-number">2</span>][<span class="hljs-string">&quot;answers&quot;</span>])`}}),Oe=new z({props:{code:`{'text': ['Denver Broncos', 'Denver Broncos', 'Denver Broncos'], 'answer_start': [177, 177, 177]}
{'text': ['Santa Clara, California', "Levi's Stadium", "Levi's Stadium in the San Francisco Bay Area at Santa Clara, California."], 'answer_start': [403, 355, 355]}`,highlighted:`{<span class="hljs-string">&#x27;text&#x27;</span>: [<span class="hljs-string">&#x27;Denver Broncos&#x27;</span>, <span class="hljs-string">&#x27;Denver Broncos&#x27;</span>, <span class="hljs-string">&#x27;Denver Broncos&#x27;</span>], <span class="hljs-string">&#x27;answer_start&#x27;</span>: [<span class="hljs-number">177</span>, <span class="hljs-number">177</span>, <span class="hljs-number">177</span>]}
{<span class="hljs-string">&#x27;text&#x27;</span>: [<span class="hljs-string">&#x27;Santa Clara, California&#x27;</span>, <span class="hljs-string">&quot;Levi&#x27;s Stadium&quot;</span>, <span class="hljs-string">&quot;Levi&#x27;s Stadium in the San Francisco Bay Area at Santa Clara, California.&quot;</span>], <span class="hljs-string">&#x27;answer_start&#x27;</span>: [<span class="hljs-number">403</span>, <span class="hljs-number">355</span>, <span class="hljs-number">355</span>]}`}}),je=new z({props:{code:`print(raw_datasets["validation"][2]["context"])
print(raw_datasets["validation"][2]["question"])`,highlighted:`<span class="hljs-built_in">print</span>(raw_datasets[<span class="hljs-string">&quot;validation&quot;</span>][<span class="hljs-number">2</span>][<span class="hljs-string">&quot;context&quot;</span>])
<span class="hljs-built_in">print</span>(raw_datasets[<span class="hljs-string">&quot;validation&quot;</span>][<span class="hljs-number">2</span>][<span class="hljs-string">&quot;question&quot;</span>])`}}),ut=new z({props:{code:`'Super Bowl 50 was an American football game to determine the champion of the National Football League (NFL) for the 2015 season. The American Football Conference (AFC) champion Denver Broncos defeated the National Football Conference (NFC) champion Carolina Panthers 24\u201310 to earn their third Super Bowl title. The game was played on February 7, 2016, at Levi\\'s Stadium in the San Francisco Bay Area at Santa Clara, California. As this was the 50th Super Bowl, the league emphasized the "golden anniversary" with various gold-themed initiatives, as well as temporarily suspending the tradition of naming each Super Bowl game with Roman numerals (under which the game would have been known as "Super Bowl L"), so that the logo could prominently feature the Arabic numerals 50.'
# Le Super Bowl 50 \xE9tait un match de football am\xE9ricain visant \xE0 d\xE9terminer le champion de la National Football League (NFL) pour la saison 2015. Les Denver Broncos, champions de la Conf\xE9rence de football am\xE9ricain (AFC), ont battu les Carolina Panthers, champions de la Conf\xE9rence nationale de football (NFC), 24 \xE0 10, pour remporter leur troisi\xE8me titre de Super Bowl. Le match s'est d\xE9roul\xE9 le 7 f\xE9vrier 2016 au Levi\\'s Stadium, dans la baie de San Francisco, \xE0 Santa Clara, en Californie. Comme il s'agissait du 50e Super Bowl, la ligue a mis l'accent sur l'" anniversaire dor\xE9 " avec diverses initiatives sur le th\xE8me de l'or, ainsi qu'en suspendant temporairement la tradition de nommer chaque match du Super Bowl avec des chiffres romains (en vertu de laquelle le match aurait \xE9t\xE9 appel\xE9 " Super Bowl L "), afin que le logo puisse mettre en \xE9vidence les chiffres arabes 50.''
'Where did Super Bowl 50 take place?' 
# O\xF9 a eu lieu le Super Bowl 50 ?`,highlighted:`<span class="hljs-string">&#x27;Super Bowl 50 was an American football game to determine the champion of the National Football League (NFL) for the 2015 season. The American Football Conference (AFC) champion Denver Broncos defeated the National Football Conference (NFC) champion Carolina Panthers 24\u201310 to earn their third Super Bowl title. The game was played on February 7, 2016, at Levi\\&#x27;s Stadium in the San Francisco Bay Area at Santa Clara, California. As this was the 50th Super Bowl, the league emphasized the &quot;golden anniversary&quot; with various gold-themed initiatives, as well as temporarily suspending the tradition of naming each Super Bowl game with Roman numerals (under which the game would have been known as &quot;Super Bowl L&quot;), so that the logo could prominently feature the Arabic numerals 50.&#x27;</span>
<span class="hljs-comment"># Le Super Bowl 50 \xE9tait un match de football am\xE9ricain visant \xE0 d\xE9terminer le champion de la National Football League (NFL) pour la saison 2015. Les Denver Broncos, champions de la Conf\xE9rence de football am\xE9ricain (AFC), ont battu les Carolina Panthers, champions de la Conf\xE9rence nationale de football (NFC), 24 \xE0 10, pour remporter leur troisi\xE8me titre de Super Bowl. Le match s&#x27;est d\xE9roul\xE9 le 7 f\xE9vrier 2016 au Levi\\&#x27;s Stadium, dans la baie de San Francisco, \xE0 Santa Clara, en Californie. Comme il s&#x27;agissait du 50e Super Bowl, la ligue a mis l&#x27;accent sur l&#x27;&quot; anniversaire dor\xE9 &quot; avec diverses initiatives sur le th\xE8me de l&#x27;or, ainsi qu&#x27;en suspendant temporairement la tradition de nommer chaque match du Super Bowl avec des chiffres romains (en vertu de laquelle le match aurait \xE9t\xE9 appel\xE9 &quot; Super Bowl L &quot;), afin que le logo puisse mettre en \xE9vidence les chiffres arabes 50.&#x27;&#x27;</span>
<span class="hljs-string">&#x27;Where did Super Bowl 50 take place?&#x27;</span> 
<span class="hljs-comment"># O\xF9 a eu lieu le Super Bowl 50 ?</span>`}}),dt=new qs({}),fs=new Cc({props:{id:"qgaM0weJHpA"}}),mt=new z({props:{code:`from transformers import AutoTokenizer

model_checkpoint = "bert-base-cased"
tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer

model_checkpoint = <span class="hljs-string">&quot;bert-base-cased&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)`}}),hs=new z({props:{code:"tokenizer.is_fast",highlighted:"tokenizer.is_fast"}}),ht=new z({props:{code:"True",highlighted:'<span class="hljs-literal">True</span>'}}),gt=new z({props:{code:"[CLS] question [SEP] context [SEP]",highlighted:'<span class="hljs-selector-attr">[CLS]</span> question <span class="hljs-selector-attr">[SEP]</span> context <span class="hljs-selector-attr">[SEP]</span>'}}),vs=new z({props:{code:`context = raw_datasets["train"][0]["context"]
question = raw_datasets["train"][0]["question"]

inputs = tokenizer(question, context)
tokenizer.decode(inputs["input_ids"])`,highlighted:`context = raw_datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;context&quot;</span>]
question = raw_datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;question&quot;</span>]

inputs = tokenizer(question, context)
tokenizer.decode(inputs[<span class="hljs-string">&quot;input_ids&quot;</span>])`}}),xt=new z({props:{code:`'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP] Architecturally, '
'the school has a Catholic character. Atop the Main Building\\'s gold dome is a golden statue of the Virgin '
'Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms '
'upraised with the legend " Venite Ad Me Omnes ". Next to the Main Building is the Basilica of the Sacred '
'Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a '
'replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette '
'Soubirous in 1858. At the end of the main drive ( and in a direct line that connects through 3 statues '
'and the Gold Dome ), is a simple, modern stone statue of Mary. [SEP]'

'[CLS] A qui la Vierge Marie serait-elle apparue en 1858 \xE0 Lourdes en France ? [SEP] Architecturalement, '
'l \xE9cole a un caract\xE8re catholique. Au sommet du d\xF4me dor\xE9 du b\xE2timent principal se trouve une statue dor\xE9e de la Vierge '
'Marie. Imm\xE9diatement devant le b\xE2timent principal et face \xE0 lui, se trouve une statue en cuivre du Christ, les bras '
'lev\xE9s avec la l\xE9gende " Venite Ad Me Omnes ". A c\xF4t\xE9 du b\xE2timent principal se trouve la basilique du Sacr\xE9 '
'C\u0153ur. Imm\xE9diatement derri\xE8re la basilique se trouve la Grotte, un lieu marial de pri\xE8re et de r\xE9flexion. Il s'agit d'une '
'r\xE9plique de la grotte de Lourdes, en France, o\xF9 la Vierge Marie serait apparue \xE0 Sainte Bernadette '
'Soubirous en 1858. Au bout de l'all\xE9e principale ( et en ligne directe qui passe par 3 statues '
'et le D\xF4me d'or), se trouve une statue de Marie en pierre, simple et moderne. [SEP]'`,highlighted:`<span class="hljs-string">&#x27;[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP] Architecturally, &#x27;</span>
<span class="hljs-string">&#x27;the school has a Catholic character. Atop the Main Building\\&#x27;s gold dome is a golden statue of the Virgin &#x27;</span>
<span class="hljs-string">&#x27;Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms &#x27;</span>
<span class="hljs-string">&#x27;upraised with the legend &quot; Venite Ad Me Omnes &quot;. Next to the Main Building is the Basilica of the Sacred &#x27;</span>
<span class="hljs-string">&#x27;Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a &#x27;</span>
<span class="hljs-string">&#x27;replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette &#x27;</span>
<span class="hljs-string">&#x27;Soubirous in 1858. At the end of the main drive ( and in a direct line that connects through 3 statues &#x27;</span>
<span class="hljs-string">&#x27;and the Gold Dome ), is a simple, modern stone statue of Mary. [SEP]&#x27;</span>

<span class="hljs-string">&#x27;[CLS] A qui la Vierge Marie serait-elle apparue en 1858 \xE0 Lourdes en France ? [SEP] Architecturalement, &#x27;</span>
<span class="hljs-string">&#x27;l \xE9cole a un caract\xE8re catholique. Au sommet du d\xF4me dor\xE9 du b\xE2timent principal se trouve une statue dor\xE9e de la Vierge &#x27;</span>
<span class="hljs-string">&#x27;Marie. Imm\xE9diatement devant le b\xE2timent principal et face \xE0 lui, se trouve une statue en cuivre du Christ, les bras &#x27;</span>
<span class="hljs-string">&#x27;lev\xE9s avec la l\xE9gende &quot; Venite Ad Me Omnes &quot;. A c\xF4t\xE9 du b\xE2timent principal se trouve la basilique du Sacr\xE9 &#x27;</span>
<span class="hljs-string">&#x27;C\u0153ur. Imm\xE9diatement derri\xE8re la basilique se trouve la Grotte, un lieu marial de pri\xE8re et de r\xE9flexion. Il s&#x27;</span>agit d<span class="hljs-string">&#x27;une &#x27;</span>
<span class="hljs-string">&#x27;r\xE9plique de la grotte de Lourdes, en France, o\xF9 la Vierge Marie serait apparue \xE0 Sainte Bernadette &#x27;</span>
<span class="hljs-string">&#x27;Soubirous en 1858. Au bout de l&#x27;</span><span class="hljs-built_in">all</span>\xE9e principale ( et en ligne directe qui passe par <span class="hljs-number">3</span> statues <span class="hljs-string">&#x27;
&#x27;</span>et le D\xF4me d<span class="hljs-string">&#x27;or), se trouve une statue de Marie en pierre, simple et moderne. [SEP]&#x27;</span>`}}),Ee=new z({props:{code:`inputs = tokenizer(
    question,
    context,
    max_length=100,
    truncation="only_second",
    stride=50,
    return_overflowing_tokens=True,
)

for ids in inputs["input_ids"]:
    print(tokenizer.decode(ids))`,highlighted:`inputs = tokenizer(
    question,
    context,
    max_length=<span class="hljs-number">100</span>,
    truncation=<span class="hljs-string">&quot;only_second&quot;</span>,
    stride=<span class="hljs-number">50</span>,
    return_overflowing_tokens=<span class="hljs-literal">True</span>,
)

<span class="hljs-keyword">for</span> ids <span class="hljs-keyword">in</span> inputs[<span class="hljs-string">&quot;input_ids&quot;</span>]:
    <span class="hljs-built_in">print</span>(tokenizer.decode(ids))`}}),pn=new z({props:{code:`'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP] Architecturally, the school has a Catholic character. Atop the Main Building\\'s gold dome is a golden statue of the Virgin Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend " Venite Ad Me Omnes ". Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basi [SEP]'
'[CLS] A qui la Vierge Marie serait-elle apparue en 1858 \xE0 Lourdes en France ? [SEP] Sur le plan architectural, l \xE9cole a un caract\xE8re catholique. Au sommet du d\xF4me dor\xE9 du b\xE2timent principal se trouve une statue dor\xE9e de la Vierge Marie. Imm\xE9diatement devant le b\xE2timent principal et face \xE0 lui, se trouve une statue en cuivre du Christ, les bras lev\xE9s, avec la l\xE9gende " Venite Ad Me Omnes ". \xC0 c\xF4t\xE9 du b\xE2timent principal se trouve la basilique du Sacr\xE9-C\u0153ur. Imm\xE9diatement derri\xE8re la basi [SEP]'

'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP] the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend " Venite Ad Me Omnes ". Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a replica of the grotto at Lourdes, France where the Virgin [SEP]'
'[CLS] A qui la Vierge Marie serait-elle apparue en 1858 \xE0 Lourdes en France ? [SEP] le b\xE2timent principal et face \xE0 lui, une statue en cuivre du Christ aux bras lev\xE9s avec la l\xE9gende " Venite Ad Me Omnes ". \xC0 c\xF4t\xE9 du b\xE2timent principal se trouve la basilique du Sacr\xE9-C\u0153ur. Imm\xE9diatement derri\xE8re la basilique se trouve la Grotte, un lieu marial de pri\xE8re et de r\xE9flexion. Il s agit d'une r\xE9plique de la grotte de Lourdes, en France, o\xF9 la Vierge [SEP]'

'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP] Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858. At the end of the main drive ( and in a direct line that connects through 3 [SEP]'
'[CLS] A qui la Vierge Marie serait-elle apparue en 1858 \xE0 Lourdes en France ? [SEP] A c\xF4t\xE9 du b\xE2timent principal se trouve la basilique du Sacr\xE9-C\u0153ur. Imm\xE9diatement derri\xE8re la basilique se trouve la Grotte, un lieu marial de pri\xE8re et de r\xE9flexion. Il s agit d une r\xE9plique de la grotte de Lourdes, en France, o\xF9 la Vierge Marie serait apparue \xE0 Sainte Bernadette Soubirous en 1858. Au bout de l all\xE9e principale ( et dans une ligne directe qui relie par 3 [SEP]'

'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP]. It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858. At the end of the main drive ( and in a direct line that connects through 3 statues and the Gold Dome ), is a simple, modern stone statue of Mary. [SEP]'
'[CLS] A qui la Vierge Marie est-elle pr\xE9tendument apparue en 1858 \xE0 Lourdes France ? [SEP]. Il s agit d une r\xE9plique de la grotte de Lourdes, en France, o\xF9 la Vierge Marie serait apparue \xE0 Sainte Bernadette Soubirous en 1858. Au bout de l all\xE9e principale (et dans une ligne directe qui passe par 3 statues et le D\xF4me d or), se trouve une simple statue de pierre moderne de Marie. [SEP]'`,highlighted:`<span class="hljs-string">&#x27;[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP] Architecturally, the school has a Catholic character. Atop the Main Building\\&#x27;s gold dome is a golden statue of the Virgin Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend &quot; Venite Ad Me Omnes &quot;. Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basi [SEP]&#x27;</span>
<span class="hljs-string">&#x27;[CLS] A qui la Vierge Marie serait-elle apparue en 1858 \xE0 Lourdes en France ? [SEP] Sur le plan architectural, l \xE9cole a un caract\xE8re catholique. Au sommet du d\xF4me dor\xE9 du b\xE2timent principal se trouve une statue dor\xE9e de la Vierge Marie. Imm\xE9diatement devant le b\xE2timent principal et face \xE0 lui, se trouve une statue en cuivre du Christ, les bras lev\xE9s, avec la l\xE9gende &quot; Venite Ad Me Omnes &quot;. \xC0 c\xF4t\xE9 du b\xE2timent principal se trouve la basilique du Sacr\xE9-C\u0153ur. Imm\xE9diatement derri\xE8re la basi [SEP]&#x27;</span>

<span class="hljs-string">&#x27;[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP] the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend &quot; Venite Ad Me Omnes &quot;. Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a replica of the grotto at Lourdes, France where the Virgin [SEP]&#x27;</span>
<span class="hljs-string">&#x27;[CLS] A qui la Vierge Marie serait-elle apparue en 1858 \xE0 Lourdes en France ? [SEP] le b\xE2timent principal et face \xE0 lui, une statue en cuivre du Christ aux bras lev\xE9s avec la l\xE9gende &quot; Venite Ad Me Omnes &quot;. \xC0 c\xF4t\xE9 du b\xE2timent principal se trouve la basilique du Sacr\xE9-C\u0153ur. Imm\xE9diatement derri\xE8re la basilique se trouve la Grotte, un lieu marial de pri\xE8re et de r\xE9flexion. Il s agit d&#x27;</span>une r\xE9plique de la grotte de Lourdes, en France, o\xF9 la Vierge [SEP]<span class="hljs-string">&#x27;

&#x27;</span>[CLS] To whom did the Virgin Mary allegedly appear <span class="hljs-keyword">in</span> <span class="hljs-number">1858</span> <span class="hljs-keyword">in</span> Lourdes France? [SEP] Next to the Main Building <span class="hljs-keyword">is</span> the Basilica of the Sacred Heart. Immediately behind the basilica <span class="hljs-keyword">is</span> the Grotto, a Marian place of prayer <span class="hljs-keyword">and</span> reflection. It <span class="hljs-keyword">is</span> a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous <span class="hljs-keyword">in</span> <span class="hljs-number">1858.</span> At the end of the main drive ( <span class="hljs-keyword">and</span> <span class="hljs-keyword">in</span> a direct line that connects through <span class="hljs-number">3</span> [SEP]<span class="hljs-string">&#x27;
&#x27;</span>[CLS] A qui la Vierge Marie serait-elle apparue en <span class="hljs-number">1858</span> \xE0 Lourdes en France ? [SEP] A c\xF4t\xE9 du b\xE2timent principal se trouve la basilique du Sacr\xE9-C\u0153ur. Imm\xE9diatement derri\xE8re la basilique se trouve la Grotte, un lieu marial de pri\xE8re et de r\xE9flexion. Il s agit d une r\xE9plique de la grotte de Lourdes, en France, o\xF9 la Vierge Marie serait apparue \xE0 Sainte Bernadette Soubirous en <span class="hljs-number">1858.</span> Au bout de l <span class="hljs-built_in">all</span>\xE9e principale ( et dans une ligne directe qui relie par <span class="hljs-number">3</span> [SEP]<span class="hljs-string">&#x27;

&#x27;</span>[CLS] To whom did the Virgin Mary allegedly appear <span class="hljs-keyword">in</span> <span class="hljs-number">1858</span> <span class="hljs-keyword">in</span> Lourdes France? [SEP]. It <span class="hljs-keyword">is</span> a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous <span class="hljs-keyword">in</span> <span class="hljs-number">1858.</span> At the end of the main drive ( <span class="hljs-keyword">and</span> <span class="hljs-keyword">in</span> a direct line that connects through <span class="hljs-number">3</span> statues <span class="hljs-keyword">and</span> the Gold Dome ), <span class="hljs-keyword">is</span> a simple, modern stone statue of Mary. [SEP]<span class="hljs-string">&#x27;
&#x27;</span>[CLS] A qui la Vierge Marie est-elle pr\xE9tendument apparue en <span class="hljs-number">1858</span> \xE0 Lourdes France ? [SEP]. Il s agit d une r\xE9plique de la grotte de Lourdes, en France, o\xF9 la Vierge Marie serait apparue \xE0 Sainte Bernadette Soubirous en <span class="hljs-number">1858.</span> Au bout de l <span class="hljs-built_in">all</span>\xE9e principale (et dans une ligne directe qui passe par <span class="hljs-number">3</span> statues et le D\xF4me d <span class="hljs-keyword">or</span>), se trouve une simple statue de pierre moderne de Marie. [SEP]<span class="hljs-string">&#x27;</span>`}}),ir=new z({props:{code:`inputs = tokenizer(
    question,
    context,
    max_length=100,
    truncation="only_second",
    stride=50,
    return_overflowing_tokens=True,
    return_offsets_mapping=True,
)
inputs.keys()`,highlighted:`inputs = tokenizer(
    question,
    context,
    max_length=<span class="hljs-number">100</span>,
    truncation=<span class="hljs-string">&quot;only_second&quot;</span>,
    stride=<span class="hljs-number">50</span>,
    return_overflowing_tokens=<span class="hljs-literal">True</span>,
    return_offsets_mapping=<span class="hljs-literal">True</span>,
)
inputs.keys()`}}),ur=new z({props:{code:"dict_keys(['input_ids', 'token_type_ids', 'attention_mask', 'offset_mapping', 'overflow_to_sample_mapping'])",highlighted:'dict_keys([<span class="hljs-string">&#x27;input_ids&#x27;</span>, <span class="hljs-string">&#x27;token_type_ids&#x27;</span>, <span class="hljs-string">&#x27;attention_mask&#x27;</span>, <span class="hljs-string">&#x27;offset_mapping&#x27;</span>, <span class="hljs-string">&#x27;overflow_to_sample_mapping&#x27;</span>])'}}),pr=new z({props:{code:'inputs["overflow_to_sample_mapping"]',highlighted:'inputs[<span class="hljs-string">&quot;overflow_to_sample_mapping&quot;</span>]'}}),dr=new z({props:{code:"[0, 0, 0, 0]",highlighted:'[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]'}}),cr=new z({props:{code:`inputs = tokenizer(
    raw_datasets["train"][2:6]["question"],
    raw_datasets["train"][2:6]["context"],
    max_length=100,
    truncation="only_second",
    stride=50,
    return_overflowing_tokens=True,
    return_offsets_mapping=True,
)

print(f"The 4 examples gave {len(inputs['input_ids'])} features.")
print(f"Here is where each comes from: {inputs['overflow_to_sample_mapping']}.")`,highlighted:`inputs = tokenizer(
    raw_datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">2</span>:<span class="hljs-number">6</span>][<span class="hljs-string">&quot;question&quot;</span>],
    raw_datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">2</span>:<span class="hljs-number">6</span>][<span class="hljs-string">&quot;context&quot;</span>],
    max_length=<span class="hljs-number">100</span>,
    truncation=<span class="hljs-string">&quot;only_second&quot;</span>,
    stride=<span class="hljs-number">50</span>,
    return_overflowing_tokens=<span class="hljs-literal">True</span>,
    return_offsets_mapping=<span class="hljs-literal">True</span>,
)

<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;The 4 examples gave <span class="hljs-subst">{<span class="hljs-built_in">len</span>(inputs[<span class="hljs-string">&#x27;input_ids&#x27;</span>])}</span> features.&quot;</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Here is where each comes from: <span class="hljs-subst">{inputs[<span class="hljs-string">&#x27;overflow_to_sample_mapping&#x27;</span>]}</span>.&quot;</span>)`}}),mr=new z({props:{code:`'The 4 examples gave 19 features.'
'Here is where each comes from: [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3].'`,highlighted:`<span class="hljs-string">&#x27;The 4 examples gave 19 features.&#x27;</span>
<span class="hljs-string">&#x27;Here is where each comes from: [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3].&#x27;</span>`}}),fr=new z({props:{code:`answers = raw_datasets["train"][2:6]["answers"]
start_positions = []
end_positions = []

for i, offset in enumerate(inputs["offset_mapping"]):
    sample_idx = inputs["overflow_to_sample_mapping"][i]
    answer = answers[sample_idx]
    start_char = answer["answer_start"][0]
    end_char = answer["answer_start"][0] + len(answer["text"][0])
    sequence_ids = inputs.sequence_ids(i)

    # Trouver le d\xE9but et la fin du contexte
    idx = 0
    while sequence_ids[idx] != 1:
        idx += 1
    context_start = idx
    while sequence_ids[idx] == 1:
        idx += 1
    context_end = idx - 1

    # Si la r\xE9ponse n'est pas enti\xE8rement dans le contexte, l'\xE9tiquette est (0, 0)
    if offset[context_start][0] > start_char or offset[context_end][1] < end_char:
        start_positions.append(0)
        end_positions.append(0)
    else:
        # Sinon, ce sont les positions de d\xE9but et de fin du token
        idx = context_start
        while idx <= context_end and offset[idx][0] <= start_char:
            idx += 1
        start_positions.append(idx - 1)

        idx = context_end
        while idx >= context_start and offset[idx][1] >= end_char:
            idx -= 1
        end_positions.append(idx + 1)

start_positions, end_positions`,highlighted:`answers = raw_datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">2</span>:<span class="hljs-number">6</span>][<span class="hljs-string">&quot;answers&quot;</span>]
start_positions = []
end_positions = []

<span class="hljs-keyword">for</span> i, offset <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(inputs[<span class="hljs-string">&quot;offset_mapping&quot;</span>]):
    sample_idx = inputs[<span class="hljs-string">&quot;overflow_to_sample_mapping&quot;</span>][i]
    answer = answers[sample_idx]
    start_char = answer[<span class="hljs-string">&quot;answer_start&quot;</span>][<span class="hljs-number">0</span>]
    end_char = answer[<span class="hljs-string">&quot;answer_start&quot;</span>][<span class="hljs-number">0</span>] + <span class="hljs-built_in">len</span>(answer[<span class="hljs-string">&quot;text&quot;</span>][<span class="hljs-number">0</span>])
    sequence_ids = inputs.sequence_ids(i)

    <span class="hljs-comment"># Trouver le d\xE9but et la fin du contexte</span>
    idx = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> sequence_ids[idx] != <span class="hljs-number">1</span>:
        idx += <span class="hljs-number">1</span>
    context_start = idx
    <span class="hljs-keyword">while</span> sequence_ids[idx] == <span class="hljs-number">1</span>:
        idx += <span class="hljs-number">1</span>
    context_end = idx - <span class="hljs-number">1</span>

    <span class="hljs-comment"># Si la r\xE9ponse n&#x27;est pas enti\xE8rement dans le contexte, l&#x27;\xE9tiquette est (0, 0)</span>
    <span class="hljs-keyword">if</span> offset[context_start][<span class="hljs-number">0</span>] &gt; start_char <span class="hljs-keyword">or</span> offset[context_end][<span class="hljs-number">1</span>] &lt; end_char:
        start_positions.append(<span class="hljs-number">0</span>)
        end_positions.append(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-comment"># Sinon, ce sont les positions de d\xE9but et de fin du token</span>
        idx = context_start
        <span class="hljs-keyword">while</span> idx &lt;= context_end <span class="hljs-keyword">and</span> offset[idx][<span class="hljs-number">0</span>] &lt;= start_char:
            idx += <span class="hljs-number">1</span>
        start_positions.append(idx - <span class="hljs-number">1</span>)

        idx = context_end
        <span class="hljs-keyword">while</span> idx &gt;= context_start <span class="hljs-keyword">and</span> offset[idx][<span class="hljs-number">1</span>] &gt;= end_char:
            idx -= <span class="hljs-number">1</span>
        end_positions.append(idx + <span class="hljs-number">1</span>)

start_positions, end_positions`}}),_r=new z({props:{code:`([83, 51, 19, 0, 0, 64, 27, 0, 34, 0, 0, 0, 67, 34, 0, 0, 0, 0, 0],
 [85, 53, 21, 0, 0, 70, 33, 0, 40, 0, 0, 0, 68, 35, 0, 0, 0, 0, 0])`,highlighted:`([<span class="hljs-number">83</span>, <span class="hljs-number">51</span>, <span class="hljs-number">19</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">64</span>, <span class="hljs-number">27</span>, <span class="hljs-number">0</span>, <span class="hljs-number">34</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">67</span>, <span class="hljs-number">34</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
 [<span class="hljs-number">85</span>, <span class="hljs-number">53</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">70</span>, <span class="hljs-number">33</span>, <span class="hljs-number">0</span>, <span class="hljs-number">40</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">68</span>, <span class="hljs-number">35</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>])`}}),hr=new z({props:{code:`idx = 0
sample_idx = inputs["overflow_to_sample_mapping"][idx]
answer = answers[sample_idx]["text"][0]

start = start_positions[idx]
end = end_positions[idx]
labeled_answer = tokenizer.decode(inputs["input_ids"][idx][start : end + 1])

print(f"Theoretical answer: {answer}, labels give: {labeled_answer}")`,highlighted:`idx = <span class="hljs-number">0</span>
sample_idx = inputs[<span class="hljs-string">&quot;overflow_to_sample_mapping&quot;</span>][idx]
answer = answers[sample_idx][<span class="hljs-string">&quot;text&quot;</span>][<span class="hljs-number">0</span>]

start = start_positions[idx]
end = end_positions[idx]
labeled_answer = tokenizer.decode(inputs[<span class="hljs-string">&quot;input_ids&quot;</span>][idx][start : end + <span class="hljs-number">1</span>])

<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Theoretical answer: <span class="hljs-subst">{answer}</span>, labels give: <span class="hljs-subst">{labeled_answer}</span>&quot;</span>)`}}),vr=new z({props:{code:"'Theoretical answer: the Main Building, labels give: the Main Building'",highlighted:'<span class="hljs-string">&#x27;Theoretical answer: the Main Building, labels give: the Main Building&#x27;</span>'}}),br=new z({props:{code:`idx = 4
sample_idx = inputs["overflow_to_sample_mapping"][idx]
answer = answers[sample_idx]["text"][0]

decoded_example = tokenizer.decode(inputs["input_ids"][idx])
print(f"Theoretical answer: {answer}, decoded example: {decoded_example}")`,highlighted:`idx = <span class="hljs-number">4</span>
sample_idx = inputs[<span class="hljs-string">&quot;overflow_to_sample_mapping&quot;</span>][idx]
answer = answers[sample_idx][<span class="hljs-string">&quot;text&quot;</span>][<span class="hljs-number">0</span>]

decoded_example = tokenizer.decode(inputs[<span class="hljs-string">&quot;input_ids&quot;</span>][idx])
<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Theoretical answer: <span class="hljs-subst">{answer}</span>, decoded example: <span class="hljs-subst">{decoded_example}</span>&quot;</span>)`}}),gr=new z({props:{code:`'Theoretical answer: a Marian place of prayer and reflection, decoded example: [CLS] What is the Grotto at Notre Dame? [SEP] Architecturally, the school has a Catholic character. Atop the Main Building\\'s gold dome is a golden statue of the Virgin Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend " Venite Ad Me Omnes ". Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grot [SEP]'`,highlighted:'<span class="hljs-string">&#x27;Theoretical answer: a Marian place of prayer and reflection, decoded example: [CLS] What is the Grotto at Notre Dame? [SEP] Architecturally, the school has a Catholic character. Atop the Main Building\\&#x27;s gold dome is a golden statue of the Virgin Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend &quot; Venite Ad Me Omnes &quot;. Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grot [SEP]&#x27;</span>'}}),Ra=new yc({props:{$$slots:{default:[Aq]},$$scope:{ctx:R}}}),qr=new z({props:{code:`max_length = 384
stride = 128


def preprocess_training_examples(examples):
    questions = [q.strip() for q in examples["question"]]
    inputs = tokenizer(
        questions,
        examples["context"],
        max_length=max_length,
        truncation="only_second",
        stride=stride,
        return_overflowing_tokens=True,
        return_offsets_mapping=True,
        padding="max_length",
    )

    offset_mapping = inputs.pop("offset_mapping")
    sample_map = inputs.pop("overflow_to_sample_mapping")
    answers = examples["answers"]
    start_positions = []
    end_positions = []

    for i, offset in enumerate(offset_mapping):
        sample_idx = sample_map[i]
        answer = answers[sample_idx]
        start_char = answer["answer_start"][0]
        end_char = answer["answer_start"][0] + len(answer["text"][0])
        sequence_ids = inputs.sequence_ids(i)

        # Trouver le d\xE9but et la fin du contexte
        idx = 0
        while sequence_ids[idx] != 1:
            idx += 1
        context_start = idx
        while sequence_ids[idx] == 1:
            idx += 1
        context_end = idx - 1

        # Si la r\xE9ponse n'est pas enti\xE8rement dans le contexte, l'\xE9tiquette est (0, 0)
        if offset[context_start][0] > start_char or offset[context_end][1] < end_char:
            start_positions.append(0)
            end_positions.append(0)
        else:
            # Sinon, ce sont les positions de d\xE9but et de fin du token
            idx = context_start
            while idx <= context_end and offset[idx][0] <= start_char:
                idx += 1
            start_positions.append(idx - 1)

            idx = context_end
            while idx >= context_start and offset[idx][1] >= end_char:
                idx -= 1
            end_positions.append(idx + 1)

    inputs["start_positions"] = start_positions
    inputs["end_positions"] = end_positions
    return inputs`,highlighted:`max_length = <span class="hljs-number">384</span>
stride = <span class="hljs-number">128</span>


<span class="hljs-keyword">def</span> <span class="hljs-title function_">preprocess_training_examples</span>(<span class="hljs-params">examples</span>):
    questions = [q.strip() <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> examples[<span class="hljs-string">&quot;question&quot;</span>]]
    inputs = tokenizer(
        questions,
        examples[<span class="hljs-string">&quot;context&quot;</span>],
        max_length=max_length,
        truncation=<span class="hljs-string">&quot;only_second&quot;</span>,
        stride=stride,
        return_overflowing_tokens=<span class="hljs-literal">True</span>,
        return_offsets_mapping=<span class="hljs-literal">True</span>,
        padding=<span class="hljs-string">&quot;max_length&quot;</span>,
    )

    offset_mapping = inputs.pop(<span class="hljs-string">&quot;offset_mapping&quot;</span>)
    sample_map = inputs.pop(<span class="hljs-string">&quot;overflow_to_sample_mapping&quot;</span>)
    answers = examples[<span class="hljs-string">&quot;answers&quot;</span>]
    start_positions = []
    end_positions = []

    <span class="hljs-keyword">for</span> i, offset <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(offset_mapping):
        sample_idx = sample_map[i]
        answer = answers[sample_idx]
        start_char = answer[<span class="hljs-string">&quot;answer_start&quot;</span>][<span class="hljs-number">0</span>]
        end_char = answer[<span class="hljs-string">&quot;answer_start&quot;</span>][<span class="hljs-number">0</span>] + <span class="hljs-built_in">len</span>(answer[<span class="hljs-string">&quot;text&quot;</span>][<span class="hljs-number">0</span>])
        sequence_ids = inputs.sequence_ids(i)

        <span class="hljs-comment"># Trouver le d\xE9but et la fin du contexte</span>
        idx = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> sequence_ids[idx] != <span class="hljs-number">1</span>:
            idx += <span class="hljs-number">1</span>
        context_start = idx
        <span class="hljs-keyword">while</span> sequence_ids[idx] == <span class="hljs-number">1</span>:
            idx += <span class="hljs-number">1</span>
        context_end = idx - <span class="hljs-number">1</span>

        <span class="hljs-comment"># Si la r\xE9ponse n&#x27;est pas enti\xE8rement dans le contexte, l&#x27;\xE9tiquette est (0, 0)</span>
        <span class="hljs-keyword">if</span> offset[context_start][<span class="hljs-number">0</span>] &gt; start_char <span class="hljs-keyword">or</span> offset[context_end][<span class="hljs-number">1</span>] &lt; end_char:
            start_positions.append(<span class="hljs-number">0</span>)
            end_positions.append(<span class="hljs-number">0</span>)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># Sinon, ce sont les positions de d\xE9but et de fin du token</span>
            idx = context_start
            <span class="hljs-keyword">while</span> idx &lt;= context_end <span class="hljs-keyword">and</span> offset[idx][<span class="hljs-number">0</span>] &lt;= start_char:
                idx += <span class="hljs-number">1</span>
            start_positions.append(idx - <span class="hljs-number">1</span>)

            idx = context_end
            <span class="hljs-keyword">while</span> idx &gt;= context_start <span class="hljs-keyword">and</span> offset[idx][<span class="hljs-number">1</span>] &gt;= end_char:
                idx -= <span class="hljs-number">1</span>
            end_positions.append(idx + <span class="hljs-number">1</span>)

    inputs[<span class="hljs-string">&quot;start_positions&quot;</span>] = start_positions
    inputs[<span class="hljs-string">&quot;end_positions&quot;</span>] = end_positions
    <span class="hljs-keyword">return</span> inputs`}}),xr=new z({props:{code:`train_dataset = raw_datasets["train"].map(
    preprocess_training_examples,
    batched=True,
    remove_columns=raw_datasets["train"].column_names,
)
len(raw_datasets["train"]), len(train_dataset)`,highlighted:`train_dataset = raw_datasets[<span class="hljs-string">&quot;train&quot;</span>].<span class="hljs-built_in">map</span>(
    preprocess_training_examples,
    batched=<span class="hljs-literal">True</span>,
    remove_columns=raw_datasets[<span class="hljs-string">&quot;train&quot;</span>].column_names,
)
<span class="hljs-built_in">len</span>(raw_datasets[<span class="hljs-string">&quot;train&quot;</span>]), <span class="hljs-built_in">len</span>(train_dataset)`}}),$r=new z({props:{code:"(87599, 88729)",highlighted:'(<span class="hljs-number">87599</span>, <span class="hljs-number">88729</span>)'}}),wr=new qs({}),jr=new z({props:{code:`def preprocess_validation_examples(examples):
    questions = [q.strip() for q in examples["question"]]
    inputs = tokenizer(
        questions,
        examples["context"],
        max_length=max_length,
        truncation="only_second",
        stride=stride,
        return_overflowing_tokens=True,
        return_offsets_mapping=True,
        padding="max_length",
    )

    sample_map = inputs.pop("overflow_to_sample_mapping")
    example_ids = []

    for i in range(len(inputs["input_ids"])):
        sample_idx = sample_map[i]
        example_ids.append(examples["id"][sample_idx])

        sequence_ids = inputs.sequence_ids(i)
        offset = inputs["offset_mapping"][i]
        inputs["offset_mapping"][i] = [
            o if sequence_ids[k] == 1 else None for k, o in enumerate(offset)
        ]

    inputs["example_id"] = example_ids
    return inputs`,highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">preprocess_validation_examples</span>(<span class="hljs-params">examples</span>):
    questions = [q.strip() <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> examples[<span class="hljs-string">&quot;question&quot;</span>]]
    inputs = tokenizer(
        questions,
        examples[<span class="hljs-string">&quot;context&quot;</span>],
        max_length=max_length,
        truncation=<span class="hljs-string">&quot;only_second&quot;</span>,
        stride=stride,
        return_overflowing_tokens=<span class="hljs-literal">True</span>,
        return_offsets_mapping=<span class="hljs-literal">True</span>,
        padding=<span class="hljs-string">&quot;max_length&quot;</span>,
    )

    sample_map = inputs.pop(<span class="hljs-string">&quot;overflow_to_sample_mapping&quot;</span>)
    example_ids = []

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(inputs[<span class="hljs-string">&quot;input_ids&quot;</span>])):
        sample_idx = sample_map[i]
        example_ids.append(examples[<span class="hljs-string">&quot;id&quot;</span>][sample_idx])

        sequence_ids = inputs.sequence_ids(i)
        offset = inputs[<span class="hljs-string">&quot;offset_mapping&quot;</span>][i]
        inputs[<span class="hljs-string">&quot;offset_mapping&quot;</span>][i] = [
            o <span class="hljs-keyword">if</span> sequence_ids[k] == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">for</span> k, o <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(offset)
        ]

    inputs[<span class="hljs-string">&quot;example_id&quot;</span>] = example_ids
    <span class="hljs-keyword">return</span> inputs`}}),Er=new z({props:{code:`validation_dataset = raw_datasets["validation"].map(
    preprocess_validation_examples,
    batched=True,
    remove_columns=raw_datasets["validation"].column_names,
)
len(raw_datasets["validation"]), len(validation_dataset)`,highlighted:`validation_dataset = raw_datasets[<span class="hljs-string">&quot;validation&quot;</span>].<span class="hljs-built_in">map</span>(
    preprocess_validation_examples,
    batched=<span class="hljs-literal">True</span>,
    remove_columns=raw_datasets[<span class="hljs-string">&quot;validation&quot;</span>].column_names,
)
<span class="hljs-built_in">len</span>(raw_datasets[<span class="hljs-string">&quot;validation&quot;</span>]), <span class="hljs-built_in">len</span>(validation_dataset)`}}),kr=new z({props:{code:"(10570, 10822)",highlighted:'(<span class="hljs-number">10570</span>, <span class="hljs-number">10822</span>)'}});const Wh=[Mq,Sq],Zr=[];function Jh(e,u){return e[0]==="pt"?0:1}jt=Jh(R),Et=Zr[jt]=Wh[jt](R),yr=new qs({});const Xh=[Dq,zq],el=[];function Kh(e,u){return e[0]==="pt"?0:1}kt=Kh(R),yt=el[kt]=Xh[kt](R),Ar=new z({props:{code:`small_eval_set = raw_datasets["validation"].select(range(100))
trained_checkpoint = "distilbert-base-cased-distilled-squad"

tokenizer = AutoTokenizer.from_pretrained(trained_checkpoint)
eval_set = small_eval_set.map(
    preprocess_validation_examples,
    batched=True,
    remove_columns=raw_datasets["validation"].column_names,
)`,highlighted:`small_eval_set = raw_datasets[<span class="hljs-string">&quot;validation&quot;</span>].select(<span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>))
trained_checkpoint = <span class="hljs-string">&quot;distilbert-base-cased-distilled-squad&quot;</span>

tokenizer = AutoTokenizer.from_pretrained(trained_checkpoint)
eval_set = small_eval_set.<span class="hljs-built_in">map</span>(
    preprocess_validation_examples,
    batched=<span class="hljs-literal">True</span>,
    remove_columns=raw_datasets[<span class="hljs-string">&quot;validation&quot;</span>].column_names,
)`}}),Sr=new z({props:{code:"tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)",highlighted:"tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)"}});const Yh=[Lq,Tq],sl=[];function Zh(e,u){return e[0]==="pt"?0:1}Ct=Zh(R),Pt=sl[Ct]=Yh[Ct](R),Mr=new z({props:{code:`import collections

example_to_features = collections.defaultdict(list)
for idx, feature in enumerate(eval_set):
    example_to_features[feature["example_id"]].append(idx)`,highlighted:`<span class="hljs-keyword">import</span> collections

example_to_features = collections.defaultdict(<span class="hljs-built_in">list</span>)
<span class="hljs-keyword">for</span> idx, feature <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(eval_set):
    example_to_features[feature[<span class="hljs-string">&quot;example_id&quot;</span>]].append(idx)`}}),Dr=new z({props:{code:`import numpy as np

n_best = 20
max_answer_length = 30
predicted_answers = []

for example in small_eval_set:
    example_id = example["id"]
    context = example["context"]
    answers = []

    for feature_index in example_to_features[example_id]:
        start_logit = start_logits[feature_index]
        end_logit = end_logits[feature_index]
        offsets = eval_set["offset_mapping"][feature_index]

        start_indexes = np.argsort(start_logit)[-1 : -n_best - 1 : -1].tolist()
        end_indexes = np.argsort(end_logit)[-1 : -n_best - 1 : -1].tolist()
        for start_index in start_indexes:
            for end_index in end_indexes:
                # Ignore les r\xE9ponses qui ne sont pas enti\xE8rement dans le contexte
                if offsets[start_index] is None or offsets[end_index] is None:
                    continue
                # Ignore les r\xE9ponses dont la longueur est soit < 0 soit > max_answer_length
                if (
                    end_index < start_index
                    or end_index - start_index + 1 > max_answer_length
                ):
                    continue

                answers.append(
                    {
                        "text": context[offsets[start_index][0] : offsets[end_index][1]],
                        "logit_score": start_logit[start_index] + end_logit[end_index],
                    }
                )

    best_answer = max(answers, key=lambda x: x["logit_score"])
    predicted_answers.append({"id": example_id, "prediction_text": best_answer["text"]})`,highlighted:`<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

n_best = <span class="hljs-number">20</span>
max_answer_length = <span class="hljs-number">30</span>
predicted_answers = []

<span class="hljs-keyword">for</span> example <span class="hljs-keyword">in</span> small_eval_set:
    example_id = example[<span class="hljs-string">&quot;id&quot;</span>]
    context = example[<span class="hljs-string">&quot;context&quot;</span>]
    answers = []

    <span class="hljs-keyword">for</span> feature_index <span class="hljs-keyword">in</span> example_to_features[example_id]:
        start_logit = start_logits[feature_index]
        end_logit = end_logits[feature_index]
        offsets = eval_set[<span class="hljs-string">&quot;offset_mapping&quot;</span>][feature_index]

        start_indexes = np.argsort(start_logit)[-<span class="hljs-number">1</span> : -n_best - <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>].tolist()
        end_indexes = np.argsort(end_logit)[-<span class="hljs-number">1</span> : -n_best - <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>].tolist()
        <span class="hljs-keyword">for</span> start_index <span class="hljs-keyword">in</span> start_indexes:
            <span class="hljs-keyword">for</span> end_index <span class="hljs-keyword">in</span> end_indexes:
                <span class="hljs-comment"># Ignore les r\xE9ponses qui ne sont pas enti\xE8rement dans le contexte</span>
                <span class="hljs-keyword">if</span> offsets[start_index] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> offsets[end_index] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                    <span class="hljs-keyword">continue</span>
                <span class="hljs-comment"># Ignore les r\xE9ponses dont la longueur est soit &lt; 0 soit &gt; max_answer_length</span>
                <span class="hljs-keyword">if</span> (
                    end_index &lt; start_index
                    <span class="hljs-keyword">or</span> end_index - start_index + <span class="hljs-number">1</span> &gt; max_answer_length
                ):
                    <span class="hljs-keyword">continue</span>

                answers.append(
                    {
                        <span class="hljs-string">&quot;text&quot;</span>: context[offsets[start_index][<span class="hljs-number">0</span>] : offsets[end_index][<span class="hljs-number">1</span>]],
                        <span class="hljs-string">&quot;logit_score&quot;</span>: start_logit[start_index] + end_logit[end_index],
                    }
                )

    best_answer = <span class="hljs-built_in">max</span>(answers, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&quot;logit_score&quot;</span>])
    predicted_answers.append({<span class="hljs-string">&quot;id&quot;</span>: example_id, <span class="hljs-string">&quot;prediction_text&quot;</span>: best_answer[<span class="hljs-string">&quot;text&quot;</span>]})`}}),Tr=new z({props:{code:`from datasets import load_metric

metric = load_metric("squad")`,highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_metric

metric = load_metric(<span class="hljs-string">&quot;squad&quot;</span>)`}}),Lr=new z({props:{code:`theoretical_answers = [
    {"id": ex["id"], "answers": ex["answers"]} for ex in small_eval_set
]`,highlighted:`theoretical_answers = [
    {<span class="hljs-string">&quot;id&quot;</span>: ex[<span class="hljs-string">&quot;id&quot;</span>], <span class="hljs-string">&quot;answers&quot;</span>: ex[<span class="hljs-string">&quot;answers&quot;</span>]} <span class="hljs-keyword">for</span> ex <span class="hljs-keyword">in</span> small_eval_set
]`}}),Nr=new z({props:{code:`print(predicted_answers[0])
print(theoretical_answers[0])`,highlighted:`<span class="hljs-built_in">print</span>(predicted_answers[<span class="hljs-number">0</span>])
<span class="hljs-built_in">print</span>(theoretical_answers[<span class="hljs-number">0</span>])`}}),Or=new z({props:{code:`{'id': '56be4db0acb8001400a502ec', 'prediction_text': 'Denver Broncos'}
{'id': '56be4db0acb8001400a502ec', 'answers': {'text': ['Denver Broncos', 'Denver Broncos', 'Denver Broncos'], 'answer_start': [177, 177, 177]}}`,highlighted:`{<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-string">&#x27;56be4db0acb8001400a502ec&#x27;</span>, <span class="hljs-string">&#x27;prediction_text&#x27;</span>: <span class="hljs-string">&#x27;Denver Broncos&#x27;</span>}
{<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-string">&#x27;56be4db0acb8001400a502ec&#x27;</span>, <span class="hljs-string">&#x27;answers&#x27;</span>: {<span class="hljs-string">&#x27;text&#x27;</span>: [<span class="hljs-string">&#x27;Denver Broncos&#x27;</span>, <span class="hljs-string">&#x27;Denver Broncos&#x27;</span>, <span class="hljs-string">&#x27;Denver Broncos&#x27;</span>], <span class="hljs-string">&#x27;answer_start&#x27;</span>: [<span class="hljs-number">177</span>, <span class="hljs-number">177</span>, <span class="hljs-number">177</span>]}}`}}),Br=new z({props:{code:"metric.compute(predictions=predicted_answers, references=theoretical_answers)",highlighted:"metric.compute(predictions=predicted_answers, references=theoretical_answers)"}}),Fr=new z({props:{code:"{'exact_match': 83.0, 'f1': 88.25}",highlighted:'{<span class="hljs-string">&#x27;exact_match&#x27;</span>: <span class="hljs-number">83.0</span>, <span class="hljs-string">&#x27;f1&#x27;</span>: <span class="hljs-number">88.25</span>}'}});function ev(e,u){return e[0]==="pt"?Oq:Nq}let Yd=ev(R),ea=Yd(R);Vr=new z({props:{code:`from tqdm.auto import tqdm


def compute_metrics(start_logits, end_logits, features, examples):
    example_to_features = collections.defaultdict(list)
    for idx, feature in enumerate(features):
        example_to_features[feature["example_id"]].append(idx)

    predicted_answers = []
    for example in tqdm(examples):
        example_id = example["id"]
        context = example["context"]
        answers = []

        # Parcourir en boucle toutes les fonctionnalit\xE9s associ\xE9es \xE0 cet exemple
        for feature_index in example_to_features[example_id]:
            start_logit = start_logits[feature_index]
            end_logit = end_logits[feature_index]
            offsets = features[feature_index]["offset_mapping"]

            start_indexes = np.argsort(start_logit)[-1 : -n_best - 1 : -1].tolist()
            end_indexes = np.argsort(end_logit)[-1 : -n_best - 1 : -1].tolist()
            for start_index in start_indexes:
                for end_index in end_indexes:
                    # Ignore les r\xE9ponses qui ne sont pas enti\xE8rement dans le contexte
                    if offsets[start_index] is None or offsets[end_index] is None:
                        continue
                    # Ignore les r\xE9ponses dont la longueur est soit < 0, soit > max_answer_length
                    if (
                        end_index < start_index
                        or end_index - start_index + 1 > max_answer_length
                    ):
                        continue

                    answer = {
                        "text": context[offsets[start_index][0] : offsets[end_index][1]],
                        "logit_score": start_logit[start_index] + end_logit[end_index],
                    }
                    answers.append(answer)

        # S\xE9lectionne la r\xE9ponse avec le meilleur score
        if len(answers) > 0:
            best_answer = max(answers, key=lambda x: x["logit_score"])
            predicted_answers.append(
                {"id": example_id, "prediction_text": best_answer["text"]}
            )
        else:
            predicted_answers.append({"id": example_id, "prediction_text": ""})

    theoretical_answers = [{"id": ex["id"], "answers": ex["answers"]} for ex in examples]
    return metric.compute(predictions=predicted_answers, references=theoretical_answers)`,highlighted:`<span class="hljs-keyword">from</span> tqdm.auto <span class="hljs-keyword">import</span> tqdm


<span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_metrics</span>(<span class="hljs-params">start_logits, end_logits, features, examples</span>):
    example_to_features = collections.defaultdict(<span class="hljs-built_in">list</span>)
    <span class="hljs-keyword">for</span> idx, feature <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(features):
        example_to_features[feature[<span class="hljs-string">&quot;example_id&quot;</span>]].append(idx)

    predicted_answers = []
    <span class="hljs-keyword">for</span> example <span class="hljs-keyword">in</span> tqdm(examples):
        example_id = example[<span class="hljs-string">&quot;id&quot;</span>]
        context = example[<span class="hljs-string">&quot;context&quot;</span>]
        answers = []

        <span class="hljs-comment"># Parcourir en boucle toutes les fonctionnalit\xE9s associ\xE9es \xE0 cet exemple</span>
        <span class="hljs-keyword">for</span> feature_index <span class="hljs-keyword">in</span> example_to_features[example_id]:
            start_logit = start_logits[feature_index]
            end_logit = end_logits[feature_index]
            offsets = features[feature_index][<span class="hljs-string">&quot;offset_mapping&quot;</span>]

            start_indexes = np.argsort(start_logit)[-<span class="hljs-number">1</span> : -n_best - <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>].tolist()
            end_indexes = np.argsort(end_logit)[-<span class="hljs-number">1</span> : -n_best - <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>].tolist()
            <span class="hljs-keyword">for</span> start_index <span class="hljs-keyword">in</span> start_indexes:
                <span class="hljs-keyword">for</span> end_index <span class="hljs-keyword">in</span> end_indexes:
                    <span class="hljs-comment"># Ignore les r\xE9ponses qui ne sont pas enti\xE8rement dans le contexte</span>
                    <span class="hljs-keyword">if</span> offsets[start_index] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> offsets[end_index] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                        <span class="hljs-keyword">continue</span>
                    <span class="hljs-comment"># Ignore les r\xE9ponses dont la longueur est soit &lt; 0, soit &gt; max_answer_length</span>
                    <span class="hljs-keyword">if</span> (
                        end_index &lt; start_index
                        <span class="hljs-keyword">or</span> end_index - start_index + <span class="hljs-number">1</span> &gt; max_answer_length
                    ):
                        <span class="hljs-keyword">continue</span>

                    answer = {
                        <span class="hljs-string">&quot;text&quot;</span>: context[offsets[start_index][<span class="hljs-number">0</span>] : offsets[end_index][<span class="hljs-number">1</span>]],
                        <span class="hljs-string">&quot;logit_score&quot;</span>: start_logit[start_index] + end_logit[end_index],
                    }
                    answers.append(answer)

        <span class="hljs-comment"># S\xE9lectionne la r\xE9ponse avec le meilleur score</span>
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(answers) &gt; <span class="hljs-number">0</span>:
            best_answer = <span class="hljs-built_in">max</span>(answers, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&quot;logit_score&quot;</span>])
            predicted_answers.append(
                {<span class="hljs-string">&quot;id&quot;</span>: example_id, <span class="hljs-string">&quot;prediction_text&quot;</span>: best_answer[<span class="hljs-string">&quot;text&quot;</span>]}
            )
        <span class="hljs-keyword">else</span>:
            predicted_answers.append({<span class="hljs-string">&quot;id&quot;</span>: example_id, <span class="hljs-string">&quot;prediction_text&quot;</span>: <span class="hljs-string">&quot;&quot;</span>})

    theoretical_answers = [{<span class="hljs-string">&quot;id&quot;</span>: ex[<span class="hljs-string">&quot;id&quot;</span>], <span class="hljs-string">&quot;answers&quot;</span>: ex[<span class="hljs-string">&quot;answers&quot;</span>]} <span class="hljs-keyword">for</span> ex <span class="hljs-keyword">in</span> examples]
    <span class="hljs-keyword">return</span> metric.compute(predictions=predicted_answers, references=theoretical_answers)`}}),Hr=new z({props:{code:"compute_metrics(start_logits, end_logits, eval_set, small_eval_set)",highlighted:"compute_metrics(start_logits, end_logits, eval_set, small_eval_set)"}}),Ur=new z({props:{code:"{'exact_match': 83.0, 'f1': 88.25}",highlighted:'{<span class="hljs-string">&#x27;exact_match&#x27;</span>: <span class="hljs-number">83.0</span>, <span class="hljs-string">&#x27;f1&#x27;</span>: <span class="hljs-number">88.25</span>}'}}),Rr=new qs({});const sv=[Fq,Bq],tl=[];function tv(e,u){return e[0]==="pt"?0:1}At=tv(R),St=tl[At]=sv[At](R),Qr=new z({props:{code:`from huggingface_hub import notebook_login

notebook_login()`,highlighted:`<span class="hljs-keyword">from</span> huggingface_hub <span class="hljs-keyword">import</span> notebook_login

notebook_login()`}}),Gr=new z({props:{code:"huggingface-cli login",highlighted:"huggingface-cli login"}});const nv=[Vq,Iq],nl=[];function av(e,u){return e[0]==="pt"?0:1}Mt=av(R),zt=nl[Mt]=nv[Mt](R);const ov=[Uq,Hq],al=[];function rv(e,u){return e[0]==="pt"?0:1}Dt=rv(R),Tt=al[Dt]=ov[Dt](R);const lv=[Gq,Qq],ol=[];function iv(e,u){return e[0]==="pt"?0:1}Lt=iv(R),Nt=ol[Lt]=lv[Lt](R),Wr=new z({props:{code:"{'exact_match': 81.18259224219489, 'f1': 88.67381321905516}",highlighted:'{<span class="hljs-string">&#x27;exact_match&#x27;</span>: <span class="hljs-number">81.18259224219489</span>, <span class="hljs-string">&#x27;f1&#x27;</span>: <span class="hljs-number">88.67381321905516</span>}'}});let $e=R[0]==="pt"&&_q();no=new yc({props:{$$slots:{default:[Wq]},$$scope:{ctx:R}}});let we=R[0]==="pt"&&hq();return Jr=new qs({}),Xr=new z({props:{code:`from transformers import pipeline

# Remplacez par votre propre checkpoint
model_checkpoint = "huggingface-course/bert-finetuned-squad"
question_answerer = pipeline("question-answering", model=model_checkpoint)

context = """
\u{1F917} Transformers is backed by the three most popular deep learning libraries \u2014 Jax, PyTorch and TensorFlow \u2014 with a seamless integration
between them. It's straightforward to train your models with one before loading them for inference with the other.
"""
question = "Which deep learning libraries back \u{1F917} Transformers?"
question_answerer(question=question, context=context)`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

<span class="hljs-comment"># Remplacez par votre propre checkpoint</span>
model_checkpoint = <span class="hljs-string">&quot;huggingface-course/bert-finetuned-squad&quot;</span>
question_answerer = pipeline(<span class="hljs-string">&quot;question-answering&quot;</span>, model=model_checkpoint)

context = <span class="hljs-string">&quot;&quot;&quot;
\u{1F917} Transformers is backed by the three most popular deep learning libraries \u2014 Jax, PyTorch and TensorFlow \u2014 with a seamless integration
between them. It&#x27;s straightforward to train your models with one before loading them for inference with the other.
&quot;&quot;&quot;</span>
question = <span class="hljs-string">&quot;Which deep learning libraries back \u{1F917} Transformers?&quot;</span>
question_answerer(question=question, context=context)`}}),Kr=new z({props:{code:`{'score': 0.9979003071784973,
 'start': 78,
 'end': 105,
 'answer': 'Jax, PyTorch and TensorFlow'}`,highlighted:`{<span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.9979003071784973</span>,
 <span class="hljs-string">&#x27;start&#x27;</span>: <span class="hljs-number">78</span>,
 <span class="hljs-string">&#x27;end&#x27;</span>: <span class="hljs-number">105</span>,
 <span class="hljs-string">&#x27;answer&#x27;</span>: <span class="hljs-string">&#x27;Jax, PyTorch and TensorFlow&#x27;</span>}`}}),{c(){p=o("meta"),b=d(),w(f.$$.fragment),y=d(),S=o("h1"),g=o("a"),q=o("span"),w(x.$$.fragment),_=d(),M=o("span"),$=n("R\xE9ponse aux questions"),A=d(),I.c(),D=d(),P=o("p"),V=n("Il est temps de s\u2019int\xE9resser \xE0 la r\xE9ponse aux questions ! Cette t\xE2che peut prendre plusieurs formes mais celle sur laquelle nous allons nous concentrer dans cette section est appel\xE9e r\xE9ponse aux questions "),L=o("em"),O=n("extractives"),N=n(". Il s\u2019agit de poser des questions sur un document et d\u2019identifier les r\xE9ponses sous forme de \xAB d\u2019\xE9tendue de texte \xBB dans le document lui-m\xEAme."),U=d(),w(Q.$$.fragment),J=d(),H=o("p"),G=n("Nous allons "),ee=o("em"),Z=n("finetuner"),F=n(" un mod\xE8le BERT sur le "),X=o("a"),re=n("jeu de donn\xE9es SQuAD"),se=n(", qui consiste en des questions pos\xE9es par des "),K=o("em"),le=n("crowdworkers"),Ce=n(" sur un ensemble d\u2019articles de Wikipedia. Cela nous donnera un mod\xE8le capable de calculer des pr\xE9dictions comme celui-ci :"),ye=d(),ie=o("iframe"),Fe=d(),ue=o("iframe"),ls=d(),W=o("p"),Y=n("Il s\u2019agit d\u2019une pr\xE9sentation du mod\xE8le qui a \xE9t\xE9 entra\xEEn\xE9 \xE0 l\u2019aide du code pr\xE9sent\xE9 dans cette section et qui a ensuit\xE9 \xE9t\xE9 t\xE9l\xE9charg\xE9 sur le "),ws=o("em"),Bt=n("Hub"),js=n(". Vous pouvez le trouver "),Ie=o("a"),Ve=n("ici"),Es=d(),w(he.$$.fragment),He=d(),pe=o("h2"),ve=o("a"),Ue=o("span"),w(Re.$$.fragment),mo=d(),Ft=o("span"),Js=n("Pr\xE9paration des donn\xE9es"),En=d(),be=o("p"),fo=n("Le jeu de donn\xE9es le plus utilis\xE9 comme r\xE9f\xE9rence acad\xE9mique pour la r\xE9ponse extractive aux questions est "),is=o("a"),_o=n("SQuAD"),ho=n(". C\u2019est donc celui que nous utiliserons ici. Il existe \xE9galement une version plus difficile "),ks=o("a"),Xs=n("SQuAD v2"),ta=n(", qui comprend des questions sans r\xE9ponse. Tant que votre propre jeu de donn\xE9es contient une colonne pour les contextes, une colonne pour les questions et une colonne pour les r\xE9ponses, vous devriez \xEAtre en mesure d\u2019adapter les \xE9tapes ci-dessous."),te=d(),us=o("h3"),Qe=o("a"),kn=o("span"),w(Ks.$$.fragment),yn=d(),Cn=o("span"),vo=n("Le jeu de donn\xE9es SQuAD"),It=d(),ys=o("p"),bo=n("Comme d\u2019habitude, nous pouvons t\xE9l\xE9charger et mettre en cache le jeu de donn\xE9es en une seule \xE9tape gr\xE2ce \xE0 "),Ys=o("code"),go=n("load_dataset()"),qo=n(" :"),Vt=d(),w(Zs.$$.fragment),na=d(),Cs=o("p"),xo=n("Nous pouvons jeter un coup d\u2019\u0153il \xE0 cet objet pour en savoir plus sur le jeu de donn\xE9es SQuAD :"),aa=d(),w(ps.$$.fragment),oa=d(),w(et.$$.fragment),Pn=d(),me=o("p"),ra=n("On dirait que nous avons tout ce dont nous avons besoin avec les champs "),Pe=o("code"),$o=n("context"),An=n(", "),Sn=o("code"),wo=n("question"),Mn=n(" et "),zn=o("code"),jo=n("answers"),la=n(". Affichons-les pour le premier \xE9l\xE9ment de notre ensemble d\u2019entra\xEEnement :"),Ps=d(),w(As.$$.fragment),de=d(),w(st.$$.fragment),Ht=d(),oe=o("p"),Eo=n("Les champs "),tt=o("code"),ko=n("context"),yo=n(" et "),nt=o("code"),Co=n("question"),Po=n(" sont tr\xE8s simples \xE0 utiliser. Le champ "),at=o("code"),Ao=n("answers"),So=n(" est un peu plus d\xE9licat car il compile un dictionnaire avec deux champs qui sont tous deux des listes. C\u2019est le format qui sera attendu par la m\xE9trique "),ot=o("code"),Mo=n("squad"),zo=n(" lors de l\u2019\xE9valuation. Si vous utilisez vos propres donn\xE9es, vous n\u2019avez pas n\xE9cessairement besoin de vous soucier de mettre les r\xE9ponses dans le m\xEAme format. Le champ "),Ut=o("code"),rt=n("text"),ia=n(" est assez \xE9vident et le champ "),ds=o("code"),ua=n("answer_start"),Rt=n(" contient l\u2019indice du caract\xE8re de d\xE9part de chaque r\xE9ponse dans le contexte."),pa=d(),cs=o("p"),lt=n("Pendant l\u2019entra\xEEnement, il n\u2019y a qu\u2019une seule r\xE9ponse possible. Nous pouvons v\xE9rifier cela en utilisant la m\xE9thode "),Qt=o("code"),Ge=n("Dataset.filter()"),Do=n(" :"),Gt=d(),w(it.$$.fragment),da=d(),w(ms.$$.fragment),ca=d(),Wt=o("p"),ma=n("Pour l\u2019\xE9valuation, cependant, il existe plusieurs r\xE9ponses possibles pour chaque \xE9chantillon, qui peuvent \xEAtre identiques ou diff\xE9rentes :"),We=d(),w(Ae.$$.fragment),Jt=d(),w(Oe.$$.fragment),fa=d(),Je=o("p"),To=n("Nous ne nous plongerons pas dans le script d\u2019\xE9valuation car tout sera envelopp\xE9 pour nous par une m\xE9trique de \u{1F917} "),Xt=o("em"),Kt=n("Datasets"),Lo=n(". La version courte est que certaines des questions ont plusieurs r\xE9ponses possibles, et ce script va comparer une r\xE9ponse pr\xE9dite \xE0 toutes les r\xE9ponses acceptables et prendre le meilleur score. Par exemple, si nous regardons l\u2019\xE9chantillon de l\u2019indice 2 :"),Dn=d(),w(je.$$.fragment),Ss=d(),w(ut.$$.fragment),Yt=d(),Zt=o("p"),No=n("nous pouvons voir que la r\xE9ponse peut effectivement \xEAtre l\u2019une des trois possibilit\xE9s que nous avons vues pr\xE9c\xE9demment."),_a=d(),ce=o("h3"),Ms=o("a"),pt=o("span"),w(dt.$$.fragment),Oo=d(),ct=o("span"),Bo=n("Traitement des donn\xE9es d'entra\xEEnement"),ha=d(),w(fs.$$.fragment),va=d(),zs=o("p"),Fo=n("Commen\xE7ons par le pr\xE9traitement des donn\xE9es d\u2019entra\xEEnement. La partie la plus difficile est de g\xE9n\xE9rer des \xE9tiquettes pour la r\xE9ponse \xE0 la question, c\u2019est-\xE0-dire les positions de d\xE9but et de fin des "),ge=o("em"),Io=n("tokens"),Tn=n(" correspondant \xE0 la r\xE9ponse dans le contexte."),ba=d(),Ds=o("p"),Ln=n("Mais ne nous emballons pas. Tout d\u2019abord, \xE0 l\u2019aide d\u2019un "),Nn=o("em"),Vo=n("tokenizer"),On=n(", nous devons convertir le texte d\u2019entr\xE9e en identifiants que le mod\xE8le peut comprendre :"),ga=d(),w(mt.$$.fragment),en=d(),ne=o("p"),Ho=n("Comme mentionn\xE9 pr\xE9c\xE9demment, nous allons "),sn=o("em"),tn=n("finetuner"),Uo=n(" un mod\xE8le BERT, mais vous pouvez utiliser n\u2019importe quel autre type de mod\xE8le tant qu\u2019il a un "),nn=o("em"),ft=n("tokenizer"),qa=n(" rapide impl\xE9ment\xE9. Vous pouvez voir toutes les architectures qui sont livr\xE9es avec un "),Xe=o("em"),Ro=n("tokenizer"),Bn=n(" rapide dans "),_t=o("a"),Qo=n("ce tableau"),xa=n(", et pour v\xE9rifier que l\u2019objet "),_s=o("code"),$a=n("tokenizer"),ae=n(" que vous utilisez est bien soutenu par \u{1F917} "),Fn=o("em"),In=n("Tokenizers"),Go=n(" vous pouvez regarder son attribut "),Vn=o("code"),Hn=n("is_fast"),Wo=n(" :"),wa=d(),w(hs.$$.fragment),ja=d(),w(ht.$$.fragment),an=d(),Ke=o("p"),Jo=n("Nous pouvons transmettre \xE0 notre "),vt=o("em"),Xo=n("tokenizer"),Ko=n(" la question et le contexte ensemble. Il ins\xE9rera correctement les "),bt=o("em"),Yo=n("tokens"),Zo=n(" sp\xE9ciaux pour former une phrase comme celle-ci :"),on=d(),w(gt.$$.fragment),Ea=d(),qt=o("p"),Ye=n("V\xE9rifions \xE0 nouveau :"),ka=d(),w(vs.$$.fragment),ya=d(),w(xt.$$.fragment),Ts=d(),Se=o("p"),er=n("Les \xE9tiquettes sont l\u2019index des "),Un=o("em"),Ca=n("tokens"),m=n(" de d\xE9but et de fin de la r\xE9ponse. Le mod\xE8le sera charg\xE9 de pr\xE9dire dans l\u2019entr\xE9e un logit de d\xE9but et de fin par "),B=o("em"),il=n("token"),Pa=n(", les \xE9tiquettes th\xE9oriques \xE9tant les suivantes :"),sr=d(),Ls=o("div"),rn=o("img"),ul=d(),ln=o("img"),nr=d(),bs=o("p"),pl=n("Dans ce cas, le contexte n\u2019est pas trop long, mais certains des exemples du jeu de donn\xE9es ont des contextes tr\xE8s longs qui d\xE9passeront la longueur maximale que nous avons fix\xE9e (qui est de 384 dans ce cas). Comme nous l\u2019avons vu dans le "),qe=o("a"),dl=n("chapitre 6"),cl=n(" lorsque nous avons explor\xE9 le pipeline de "),Aa=o("code"),ml=n("question-answering"),fl=n(", nous allons traiter les contextes longs en cr\xE9ant plusieurs caract\xE9ristiques d\u2019entra\xEEnement \xE0 partir d\u2019un \xE9chantillon de notre jeu de donn\xE9es et avec une fen\xEAtre glissante entre eux."),Qn=d(),$t=o("p"),Sa=n("Pour voir comment cela fonctionne sur notre exemple, nous pouvons limiter la longueur \xE0 100 et utiliser une fen\xEAtre glissante de 50 "),Ma=o("em"),fe=n("tokens"),_l=n(". Pour rappel, nous utilisons :"),ar=d(),Be=o("ul"),Gn=o("li"),za=o("code"),hl=n("max_length"),vl=n(" pour d\xE9finir la longueur maximale (ici 100)"),un=d(),Wn=o("li"),Da=o("code"),Me=n('truncation="only_second"'),bl=n(" pour tronquer le contexte (qui est en deuxi\xE8me position) quand la question avec son contexte est trop longue"),gl=d(),wt=o("li"),Ta=o("code"),ql=n("stride"),xl=n(" pour fixer le nombre de "),Ns=o("em"),$l=n("tokens"),wl=n(" se chevauchant entre deux morceaux successifs (ici 50)"),La=d(),gs=o("li"),Na=o("code"),jl=n("return_overflowing_tokens=True"),El=n(" pour indiquer au "),Os=o("em"),Oa=n("tokenizer"),kl=n(" que l\u2019on veut les "),Ze=o("em"),yl=n("tokens"),Cl=n(" qui d\xE9bordent"),or=d(),w(Ee.$$.fragment),rr=d(),w(pn.$$.fragment),lr=d(),xe=o("p"),Pl=n("Comme nous pouvons le voir, notre exemple a \xE9t\xE9 divis\xE9 en quatre entr\xE9es, chacune d\u2019entre elles contenant la question et une partie du contexte. Notez que la r\xE9ponse \xE0 la question (\xAB Bernadette Soubirous \xBB) n\u2019appara\xEEt que dans la troisi\xE8me et la derni\xE8re entr\xE9e. Donc en traitant les longs contextes de cette fa\xE7on, nous allons cr\xE9er quelques exemples d\u2019entra\xEEnement o\xF9 la r\xE9ponse n\u2019est pas incluse dans le contexte. Pour ces exemples, les \xE9tiquettes seront "),dn=o("code"),Al=n("start_position = end_position = 0"),_e=n(" (donc nous pr\xE9disons le "),Ba=o("em"),Sl=n("token"),Ml=d(),Fa=o("code"),zl=n("[CLS]"),Dl=n("). Nous d\xE9finirons \xE9galement ces \xE9tiquettes dans le cas malheureux o\xF9 la r\xE9ponse a \xE9t\xE9 tronqu\xE9e de sorte que nous n\u2019avons que le d\xE9but (ou la fin) de celle-ci. Pour les exemples o\xF9 la r\xE9ponse est enti\xE8rement dans le contexte, les \xE9tiquettes seront l\u2019index du "),Ia=o("em"),cn=n("token"),Tl=n(" o\xF9 la r\xE9ponse commence et l\u2019index du "),Va=o("em"),Ll=n("token"),Pc=n(" o\xF9 la r\xE9ponse se termine."),_p=d(),ze=o("p"),Ac=n("Le jeu de donn\xE9es nous fournit le caract\xE8re de d\xE9but de la r\xE9ponse dans le contexte, et en ajoutant la longueur de la r\xE9ponse, nous pouvons trouver le caract\xE8re de fin dans le contexte. Pour faire correspondre ces indices aux "),Si=o("em"),Sc=n("tokens"),Mc=n(", nous devrons utiliser les correspondances "),Mi=o("em"),zc=n("offset"),Dc=n(" que nous avons \xE9tudi\xE9s au "),Nl=o("a"),Tc=n("chapitre 6"),Lc=n(". Nous pouvons faire en sorte que notre "),zi=o("em"),Nc=n("tokenizer"),Oc=n(" renvoie ces index en passant "),Di=o("code"),Bc=n("return_offsets_mapping=True"),Fc=n(" :"),hp=d(),w(ir.$$.fragment),vp=d(),w(ur.$$.fragment),bp=d(),De=o("p"),Ic=n("Comme nous pouvons le voir, nous r\xE9cup\xE9rons les identifiants d\u2019entr\xE9e, les "),Ti=o("em"),Vc=n("tokens"),Hc=n(" de type identifiant, le masque d\u2019attention, ainsi que la correspondance "),Li=o("em"),Uc=n("offset"),Rc=n(" dont nous avions besoin et une cl\xE9 suppl\xE9mentaire, "),Ni=o("code"),Qc=n("overflow_to_sample_mapping"),Gc=n(". La valeur correspondante nous sera utile lorsque nous tokeniserons plusieurs textes en m\xEAme temps (ce que nous devrions faire pour b\xE9n\xE9ficier du fait que notre "),Oi=o("em"),Wc=n("tokenizer"),Jc=n(" est en Rust). Puisqu\u2019un \xE9chantillon peut donner plusieurs caract\xE9ristiques, il fait correspondre chaque caract\xE9ristique \xE0 l\u2019exemple d\u2019o\xF9 elle provient. Parce qu\u2019ici nous avons seulement tokenis\xE9 un exemple, nous obtenons une liste de "),Bi=o("code"),Xc=n("0"),Kc=n(" :"),gp=d(),w(pr.$$.fragment),qp=d(),w(dr.$$.fragment),xp=d(),Ol=o("p"),Yc=n("Mais si nous tokenisons davantage d\u2019exemples, cela deviendra plus utile :"),$p=d(),w(cr.$$.fragment),wp=d(),w(mr.$$.fragment),jp=d(),Bl=o("p"),Zc=n("Comme nous pouvons le voir, les trois premiers exemples (aux indices 2, 3 et 4 de l\u2019ensemble d\u2019entra\xEEnement) ont chacun donn\xE9 quatre caract\xE9ristiques et le dernier exemple (\xE0 l\u2019indice 5 de l\u2019ensemble d\u2019entra\xEEnement) a donn\xE9 7 caract\xE9ristiques."),Ep=d(),Fl=o("p"),em=n("Ces informations seront utiles pour associer chaque caract\xE9ristique obtenue \xE0 son \xE9tiquette correspondante. Comme mentionn\xE9 pr\xE9c\xE9demment, ces \xE9tiquettes sont :"),kp=d(),Ha=o("ul"),Il=o("li"),Fi=o("code"),sm=n("(0, 0)"),tm=n(" si la r\xE9ponse n\u2019est pas dans l\u2019espace correspondant du contexte."),nm=d(),es=o("li"),Ii=o("code"),am=n("(start_position, end_position)"),om=n(" si la r\xE9ponse est dans l\u2019espace correspondant du contexte, avec "),Vi=o("code"),rm=n("start_position"),lm=n(" \xE9tant l\u2019index du "),Hi=o("em"),im=n("token"),um=n(" (dans les identifiants d\u2019entr\xE9e) au d\xE9but de la r\xE9ponse et "),Ui=o("code"),pm=n("end_position"),dm=n(" \xE9tant l\u2019index du "),Ri=o("em"),cm=n("token"),mm=n(" (dans les identifiants d\u2019entr\xE9e) o\xF9 la r\xE9ponse se termine."),yp=d(),Te=o("p"),fm=n("Pour d\xE9terminer ce qui est le cas et, le cas \xE9ch\xE9ant, les positions des "),Qi=o("em"),_m=n("tokens"),hm=n(", nous trouvons d\u2019abord les indices qui commencent et finissent le contexte dans les identifiants d\u2019entr\xE9e. Nous pourrions utiliser les "),Gi=o("em"),vm=n("tokens"),bm=n(" de type identifiants pour le faire, mais puisque ceux-ci n\u2019existent pas n\xE9cessairement pour tous les mod\xE8les (DistilBERT ne les requiert pas par exemple), nous allons plut\xF4t utiliser la m\xE9thode "),Wi=o("code"),gm=n("sequence_ids()"),qm=n(" du "),Ji=o("code"),xm=n("BatchEncoding"),$m=n(" que notre "),Xi=o("em"),wm=n("tokenizer"),jm=n(" retourne."),Cp=d(),Le=o("p"),Em=n("Une fois que nous avons ces indices de "),Ki=o("em"),km=n("tokens"),ym=n(", nous regardons les "),Yi=o("em"),Cm=n("offsets"),Pm=n(" correspondants, qui sont des "),Zi=o("em"),Am=n("tuples"),Sm=n(" de deux entiers repr\xE9sentant l\u2019\xE9tendue des caract\xE8res dans le contexte original. Nous pouvons ainsi d\xE9tecter si le morceau de contexte dans cette fonctionnalit\xE9 commence apr\xE8s la r\xE9ponse ou se termine avant que la r\xE9ponse ne commence (dans ce cas, l\u2019\xE9tiquette est "),eu=o("code"),Mm=n("(0, 0)"),zm=n("). Si ce n\u2019est pas le cas, nous bouclons pour trouver le premier et le dernier "),su=o("em"),Dm=n("token"),Tm=n(" de la r\xE9ponse :"),Pp=d(),w(fr.$$.fragment),Ap=d(),w(_r.$$.fragment),Sp=d(),mn=o("p"),Lm=n("Jetons un coup d\u2019\u0153il  \xE0 quelques r\xE9sultats pour v\xE9rifier que notre approche est correcte. Pour la premi\xE8re caract\xE9ristique, nous trouvons "),tu=o("code"),Nm=n("(83, 85)"),Om=n(" comme \xE9tiquettes. Comparons alors la r\xE9ponse th\xE9orique avec l\u2019\xE9tendue d\xE9cod\xE9e des "),nu=o("em"),Bm=n("tokens"),Fm=n(" de 83 \xE0 85 (inclus) :"),Mp=d(),w(hr.$$.fragment),zp=d(),w(vr.$$.fragment),Dp=d(),Ua=o("p"),Im=n("Cela correspond ! Maintenant v\xE9rifions l\u2019index 4, o\xF9 nous avons mis les \xE9tiquettes \xE0 "),au=o("code"),Vm=n("(0, 0)"),Hm=n(", signifiant que la r\xE9ponse n\u2019est pas dans le morceau de contexte de cette caract\xE9ristique :"),Tp=d(),w(br.$$.fragment),Lp=d(),w(gr.$$.fragment),Np=d(),Vl=o("p"),Um=n("En effet, nous ne voyons pas la r\xE9ponse dans le contexte."),Op=d(),w(Ra.$$.fragment),Bp=d(),Hl=o("p"),Rm=n("Maintenant que nous avons vu \xE9tape par \xE9tape comment pr\xE9traiter nos donn\xE9es d\u2019entra\xEEnement, nous pouvons les regrouper dans une fonction que nous appliquerons \xE0 l\u2019ensemble des donn\xE9es d\u2019entra\xEEnement. Nous allons rembourrer chaque caract\xE9ristique \xE0 la longueur maximale que nous avons d\xE9finie, car la plupart des contextes seront longs (et les \xE9chantillons correspondants seront divis\xE9s en plusieurs caract\xE9ristiques). Il n\u2019y a donc pas de r\xE9el avantage \xE0 appliquer un rembourrage dynamique ici :"),Fp=d(),w(qr.$$.fragment),Ip=d(),Ul=o("p"),Qm=n("Notez que nous avons d\xE9fini deux constantes pour d\xE9terminer la longueur maximale utilis\xE9e ainsi que la longueur de la fen\xEAtre glissante, et que nous avons ajout\xE9 un petit nettoyage avant la tok\xE9nisation : certaines des questions dans SQuAD ont des espaces suppl\xE9mentaires au d\xE9but et \xE0 la fin qui n\u2019ajoutent rien (et prennent de la place lors de la tok\xE9nisation si vous utilisez un mod\xE8le comme RoBERTa), donc nous avons supprim\xE9 ces espaces suppl\xE9mentaires."),Vp=d(),fn=o("p"),Gm=n("Pour appliquer cette fonction \xE0 l\u2019ensemble de l\u2019entra\xEEnement, nous utilisons la m\xE9thode "),ou=o("code"),Wm=n("Dataset.map()"),Jm=n(" avec le flag "),ru=o("code"),Xm=n("batched=True"),Km=n(". C\u2019est n\xE9cessaire ici car nous changeons la longueur du jeu de donn\xE9es (puisqu\u2019un exemple peut donner plusieurs caract\xE9ristiques d\u2019entra\xEEnement) :"),Hp=d(),w(xr.$$.fragment),Up=d(),w($r.$$.fragment),Rp=d(),Rl=o("p"),Ym=n("Comme nous pouvons le voir, le pr\xE9traitement a ajout\xE9 environ 1 000 caract\xE9ristiques. Notre ensemble d\u2019entra\xEEnement est maintenant pr\xEAt \xE0 \xEAtre utilis\xE9. Passons au pr\xE9traitement de l\u2019ensemble de validation !"),Qp=d(),Jn=o("h3"),Qa=o("a"),lu=o("span"),w(wr.$$.fragment),Zm=d(),iu=o("span"),ef=n("Traitement des donn\xE9es de validation"),Gp=d(),Ga=o("p"),sf=n("Le pr\xE9traitement des donn\xE9es de validation sera l\xE9g\xE8rement plus facile car nous n\u2019avons pas besoin de g\xE9n\xE9rer des \xE9tiquettes (sauf si nous voulons calculer une perte de validation, mais elle ne nous aidera pas vraiment \xE0 comprendre la qualit\xE9 du mod\xE8le). Le r\xE9el plaisir sera d\u2019interpr\xE9ter les pr\xE9dictions du mod\xE8le dans des \xE9tendues du contexte original. Pour cela, il nous suffit de stocker les correspondances d\u2019"),uu=o("em"),tf=n("offset"),nf=n(" et un moyen de faire correspondre chaque caract\xE9ristique cr\xE9\xE9e \xE0 l\u2019exemple original dont elle provient. Puisqu\u2019il y a une colonne identifiant dans le jeu de donn\xE9es original, nous l\u2019utiliserons."),Wp=d(),ke=o("p"),af=n("La seule chose que nous allons ajouter ici est un petit nettoyage des correspondances d\u2019"),pu=o("em"),of=n("offset"),rf=n(". Elles contiendront les "),du=o("em"),lf=n("offsets"),uf=n(" pour la question et le contexte, mais une fois que nous serons \xE0 la phase de post-traitement, nous n\u2019aurons aucun moyen de savoir quelle partie des identifiants d\u2019entr\xE9e correspondait au contexte et quelle partie \xE9tait la question (la m\xE9thode "),cu=o("code"),pf=n("sequence_ids()"),df=n(" que nous avons utilis\xE9e n\u2019est disponible que pour la sortie du "),mu=o("em"),cf=n("tokenizer"),mf=n("). Donc, nous allons mettre les "),fu=o("em"),ff=n("offsets"),_f=n(" correspondant \xE0 la question \xE0 "),_u=o("code"),hf=n("None"),vf=n(" :"),Jp=d(),w(jr.$$.fragment),Xp=d(),Ql=o("p"),bf=n("Nous pouvons appliquer cette fonction sur l\u2019ensemble de validation comme pr\xE9c\xE9demment :"),Kp=d(),w(Er.$$.fragment),Yp=d(),w(kr.$$.fragment),Zp=d(),Gl=o("p"),gf=n("Dans ce cas, nous n\u2019avons ajout\xE9 que quelques centaines d\u2019\xE9chantillons, il semble donc que les contextes dans l\u2019ensemble de validation soient un peu plus courts."),ed=d(),Wl=o("p"),qf=n("Maintenant que nous avons pr\xE9trait\xE9 toutes les donn\xE9es, nous pouvons passer \xE0 l\u2019entra\xEEnement."),sd=d(),Et.c(),Jl=d(),Xn=o("h3"),Wa=o("a"),hu=o("span"),w(yr.$$.fragment),xf=d(),vu=o("span"),$f=n("Post-traitement"),td=d(),yt.c(),Xl=d(),_n=o("p"),wf=n("Le mod\xE8le produira des logits pour les positions de d\xE9but et de fin de la r\xE9ponse dans les identifiants d\u2019entr\xE9e, comme nous l\u2019avons vu lors de notre exploration du pipeline de "),bu=o("code"),jf=n("question-answering"),Ef=d(),Kl=o("a"),kf=n("au chapitre 6"),yf=n(". L\u2019\xE9tape de post-traitement sera similaire \xE0 ce que nous avons fait \xE0 ce chapitre l\xE0. Voici un rapide rappel des actions que nous avons prises :"),nd=d(),Bs=o("ul"),Cr=o("li"),Cf=n("nous avons masqu\xE9 les logits de d\xE9but et de fin correspondant aux "),gu=o("em"),Pf=n("tokens"),Af=n(" en dehors du contexte,"),Sf=d(),qu=o("li"),Mf=n("nous avons ensuite converti les logits de d\xE9but et de fin en probabilit\xE9s en utilisant une fonction SoftMax,"),zf=d(),Pr=o("li"),Df=n("nous avons attribu\xE9 un score \xE0 chaque paire "),xu=o("code"),Tf=n("(start_token, end_token)"),Lf=n(" en prenant le produit des deux probabilit\xE9s correspondantes,"),Nf=d(),Kn=o("li"),Of=n("nous avons cherch\xE9 la paire avec le score maximum qui donnait une r\xE9ponse valide (par exemple, un "),$u=o("code"),Bf=n("start_token"),Ff=n(" inf\xE9rieur au "),wu=o("code"),If=n("end_token"),Vf=n(")."),ad=d(),ss=o("p"),Hf=n("Ici, nous allons modifier l\xE9g\xE8rement ce processus car nous n\u2019avons pas besoin de calculer les scores r\xE9els (juste la r\xE9ponse pr\xE9dite). Cela signifie que nous pouvons sauter l\u2019\xE9tape de la SoftMax. Pour aller plus vite, nous ne donnerons pas non plus un score \xE0 toutes les paires "),ju=o("code"),Uf=n("(start_token, end_token)"),Rf=n(" possibles, mais seulement celles correspondant aux "),Eu=o("code"),Qf=n("n_best"),Gf=n(" logits les plus \xE9lev\xE9s (avec "),ku=o("code"),Wf=n("n_best=20"),Jf=n("). Puisque nous sautons la SoftMax, les scores seront des scores logi, et seront obtenus en prenant la somme des logits de d\xE9but et de fin (au lieu du produit, \xE0 cause de la r\xE8gle "),od=new $q,rd=n(")."),ld=d(),Fs=o("p"),Xf=n("Pour d\xE9montrer tout cela, nous aurons besoin d\u2019un certain type de pr\xE9dictions. Puisque nous n\u2019avons pas encore entra\xEEn\xE9 notre mod\xE8le, nous allons utiliser le mod\xE8le par d\xE9faut du pipeline de "),yu=o("code"),Kf=n("question-answering"),Yf=n(" pour g\xE9n\xE9rer quelques pr\xE9dictions sur une petite partie de l\u2019ensemble de validation. Nous pouvons utiliser la m\xEAme fonction de traitement que pr\xE9c\xE9demment car elle repose sur la constante globale "),Cu=o("code"),Zf=n("tokenizer"),e_=n(", nous devons juste changer cet objet par le "),Pu=o("em"),s_=n("tokenizer"),t_=n(" du mod\xE8le que nous voulons utiliser temporairement :"),id=d(),w(Ar.$$.fragment),ud=d(),Ja=o("p"),n_=n("Maintenant que le pr\xE9traitement est termin\xE9, nous changeons le "),Au=o("em"),a_=n("tokenizer"),o_=n(" pour celui que nous avons choisi \xE0 l\u2019origine :"),pd=d(),w(Sr.$$.fragment),dd=d(),Xa=o("p"),r_=n("Nous supprimons ensuite les colonnes de notre "),Su=o("code"),l_=n("eval_set"),i_=n(" qui ne sont pas attendues par le mod\xE8le. Nous construisons un batch avec tout de ce petit ensemble de validation et le passons au mod\xE8le. Si un GPU est disponible, nous l\u2019utilisons pour aller plus vite :"),cd=d(),Pt.c(),Yl=d(),ts=o("p"),u_=n("Maintenant, nous devons trouver la r\xE9ponse pr\xE9dite pour chaque exemple dans notre "),Mu=o("code"),p_=n("small_eval_set"),d_=n(". Un exemple peut avoir \xE9t\xE9 divis\xE9 en plusieurs caract\xE9ristiques dans "),zu=o("code"),c_=n("eval_set"),m_=n(", donc la premi\xE8re \xE9tape est de faire correspondre chaque exemple dans "),Du=o("code"),f_=n("small_eval_set"),__=n(" aux caract\xE9ristiques correspondantes dans "),Tu=o("code"),h_=n("eval_set"),v_=n(" :"),md=d(),w(Mr.$$.fragment),fd=d(),Ka=o("p"),b_=n("Avec cela, nous pouvons vraiment nous mettre au travail en bouclant tous les exemples et, pour chaque exemple, toutes les caract\xE9ristiques associ\xE9es. Comme nous l\u2019avons dit pr\xE9c\xE9demment, nous allons regarder les scores logit pour les "),Lu=o("code"),g_=n("n_best"),q_=n(" logits de d\xE9but et logits de fin, en excluant les positions qui donnent :"),_d=d(),hn=o("ul"),Nu=o("li"),x_=n("une r\xE9ponse qui ne serait pas dans le contexte"),$_=d(),Ou=o("li"),w_=n("une r\xE9ponse avec une longueur n\xE9gative"),j_=d(),zr=o("li"),E_=n("une r\xE9ponse qui est trop longue (nous limitons les possibilit\xE9s \xE0 "),Bu=o("code"),k_=n("max_answer_length=30"),y_=n(")"),hd=d(),Zl=o("p"),C_=n("Une fois que nous avons toutes les r\xE9ponses possibles not\xE9es pour un exemple, nous choisissons simplement celle qui a le meilleur score logit :"),vd=d(),w(Dr.$$.fragment),bd=d(),Ya=o("p"),P_=n("Le format final des r\xE9ponses pr\xE9dites est celui qui sera attendu par la m\xE9trique que nous allons utiliser. Comme d\u2019habitude, nous pouvons la charger \xE0 l\u2019aide de la biblioth\xE8que \u{1F917} "),Fu=o("em"),A_=n("Datasets"),S_=n(" :"),gd=d(),w(Tr.$$.fragment),qd=d(),ei=o("p"),M_=n("Cette m\xE9trique attend les r\xE9ponses pr\xE9dites dans le format que nous avons vu ci-dessus (une liste de dictionnaires avec une cl\xE9 pour l\u2019identifiant de l\u2019exemple et une cl\xE9 pour le texte pr\xE9dit) et les r\xE9ponses th\xE9oriques dans le format ci-dessous (une liste de dictionnaires avec une cl\xE9 pour l\u2019identifiant de l\u2019exemple et une cl\xE9 pour les r\xE9ponses possibles) :"),xd=d(),w(Lr.$$.fragment),$d=d(),si=o("p"),z_=n("Nous pouvons maintenant v\xE9rifier que nous obtenons des r\xE9sultats raisonnables en examinant le premier \xE9l\xE9ment des deux listes :"),wd=d(),w(Nr.$$.fragment),jd=d(),w(Or.$$.fragment),Ed=d(),ti=o("p"),D_=n("Pas trop mal ! Voyons maintenant le score que la m\xE9trique nous donne :"),kd=d(),w(Br.$$.fragment),yd=d(),w(Fr.$$.fragment),Cd=d(),vn=o("p"),T_=n("Encore une fois, c\u2019est plut\xF4t bon si l\u2019on consid\xE8re que, d\u2019apr\xE8s "),Ir=o("a"),L_=n("le papier"),N_=n(" de DistilBERT, "),Iu=o("em"),O_=n("finetun\xE9"),B_=n(" sur SQuAD, ce mod\xE8le obtient 79,1 et 86,9 pour ces scores sur l\u2019ensemble du jeu de donn\xE9es."),Pd=d(),ea.c(),ni=d(),w(Vr.$$.fragment),Ad=d(),ai=o("p"),F_=n("Nous pouvons v\xE9rifier que cela fonctionne sur nos pr\xE9dictions :"),Sd=d(),w(Hr.$$.fragment),Md=d(),w(Ur.$$.fragment),zd=d(),Za=o("p"),I_=n("C\u2019est bien ! Maintenant, utilisons ceci pour "),Vu=o("em"),V_=n("finetuner"),H_=n(" notre mod\xE8le."),Dd=d(),Yn=o("h3"),eo=o("a"),Hu=o("span"),w(Rr.$$.fragment),U_=d(),oi=o("span"),Uu=o("i"),R_=n("Finetuning"),Q_=n(" du mod\xE8le"),Td=d(),St.c(),ri=d(),so=o("p"),G_=n("Comme d\u2019habitude, nous recevons un avertissement indiquant que certains poids ne sont pas utilis\xE9s (ceux de la t\xEAte de pr\xE9-entra\xEEnement) et que d\u2019autres sont initialis\xE9s de mani\xE8re al\xE9atoire (ceux de la t\xEAte de r\xE9ponse aux questions). Vous devriez \xEAtre habitu\xE9 \xE0 cela maintenant, mais cela signifie que ce mod\xE8le n\u2019est pas encore pr\xEAt \xE0 \xEAtre utilis\xE9 et qu\u2019il a besoin d\u2019\xEAtre "),Ru=o("em"),W_=n("finetun\xE9"),J_=n(". Une bonne chose que nous soyons sur le point de le faire !"),Ld=d(),Is=o("p"),X_=n("Pour pouvoir pousser notre mod\xE8le vers le "),Qu=o("em"),K_=n("Hub"),Y_=n(", nous devons nous connecter \xE0 Hugging Face. Si vous ex\xE9cutez ce code dans un "),Gu=o("em"),Z_=n("notebook"),eh=n(", vous pouvez le faire avec la fonction utilitaire suivante, qui affiche un "),Wu=o("em"),sh=n("widget"),th=n(" o\xF9 vous pouvez entrer vos identifiants de connexion :"),Nd=d(),w(Qr.$$.fragment),Od=d(),to=o("p"),nh=n("Si vous ne travaillez pas dans un "),Ju=o("em"),ah=n("notebook"),oh=n(", tapez simplement la ligne suivante dans votre terminal :"),Bd=d(),w(Gr.$$.fragment),Fd=d(),zt.c(),li=d(),ns=o("p"),rh=n("Par d\xE9faut, le d\xE9p\xF4t utilis\xE9 sera dans votre espace et nomm\xE9 apr\xE8s le r\xE9pertoire de sortie que vous avez d\xE9fini. Donc dans notre cas il sera dans "),Xu=o("code"),lh=n('"sgugger/bert-finetuned-squad"'),ih=n(". Nous pouvons passer outre en passant un "),Ku=o("code"),uh=n("hub_model_id"),ph=n(", par exemple, pour pousser le mod\xE8le dans l\u2019organisation "),Yu=o("code"),dh=n("huggingface_course"),ch=n(" nous avons utilis\xE9 "),Zu=o("code"),mh=n('hub_model_id= "huggingface_course/bert-finetuned-squad"'),fh=n(" (qui est le mod\xE8le que nous avons li\xE9 au d\xE9but de cette section)."),Id=d(),Tt.c(),ii=d(),bn=o("p"),_h=n("Notez que pendant l\u2019entra\xEEnement, chaque fois que le mod\xE8le est sauvegard\xE9 (ici, \xE0 chaque \xE9poque), il est t\xE9l\xE9charg\xE9 sur le "),ep=o("em"),hh=n("Hub"),vh=n(" en arri\xE8re-plan. Ainsi, vous pourrez reprendre votre entra\xEEnement sur une autre machine si n\xE9cessaire. L\u2019ensemble de l\u2019entra\xEEnement prend un certain temps (un peu plus d\u2019une heure sur une Titan RTX), vous pouvez donc prendre un caf\xE9 ou relire les parties du cours qui vous ont sembl\xE9 plus difficiles pendant qu\u2019il se d\xE9roule. Notez \xE9galement que d\xE8s que la premi\xE8re \xE9poque est termin\xE9e, vous verrez des poids t\xE9l\xE9charg\xE9s sur le "),sp=o("em"),bh=n("Hub"),gh=n(" et vous pourrez commencer \xE0 jouer avec votre mod\xE8le sur sa page."),Vd=d(),Nt.c(),ui=d(),w(Wr.$$.fragment),Hd=d(),pi=o("p"),qh=n("Super ! \xC0 titre de comparaison, les scores indiqu\xE9s dans l\u2019article de BERT pour ce t\xE2che sont de 80,8 et 88,5. Donc nous sommes exactement l\xE0 o\xF9 nous devrions \xEAtre."),Ud=d(),$e&&$e.c(),di=d(),Vs=o("p"),xh=n("\xC0 ce stade, vous pouvez utiliser le "),tp=o("em"),$h=n("widget"),wh=n(" d\u2019inf\xE9rence sur le "),np=o("em"),jh=n("Hub"),Eh=n(" du mod\xE8le pour tester le mod\xE8le et le partager avec vos amis, votre famille et vos animaux pr\xE9f\xE9r\xE9s. Vous avez r\xE9ussi \xE0 "),ap=o("em"),kh=n("finetuner"),yh=n(" un mod\xE8le sur une t\xE2che de r\xE9ponse \xE0 une question. F\xE9licitations !"),Rd=d(),w(no.$$.fragment),Qd=d(),we&&we.c(),ci=d(),Zn=o("h3"),ao=o("a"),op=o("span"),w(Jr.$$.fragment),Ch=d(),mi=o("span"),Ph=n("Utilisation du mod\xE8le "),rp=o("i"),Ah=n("finetun\xE9"),Gd=d(),as=o("p"),Sh=n("Nous vous avons d\xE9j\xE0 montr\xE9 comment vous pouvez utiliser le mod\xE8le que nous avons "),lp=o("em"),Mh=n("finetun\xE9"),zh=n(" sur le "),ip=o("em"),Dh=n("Hub"),Th=n(" avec le "),up=o("em"),Lh=n("widget"),Nh=n(" d\u2019inf\xE9rence. Pour l\u2019utiliser localement dans un "),pp=o("code"),Oh=n("pipeline"),Bh=n(", il suffit de sp\xE9cifier l\u2019identifiant du mod\xE8le :"),Wd=d(),w(Xr.$$.fragment),Jd=d(),w(Kr.$$.fragment),Xd=d(),fi=o("p"),Fh=n("Super ! Notre mod\xE8le fonctionne aussi bien que le mod\xE8le par d\xE9faut pour ce pipeline !"),this.h()},l(e){const u=wq('[data-svelte="svelte-1phssyn"]',document.head);p=r(u,"META",{name:!0,content:!0}),u.forEach(t),b=c(e),j(f.$$.fragment,e),y=c(e),S=r(e,"H1",{class:!0});var rl=l(S);g=r(rl,"A",{id:!0,class:!0,href:!0});var _i=l(g);q=r(_i,"SPAN",{});var dp=l(q);j(x.$$.fragment,dp),dp.forEach(t),_i.forEach(t),_=c(rl),M=r(rl,"SPAN",{});var cp=l(M);$=a(cp,"R\xE9ponse aux questions"),cp.forEach(t),rl.forEach(t),A=c(e),I.l(e),D=c(e),P=r(e,"P",{});var oo=l(P);V=a(oo,"Il est temps de s\u2019int\xE9resser \xE0 la r\xE9ponse aux questions ! Cette t\xE2che peut prendre plusieurs formes mais celle sur laquelle nous allons nous concentrer dans cette section est appel\xE9e r\xE9ponse aux questions "),L=r(oo,"EM",{});var hi=l(L);O=a(hi,"extractives"),hi.forEach(t),N=a(oo,". Il s\u2019agit de poser des questions sur un document et d\u2019identifier les r\xE9ponses sous forme de \xAB d\u2019\xE9tendue de texte \xBB dans le document lui-m\xEAme."),oo.forEach(t),U=c(e),j(Q.$$.fragment,e),J=c(e),H=r(e,"P",{});var Hs=l(H);G=a(Hs,"Nous allons "),ee=r(Hs,"EM",{});var vi=l(ee);Z=a(vi,"finetuner"),vi.forEach(t),F=a(Hs," un mod\xE8le BERT sur le "),X=r(Hs,"A",{href:!0,rel:!0});var bi=l(X);re=a(bi,"jeu de donn\xE9es SQuAD"),bi.forEach(t),se=a(Hs,", qui consiste en des questions pos\xE9es par des "),K=r(Hs,"EM",{});var gi=l(K);le=a(gi,"crowdworkers"),gi.forEach(t),Ce=a(Hs," sur un ensemble d\u2019articles de Wikipedia. Cela nous donnera un mod\xE8le capable de calculer des pr\xE9dictions comme celui-ci :"),Hs.forEach(t),ye=c(e),ie=r(e,"IFRAME",{src:!0,frameborder:!0,height:!0,title:!0,class:!0,allow:!0,sandbox:!0}),l(ie).forEach(t),Fe=c(e),ue=r(e,"IFRAME",{src:!0,frameborder:!0,height:!0,title:!0,class:!0,allow:!0,sandbox:!0}),l(ue).forEach(t),ls=c(e),W=r(e,"P",{});var sa=l(W);Y=a(sa,"Il s\u2019agit d\u2019une pr\xE9sentation du mod\xE8le qui a \xE9t\xE9 entra\xEEn\xE9 \xE0 l\u2019aide du code pr\xE9sent\xE9 dans cette section et qui a ensuit\xE9 \xE9t\xE9 t\xE9l\xE9charg\xE9 sur le "),ws=r(sa,"EM",{});var mp=l(ws);Bt=a(mp,"Hub"),mp.forEach(t),js=a(sa,". Vous pouvez le trouver "),Ie=r(sa,"A",{href:!0,rel:!0});var uv=l(Ie);Ve=a(uv,"ici"),uv.forEach(t),sa.forEach(t),Es=c(e),j(he.$$.fragment,e),He=c(e),pe=r(e,"H2",{class:!0});var Zd=l(pe);ve=r(Zd,"A",{id:!0,class:!0,href:!0});var pv=l(ve);Ue=r(pv,"SPAN",{});var dv=l(Ue);j(Re.$$.fragment,dv),dv.forEach(t),pv.forEach(t),mo=c(Zd),Ft=r(Zd,"SPAN",{});var cv=l(Ft);Js=a(cv,"Pr\xE9paration des donn\xE9es"),cv.forEach(t),Zd.forEach(t),En=c(e),be=r(e,"P",{});var qi=l(be);fo=a(qi,"Le jeu de donn\xE9es le plus utilis\xE9 comme r\xE9f\xE9rence acad\xE9mique pour la r\xE9ponse extractive aux questions est "),is=r(qi,"A",{href:!0,rel:!0});var mv=l(is);_o=a(mv,"SQuAD"),mv.forEach(t),ho=a(qi,". C\u2019est donc celui que nous utiliserons ici. Il existe \xE9galement une version plus difficile "),ks=r(qi,"A",{href:!0,rel:!0});var fv=l(ks);Xs=a(fv,"SQuAD v2"),fv.forEach(t),ta=a(qi,", qui comprend des questions sans r\xE9ponse. Tant que votre propre jeu de donn\xE9es contient une colonne pour les contextes, une colonne pour les questions et une colonne pour les r\xE9ponses, vous devriez \xEAtre en mesure d\u2019adapter les \xE9tapes ci-dessous."),qi.forEach(t),te=c(e),us=r(e,"H3",{class:!0});var ec=l(us);Qe=r(ec,"A",{id:!0,class:!0,href:!0});var _v=l(Qe);kn=r(_v,"SPAN",{});var hv=l(kn);j(Ks.$$.fragment,hv),hv.forEach(t),_v.forEach(t),yn=c(ec),Cn=r(ec,"SPAN",{});var vv=l(Cn);vo=a(vv,"Le jeu de donn\xE9es SQuAD"),vv.forEach(t),ec.forEach(t),It=c(e),ys=r(e,"P",{});var sc=l(ys);bo=a(sc,"Comme d\u2019habitude, nous pouvons t\xE9l\xE9charger et mettre en cache le jeu de donn\xE9es en une seule \xE9tape gr\xE2ce \xE0 "),Ys=r(sc,"CODE",{});var bv=l(Ys);go=a(bv,"load_dataset()"),bv.forEach(t),qo=a(sc," :"),sc.forEach(t),Vt=c(e),j(Zs.$$.fragment,e),na=c(e),Cs=r(e,"P",{});var gv=l(Cs);xo=a(gv,"Nous pouvons jeter un coup d\u2019\u0153il \xE0 cet objet pour en savoir plus sur le jeu de donn\xE9es SQuAD :"),gv.forEach(t),aa=c(e),j(ps.$$.fragment,e),oa=c(e),j(et.$$.fragment,e),Pn=c(e),me=r(e,"P",{});var ro=l(me);ra=a(ro,"On dirait que nous avons tout ce dont nous avons besoin avec les champs "),Pe=r(ro,"CODE",{});var qv=l(Pe);$o=a(qv,"context"),qv.forEach(t),An=a(ro,", "),Sn=r(ro,"CODE",{});var xv=l(Sn);wo=a(xv,"question"),xv.forEach(t),Mn=a(ro," et "),zn=r(ro,"CODE",{});var $v=l(zn);jo=a($v,"answers"),$v.forEach(t),la=a(ro,". Affichons-les pour le premier \xE9l\xE9ment de notre ensemble d\u2019entra\xEEnement :"),ro.forEach(t),Ps=c(e),j(As.$$.fragment,e),de=c(e),j(st.$$.fragment,e),Ht=c(e),oe=r(e,"P",{});var os=l(oe);Eo=a(os,"Les champs "),tt=r(os,"CODE",{});var wv=l(tt);ko=a(wv,"context"),wv.forEach(t),yo=a(os," et "),nt=r(os,"CODE",{});var jv=l(nt);Co=a(jv,"question"),jv.forEach(t),Po=a(os," sont tr\xE8s simples \xE0 utiliser. Le champ "),at=r(os,"CODE",{});var Ev=l(at);Ao=a(Ev,"answers"),Ev.forEach(t),So=a(os," est un peu plus d\xE9licat car il compile un dictionnaire avec deux champs qui sont tous deux des listes. C\u2019est le format qui sera attendu par la m\xE9trique "),ot=r(os,"CODE",{});var kv=l(ot);Mo=a(kv,"squad"),kv.forEach(t),zo=a(os," lors de l\u2019\xE9valuation. Si vous utilisez vos propres donn\xE9es, vous n\u2019avez pas n\xE9cessairement besoin de vous soucier de mettre les r\xE9ponses dans le m\xEAme format. Le champ "),Ut=r(os,"CODE",{});var yv=l(Ut);rt=a(yv,"text"),yv.forEach(t),ia=a(os," est assez \xE9vident et le champ "),ds=r(os,"CODE",{});var Cv=l(ds);ua=a(Cv,"answer_start"),Cv.forEach(t),Rt=a(os," contient l\u2019indice du caract\xE8re de d\xE9part de chaque r\xE9ponse dans le contexte."),os.forEach(t),pa=c(e),cs=r(e,"P",{});var tc=l(cs);lt=a(tc,"Pendant l\u2019entra\xEEnement, il n\u2019y a qu\u2019une seule r\xE9ponse possible. Nous pouvons v\xE9rifier cela en utilisant la m\xE9thode "),Qt=r(tc,"CODE",{});var Pv=l(Qt);Ge=a(Pv,"Dataset.filter()"),Pv.forEach(t),Do=a(tc," :"),tc.forEach(t),Gt=c(e),j(it.$$.fragment,e),da=c(e),j(ms.$$.fragment,e),ca=c(e),Wt=r(e,"P",{});var Av=l(Wt);ma=a(Av,"Pour l\u2019\xE9valuation, cependant, il existe plusieurs r\xE9ponses possibles pour chaque \xE9chantillon, qui peuvent \xEAtre identiques ou diff\xE9rentes :"),Av.forEach(t),We=c(e),j(Ae.$$.fragment,e),Jt=c(e),j(Oe.$$.fragment,e),fa=c(e),Je=r(e,"P",{});var nc=l(Je);To=a(nc,"Nous ne nous plongerons pas dans le script d\u2019\xE9valuation car tout sera envelopp\xE9 pour nous par une m\xE9trique de \u{1F917} "),Xt=r(nc,"EM",{});var Sv=l(Xt);Kt=a(Sv,"Datasets"),Sv.forEach(t),Lo=a(nc,". La version courte est que certaines des questions ont plusieurs r\xE9ponses possibles, et ce script va comparer une r\xE9ponse pr\xE9dite \xE0 toutes les r\xE9ponses acceptables et prendre le meilleur score. Par exemple, si nous regardons l\u2019\xE9chantillon de l\u2019indice 2 :"),nc.forEach(t),Dn=c(e),j(je.$$.fragment,e),Ss=c(e),j(ut.$$.fragment,e),Yt=c(e),Zt=r(e,"P",{});var Mv=l(Zt);No=a(Mv,"nous pouvons voir que la r\xE9ponse peut effectivement \xEAtre l\u2019une des trois possibilit\xE9s que nous avons vues pr\xE9c\xE9demment."),Mv.forEach(t),_a=c(e),ce=r(e,"H3",{class:!0});var ac=l(ce);Ms=r(ac,"A",{id:!0,class:!0,href:!0});var zv=l(Ms);pt=r(zv,"SPAN",{});var Dv=l(pt);j(dt.$$.fragment,Dv),Dv.forEach(t),zv.forEach(t),Oo=c(ac),ct=r(ac,"SPAN",{});var Tv=l(ct);Bo=a(Tv,"Traitement des donn\xE9es d'entra\xEEnement"),Tv.forEach(t),ac.forEach(t),ha=c(e),j(fs.$$.fragment,e),va=c(e),zs=r(e,"P",{});var oc=l(zs);Fo=a(oc,"Commen\xE7ons par le pr\xE9traitement des donn\xE9es d\u2019entra\xEEnement. La partie la plus difficile est de g\xE9n\xE9rer des \xE9tiquettes pour la r\xE9ponse \xE0 la question, c\u2019est-\xE0-dire les positions de d\xE9but et de fin des "),ge=r(oc,"EM",{});var Lv=l(ge);Io=a(Lv,"tokens"),Lv.forEach(t),Tn=a(oc," correspondant \xE0 la r\xE9ponse dans le contexte."),oc.forEach(t),ba=c(e),Ds=r(e,"P",{});var rc=l(Ds);Ln=a(rc,"Mais ne nous emballons pas. Tout d\u2019abord, \xE0 l\u2019aide d\u2019un "),Nn=r(rc,"EM",{});var Nv=l(Nn);Vo=a(Nv,"tokenizer"),Nv.forEach(t),On=a(rc,", nous devons convertir le texte d\u2019entr\xE9e en identifiants que le mod\xE8le peut comprendre :"),rc.forEach(t),ga=c(e),j(mt.$$.fragment,e),en=c(e),ne=r(e,"P",{});var Ne=l(ne);Ho=a(Ne,"Comme mentionn\xE9 pr\xE9c\xE9demment, nous allons "),sn=r(Ne,"EM",{});var Ov=l(sn);tn=a(Ov,"finetuner"),Ov.forEach(t),Uo=a(Ne," un mod\xE8le BERT, mais vous pouvez utiliser n\u2019importe quel autre type de mod\xE8le tant qu\u2019il a un "),nn=r(Ne,"EM",{});var Bv=l(nn);ft=a(Bv,"tokenizer"),Bv.forEach(t),qa=a(Ne," rapide impl\xE9ment\xE9. Vous pouvez voir toutes les architectures qui sont livr\xE9es avec un "),Xe=r(Ne,"EM",{});var Fv=l(Xe);Ro=a(Fv,"tokenizer"),Fv.forEach(t),Bn=a(Ne," rapide dans "),_t=r(Ne,"A",{href:!0,rel:!0});var Iv=l(_t);Qo=a(Iv,"ce tableau"),Iv.forEach(t),xa=a(Ne,", et pour v\xE9rifier que l\u2019objet "),_s=r(Ne,"CODE",{});var Vv=l(_s);$a=a(Vv,"tokenizer"),Vv.forEach(t),ae=a(Ne," que vous utilisez est bien soutenu par \u{1F917} "),Fn=r(Ne,"EM",{});var Hv=l(Fn);In=a(Hv,"Tokenizers"),Hv.forEach(t),Go=a(Ne," vous pouvez regarder son attribut "),Vn=r(Ne,"CODE",{});var Uv=l(Vn);Hn=a(Uv,"is_fast"),Uv.forEach(t),Wo=a(Ne," :"),Ne.forEach(t),wa=c(e),j(hs.$$.fragment,e),ja=c(e),j(ht.$$.fragment,e),an=c(e),Ke=r(e,"P",{});var xi=l(Ke);Jo=a(xi,"Nous pouvons transmettre \xE0 notre "),vt=r(xi,"EM",{});var Rv=l(vt);Xo=a(Rv,"tokenizer"),Rv.forEach(t),Ko=a(xi," la question et le contexte ensemble. Il ins\xE9rera correctement les "),bt=r(xi,"EM",{});var Qv=l(bt);Yo=a(Qv,"tokens"),Qv.forEach(t),Zo=a(xi," sp\xE9ciaux pour former une phrase comme celle-ci :"),xi.forEach(t),on=c(e),j(gt.$$.fragment,e),Ea=c(e),qt=r(e,"P",{});var Gv=l(qt);Ye=a(Gv,"V\xE9rifions \xE0 nouveau :"),Gv.forEach(t),ka=c(e),j(vs.$$.fragment,e),ya=c(e),j(xt.$$.fragment,e),Ts=c(e),Se=r(e,"P",{});var $i=l(Se);er=a($i,"Les \xE9tiquettes sont l\u2019index des "),Un=r($i,"EM",{});var Wv=l(Un);Ca=a(Wv,"tokens"),Wv.forEach(t),m=a($i," de d\xE9but et de fin de la r\xE9ponse. Le mod\xE8le sera charg\xE9 de pr\xE9dire dans l\u2019entr\xE9e un logit de d\xE9but et de fin par "),B=r($i,"EM",{});var Jv=l(B);il=a(Jv,"token"),Jv.forEach(t),Pa=a($i,", les \xE9tiquettes th\xE9oriques \xE9tant les suivantes :"),$i.forEach(t),sr=c(e),Ls=r(e,"DIV",{class:!0});var lc=l(Ls);rn=r(lc,"IMG",{class:!0,src:!0,alt:!0}),ul=c(lc),ln=r(lc,"IMG",{class:!0,src:!0,alt:!0}),lc.forEach(t),nr=c(e),bs=r(e,"P",{});var wi=l(bs);pl=a(wi,"Dans ce cas, le contexte n\u2019est pas trop long, mais certains des exemples du jeu de donn\xE9es ont des contextes tr\xE8s longs qui d\xE9passeront la longueur maximale que nous avons fix\xE9e (qui est de 384 dans ce cas). Comme nous l\u2019avons vu dans le "),qe=r(wi,"A",{href:!0});var Xv=l(qe);dl=a(Xv,"chapitre 6"),Xv.forEach(t),cl=a(wi," lorsque nous avons explor\xE9 le pipeline de "),Aa=r(wi,"CODE",{});var Kv=l(Aa);ml=a(Kv,"question-answering"),Kv.forEach(t),fl=a(wi,", nous allons traiter les contextes longs en cr\xE9ant plusieurs caract\xE9ristiques d\u2019entra\xEEnement \xE0 partir d\u2019un \xE9chantillon de notre jeu de donn\xE9es et avec une fen\xEAtre glissante entre eux."),wi.forEach(t),Qn=c(e),$t=r(e,"P",{});var ic=l($t);Sa=a(ic,"Pour voir comment cela fonctionne sur notre exemple, nous pouvons limiter la longueur \xE0 100 et utiliser une fen\xEAtre glissante de 50 "),Ma=r(ic,"EM",{});var Yv=l(Ma);fe=a(Yv,"tokens"),Yv.forEach(t),_l=a(ic,". Pour rappel, nous utilisons :"),ic.forEach(t),ar=c(e),Be=r(e,"UL",{});var lo=l(Be);Gn=r(lo,"LI",{});var Ih=l(Gn);za=r(Ih,"CODE",{});var Zv=l(za);hl=a(Zv,"max_length"),Zv.forEach(t),vl=a(Ih," pour d\xE9finir la longueur maximale (ici 100)"),Ih.forEach(t),un=c(lo),Wn=r(lo,"LI",{});var Vh=l(Wn);Da=r(Vh,"CODE",{});var eb=l(Da);Me=a(eb,'truncation="only_second"'),eb.forEach(t),bl=a(Vh," pour tronquer le contexte (qui est en deuxi\xE8me position) quand la question avec son contexte est trop longue"),Vh.forEach(t),gl=c(lo),wt=r(lo,"LI",{});var fp=l(wt);Ta=r(fp,"CODE",{});var sb=l(Ta);ql=a(sb,"stride"),sb.forEach(t),xl=a(fp," pour fixer le nombre de "),Ns=r(fp,"EM",{});var tb=l(Ns);$l=a(tb,"tokens"),tb.forEach(t),wl=a(fp," se chevauchant entre deux morceaux successifs (ici 50)"),fp.forEach(t),La=c(lo),gs=r(lo,"LI",{});var ll=l(gs);Na=r(ll,"CODE",{});var nb=l(Na);jl=a(nb,"return_overflowing_tokens=True"),nb.forEach(t),El=a(ll," pour indiquer au "),Os=r(ll,"EM",{});var ab=l(Os);Oa=a(ab,"tokenizer"),ab.forEach(t),kl=a(ll," que l\u2019on veut les "),Ze=r(ll,"EM",{});var ob=l(Ze);yl=a(ob,"tokens"),ob.forEach(t),Cl=a(ll," qui d\xE9bordent"),ll.forEach(t),lo.forEach(t),or=c(e),j(Ee.$$.fragment,e),rr=c(e),j(pn.$$.fragment,e),lr=c(e),xe=r(e,"P",{});var Us=l(xe);Pl=a(Us,"Comme nous pouvons le voir, notre exemple a \xE9t\xE9 divis\xE9 en quatre entr\xE9es, chacune d\u2019entre elles contenant la question et une partie du contexte. Notez que la r\xE9ponse \xE0 la question (\xAB Bernadette Soubirous \xBB) n\u2019appara\xEEt que dans la troisi\xE8me et la derni\xE8re entr\xE9e. Donc en traitant les longs contextes de cette fa\xE7on, nous allons cr\xE9er quelques exemples d\u2019entra\xEEnement o\xF9 la r\xE9ponse n\u2019est pas incluse dans le contexte. Pour ces exemples, les \xE9tiquettes seront "),dn=r(Us,"CODE",{});var rb=l(dn);Al=a(rb,"start_position = end_position = 0"),rb.forEach(t),_e=a(Us," (donc nous pr\xE9disons le "),Ba=r(Us,"EM",{});var lb=l(Ba);Sl=a(lb,"token"),lb.forEach(t),Ml=c(Us),Fa=r(Us,"CODE",{});var ib=l(Fa);zl=a(ib,"[CLS]"),ib.forEach(t),Dl=a(Us,"). Nous d\xE9finirons \xE9galement ces \xE9tiquettes dans le cas malheureux o\xF9 la r\xE9ponse a \xE9t\xE9 tronqu\xE9e de sorte que nous n\u2019avons que le d\xE9but (ou la fin) de celle-ci. Pour les exemples o\xF9 la r\xE9ponse est enti\xE8rement dans le contexte, les \xE9tiquettes seront l\u2019index du "),Ia=r(Us,"EM",{});var ub=l(Ia);cn=a(ub,"token"),ub.forEach(t),Tl=a(Us," o\xF9 la r\xE9ponse commence et l\u2019index du "),Va=r(Us,"EM",{});var pb=l(Va);Ll=a(pb,"token"),pb.forEach(t),Pc=a(Us," o\xF9 la r\xE9ponse se termine."),Us.forEach(t),_p=c(e),ze=r(e,"P",{});var Rs=l(ze);Ac=a(Rs,"Le jeu de donn\xE9es nous fournit le caract\xE8re de d\xE9but de la r\xE9ponse dans le contexte, et en ajoutant la longueur de la r\xE9ponse, nous pouvons trouver le caract\xE8re de fin dans le contexte. Pour faire correspondre ces indices aux "),Si=r(Rs,"EM",{});var db=l(Si);Sc=a(db,"tokens"),db.forEach(t),Mc=a(Rs,", nous devrons utiliser les correspondances "),Mi=r(Rs,"EM",{});var cb=l(Mi);zc=a(cb,"offset"),cb.forEach(t),Dc=a(Rs," que nous avons \xE9tudi\xE9s au "),Nl=r(Rs,"A",{href:!0});var mb=l(Nl);Tc=a(mb,"chapitre 6"),mb.forEach(t),Lc=a(Rs,". Nous pouvons faire en sorte que notre "),zi=r(Rs,"EM",{});var fb=l(zi);Nc=a(fb,"tokenizer"),fb.forEach(t),Oc=a(Rs," renvoie ces index en passant "),Di=r(Rs,"CODE",{});var _b=l(Di);Bc=a(_b,"return_offsets_mapping=True"),_b.forEach(t),Fc=a(Rs," :"),Rs.forEach(t),hp=c(e),j(ir.$$.fragment,e),vp=c(e),j(ur.$$.fragment,e),bp=c(e),De=r(e,"P",{});var Qs=l(De);Ic=a(Qs,"Comme nous pouvons le voir, nous r\xE9cup\xE9rons les identifiants d\u2019entr\xE9e, les "),Ti=r(Qs,"EM",{});var hb=l(Ti);Vc=a(hb,"tokens"),hb.forEach(t),Hc=a(Qs," de type identifiant, le masque d\u2019attention, ainsi que la correspondance "),Li=r(Qs,"EM",{});var vb=l(Li);Uc=a(vb,"offset"),vb.forEach(t),Rc=a(Qs," dont nous avions besoin et une cl\xE9 suppl\xE9mentaire, "),Ni=r(Qs,"CODE",{});var bb=l(Ni);Qc=a(bb,"overflow_to_sample_mapping"),bb.forEach(t),Gc=a(Qs,". La valeur correspondante nous sera utile lorsque nous tokeniserons plusieurs textes en m\xEAme temps (ce que nous devrions faire pour b\xE9n\xE9ficier du fait que notre "),Oi=r(Qs,"EM",{});var gb=l(Oi);Wc=a(gb,"tokenizer"),gb.forEach(t),Jc=a(Qs," est en Rust). Puisqu\u2019un \xE9chantillon peut donner plusieurs caract\xE9ristiques, il fait correspondre chaque caract\xE9ristique \xE0 l\u2019exemple d\u2019o\xF9 elle provient. Parce qu\u2019ici nous avons seulement tokenis\xE9 un exemple, nous obtenons une liste de "),Bi=r(Qs,"CODE",{});var qb=l(Bi);Xc=a(qb,"0"),qb.forEach(t),Kc=a(Qs," :"),Qs.forEach(t),gp=c(e),j(pr.$$.fragment,e),qp=c(e),j(dr.$$.fragment,e),xp=c(e),Ol=r(e,"P",{});var xb=l(Ol);Yc=a(xb,"Mais si nous tokenisons davantage d\u2019exemples, cela deviendra plus utile :"),xb.forEach(t),$p=c(e),j(cr.$$.fragment,e),wp=c(e),j(mr.$$.fragment,e),jp=c(e),Bl=r(e,"P",{});var $b=l(Bl);Zc=a($b,"Comme nous pouvons le voir, les trois premiers exemples (aux indices 2, 3 et 4 de l\u2019ensemble d\u2019entra\xEEnement) ont chacun donn\xE9 quatre caract\xE9ristiques et le dernier exemple (\xE0 l\u2019indice 5 de l\u2019ensemble d\u2019entra\xEEnement) a donn\xE9 7 caract\xE9ristiques."),$b.forEach(t),Ep=c(e),Fl=r(e,"P",{});var wb=l(Fl);em=a(wb,"Ces informations seront utiles pour associer chaque caract\xE9ristique obtenue \xE0 son \xE9tiquette correspondante. Comme mentionn\xE9 pr\xE9c\xE9demment, ces \xE9tiquettes sont :"),wb.forEach(t),kp=c(e),Ha=r(e,"UL",{});var uc=l(Ha);Il=r(uc,"LI",{});var Hh=l(Il);Fi=r(Hh,"CODE",{});var jb=l(Fi);sm=a(jb,"(0, 0)"),jb.forEach(t),tm=a(Hh," si la r\xE9ponse n\u2019est pas dans l\u2019espace correspondant du contexte."),Hh.forEach(t),nm=c(uc),es=r(uc,"LI",{});var Ot=l(es);Ii=r(Ot,"CODE",{});var Eb=l(Ii);am=a(Eb,"(start_position, end_position)"),Eb.forEach(t),om=a(Ot," si la r\xE9ponse est dans l\u2019espace correspondant du contexte, avec "),Vi=r(Ot,"CODE",{});var kb=l(Vi);rm=a(kb,"start_position"),kb.forEach(t),lm=a(Ot," \xE9tant l\u2019index du "),Hi=r(Ot,"EM",{});var yb=l(Hi);im=a(yb,"token"),yb.forEach(t),um=a(Ot," (dans les identifiants d\u2019entr\xE9e) au d\xE9but de la r\xE9ponse et "),Ui=r(Ot,"CODE",{});var Cb=l(Ui);pm=a(Cb,"end_position"),Cb.forEach(t),dm=a(Ot," \xE9tant l\u2019index du "),Ri=r(Ot,"EM",{});var Pb=l(Ri);cm=a(Pb,"token"),Pb.forEach(t),mm=a(Ot," (dans les identifiants d\u2019entr\xE9e) o\xF9 la r\xE9ponse se termine."),Ot.forEach(t),uc.forEach(t),yp=c(e),Te=r(e,"P",{});var Gs=l(Te);fm=a(Gs,"Pour d\xE9terminer ce qui est le cas et, le cas \xE9ch\xE9ant, les positions des "),Qi=r(Gs,"EM",{});var Ab=l(Qi);_m=a(Ab,"tokens"),Ab.forEach(t),hm=a(Gs,", nous trouvons d\u2019abord les indices qui commencent et finissent le contexte dans les identifiants d\u2019entr\xE9e. Nous pourrions utiliser les "),Gi=r(Gs,"EM",{});var Sb=l(Gi);vm=a(Sb,"tokens"),Sb.forEach(t),bm=a(Gs," de type identifiants pour le faire, mais puisque ceux-ci n\u2019existent pas n\xE9cessairement pour tous les mod\xE8les (DistilBERT ne les requiert pas par exemple), nous allons plut\xF4t utiliser la m\xE9thode "),Wi=r(Gs,"CODE",{});var Mb=l(Wi);gm=a(Mb,"sequence_ids()"),Mb.forEach(t),qm=a(Gs," du "),Ji=r(Gs,"CODE",{});var zb=l(Ji);xm=a(zb,"BatchEncoding"),zb.forEach(t),$m=a(Gs," que notre "),Xi=r(Gs,"EM",{});var Db=l(Xi);wm=a(Db,"tokenizer"),Db.forEach(t),jm=a(Gs," retourne."),Gs.forEach(t),Cp=c(e),Le=r(e,"P",{});var Ws=l(Le);Em=a(Ws,"Une fois que nous avons ces indices de "),Ki=r(Ws,"EM",{});var Tb=l(Ki);km=a(Tb,"tokens"),Tb.forEach(t),ym=a(Ws,", nous regardons les "),Yi=r(Ws,"EM",{});var Lb=l(Yi);Cm=a(Lb,"offsets"),Lb.forEach(t),Pm=a(Ws," correspondants, qui sont des "),Zi=r(Ws,"EM",{});var Nb=l(Zi);Am=a(Nb,"tuples"),Nb.forEach(t),Sm=a(Ws," de deux entiers repr\xE9sentant l\u2019\xE9tendue des caract\xE8res dans le contexte original. Nous pouvons ainsi d\xE9tecter si le morceau de contexte dans cette fonctionnalit\xE9 commence apr\xE8s la r\xE9ponse ou se termine avant que la r\xE9ponse ne commence (dans ce cas, l\u2019\xE9tiquette est "),eu=r(Ws,"CODE",{});var Ob=l(eu);Mm=a(Ob,"(0, 0)"),Ob.forEach(t),zm=a(Ws,"). Si ce n\u2019est pas le cas, nous bouclons pour trouver le premier et le dernier "),su=r(Ws,"EM",{});var Bb=l(su);Dm=a(Bb,"token"),Bb.forEach(t),Tm=a(Ws," de la r\xE9ponse :"),Ws.forEach(t),Pp=c(e),j(fr.$$.fragment,e),Ap=c(e),j(_r.$$.fragment,e),Sp=c(e),mn=r(e,"P",{});var ji=l(mn);Lm=a(ji,"Jetons un coup d\u2019\u0153il  \xE0 quelques r\xE9sultats pour v\xE9rifier que notre approche est correcte. Pour la premi\xE8re caract\xE9ristique, nous trouvons "),tu=r(ji,"CODE",{});var Fb=l(tu);Nm=a(Fb,"(83, 85)"),Fb.forEach(t),Om=a(ji," comme \xE9tiquettes. Comparons alors la r\xE9ponse th\xE9orique avec l\u2019\xE9tendue d\xE9cod\xE9e des "),nu=r(ji,"EM",{});var Ib=l(nu);Bm=a(Ib,"tokens"),Ib.forEach(t),Fm=a(ji," de 83 \xE0 85 (inclus) :"),ji.forEach(t),Mp=c(e),j(hr.$$.fragment,e),zp=c(e),j(vr.$$.fragment,e),Dp=c(e),Ua=r(e,"P",{});var pc=l(Ua);Im=a(pc,"Cela correspond ! Maintenant v\xE9rifions l\u2019index 4, o\xF9 nous avons mis les \xE9tiquettes \xE0 "),au=r(pc,"CODE",{});var Vb=l(au);Vm=a(Vb,"(0, 0)"),Vb.forEach(t),Hm=a(pc,", signifiant que la r\xE9ponse n\u2019est pas dans le morceau de contexte de cette caract\xE9ristique :"),pc.forEach(t),Tp=c(e),j(br.$$.fragment,e),Lp=c(e),j(gr.$$.fragment,e),Np=c(e),Vl=r(e,"P",{});var Hb=l(Vl);Um=a(Hb,"En effet, nous ne voyons pas la r\xE9ponse dans le contexte."),Hb.forEach(t),Op=c(e),j(Ra.$$.fragment,e),Bp=c(e),Hl=r(e,"P",{});var Ub=l(Hl);Rm=a(Ub,"Maintenant que nous avons vu \xE9tape par \xE9tape comment pr\xE9traiter nos donn\xE9es d\u2019entra\xEEnement, nous pouvons les regrouper dans une fonction que nous appliquerons \xE0 l\u2019ensemble des donn\xE9es d\u2019entra\xEEnement. Nous allons rembourrer chaque caract\xE9ristique \xE0 la longueur maximale que nous avons d\xE9finie, car la plupart des contextes seront longs (et les \xE9chantillons correspondants seront divis\xE9s en plusieurs caract\xE9ristiques). Il n\u2019y a donc pas de r\xE9el avantage \xE0 appliquer un rembourrage dynamique ici :"),Ub.forEach(t),Fp=c(e),j(qr.$$.fragment,e),Ip=c(e),Ul=r(e,"P",{});var Rb=l(Ul);Qm=a(Rb,"Notez que nous avons d\xE9fini deux constantes pour d\xE9terminer la longueur maximale utilis\xE9e ainsi que la longueur de la fen\xEAtre glissante, et que nous avons ajout\xE9 un petit nettoyage avant la tok\xE9nisation : certaines des questions dans SQuAD ont des espaces suppl\xE9mentaires au d\xE9but et \xE0 la fin qui n\u2019ajoutent rien (et prennent de la place lors de la tok\xE9nisation si vous utilisez un mod\xE8le comme RoBERTa), donc nous avons supprim\xE9 ces espaces suppl\xE9mentaires."),Rb.forEach(t),Vp=c(e),fn=r(e,"P",{});var Ei=l(fn);Gm=a(Ei,"Pour appliquer cette fonction \xE0 l\u2019ensemble de l\u2019entra\xEEnement, nous utilisons la m\xE9thode "),ou=r(Ei,"CODE",{});var Qb=l(ou);Wm=a(Qb,"Dataset.map()"),Qb.forEach(t),Jm=a(Ei," avec le flag "),ru=r(Ei,"CODE",{});var Gb=l(ru);Xm=a(Gb,"batched=True"),Gb.forEach(t),Km=a(Ei,". C\u2019est n\xE9cessaire ici car nous changeons la longueur du jeu de donn\xE9es (puisqu\u2019un exemple peut donner plusieurs caract\xE9ristiques d\u2019entra\xEEnement) :"),Ei.forEach(t),Hp=c(e),j(xr.$$.fragment,e),Up=c(e),j($r.$$.fragment,e),Rp=c(e),Rl=r(e,"P",{});var Wb=l(Rl);Ym=a(Wb,"Comme nous pouvons le voir, le pr\xE9traitement a ajout\xE9 environ 1 000 caract\xE9ristiques. Notre ensemble d\u2019entra\xEEnement est maintenant pr\xEAt \xE0 \xEAtre utilis\xE9. Passons au pr\xE9traitement de l\u2019ensemble de validation !"),Wb.forEach(t),Qp=c(e),Jn=r(e,"H3",{class:!0});var dc=l(Jn);Qa=r(dc,"A",{id:!0,class:!0,href:!0});var Jb=l(Qa);lu=r(Jb,"SPAN",{});var Xb=l(lu);j(wr.$$.fragment,Xb),Xb.forEach(t),Jb.forEach(t),Zm=c(dc),iu=r(dc,"SPAN",{});var Kb=l(iu);ef=a(Kb,"Traitement des donn\xE9es de validation"),Kb.forEach(t),dc.forEach(t),Gp=c(e),Ga=r(e,"P",{});var cc=l(Ga);sf=a(cc,"Le pr\xE9traitement des donn\xE9es de validation sera l\xE9g\xE8rement plus facile car nous n\u2019avons pas besoin de g\xE9n\xE9rer des \xE9tiquettes (sauf si nous voulons calculer une perte de validation, mais elle ne nous aidera pas vraiment \xE0 comprendre la qualit\xE9 du mod\xE8le). Le r\xE9el plaisir sera d\u2019interpr\xE9ter les pr\xE9dictions du mod\xE8le dans des \xE9tendues du contexte original. Pour cela, il nous suffit de stocker les correspondances d\u2019"),uu=r(cc,"EM",{});var Yb=l(uu);tf=a(Yb,"offset"),Yb.forEach(t),nf=a(cc," et un moyen de faire correspondre chaque caract\xE9ristique cr\xE9\xE9e \xE0 l\u2019exemple original dont elle provient. Puisqu\u2019il y a une colonne identifiant dans le jeu de donn\xE9es original, nous l\u2019utiliserons."),cc.forEach(t),Wp=c(e),ke=r(e,"P",{});var rs=l(ke);af=a(rs,"La seule chose que nous allons ajouter ici est un petit nettoyage des correspondances d\u2019"),pu=r(rs,"EM",{});var Zb=l(pu);of=a(Zb,"offset"),Zb.forEach(t),rf=a(rs,". Elles contiendront les "),du=r(rs,"EM",{});var eg=l(du);lf=a(eg,"offsets"),eg.forEach(t),uf=a(rs," pour la question et le contexte, mais une fois que nous serons \xE0 la phase de post-traitement, nous n\u2019aurons aucun moyen de savoir quelle partie des identifiants d\u2019entr\xE9e correspondait au contexte et quelle partie \xE9tait la question (la m\xE9thode "),cu=r(rs,"CODE",{});var sg=l(cu);pf=a(sg,"sequence_ids()"),sg.forEach(t),df=a(rs," que nous avons utilis\xE9e n\u2019est disponible que pour la sortie du "),mu=r(rs,"EM",{});var tg=l(mu);cf=a(tg,"tokenizer"),tg.forEach(t),mf=a(rs,"). Donc, nous allons mettre les "),fu=r(rs,"EM",{});var ng=l(fu);ff=a(ng,"offsets"),ng.forEach(t),_f=a(rs," correspondant \xE0 la question \xE0 "),_u=r(rs,"CODE",{});var ag=l(_u);hf=a(ag,"None"),ag.forEach(t),vf=a(rs," :"),rs.forEach(t),Jp=c(e),j(jr.$$.fragment,e),Xp=c(e),Ql=r(e,"P",{});var og=l(Ql);bf=a(og,"Nous pouvons appliquer cette fonction sur l\u2019ensemble de validation comme pr\xE9c\xE9demment :"),og.forEach(t),Kp=c(e),j(Er.$$.fragment,e),Yp=c(e),j(kr.$$.fragment,e),Zp=c(e),Gl=r(e,"P",{});var rg=l(Gl);gf=a(rg,"Dans ce cas, nous n\u2019avons ajout\xE9 que quelques centaines d\u2019\xE9chantillons, il semble donc que les contextes dans l\u2019ensemble de validation soient un peu plus courts."),rg.forEach(t),ed=c(e),Wl=r(e,"P",{});var lg=l(Wl);qf=a(lg,"Maintenant que nous avons pr\xE9trait\xE9 toutes les donn\xE9es, nous pouvons passer \xE0 l\u2019entra\xEEnement."),lg.forEach(t),sd=c(e),Et.l(e),Jl=c(e),Xn=r(e,"H3",{class:!0});var mc=l(Xn);Wa=r(mc,"A",{id:!0,class:!0,href:!0});var ig=l(Wa);hu=r(ig,"SPAN",{});var ug=l(hu);j(yr.$$.fragment,ug),ug.forEach(t),ig.forEach(t),xf=c(mc),vu=r(mc,"SPAN",{});var pg=l(vu);$f=a(pg,"Post-traitement"),pg.forEach(t),mc.forEach(t),td=c(e),yt.l(e),Xl=c(e),_n=r(e,"P",{});var ki=l(_n);wf=a(ki,"Le mod\xE8le produira des logits pour les positions de d\xE9but et de fin de la r\xE9ponse dans les identifiants d\u2019entr\xE9e, comme nous l\u2019avons vu lors de notre exploration du pipeline de "),bu=r(ki,"CODE",{});var dg=l(bu);jf=a(dg,"question-answering"),dg.forEach(t),Ef=c(ki),Kl=r(ki,"A",{href:!0});var cg=l(Kl);kf=a(cg,"au chapitre 6"),cg.forEach(t),yf=a(ki,". L\u2019\xE9tape de post-traitement sera similaire \xE0 ce que nous avons fait \xE0 ce chapitre l\xE0. Voici un rapide rappel des actions que nous avons prises :"),ki.forEach(t),nd=c(e),Bs=r(e,"UL",{});var io=l(Bs);Cr=r(io,"LI",{});var fc=l(Cr);Cf=a(fc,"nous avons masqu\xE9 les logits de d\xE9but et de fin correspondant aux "),gu=r(fc,"EM",{});var mg=l(gu);Pf=a(mg,"tokens"),mg.forEach(t),Af=a(fc," en dehors du contexte,"),fc.forEach(t),Sf=c(io),qu=r(io,"LI",{});var fg=l(qu);Mf=a(fg,"nous avons ensuite converti les logits de d\xE9but et de fin en probabilit\xE9s en utilisant une fonction SoftMax,"),fg.forEach(t),zf=c(io),Pr=r(io,"LI",{});var _c=l(Pr);Df=a(_c,"nous avons attribu\xE9 un score \xE0 chaque paire "),xu=r(_c,"CODE",{});var _g=l(xu);Tf=a(_g,"(start_token, end_token)"),_g.forEach(t),Lf=a(_c," en prenant le produit des deux probabilit\xE9s correspondantes,"),_c.forEach(t),Nf=c(io),Kn=r(io,"LI",{});var yi=l(Kn);Of=a(yi,"nous avons cherch\xE9 la paire avec le score maximum qui donnait une r\xE9ponse valide (par exemple, un "),$u=r(yi,"CODE",{});var hg=l($u);Bf=a(hg,"start_token"),hg.forEach(t),Ff=a(yi," inf\xE9rieur au "),wu=r(yi,"CODE",{});var vg=l(wu);If=a(vg,"end_token"),vg.forEach(t),Vf=a(yi,")."),yi.forEach(t),io.forEach(t),ad=c(e),ss=r(e,"P",{});var gn=l(ss);Hf=a(gn,"Ici, nous allons modifier l\xE9g\xE8rement ce processus car nous n\u2019avons pas besoin de calculer les scores r\xE9els (juste la r\xE9ponse pr\xE9dite). Cela signifie que nous pouvons sauter l\u2019\xE9tape de la SoftMax. Pour aller plus vite, nous ne donnerons pas non plus un score \xE0 toutes les paires "),ju=r(gn,"CODE",{});var bg=l(ju);Uf=a(bg,"(start_token, end_token)"),bg.forEach(t),Rf=a(gn," possibles, mais seulement celles correspondant aux "),Eu=r(gn,"CODE",{});var gg=l(Eu);Qf=a(gg,"n_best"),gg.forEach(t),Gf=a(gn," logits les plus \xE9lev\xE9s (avec "),ku=r(gn,"CODE",{});var qg=l(ku);Wf=a(qg,"n_best=20"),qg.forEach(t),Jf=a(gn,"). Puisque nous sautons la SoftMax, les scores seront des scores logi, et seront obtenus en prenant la somme des logits de d\xE9but et de fin (au lieu du produit, \xE0 cause de la r\xE8gle "),od=jq(gn),rd=a(gn,")."),gn.forEach(t),ld=c(e),Fs=r(e,"P",{});var uo=l(Fs);Xf=a(uo,"Pour d\xE9montrer tout cela, nous aurons besoin d\u2019un certain type de pr\xE9dictions. Puisque nous n\u2019avons pas encore entra\xEEn\xE9 notre mod\xE8le, nous allons utiliser le mod\xE8le par d\xE9faut du pipeline de "),yu=r(uo,"CODE",{});var xg=l(yu);Kf=a(xg,"question-answering"),xg.forEach(t),Yf=a(uo," pour g\xE9n\xE9rer quelques pr\xE9dictions sur une petite partie de l\u2019ensemble de validation. Nous pouvons utiliser la m\xEAme fonction de traitement que pr\xE9c\xE9demment car elle repose sur la constante globale "),Cu=r(uo,"CODE",{});var $g=l(Cu);Zf=a($g,"tokenizer"),$g.forEach(t),e_=a(uo,", nous devons juste changer cet objet par le "),Pu=r(uo,"EM",{});var wg=l(Pu);s_=a(wg,"tokenizer"),wg.forEach(t),t_=a(uo," du mod\xE8le que nous voulons utiliser temporairement :"),uo.forEach(t),id=c(e),j(Ar.$$.fragment,e),ud=c(e),Ja=r(e,"P",{});var hc=l(Ja);n_=a(hc,"Maintenant que le pr\xE9traitement est termin\xE9, nous changeons le "),Au=r(hc,"EM",{});var jg=l(Au);a_=a(jg,"tokenizer"),jg.forEach(t),o_=a(hc," pour celui que nous avons choisi \xE0 l\u2019origine :"),hc.forEach(t),pd=c(e),j(Sr.$$.fragment,e),dd=c(e),Xa=r(e,"P",{});var vc=l(Xa);r_=a(vc,"Nous supprimons ensuite les colonnes de notre "),Su=r(vc,"CODE",{});var Eg=l(Su);l_=a(Eg,"eval_set"),Eg.forEach(t),i_=a(vc," qui ne sont pas attendues par le mod\xE8le. Nous construisons un batch avec tout de ce petit ensemble de validation et le passons au mod\xE8le. Si un GPU est disponible, nous l\u2019utilisons pour aller plus vite :"),vc.forEach(t),cd=c(e),Pt.l(e),Yl=c(e),ts=r(e,"P",{});var qn=l(ts);u_=a(qn,"Maintenant, nous devons trouver la r\xE9ponse pr\xE9dite pour chaque exemple dans notre "),Mu=r(qn,"CODE",{});var kg=l(Mu);p_=a(kg,"small_eval_set"),kg.forEach(t),d_=a(qn,". Un exemple peut avoir \xE9t\xE9 divis\xE9 en plusieurs caract\xE9ristiques dans "),zu=r(qn,"CODE",{});var yg=l(zu);c_=a(yg,"eval_set"),yg.forEach(t),m_=a(qn,", donc la premi\xE8re \xE9tape est de faire correspondre chaque exemple dans "),Du=r(qn,"CODE",{});var Cg=l(Du);f_=a(Cg,"small_eval_set"),Cg.forEach(t),__=a(qn," aux caract\xE9ristiques correspondantes dans "),Tu=r(qn,"CODE",{});var Pg=l(Tu);h_=a(Pg,"eval_set"),Pg.forEach(t),v_=a(qn," :"),qn.forEach(t),md=c(e),j(Mr.$$.fragment,e),fd=c(e),Ka=r(e,"P",{});var bc=l(Ka);b_=a(bc,"Avec cela, nous pouvons vraiment nous mettre au travail en bouclant tous les exemples et, pour chaque exemple, toutes les caract\xE9ristiques associ\xE9es. Comme nous l\u2019avons dit pr\xE9c\xE9demment, nous allons regarder les scores logit pour les "),Lu=r(bc,"CODE",{});var Ag=l(Lu);g_=a(Ag,"n_best"),Ag.forEach(t),q_=a(bc," logits de d\xE9but et logits de fin, en excluant les positions qui donnent :"),bc.forEach(t),_d=c(e),hn=r(e,"UL",{});var Ci=l(hn);Nu=r(Ci,"LI",{});var Sg=l(Nu);x_=a(Sg,"une r\xE9ponse qui ne serait pas dans le contexte"),Sg.forEach(t),$_=c(Ci),Ou=r(Ci,"LI",{});var Mg=l(Ou);w_=a(Mg,"une r\xE9ponse avec une longueur n\xE9gative"),Mg.forEach(t),j_=c(Ci),zr=r(Ci,"LI",{});var gc=l(zr);E_=a(gc,"une r\xE9ponse qui est trop longue (nous limitons les possibilit\xE9s \xE0 "),Bu=r(gc,"CODE",{});var zg=l(Bu);k_=a(zg,"max_answer_length=30"),zg.forEach(t),y_=a(gc,")"),gc.forEach(t),Ci.forEach(t),hd=c(e),Zl=r(e,"P",{});var Dg=l(Zl);C_=a(Dg,"Une fois que nous avons toutes les r\xE9ponses possibles not\xE9es pour un exemple, nous choisissons simplement celle qui a le meilleur score logit :"),Dg.forEach(t),vd=c(e),j(Dr.$$.fragment,e),bd=c(e),Ya=r(e,"P",{});var qc=l(Ya);P_=a(qc,"Le format final des r\xE9ponses pr\xE9dites est celui qui sera attendu par la m\xE9trique que nous allons utiliser. Comme d\u2019habitude, nous pouvons la charger \xE0 l\u2019aide de la biblioth\xE8que \u{1F917} "),Fu=r(qc,"EM",{});var Tg=l(Fu);A_=a(Tg,"Datasets"),Tg.forEach(t),S_=a(qc," :"),qc.forEach(t),gd=c(e),j(Tr.$$.fragment,e),qd=c(e),ei=r(e,"P",{});var Lg=l(ei);M_=a(Lg,"Cette m\xE9trique attend les r\xE9ponses pr\xE9dites dans le format que nous avons vu ci-dessus (une liste de dictionnaires avec une cl\xE9 pour l\u2019identifiant de l\u2019exemple et une cl\xE9 pour le texte pr\xE9dit) et les r\xE9ponses th\xE9oriques dans le format ci-dessous (une liste de dictionnaires avec une cl\xE9 pour l\u2019identifiant de l\u2019exemple et une cl\xE9 pour les r\xE9ponses possibles) :"),Lg.forEach(t),xd=c(e),j(Lr.$$.fragment,e),$d=c(e),si=r(e,"P",{});var Ng=l(si);z_=a(Ng,"Nous pouvons maintenant v\xE9rifier que nous obtenons des r\xE9sultats raisonnables en examinant le premier \xE9l\xE9ment des deux listes :"),Ng.forEach(t),wd=c(e),j(Nr.$$.fragment,e),jd=c(e),j(Or.$$.fragment,e),Ed=c(e),ti=r(e,"P",{});var Og=l(ti);D_=a(Og,"Pas trop mal ! Voyons maintenant le score que la m\xE9trique nous donne :"),Og.forEach(t),kd=c(e),j(Br.$$.fragment,e),yd=c(e),j(Fr.$$.fragment,e),Cd=c(e),vn=r(e,"P",{});var Pi=l(vn);T_=a(Pi,"Encore une fois, c\u2019est plut\xF4t bon si l\u2019on consid\xE8re que, d\u2019apr\xE8s "),Ir=r(Pi,"A",{href:!0,rel:!0});var Bg=l(Ir);L_=a(Bg,"le papier"),Bg.forEach(t),N_=a(Pi," de DistilBERT, "),Iu=r(Pi,"EM",{});var Fg=l(Iu);O_=a(Fg,"finetun\xE9"),Fg.forEach(t),B_=a(Pi," sur SQuAD, ce mod\xE8le obtient 79,1 et 86,9 pour ces scores sur l\u2019ensemble du jeu de donn\xE9es."),Pi.forEach(t),Pd=c(e),ea.l(e),ni=c(e),j(Vr.$$.fragment,e),Ad=c(e),ai=r(e,"P",{});var Ig=l(ai);F_=a(Ig,"Nous pouvons v\xE9rifier que cela fonctionne sur nos pr\xE9dictions :"),Ig.forEach(t),Sd=c(e),j(Hr.$$.fragment,e),Md=c(e),j(Ur.$$.fragment,e),zd=c(e),Za=r(e,"P",{});var xc=l(Za);I_=a(xc,"C\u2019est bien ! Maintenant, utilisons ceci pour "),Vu=r(xc,"EM",{});var Vg=l(Vu);V_=a(Vg,"finetuner"),Vg.forEach(t),H_=a(xc," notre mod\xE8le."),xc.forEach(t),Dd=c(e),Yn=r(e,"H3",{class:!0});var $c=l(Yn);eo=r($c,"A",{id:!0,class:!0,href:!0});var Hg=l(eo);Hu=r(Hg,"SPAN",{});var Ug=l(Hu);j(Rr.$$.fragment,Ug),Ug.forEach(t),Hg.forEach(t),U_=c($c),oi=r($c,"SPAN",{});var Uh=l(oi);Uu=r(Uh,"I",{});var Rg=l(Uu);R_=a(Rg,"Finetuning"),Rg.forEach(t),Q_=a(Uh," du mod\xE8le"),Uh.forEach(t),$c.forEach(t),Td=c(e),St.l(e),ri=c(e),so=r(e,"P",{});var wc=l(so);G_=a(wc,"Comme d\u2019habitude, nous recevons un avertissement indiquant que certains poids ne sont pas utilis\xE9s (ceux de la t\xEAte de pr\xE9-entra\xEEnement) et que d\u2019autres sont initialis\xE9s de mani\xE8re al\xE9atoire (ceux de la t\xEAte de r\xE9ponse aux questions). Vous devriez \xEAtre habitu\xE9 \xE0 cela maintenant, mais cela signifie que ce mod\xE8le n\u2019est pas encore pr\xEAt \xE0 \xEAtre utilis\xE9 et qu\u2019il a besoin d\u2019\xEAtre "),Ru=r(wc,"EM",{});var Qg=l(Ru);W_=a(Qg,"finetun\xE9"),Qg.forEach(t),J_=a(wc,". Une bonne chose que nous soyons sur le point de le faire !"),wc.forEach(t),Ld=c(e),Is=r(e,"P",{});var po=l(Is);X_=a(po,"Pour pouvoir pousser notre mod\xE8le vers le "),Qu=r(po,"EM",{});var Gg=l(Qu);K_=a(Gg,"Hub"),Gg.forEach(t),Y_=a(po,", nous devons nous connecter \xE0 Hugging Face. Si vous ex\xE9cutez ce code dans un "),Gu=r(po,"EM",{});var Wg=l(Gu);Z_=a(Wg,"notebook"),Wg.forEach(t),eh=a(po,", vous pouvez le faire avec la fonction utilitaire suivante, qui affiche un "),Wu=r(po,"EM",{});var Jg=l(Wu);sh=a(Jg,"widget"),Jg.forEach(t),th=a(po," o\xF9 vous pouvez entrer vos identifiants de connexion :"),po.forEach(t),Nd=c(e),j(Qr.$$.fragment,e),Od=c(e),to=r(e,"P",{});var jc=l(to);nh=a(jc,"Si vous ne travaillez pas dans un "),Ju=r(jc,"EM",{});var Xg=l(Ju);ah=a(Xg,"notebook"),Xg.forEach(t),oh=a(jc,", tapez simplement la ligne suivante dans votre terminal :"),jc.forEach(t),Bd=c(e),j(Gr.$$.fragment,e),Fd=c(e),zt.l(e),li=c(e),ns=r(e,"P",{});var xn=l(ns);rh=a(xn,"Par d\xE9faut, le d\xE9p\xF4t utilis\xE9 sera dans votre espace et nomm\xE9 apr\xE8s le r\xE9pertoire de sortie que vous avez d\xE9fini. Donc dans notre cas il sera dans "),Xu=r(xn,"CODE",{});var Kg=l(Xu);lh=a(Kg,'"sgugger/bert-finetuned-squad"'),Kg.forEach(t),ih=a(xn,". Nous pouvons passer outre en passant un "),Ku=r(xn,"CODE",{});var Yg=l(Ku);uh=a(Yg,"hub_model_id"),Yg.forEach(t),ph=a(xn,", par exemple, pour pousser le mod\xE8le dans l\u2019organisation "),Yu=r(xn,"CODE",{});var Zg=l(Yu);dh=a(Zg,"huggingface_course"),Zg.forEach(t),ch=a(xn," nous avons utilis\xE9 "),Zu=r(xn,"CODE",{});var eq=l(Zu);mh=a(eq,'hub_model_id= "huggingface_course/bert-finetuned-squad"'),eq.forEach(t),fh=a(xn," (qui est le mod\xE8le que nous avons li\xE9 au d\xE9but de cette section)."),xn.forEach(t),Id=c(e),Tt.l(e),ii=c(e),bn=r(e,"P",{});var Ai=l(bn);_h=a(Ai,"Notez que pendant l\u2019entra\xEEnement, chaque fois que le mod\xE8le est sauvegard\xE9 (ici, \xE0 chaque \xE9poque), il est t\xE9l\xE9charg\xE9 sur le "),ep=r(Ai,"EM",{});var sq=l(ep);hh=a(sq,"Hub"),sq.forEach(t),vh=a(Ai," en arri\xE8re-plan. Ainsi, vous pourrez reprendre votre entra\xEEnement sur une autre machine si n\xE9cessaire. L\u2019ensemble de l\u2019entra\xEEnement prend un certain temps (un peu plus d\u2019une heure sur une Titan RTX), vous pouvez donc prendre un caf\xE9 ou relire les parties du cours qui vous ont sembl\xE9 plus difficiles pendant qu\u2019il se d\xE9roule. Notez \xE9galement que d\xE8s que la premi\xE8re \xE9poque est termin\xE9e, vous verrez des poids t\xE9l\xE9charg\xE9s sur le "),sp=r(Ai,"EM",{});var tq=l(sp);bh=a(tq,"Hub"),tq.forEach(t),gh=a(Ai," et vous pourrez commencer \xE0 jouer avec votre mod\xE8le sur sa page."),Ai.forEach(t),Vd=c(e),Nt.l(e),ui=c(e),j(Wr.$$.fragment,e),Hd=c(e),pi=r(e,"P",{});var nq=l(pi);qh=a(nq,"Super ! \xC0 titre de comparaison, les scores indiqu\xE9s dans l\u2019article de BERT pour ce t\xE2che sont de 80,8 et 88,5. Donc nous sommes exactement l\xE0 o\xF9 nous devrions \xEAtre."),nq.forEach(t),Ud=c(e),$e&&$e.l(e),di=c(e),Vs=r(e,"P",{});var co=l(Vs);xh=a(co,"\xC0 ce stade, vous pouvez utiliser le "),tp=r(co,"EM",{});var aq=l(tp);$h=a(aq,"widget"),aq.forEach(t),wh=a(co," d\u2019inf\xE9rence sur le "),np=r(co,"EM",{});var oq=l(np);jh=a(oq,"Hub"),oq.forEach(t),Eh=a(co," du mod\xE8le pour tester le mod\xE8le et le partager avec vos amis, votre famille et vos animaux pr\xE9f\xE9r\xE9s. Vous avez r\xE9ussi \xE0 "),ap=r(co,"EM",{});var rq=l(ap);kh=a(rq,"finetuner"),rq.forEach(t),yh=a(co," un mod\xE8le sur une t\xE2che de r\xE9ponse \xE0 une question. F\xE9licitations !"),co.forEach(t),Rd=c(e),j(no.$$.fragment,e),Qd=c(e),we&&we.l(e),ci=c(e),Zn=r(e,"H3",{class:!0});var Ec=l(Zn);ao=r(Ec,"A",{id:!0,class:!0,href:!0});var lq=l(ao);op=r(lq,"SPAN",{});var iq=l(op);j(Jr.$$.fragment,iq),iq.forEach(t),lq.forEach(t),Ch=c(Ec),mi=r(Ec,"SPAN",{});var Rh=l(mi);Ph=a(Rh,"Utilisation du mod\xE8le "),rp=r(Rh,"I",{});var uq=l(rp);Ah=a(uq,"finetun\xE9"),uq.forEach(t),Rh.forEach(t),Ec.forEach(t),Gd=c(e),as=r(e,"P",{});var $n=l(as);Sh=a($n,"Nous vous avons d\xE9j\xE0 montr\xE9 comment vous pouvez utiliser le mod\xE8le que nous avons "),lp=r($n,"EM",{});var pq=l(lp);Mh=a(pq,"finetun\xE9"),pq.forEach(t),zh=a($n," sur le "),ip=r($n,"EM",{});var dq=l(ip);Dh=a(dq,"Hub"),dq.forEach(t),Th=a($n," avec le "),up=r($n,"EM",{});var cq=l(up);Lh=a(cq,"widget"),cq.forEach(t),Nh=a($n," d\u2019inf\xE9rence. Pour l\u2019utiliser localement dans un "),pp=r($n,"CODE",{});var mq=l(pp);Oh=a(mq,"pipeline"),mq.forEach(t),Bh=a($n,", il suffit de sp\xE9cifier l\u2019identifiant du mod\xE8le :"),$n.forEach(t),Wd=c(e),j(Xr.$$.fragment,e),Jd=c(e),j(Kr.$$.fragment,e),Xd=c(e),fi=r(e,"P",{});var fq=l(fi);Fh=a(fq,"Super ! Notre mod\xE8le fonctionne aussi bien que le mod\xE8le par d\xE9faut pour ce pipeline !"),fq.forEach(t),this.h()},h(){C(p,"name","hf:doc:metadata"),C(p,"content",JSON.stringify(Xq)),C(g,"id","rponse-aux-questions"),C(g,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),C(g,"href","#rponse-aux-questions"),C(S,"class","relative group"),C(X,"href","https://rajpurkar.github.io/SQuAD-explorer/"),C(X,"rel","nofollow"),kc(ie.src,xs="https://hf.space/gradioiframe/course-demos/bert-finetuned-squad/+")||C(ie,"src",xs),C(ie,"frameborder","0"),C(ie,"height","450"),C(ie,"title","Gradio app"),C(ie,"class","block dark:hidden container p-0 flex-grow space-iframe"),C(ie,"allow","accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking"),C(ie,"sandbox","allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"),kc(ue.src,$s="https://hf.space/gradioiframe/course-demos/bert-finetuned-squad-darkmode/+")||C(ue,"src",$s),C(ue,"frameborder","0"),C(ue,"height","450"),C(ue,"title","Gradio app"),C(ue,"class","hidden dark:block container p-0 flex-grow space-iframe"),C(ue,"allow","accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking"),C(ue,"sandbox","allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"),C(Ie,"href","https://huggingface.co/huggingface-course/bert-finetuned-squad?context=%F0%9F%A4%97+Transformers+is+backed+by+the+three+most+popular+deep+learning+libraries+%E2%80%94+Jax%2C+PyTorch+and+TensorFlow+%E2%80%94+with+a+seamless+integration+between+them.+It%27s+straightforward+to+train+your+models+with+one+before+loading+them+for+inference+with+the+other.&question=Which+deep+learning+libraries+back+%F0%9F%A4%97+Transformers%3F"),C(Ie,"rel","nofollow"),C(ve,"id","prparation-des-donnes"),C(ve,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),C(ve,"href","#prparation-des-donnes"),C(pe,"class","relative group"),C(is,"href","https://rajpurkar.github.io/SQuAD-explorer/"),C(is,"rel","nofollow"),C(ks,"href","https://huggingface.co/datasets/squad_v2"),C(ks,"rel","nofollow"),C(Qe,"id","le-jeu-de-donnes-squad"),C(Qe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),C(Qe,"href","#le-jeu-de-donnes-squad"),C(us,"class","relative group"),C(Ms,"id","traitement-des-donnes-dentranement"),C(Ms,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),C(Ms,"href","#traitement-des-donnes-dentranement"),C(ce,"class","relative group"),C(_t,"href","https://huggingface.co/transformers/#supported-frameworks"),C(_t,"rel","nofollow"),C(rn,"class","block dark:hidden"),kc(rn.src,Rn="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter7/qa_labels.svg")||C(rn,"src",Rn),C(rn,"alt","One-hot encoded labels for question answering."),C(ln,"class","hidden dark:block"),kc(ln.src,tr="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter7/qa_labels-dark.svg")||C(ln,"src",tr),C(ln,"alt","One-hot encoded labels for question answering."),C(Ls,"class","flex justify-center"),C(qe,"href","/course/fr/chapter6/4"),C(Nl,"href","/course/fr/chapter6/4"),C(Qa,"id","traitement-des-donnes-de-validation"),C(Qa,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),C(Qa,"href","#traitement-des-donnes-de-validation"),C(Jn,"class","relative group"),C(Wa,"id","posttraitement"),C(Wa,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),C(Wa,"href","#posttraitement"),C(Xn,"class","relative group"),C(Kl,"href","/course/fr/chapter6/3b"),od.a=rd,C(Ir,"href","https://arxiv.org/abs/1910.01108v2"),C(Ir,"rel","nofollow"),C(eo,"id","ifinetuningi-du-modle"),C(eo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),C(eo,"href","#ifinetuningi-du-modle"),C(Yn,"class","relative group"),C(ao,"id","utilisation-du-modle-ifinetuni"),C(ao,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),C(ao,"href","#utilisation-du-modle-ifinetuni"),C(Zn,"class","relative group")},m(e,u){s(document.head,p),i(e,b,u),E(f,e,u),i(e,y,u),i(e,S,u),s(S,g),s(g,q),E(x,q,null),s(S,_),s(S,M),s(M,$),i(e,A,u),Yr[T].m(e,u),i(e,D,u),i(e,P,u),s(P,V),s(P,L),s(L,O),s(P,N),i(e,U,u),E(Q,e,u),i(e,J,u),i(e,H,u),s(H,G),s(H,ee),s(ee,Z),s(H,F),s(H,X),s(X,re),s(H,se),s(H,K),s(K,le),s(H,Ce),i(e,ye,u),i(e,ie,u),i(e,Fe,u),i(e,ue,u),i(e,ls,u),i(e,W,u),s(W,Y),s(W,ws),s(ws,Bt),s(W,js),s(W,Ie),s(Ie,Ve),i(e,Es,u),E(he,e,u),i(e,He,u),i(e,pe,u),s(pe,ve),s(ve,Ue),E(Re,Ue,null),s(pe,mo),s(pe,Ft),s(Ft,Js),i(e,En,u),i(e,be,u),s(be,fo),s(be,is),s(is,_o),s(be,ho),s(be,ks),s(ks,Xs),s(be,ta),i(e,te,u),i(e,us,u),s(us,Qe),s(Qe,kn),E(Ks,kn,null),s(us,yn),s(us,Cn),s(Cn,vo),i(e,It,u),i(e,ys,u),s(ys,bo),s(ys,Ys),s(Ys,go),s(ys,qo),i(e,Vt,u),E(Zs,e,u),i(e,na,u),i(e,Cs,u),s(Cs,xo),i(e,aa,u),E(ps,e,u),i(e,oa,u),E(et,e,u),i(e,Pn,u),i(e,me,u),s(me,ra),s(me,Pe),s(Pe,$o),s(me,An),s(me,Sn),s(Sn,wo),s(me,Mn),s(me,zn),s(zn,jo),s(me,la),i(e,Ps,u),E(As,e,u),i(e,de,u),E(st,e,u),i(e,Ht,u),i(e,oe,u),s(oe,Eo),s(oe,tt),s(tt,ko),s(oe,yo),s(oe,nt),s(nt,Co),s(oe,Po),s(oe,at),s(at,Ao),s(oe,So),s(oe,ot),s(ot,Mo),s(oe,zo),s(oe,Ut),s(Ut,rt),s(oe,ia),s(oe,ds),s(ds,ua),s(oe,Rt),i(e,pa,u),i(e,cs,u),s(cs,lt),s(cs,Qt),s(Qt,Ge),s(cs,Do),i(e,Gt,u),E(it,e,u),i(e,da,u),E(ms,e,u),i(e,ca,u),i(e,Wt,u),s(Wt,ma),i(e,We,u),E(Ae,e,u),i(e,Jt,u),E(Oe,e,u),i(e,fa,u),i(e,Je,u),s(Je,To),s(Je,Xt),s(Xt,Kt),s(Je,Lo),i(e,Dn,u),E(je,e,u),i(e,Ss,u),E(ut,e,u),i(e,Yt,u),i(e,Zt,u),s(Zt,No),i(e,_a,u),i(e,ce,u),s(ce,Ms),s(Ms,pt),E(dt,pt,null),s(ce,Oo),s(ce,ct),s(ct,Bo),i(e,ha,u),E(fs,e,u),i(e,va,u),i(e,zs,u),s(zs,Fo),s(zs,ge),s(ge,Io),s(zs,Tn),i(e,ba,u),i(e,Ds,u),s(Ds,Ln),s(Ds,Nn),s(Nn,Vo),s(Ds,On),i(e,ga,u),E(mt,e,u),i(e,en,u),i(e,ne,u),s(ne,Ho),s(ne,sn),s(sn,tn),s(ne,Uo),s(ne,nn),s(nn,ft),s(ne,qa),s(ne,Xe),s(Xe,Ro),s(ne,Bn),s(ne,_t),s(_t,Qo),s(ne,xa),s(ne,_s),s(_s,$a),s(ne,ae),s(ne,Fn),s(Fn,In),s(ne,Go),s(ne,Vn),s(Vn,Hn),s(ne,Wo),i(e,wa,u),E(hs,e,u),i(e,ja,u),E(ht,e,u),i(e,an,u),i(e,Ke,u),s(Ke,Jo),s(Ke,vt),s(vt,Xo),s(Ke,Ko),s(Ke,bt),s(bt,Yo),s(Ke,Zo),i(e,on,u),E(gt,e,u),i(e,Ea,u),i(e,qt,u),s(qt,Ye),i(e,ka,u),E(vs,e,u),i(e,ya,u),E(xt,e,u),i(e,Ts,u),i(e,Se,u),s(Se,er),s(Se,Un),s(Un,Ca),s(Se,m),s(Se,B),s(B,il),s(Se,Pa),i(e,sr,u),i(e,Ls,u),s(Ls,rn),s(Ls,ul),s(Ls,ln),i(e,nr,u),i(e,bs,u),s(bs,pl),s(bs,qe),s(qe,dl),s(bs,cl),s(bs,Aa),s(Aa,ml),s(bs,fl),i(e,Qn,u),i(e,$t,u),s($t,Sa),s($t,Ma),s(Ma,fe),s($t,_l),i(e,ar,u),i(e,Be,u),s(Be,Gn),s(Gn,za),s(za,hl),s(Gn,vl),s(Be,un),s(Be,Wn),s(Wn,Da),s(Da,Me),s(Wn,bl),s(Be,gl),s(Be,wt),s(wt,Ta),s(Ta,ql),s(wt,xl),s(wt,Ns),s(Ns,$l),s(wt,wl),s(Be,La),s(Be,gs),s(gs,Na),s(Na,jl),s(gs,El),s(gs,Os),s(Os,Oa),s(gs,kl),s(gs,Ze),s(Ze,yl),s(gs,Cl),i(e,or,u),E(Ee,e,u),i(e,rr,u),E(pn,e,u),i(e,lr,u),i(e,xe,u),s(xe,Pl),s(xe,dn),s(dn,Al),s(xe,_e),s(xe,Ba),s(Ba,Sl),s(xe,Ml),s(xe,Fa),s(Fa,zl),s(xe,Dl),s(xe,Ia),s(Ia,cn),s(xe,Tl),s(xe,Va),s(Va,Ll),s(xe,Pc),i(e,_p,u),i(e,ze,u),s(ze,Ac),s(ze,Si),s(Si,Sc),s(ze,Mc),s(ze,Mi),s(Mi,zc),s(ze,Dc),s(ze,Nl),s(Nl,Tc),s(ze,Lc),s(ze,zi),s(zi,Nc),s(ze,Oc),s(ze,Di),s(Di,Bc),s(ze,Fc),i(e,hp,u),E(ir,e,u),i(e,vp,u),E(ur,e,u),i(e,bp,u),i(e,De,u),s(De,Ic),s(De,Ti),s(Ti,Vc),s(De,Hc),s(De,Li),s(Li,Uc),s(De,Rc),s(De,Ni),s(Ni,Qc),s(De,Gc),s(De,Oi),s(Oi,Wc),s(De,Jc),s(De,Bi),s(Bi,Xc),s(De,Kc),i(e,gp,u),E(pr,e,u),i(e,qp,u),E(dr,e,u),i(e,xp,u),i(e,Ol,u),s(Ol,Yc),i(e,$p,u),E(cr,e,u),i(e,wp,u),E(mr,e,u),i(e,jp,u),i(e,Bl,u),s(Bl,Zc),i(e,Ep,u),i(e,Fl,u),s(Fl,em),i(e,kp,u),i(e,Ha,u),s(Ha,Il),s(Il,Fi),s(Fi,sm),s(Il,tm),s(Ha,nm),s(Ha,es),s(es,Ii),s(Ii,am),s(es,om),s(es,Vi),s(Vi,rm),s(es,lm),s(es,Hi),s(Hi,im),s(es,um),s(es,Ui),s(Ui,pm),s(es,dm),s(es,Ri),s(Ri,cm),s(es,mm),i(e,yp,u),i(e,Te,u),s(Te,fm),s(Te,Qi),s(Qi,_m),s(Te,hm),s(Te,Gi),s(Gi,vm),s(Te,bm),s(Te,Wi),s(Wi,gm),s(Te,qm),s(Te,Ji),s(Ji,xm),s(Te,$m),s(Te,Xi),s(Xi,wm),s(Te,jm),i(e,Cp,u),i(e,Le,u),s(Le,Em),s(Le,Ki),s(Ki,km),s(Le,ym),s(Le,Yi),s(Yi,Cm),s(Le,Pm),s(Le,Zi),s(Zi,Am),s(Le,Sm),s(Le,eu),s(eu,Mm),s(Le,zm),s(Le,su),s(su,Dm),s(Le,Tm),i(e,Pp,u),E(fr,e,u),i(e,Ap,u),E(_r,e,u),i(e,Sp,u),i(e,mn,u),s(mn,Lm),s(mn,tu),s(tu,Nm),s(mn,Om),s(mn,nu),s(nu,Bm),s(mn,Fm),i(e,Mp,u),E(hr,e,u),i(e,zp,u),E(vr,e,u),i(e,Dp,u),i(e,Ua,u),s(Ua,Im),s(Ua,au),s(au,Vm),s(Ua,Hm),i(e,Tp,u),E(br,e,u),i(e,Lp,u),E(gr,e,u),i(e,Np,u),i(e,Vl,u),s(Vl,Um),i(e,Op,u),E(Ra,e,u),i(e,Bp,u),i(e,Hl,u),s(Hl,Rm),i(e,Fp,u),E(qr,e,u),i(e,Ip,u),i(e,Ul,u),s(Ul,Qm),i(e,Vp,u),i(e,fn,u),s(fn,Gm),s(fn,ou),s(ou,Wm),s(fn,Jm),s(fn,ru),s(ru,Xm),s(fn,Km),i(e,Hp,u),E(xr,e,u),i(e,Up,u),E($r,e,u),i(e,Rp,u),i(e,Rl,u),s(Rl,Ym),i(e,Qp,u),i(e,Jn,u),s(Jn,Qa),s(Qa,lu),E(wr,lu,null),s(Jn,Zm),s(Jn,iu),s(iu,ef),i(e,Gp,u),i(e,Ga,u),s(Ga,sf),s(Ga,uu),s(uu,tf),s(Ga,nf),i(e,Wp,u),i(e,ke,u),s(ke,af),s(ke,pu),s(pu,of),s(ke,rf),s(ke,du),s(du,lf),s(ke,uf),s(ke,cu),s(cu,pf),s(ke,df),s(ke,mu),s(mu,cf),s(ke,mf),s(ke,fu),s(fu,ff),s(ke,_f),s(ke,_u),s(_u,hf),s(ke,vf),i(e,Jp,u),E(jr,e,u),i(e,Xp,u),i(e,Ql,u),s(Ql,bf),i(e,Kp,u),E(Er,e,u),i(e,Yp,u),E(kr,e,u),i(e,Zp,u),i(e,Gl,u),s(Gl,gf),i(e,ed,u),i(e,Wl,u),s(Wl,qf),i(e,sd,u),Zr[jt].m(e,u),i(e,Jl,u),i(e,Xn,u),s(Xn,Wa),s(Wa,hu),E(yr,hu,null),s(Xn,xf),s(Xn,vu),s(vu,$f),i(e,td,u),el[kt].m(e,u),i(e,Xl,u),i(e,_n,u),s(_n,wf),s(_n,bu),s(bu,jf),s(_n,Ef),s(_n,Kl),s(Kl,kf),s(_n,yf),i(e,nd,u),i(e,Bs,u),s(Bs,Cr),s(Cr,Cf),s(Cr,gu),s(gu,Pf),s(Cr,Af),s(Bs,Sf),s(Bs,qu),s(qu,Mf),s(Bs,zf),s(Bs,Pr),s(Pr,Df),s(Pr,xu),s(xu,Tf),s(Pr,Lf),s(Bs,Nf),s(Bs,Kn),s(Kn,Of),s(Kn,$u),s($u,Bf),s(Kn,Ff),s(Kn,wu),s(wu,If),s(Kn,Vf),i(e,ad,u),i(e,ss,u),s(ss,Hf),s(ss,ju),s(ju,Uf),s(ss,Rf),s(ss,Eu),s(Eu,Qf),s(ss,Gf),s(ss,ku),s(ku,Wf),s(ss,Jf),od.m(bq,ss),s(ss,rd),i(e,ld,u),i(e,Fs,u),s(Fs,Xf),s(Fs,yu),s(yu,Kf),s(Fs,Yf),s(Fs,Cu),s(Cu,Zf),s(Fs,e_),s(Fs,Pu),s(Pu,s_),s(Fs,t_),i(e,id,u),E(Ar,e,u),i(e,ud,u),i(e,Ja,u),s(Ja,n_),s(Ja,Au),s(Au,a_),s(Ja,o_),i(e,pd,u),E(Sr,e,u),i(e,dd,u),i(e,Xa,u),s(Xa,r_),s(Xa,Su),s(Su,l_),s(Xa,i_),i(e,cd,u),sl[Ct].m(e,u),i(e,Yl,u),i(e,ts,u),s(ts,u_),s(ts,Mu),s(Mu,p_),s(ts,d_),s(ts,zu),s(zu,c_),s(ts,m_),s(ts,Du),s(Du,f_),s(ts,__),s(ts,Tu),s(Tu,h_),s(ts,v_),i(e,md,u),E(Mr,e,u),i(e,fd,u),i(e,Ka,u),s(Ka,b_),s(Ka,Lu),s(Lu,g_),s(Ka,q_),i(e,_d,u),i(e,hn,u),s(hn,Nu),s(Nu,x_),s(hn,$_),s(hn,Ou),s(Ou,w_),s(hn,j_),s(hn,zr),s(zr,E_),s(zr,Bu),s(Bu,k_),s(zr,y_),i(e,hd,u),i(e,Zl,u),s(Zl,C_),i(e,vd,u),E(Dr,e,u),i(e,bd,u),i(e,Ya,u),s(Ya,P_),s(Ya,Fu),s(Fu,A_),s(Ya,S_),i(e,gd,u),E(Tr,e,u),i(e,qd,u),i(e,ei,u),s(ei,M_),i(e,xd,u),E(Lr,e,u),i(e,$d,u),i(e,si,u),s(si,z_),i(e,wd,u),E(Nr,e,u),i(e,jd,u),E(Or,e,u),i(e,Ed,u),i(e,ti,u),s(ti,D_),i(e,kd,u),E(Br,e,u),i(e,yd,u),E(Fr,e,u),i(e,Cd,u),i(e,vn,u),s(vn,T_),s(vn,Ir),s(Ir,L_),s(vn,N_),s(vn,Iu),s(Iu,O_),s(vn,B_),i(e,Pd,u),ea.m(e,u),i(e,ni,u),E(Vr,e,u),i(e,Ad,u),i(e,ai,u),s(ai,F_),i(e,Sd,u),E(Hr,e,u),i(e,Md,u),E(Ur,e,u),i(e,zd,u),i(e,Za,u),s(Za,I_),s(Za,Vu),s(Vu,V_),s(Za,H_),i(e,Dd,u),i(e,Yn,u),s(Yn,eo),s(eo,Hu),E(Rr,Hu,null),s(Yn,U_),s(Yn,oi),s(oi,Uu),s(Uu,R_),s(oi,Q_),i(e,Td,u),tl[At].m(e,u),i(e,ri,u),i(e,so,u),s(so,G_),s(so,Ru),s(Ru,W_),s(so,J_),i(e,Ld,u),i(e,Is,u),s(Is,X_),s(Is,Qu),s(Qu,K_),s(Is,Y_),s(Is,Gu),s(Gu,Z_),s(Is,eh),s(Is,Wu),s(Wu,sh),s(Is,th),i(e,Nd,u),E(Qr,e,u),i(e,Od,u),i(e,to,u),s(to,nh),s(to,Ju),s(Ju,ah),s(to,oh),i(e,Bd,u),E(Gr,e,u),i(e,Fd,u),nl[Mt].m(e,u),i(e,li,u),i(e,ns,u),s(ns,rh),s(ns,Xu),s(Xu,lh),s(ns,ih),s(ns,Ku),s(Ku,uh),s(ns,ph),s(ns,Yu),s(Yu,dh),s(ns,ch),s(ns,Zu),s(Zu,mh),s(ns,fh),i(e,Id,u),al[Dt].m(e,u),i(e,ii,u),i(e,bn,u),s(bn,_h),s(bn,ep),s(ep,hh),s(bn,vh),s(bn,sp),s(sp,bh),s(bn,gh),i(e,Vd,u),ol[Lt].m(e,u),i(e,ui,u),E(Wr,e,u),i(e,Hd,u),i(e,pi,u),s(pi,qh),i(e,Ud,u),$e&&$e.m(e,u),i(e,di,u),i(e,Vs,u),s(Vs,xh),s(Vs,tp),s(tp,$h),s(Vs,wh),s(Vs,np),s(np,jh),s(Vs,Eh),s(Vs,ap),s(ap,kh),s(Vs,yh),i(e,Rd,u),E(no,e,u),i(e,Qd,u),we&&we.m(e,u),i(e,ci,u),i(e,Zn,u),s(Zn,ao),s(ao,op),E(Jr,op,null),s(Zn,Ch),s(Zn,mi),s(mi,Ph),s(mi,rp),s(rp,Ah),i(e,Gd,u),i(e,as,u),s(as,Sh),s(as,lp),s(lp,Mh),s(as,zh),s(as,ip),s(ip,Dh),s(as,Th),s(as,up),s(up,Lh),s(as,Nh),s(as,pp),s(pp,Oh),s(as,Bh),i(e,Wd,u),E(Xr,e,u),i(e,Jd,u),E(Kr,e,u),i(e,Xd,u),i(e,fi,u),s(fi,Fh),Kd=!0},p(e,[u]){const rl={};u&1&&(rl.fw=e[0]),f.$set(rl);let _i=T;T=Gh(e),T!==_i&&(jn(),v(Yr[_i],1,1,()=>{Yr[_i]=null}),wn(),I=Yr[T],I||(I=Yr[T]=Qh[T](e),I.c()),h(I,1),I.m(D.parentNode,D));const dp={};u&2&&(dp.$$scope={dirty:u,ctx:e}),he.$set(dp);const cp={};u&2&&(cp.$$scope={dirty:u,ctx:e}),Ra.$set(cp);let oo=jt;jt=Jh(e),jt!==oo&&(jn(),v(Zr[oo],1,1,()=>{Zr[oo]=null}),wn(),Et=Zr[jt],Et||(Et=Zr[jt]=Wh[jt](e),Et.c()),h(Et,1),Et.m(Jl.parentNode,Jl));let hi=kt;kt=Kh(e),kt!==hi&&(jn(),v(el[hi],1,1,()=>{el[hi]=null}),wn(),yt=el[kt],yt||(yt=el[kt]=Xh[kt](e),yt.c()),h(yt,1),yt.m(Xl.parentNode,Xl));let Hs=Ct;Ct=Zh(e),Ct!==Hs&&(jn(),v(sl[Hs],1,1,()=>{sl[Hs]=null}),wn(),Pt=sl[Ct],Pt||(Pt=sl[Ct]=Yh[Ct](e),Pt.c()),h(Pt,1),Pt.m(Yl.parentNode,Yl)),Yd!==(Yd=ev(e))&&(ea.d(1),ea=Yd(e),ea&&(ea.c(),ea.m(ni.parentNode,ni)));let vi=At;At=tv(e),At!==vi&&(jn(),v(tl[vi],1,1,()=>{tl[vi]=null}),wn(),St=tl[At],St||(St=tl[At]=sv[At](e),St.c()),h(St,1),St.m(ri.parentNode,ri));let bi=Mt;Mt=av(e),Mt!==bi&&(jn(),v(nl[bi],1,1,()=>{nl[bi]=null}),wn(),zt=nl[Mt],zt||(zt=nl[Mt]=nv[Mt](e),zt.c()),h(zt,1),zt.m(li.parentNode,li));let gi=Dt;Dt=rv(e),Dt!==gi&&(jn(),v(al[gi],1,1,()=>{al[gi]=null}),wn(),Tt=al[Dt],Tt||(Tt=al[Dt]=ov[Dt](e),Tt.c()),h(Tt,1),Tt.m(ii.parentNode,ii));let sa=Lt;Lt=iv(e),Lt!==sa&&(jn(),v(ol[sa],1,1,()=>{ol[sa]=null}),wn(),Nt=ol[Lt],Nt||(Nt=ol[Lt]=lv[Lt](e),Nt.c()),h(Nt,1),Nt.m(ui.parentNode,ui)),e[0]==="pt"?$e?u&1&&h($e,1):($e=_q(),$e.c(),h($e,1),$e.m(di.parentNode,di)):$e&&(jn(),v($e,1,1,()=>{$e=null}),wn());const mp={};u&2&&(mp.$$scope={dirty:u,ctx:e}),no.$set(mp),e[0]==="pt"?we?u&1&&h(we,1):(we=hq(),we.c(),h(we,1),we.m(ci.parentNode,ci)):we&&(jn(),v(we,1,1,()=>{we=null}),wn())},i(e){Kd||(h(f.$$.fragment,e),h(x.$$.fragment,e),h(I),h(Q.$$.fragment,e),h(he.$$.fragment,e),h(Re.$$.fragment,e),h(Ks.$$.fragment,e),h(Zs.$$.fragment,e),h(ps.$$.fragment,e),h(et.$$.fragment,e),h(As.$$.fragment,e),h(st.$$.fragment,e),h(it.$$.fragment,e),h(ms.$$.fragment,e),h(Ae.$$.fragment,e),h(Oe.$$.fragment,e),h(je.$$.fragment,e),h(ut.$$.fragment,e),h(dt.$$.fragment,e),h(fs.$$.fragment,e),h(mt.$$.fragment,e),h(hs.$$.fragment,e),h(ht.$$.fragment,e),h(gt.$$.fragment,e),h(vs.$$.fragment,e),h(xt.$$.fragment,e),h(Ee.$$.fragment,e),h(pn.$$.fragment,e),h(ir.$$.fragment,e),h(ur.$$.fragment,e),h(pr.$$.fragment,e),h(dr.$$.fragment,e),h(cr.$$.fragment,e),h(mr.$$.fragment,e),h(fr.$$.fragment,e),h(_r.$$.fragment,e),h(hr.$$.fragment,e),h(vr.$$.fragment,e),h(br.$$.fragment,e),h(gr.$$.fragment,e),h(Ra.$$.fragment,e),h(qr.$$.fragment,e),h(xr.$$.fragment,e),h($r.$$.fragment,e),h(wr.$$.fragment,e),h(jr.$$.fragment,e),h(Er.$$.fragment,e),h(kr.$$.fragment,e),h(Et),h(yr.$$.fragment,e),h(yt),h(Ar.$$.fragment,e),h(Sr.$$.fragment,e),h(Pt),h(Mr.$$.fragment,e),h(Dr.$$.fragment,e),h(Tr.$$.fragment,e),h(Lr.$$.fragment,e),h(Nr.$$.fragment,e),h(Or.$$.fragment,e),h(Br.$$.fragment,e),h(Fr.$$.fragment,e),h(Vr.$$.fragment,e),h(Hr.$$.fragment,e),h(Ur.$$.fragment,e),h(Rr.$$.fragment,e),h(St),h(Qr.$$.fragment,e),h(Gr.$$.fragment,e),h(zt),h(Tt),h(Nt),h(Wr.$$.fragment,e),h($e),h(no.$$.fragment,e),h(we),h(Jr.$$.fragment,e),h(Xr.$$.fragment,e),h(Kr.$$.fragment,e),Kd=!0)},o(e){v(f.$$.fragment,e),v(x.$$.fragment,e),v(I),v(Q.$$.fragment,e),v(he.$$.fragment,e),v(Re.$$.fragment,e),v(Ks.$$.fragment,e),v(Zs.$$.fragment,e),v(ps.$$.fragment,e),v(et.$$.fragment,e),v(As.$$.fragment,e),v(st.$$.fragment,e),v(it.$$.fragment,e),v(ms.$$.fragment,e),v(Ae.$$.fragment,e),v(Oe.$$.fragment,e),v(je.$$.fragment,e),v(ut.$$.fragment,e),v(dt.$$.fragment,e),v(fs.$$.fragment,e),v(mt.$$.fragment,e),v(hs.$$.fragment,e),v(ht.$$.fragment,e),v(gt.$$.fragment,e),v(vs.$$.fragment,e),v(xt.$$.fragment,e),v(Ee.$$.fragment,e),v(pn.$$.fragment,e),v(ir.$$.fragment,e),v(ur.$$.fragment,e),v(pr.$$.fragment,e),v(dr.$$.fragment,e),v(cr.$$.fragment,e),v(mr.$$.fragment,e),v(fr.$$.fragment,e),v(_r.$$.fragment,e),v(hr.$$.fragment,e),v(vr.$$.fragment,e),v(br.$$.fragment,e),v(gr.$$.fragment,e),v(Ra.$$.fragment,e),v(qr.$$.fragment,e),v(xr.$$.fragment,e),v($r.$$.fragment,e),v(wr.$$.fragment,e),v(jr.$$.fragment,e),v(Er.$$.fragment,e),v(kr.$$.fragment,e),v(Et),v(yr.$$.fragment,e),v(yt),v(Ar.$$.fragment,e),v(Sr.$$.fragment,e),v(Pt),v(Mr.$$.fragment,e),v(Dr.$$.fragment,e),v(Tr.$$.fragment,e),v(Lr.$$.fragment,e),v(Nr.$$.fragment,e),v(Or.$$.fragment,e),v(Br.$$.fragment,e),v(Fr.$$.fragment,e),v(Vr.$$.fragment,e),v(Hr.$$.fragment,e),v(Ur.$$.fragment,e),v(Rr.$$.fragment,e),v(St),v(Qr.$$.fragment,e),v(Gr.$$.fragment,e),v(zt),v(Tt),v(Nt),v(Wr.$$.fragment,e),v($e),v(no.$$.fragment,e),v(we),v(Jr.$$.fragment,e),v(Xr.$$.fragment,e),v(Kr.$$.fragment,e),Kd=!1},d(e){t(p),e&&t(b),k(f,e),e&&t(y),e&&t(S),k(x),e&&t(A),Yr[T].d(e),e&&t(D),e&&t(P),e&&t(U),k(Q,e),e&&t(J),e&&t(H),e&&t(ye),e&&t(ie),e&&t(Fe),e&&t(ue),e&&t(ls),e&&t(W),e&&t(Es),k(he,e),e&&t(He),e&&t(pe),k(Re),e&&t(En),e&&t(be),e&&t(te),e&&t(us),k(Ks),e&&t(It),e&&t(ys),e&&t(Vt),k(Zs,e),e&&t(na),e&&t(Cs),e&&t(aa),k(ps,e),e&&t(oa),k(et,e),e&&t(Pn),e&&t(me),e&&t(Ps),k(As,e),e&&t(de),k(st,e),e&&t(Ht),e&&t(oe),e&&t(pa),e&&t(cs),e&&t(Gt),k(it,e),e&&t(da),k(ms,e),e&&t(ca),e&&t(Wt),e&&t(We),k(Ae,e),e&&t(Jt),k(Oe,e),e&&t(fa),e&&t(Je),e&&t(Dn),k(je,e),e&&t(Ss),k(ut,e),e&&t(Yt),e&&t(Zt),e&&t(_a),e&&t(ce),k(dt),e&&t(ha),k(fs,e),e&&t(va),e&&t(zs),e&&t(ba),e&&t(Ds),e&&t(ga),k(mt,e),e&&t(en),e&&t(ne),e&&t(wa),k(hs,e),e&&t(ja),k(ht,e),e&&t(an),e&&t(Ke),e&&t(on),k(gt,e),e&&t(Ea),e&&t(qt),e&&t(ka),k(vs,e),e&&t(ya),k(xt,e),e&&t(Ts),e&&t(Se),e&&t(sr),e&&t(Ls),e&&t(nr),e&&t(bs),e&&t(Qn),e&&t($t),e&&t(ar),e&&t(Be),e&&t(or),k(Ee,e),e&&t(rr),k(pn,e),e&&t(lr),e&&t(xe),e&&t(_p),e&&t(ze),e&&t(hp),k(ir,e),e&&t(vp),k(ur,e),e&&t(bp),e&&t(De),e&&t(gp),k(pr,e),e&&t(qp),k(dr,e),e&&t(xp),e&&t(Ol),e&&t($p),k(cr,e),e&&t(wp),k(mr,e),e&&t(jp),e&&t(Bl),e&&t(Ep),e&&t(Fl),e&&t(kp),e&&t(Ha),e&&t(yp),e&&t(Te),e&&t(Cp),e&&t(Le),e&&t(Pp),k(fr,e),e&&t(Ap),k(_r,e),e&&t(Sp),e&&t(mn),e&&t(Mp),k(hr,e),e&&t(zp),k(vr,e),e&&t(Dp),e&&t(Ua),e&&t(Tp),k(br,e),e&&t(Lp),k(gr,e),e&&t(Np),e&&t(Vl),e&&t(Op),k(Ra,e),e&&t(Bp),e&&t(Hl),e&&t(Fp),k(qr,e),e&&t(Ip),e&&t(Ul),e&&t(Vp),e&&t(fn),e&&t(Hp),k(xr,e),e&&t(Up),k($r,e),e&&t(Rp),e&&t(Rl),e&&t(Qp),e&&t(Jn),k(wr),e&&t(Gp),e&&t(Ga),e&&t(Wp),e&&t(ke),e&&t(Jp),k(jr,e),e&&t(Xp),e&&t(Ql),e&&t(Kp),k(Er,e),e&&t(Yp),k(kr,e),e&&t(Zp),e&&t(Gl),e&&t(ed),e&&t(Wl),e&&t(sd),Zr[jt].d(e),e&&t(Jl),e&&t(Xn),k(yr),e&&t(td),el[kt].d(e),e&&t(Xl),e&&t(_n),e&&t(nd),e&&t(Bs),e&&t(ad),e&&t(ss),e&&t(ld),e&&t(Fs),e&&t(id),k(Ar,e),e&&t(ud),e&&t(Ja),e&&t(pd),k(Sr,e),e&&t(dd),e&&t(Xa),e&&t(cd),sl[Ct].d(e),e&&t(Yl),e&&t(ts),e&&t(md),k(Mr,e),e&&t(fd),e&&t(Ka),e&&t(_d),e&&t(hn),e&&t(hd),e&&t(Zl),e&&t(vd),k(Dr,e),e&&t(bd),e&&t(Ya),e&&t(gd),k(Tr,e),e&&t(qd),e&&t(ei),e&&t(xd),k(Lr,e),e&&t($d),e&&t(si),e&&t(wd),k(Nr,e),e&&t(jd),k(Or,e),e&&t(Ed),e&&t(ti),e&&t(kd),k(Br,e),e&&t(yd),k(Fr,e),e&&t(Cd),e&&t(vn),e&&t(Pd),ea.d(e),e&&t(ni),k(Vr,e),e&&t(Ad),e&&t(ai),e&&t(Sd),k(Hr,e),e&&t(Md),k(Ur,e),e&&t(zd),e&&t(Za),e&&t(Dd),e&&t(Yn),k(Rr),e&&t(Td),tl[At].d(e),e&&t(ri),e&&t(so),e&&t(Ld),e&&t(Is),e&&t(Nd),k(Qr,e),e&&t(Od),e&&t(to),e&&t(Bd),k(Gr,e),e&&t(Fd),nl[Mt].d(e),e&&t(li),e&&t(ns),e&&t(Id),al[Dt].d(e),e&&t(ii),e&&t(bn),e&&t(Vd),ol[Lt].d(e),e&&t(ui),k(Wr,e),e&&t(Hd),e&&t(pi),e&&t(Ud),$e&&$e.d(e),e&&t(di),e&&t(Vs),e&&t(Rd),k(no,e),e&&t(Qd),we&&we.d(e),e&&t(ci),e&&t(Zn),k(Jr),e&&t(Gd),e&&t(as),e&&t(Wd),k(Xr,e),e&&t(Jd),k(Kr,e),e&&t(Xd),e&&t(fi)}}}const Xq={local:"rponse-aux-questions",sections:[{local:"prparation-des-donnes",sections:[{local:"le-jeu-de-donnes-squad",title:"Le jeu de donn\xE9es SQuAD"},{local:"traitement-des-donnes-dentranement",title:"Traitement des donn\xE9es d'entra\xEEnement"},{local:"traitement-des-donnes-de-validation",title:"Traitement des donn\xE9es de validation"}],title:"Pr\xE9paration des donn\xE9es"},{local:"ifinetuneri-le-modle-avec-lapi-trainer",title:"<i>Finetuner</i> le mod\xE8le avec l'API `Trainer`"},{local:"ifinetuneri-fin-du-modle-avec-keras",sections:[{local:"posttraitement",title:"Post-traitement"},{local:"ifinetuningi-du-modle",title:"<i>Finetuning</i> du mod\xE8le"}],title:"<i>Finetuner</i> fin du mod\xE8le avec Keras"},{local:"une-boucle-dentranement-personnalise",sections:[{local:"prparer-tout-pour-lentranement",title:"Pr\xE9parer tout pour l'entra\xEEnement"}],title:"Une boucle d'entra\xEEnement personnalis\xE9e"},{local:"boucle-dentranement",sections:[{local:"utilisation-du-modle-ifinetuni",title:"Utilisation du mod\xE8le <i>finetun\xE9</i>"}],title:"Boucle d'entra\xEEnement"}],title:"R\xE9ponse aux questions"};function Kq(R,p,b){let f="pt";return Eq(()=>{const y=new URLSearchParams(window.location.search);b(0,f=y.get("fw")||"pt")}),[f]}class ox extends gq{constructor(p){super();qq(this,p,Kq,Jq,xq,{})}}export{ox as default,Xq as metadata};
