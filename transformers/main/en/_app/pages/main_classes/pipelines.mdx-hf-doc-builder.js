import{S as rz,i as sz,s as az,e as o,k as l,w as h,t as a,M as iz,c as r,d as n,m as c,a as s,x as u,h as i,b as d,G as e,g as f,y as g,q as _,o as b,B as w,v as lz,L as he}from"../../chunks/vendor-hf-doc-builder.js";import{T as oz}from"../../chunks/Tip-hf-doc-builder.js";import{D as x}from"../../chunks/Docstring-hf-doc-builder.js";import{C as I}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as D}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{E as fe}from"../../chunks/ExampleCodeBlock-hf-doc-builder.js";function cz(A){let k,$,T,v,y;return v=new I({props:{code:`from transformers import pipeline, AutoModelForTokenClassification, AutoTokenizer

# Sentiment analysis pipeline
pipeline("sentiment-analysis")

# Question answering pipeline, specifying the checkpoint identifier
pipeline("question-answering", model="distilbert-base-cased-distilled-squad", tokenizer="bert-base-cased")

# Named entity recognition pipeline, passing in a specific model and tokenizer
model = AutoModelForTokenClassification.from_pretrained("dbmdz/bert-large-cased-finetuned-conll03-english")
tokenizer = AutoTokenizer.from_pretrained("bert-base-cased")
pipeline("ner", model=model, tokenizer=tokenizer)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline, AutoModelForTokenClassification, AutoTokenizer

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Sentiment analysis pipeline</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pipeline(<span class="hljs-string">&quot;sentiment-analysis&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Question answering pipeline, specifying the checkpoint identifier</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pipeline(<span class="hljs-string">&quot;question-answering&quot;</span>, model=<span class="hljs-string">&quot;distilbert-base-cased-distilled-squad&quot;</span>, tokenizer=<span class="hljs-string">&quot;bert-base-cased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Named entity recognition pipeline, passing in a specific model and tokenizer</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = AutoModelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;dbmdz/bert-large-cased-finetuned-conll03-english&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;bert-base-cased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>pipeline(<span class="hljs-string">&quot;ner&quot;</span>, model=model, tokenizer=tokenizer)`}}),{c(){k=o("p"),$=a("Examples:"),T=l(),h(v.$$.fragment)},l(p){k=r(p,"P",{});var P=s(k);$=i(P,"Examples:"),P.forEach(n),T=c(p),u(v.$$.fragment,p)},m(p,P){f(p,k,P),e(k,$),f(p,T,P),g(v,p,P),y=!0},p:he,i(p){y||(_(v.$$.fragment,p),y=!0)},o(p){b(v.$$.fragment,p),y=!1},d(p){p&&n(k),p&&n(T),w(v,p)}}}function dz(A){let k,$,T,v,y;return{c(){k=o("p"),$=a(`However, this is not automatically a win for performance. It can be either a 10x speedup or 5x slowdown depending
on hardware, data and the actual model being used.`),T=l(),v=o("p"),y=a("Example where it\u2019s mostly a speedup:")},l(p){k=r(p,"P",{});var P=s(k);$=i(P,`However, this is not automatically a win for performance. It can be either a 10x speedup or 5x slowdown depending
on hardware, data and the actual model being used.`),P.forEach(n),T=c(p),v=r(p,"P",{});var Se=s(v);y=i(Se,"Example where it\u2019s mostly a speedup:"),Se.forEach(n)},m(p,P){f(p,k,P),e(k,$),f(p,T,P),f(p,v,P),e(v,y)},d(p){p&&n(k),p&&n(T),p&&n(v)}}}function pz(A){let k,$,T,v,y;return v=new I({props:{code:`from transformers import pipeline

classifier = pipeline(model="superb/wav2vec2-base-superb-ks")
result = classifier("https://huggingface.co/datasets/Narsil/asr_dummy/resolve/main/1.flac")

# Simplify results, different torch versions might alter the scores slightly.
from transformers.testing_utils import nested_simplify

nested_simplify(result)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

<span class="hljs-meta">&gt;&gt;&gt; </span>classifier = pipeline(model=<span class="hljs-string">&quot;superb/wav2vec2-base-superb-ks&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>result = classifier(<span class="hljs-string">&quot;https://huggingface.co/datasets/Narsil/asr_dummy/resolve/main/1.flac&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Simplify results, different torch versions might alter the scores slightly.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.testing_utils <span class="hljs-keyword">import</span> nested_simplify

<span class="hljs-meta">&gt;&gt;&gt; </span>nested_simplify(result)
[{<span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.997</span>, <span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;_unknown_&#x27;</span>}, {<span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.002</span>, <span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;left&#x27;</span>}, {<span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.0</span>, <span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;yes&#x27;</span>}, {<span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.0</span>, <span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;down&#x27;</span>}, {<span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.0</span>, <span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;stop&#x27;</span>}]`}}),{c(){k=o("p"),$=a("Example:"),T=l(),h(v.$$.fragment)},l(p){k=r(p,"P",{});var P=s(k);$=i(P,"Example:"),P.forEach(n),T=c(p),u(v.$$.fragment,p)},m(p,P){f(p,k,P),e(k,$),f(p,T,P),g(v,p,P),y=!0},p:he,i(p){y||(_(v.$$.fragment,p),y=!0)},o(p){b(v.$$.fragment,p),y=!1},d(p){p&&n(k),p&&n(T),w(v,p)}}}function mz(A){let k,$,T,v,y;return v=new I({props:{code:`from transformers import pipeline

transcriber = pipeline(model="openai/whisper-base")
transcriber("https://huggingface.co/datasets/Narsil/asr_dummy/resolve/main/1.flac")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

<span class="hljs-meta">&gt;&gt;&gt; </span>transcriber = pipeline(model=<span class="hljs-string">&quot;openai/whisper-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>transcriber(<span class="hljs-string">&quot;https://huggingface.co/datasets/Narsil/asr_dummy/resolve/main/1.flac&quot;</span>)
{<span class="hljs-string">&#x27;text&#x27;</span>: <span class="hljs-string">&#x27; He hoped there would be stew for dinner, turnips and carrots and bruised potatoes and fat mutton pieces to be ladled out in thick, peppered flour fat and sauce.&#x27;</span>}`}}),{c(){k=o("p"),$=a("Example:"),T=l(),h(v.$$.fragment)},l(p){k=r(p,"P",{});var P=s(k);$=i(P,"Example:"),P.forEach(n),T=c(p),u(v.$$.fragment,p)},m(p,P){f(p,k,P),e(k,$),f(p,T,P),g(v,p,P),y=!0},p:he,i(p){y||(_(v.$$.fragment,p),y=!0)},o(p){b(v.$$.fragment,p),y=!1},d(p){p&&n(k),p&&n(T),w(v,p)}}}function fz(A){let k,$,T,v,y;return v=new I({props:{code:`conversation = Conversation("Going to the movies tonight - any suggestions?")

# Steps usually performed by the model when generating a response:
# 1. Mark the user input as processed (moved to the history)
conversation.mark_processed()
# 2. Append a mode response
conversation.append_response("The Big lebowski.")

conversation.add_user_input("Is it good?")`,highlighted:`conversation = Conversation(<span class="hljs-string">&quot;Going to the movies tonight - any suggestions?&quot;</span>)

<span class="hljs-comment"># Steps usually performed by the model when generating a response:</span>
<span class="hljs-comment"># 1. Mark the user input as processed (moved to the history)</span>
conversation.mark_processed()
<span class="hljs-comment"># 2. Append a mode response</span>
conversation.append_response(<span class="hljs-string">&quot;The Big lebowski.&quot;</span>)

conversation.add_user_input(<span class="hljs-string">&quot;Is it good?&quot;</span>)`}}),{c(){k=o("p"),$=a("Usage:"),T=l(),h(v.$$.fragment)},l(p){k=r(p,"P",{});var P=s(k);$=i(P,"Usage:"),P.forEach(n),T=c(p),u(v.$$.fragment,p)},m(p,P){f(p,k,P),e(k,$),f(p,T,P),g(v,p,P),y=!0},p:he,i(p){y||(_(v.$$.fragment,p),y=!0)},o(p){b(v.$$.fragment,p),y=!1},d(p){p&&n(k),p&&n(T),w(v,p)}}}function hz(A){let k,$,T,v,y;return v=new I({props:{code:`from transformers import pipeline, Conversation

chatbot = pipeline(model="microsoft/DialoGPT-medium")
conversation = Conversation("Going to the movies tonight - any suggestions?")
conversation = chatbot(conversation)
conversation.generated_responses[-1]

conversation.add_user_input("Is it an action movie?")
conversation = chatbot(conversation)
conversation.generated_responses[-1]`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline, Conversation

<span class="hljs-meta">&gt;&gt;&gt; </span>chatbot = pipeline(model=<span class="hljs-string">&quot;microsoft/DialoGPT-medium&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>conversation = Conversation(<span class="hljs-string">&quot;Going to the movies tonight - any suggestions?&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>conversation = chatbot(conversation)
<span class="hljs-meta">&gt;&gt;&gt; </span>conversation.generated_responses[-<span class="hljs-number">1</span>]
<span class="hljs-string">&#x27;The Big Lebowski&#x27;</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>conversation.add_user_input(<span class="hljs-string">&quot;Is it an action movie?&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>conversation = chatbot(conversation)
<span class="hljs-meta">&gt;&gt;&gt; </span>conversation.generated_responses[-<span class="hljs-number">1</span>]
<span class="hljs-string">&quot;It&#x27;s a comedy.&quot;</span>`}}),{c(){k=o("p"),$=a("Example:"),T=l(),h(v.$$.fragment)},l(p){k=r(p,"P",{});var P=s(k);$=i(P,"Example:"),P.forEach(n),T=c(p),u(v.$$.fragment,p)},m(p,P){f(p,k,P),e(k,$),f(p,T,P),g(v,p,P),y=!0},p:he,i(p){y||(_(v.$$.fragment,p),y=!0)},o(p){b(v.$$.fragment,p),y=!1},d(p){p&&n(k),p&&n(T),w(v,p)}}}function uz(A){let k,$,T,v,y;return v=new I({props:{code:`from transformers import pipeline

depth_estimator = pipeline(task="depth-estimation", model="Intel/dpt-large")
output = depth_estimator("http://images.cocodataset.org/val2017/000000039769.jpg")
# This is a tensor with the values being the depth expressed in meters for each pixel
output["predicted_depth"].shape`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

<span class="hljs-meta">&gt;&gt;&gt; </span>depth_estimator = pipeline(task=<span class="hljs-string">&quot;depth-estimation&quot;</span>, model=<span class="hljs-string">&quot;Intel/dpt-large&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>output = depth_estimator(<span class="hljs-string">&quot;http://images.cocodataset.org/val2017/000000039769.jpg&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># This is a tensor with the values being the depth expressed in meters for each pixel</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>output[<span class="hljs-string">&quot;predicted_depth&quot;</span>].shape
torch.Size([<span class="hljs-number">1</span>, <span class="hljs-number">384</span>, <span class="hljs-number">384</span>])`}}),{c(){k=o("p"),$=a("Example:"),T=l(),h(v.$$.fragment)},l(p){k=r(p,"P",{});var P=s(k);$=i(P,"Example:"),P.forEach(n),T=c(p),u(v.$$.fragment,p)},m(p,P){f(p,k,P),e(k,$),f(p,T,P),g(v,p,P),y=!0},p:he,i(p){y||(_(v.$$.fragment,p),y=!0)},o(p){b(v.$$.fragment,p),y=!1},d(p){p&&n(k),p&&n(T),w(v,p)}}}function gz(A){let k,$,T,v,y;return v=new I({props:{code:`from transformers import pipeline

document_qa = pipeline(model="impira/layoutlm-document-qa")
result = document_qa(
    image="https://huggingface.co/spaces/impira/docquery/resolve/2359223c1837a7587402bda0f2643382a6eefeab/invoice.png",
    question="What is the invoice number?",
)
result[0]["answer"]`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

<span class="hljs-meta">&gt;&gt;&gt; </span>document_qa = pipeline(model=<span class="hljs-string">&quot;impira/layoutlm-document-qa&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>result = document_qa(
<span class="hljs-meta">... </span>    image=<span class="hljs-string">&quot;https://huggingface.co/spaces/impira/docquery/resolve/2359223c1837a7587402bda0f2643382a6eefeab/invoice.png&quot;</span>,
<span class="hljs-meta">... </span>    question=<span class="hljs-string">&quot;What is the invoice number?&quot;</span>,
<span class="hljs-meta">... </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>result[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;answer&quot;</span>]
<span class="hljs-string">&#x27;1110212019&#x27;</span>`}}),{c(){k=o("p"),$=a("Example:"),T=l(),h(v.$$.fragment)},l(p){k=r(p,"P",{});var P=s(k);$=i(P,"Example:"),P.forEach(n),T=c(p),u(v.$$.fragment,p)},m(p,P){f(p,k,P),e(k,$),f(p,T,P),g(v,p,P),y=!0},p:he,i(p){y||(_(v.$$.fragment,p),y=!0)},o(p){b(v.$$.fragment,p),y=!1},d(p){p&&n(k),p&&n(T),w(v,p)}}}function _z(A){let k,$,T,v,y;return v=new I({props:{code:`from transformers import pipeline

extractor = pipeline(model="bert-base-uncased", task="feature-extraction")
result = extractor("This is a simple test.", return_tensors=True)
result.shape  # This is a tensor of shape [1, sequence_lenth, hidden_dimension] representing the input string.`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

<span class="hljs-meta">&gt;&gt;&gt; </span>extractor = pipeline(model=<span class="hljs-string">&quot;bert-base-uncased&quot;</span>, task=<span class="hljs-string">&quot;feature-extraction&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>result = extractor(<span class="hljs-string">&quot;This is a simple test.&quot;</span>, return_tensors=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>result.shape  <span class="hljs-comment"># This is a tensor of shape [1, sequence_lenth, hidden_dimension] representing the input string.</span>
torch.Size([<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">768</span>])`}}),{c(){k=o("p"),$=a("Example:"),T=l(),h(v.$$.fragment)},l(p){k=r(p,"P",{});var P=s(k);$=i(P,"Example:"),P.forEach(n),T=c(p),u(v.$$.fragment,p)},m(p,P){f(p,k,P),e(k,$),f(p,T,P),g(v,p,P),y=!0},p:he,i(p){y||(_(v.$$.fragment,p),y=!0)},o(p){b(v.$$.fragment,p),y=!1},d(p){p&&n(k),p&&n(T),w(v,p)}}}function bz(A){let k,$,T,v,y;return v=new I({props:{code:`from transformers import pipeline

fill_masker = pipeline(model="bert-base-uncased")
potential_words = fill_masker("This is a simple [MASK].")

from transformers.testing_utils import nested_simplify

nested_simplify(potential_words)  # The scores might vary slightly across pytorch/tensorflow versions.`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

<span class="hljs-meta">&gt;&gt;&gt; </span>fill_masker = pipeline(model=<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>potential_words = fill_masker(<span class="hljs-string">&quot;This is a simple [MASK].&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.testing_utils <span class="hljs-keyword">import</span> nested_simplify

<span class="hljs-meta">&gt;&gt;&gt; </span>nested_simplify(potential_words)  <span class="hljs-comment"># The scores might vary slightly across pytorch/tensorflow versions.</span>
[{<span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.042</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">3291</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;problem&#x27;</span>, <span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;this is a simple problem.&#x27;</span>}, {<span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.031</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">3160</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;question&#x27;</span>, <span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;this is a simple question.&#x27;</span>}, {<span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.03</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">8522</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;equation&#x27;</span>, <span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;this is a simple equation.&#x27;</span>}, {<span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.027</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">2028</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;this is a simple one.&#x27;</span>}, {<span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.024</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">3627</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;rule&#x27;</span>, <span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;this is a simple rule.&#x27;</span>}]`}}),{c(){k=o("p"),$=a("Example:"),T=l(),h(v.$$.fragment)},l(p){k=r(p,"P",{});var P=s(k);$=i(P,"Example:"),P.forEach(n),T=c(p),u(v.$$.fragment,p)},m(p,P){f(p,k,P),e(k,$),f(p,T,P),g(v,p,P),y=!0},p:he,i(p){y||(_(v.$$.fragment,p),y=!0)},o(p){b(v.$$.fragment,p),y=!1},d(p){p&&n(k),p&&n(T),w(v,p)}}}function wz(A){let k,$,T,v,y;return{c(){k=o("p"),$=a(`This pipeline only works for inputs with exactly one token masked. Experimental: We added support for multiple
masks. The returned values are raw model output, and correspond to disjoint probabilities where one might expect
joint probabilities (See `),T=o("a"),v=a("discussion"),y=a(")."),this.h()},l(p){k=r(p,"P",{});var P=s(k);$=i(P,`This pipeline only works for inputs with exactly one token masked. Experimental: We added support for multiple
masks. The returned values are raw model output, and correspond to disjoint probabilities where one might expect
joint probabilities (See `),T=r(P,"A",{href:!0,rel:!0});var Se=s(T);v=i(Se,"discussion"),Se.forEach(n),y=i(P,")."),P.forEach(n),this.h()},h(){d(T,"href","https://github.com/huggingface/transformers/pull/10222"),d(T,"rel","nofollow")},m(p,P){f(p,k,P),e(k,$),e(k,T),e(T,v),e(k,y)},d(p){p&&n(k)}}}function vz(A){let k,$,T,v,y;return v=new I({props:{code:`# use bart in pytorch
summarizer = pipeline("summarization")
summarizer("An apple a day, keeps the doctor away", min_length=5, max_length=20)

# use t5 in tf
summarizer = pipeline("summarization", model="t5-base", tokenizer="t5-base", framework="tf")
summarizer("An apple a day, keeps the doctor away", min_length=5, max_length=20)`,highlighted:`<span class="hljs-comment"># use bart in pytorch</span>
summarizer = pipeline(<span class="hljs-string">&quot;summarization&quot;</span>)
summarizer(<span class="hljs-string">&quot;An apple a day, keeps the doctor away&quot;</span>, min_length=<span class="hljs-number">5</span>, max_length=<span class="hljs-number">20</span>)

<span class="hljs-comment"># use t5 in tf</span>
summarizer = pipeline(<span class="hljs-string">&quot;summarization&quot;</span>, model=<span class="hljs-string">&quot;t5-base&quot;</span>, tokenizer=<span class="hljs-string">&quot;t5-base&quot;</span>, framework=<span class="hljs-string">&quot;tf&quot;</span>)
summarizer(<span class="hljs-string">&quot;An apple a day, keeps the doctor away&quot;</span>, min_length=<span class="hljs-number">5</span>, max_length=<span class="hljs-number">20</span>)`}}),{c(){k=o("p"),$=a("Usage:"),T=l(),h(v.$$.fragment)},l(p){k=r(p,"P",{});var P=s(k);$=i(P,"Usage:"),P.forEach(n),T=c(p),u(v.$$.fragment,p)},m(p,P){f(p,k,P),e(k,$),f(p,T,P),g(v,p,P),y=!0},p:he,i(p){y||(_(v.$$.fragment,p),y=!0)},o(p){b(v.$$.fragment,p),y=!1},d(p){p&&n(k),p&&n(T),w(v,p)}}}function kz(A){let k,$,T,v,y;return v=new I({props:{code:`data = {
    "actors": ["brad pitt", "leonardo di caprio", "george clooney"],
    "age": ["56", "45", "59"],
    "number of movies": ["87", "53", "69"],
    "date of birth": ["7 february 1967", "10 june 1996", "28 november 1967"],
}`,highlighted:`data = {
    <span class="hljs-string">&quot;actors&quot;</span>: [<span class="hljs-string">&quot;brad pitt&quot;</span>, <span class="hljs-string">&quot;leonardo di caprio&quot;</span>, <span class="hljs-string">&quot;george clooney&quot;</span>],
    <span class="hljs-string">&quot;age&quot;</span>: [<span class="hljs-string">&quot;56&quot;</span>, <span class="hljs-string">&quot;45&quot;</span>, <span class="hljs-string">&quot;59&quot;</span>],
    <span class="hljs-string">&quot;number of movies&quot;</span>: [<span class="hljs-string">&quot;87&quot;</span>, <span class="hljs-string">&quot;53&quot;</span>, <span class="hljs-string">&quot;69&quot;</span>],
    <span class="hljs-string">&quot;date of birth&quot;</span>: [<span class="hljs-string">&quot;7 february 1967&quot;</span>, <span class="hljs-string">&quot;10 june 1996&quot;</span>, <span class="hljs-string">&quot;28 november 1967&quot;</span>],
}`}}),{c(){k=o("p"),$=a("Example:"),T=l(),h(v.$$.fragment)},l(p){k=r(p,"P",{});var P=s(k);$=i(P,"Example:"),P.forEach(n),T=c(p),u(v.$$.fragment,p)},m(p,P){f(p,k,P),e(k,$),f(p,T,P),g(v,p,P),y=!0},p:he,i(p){y||(_(v.$$.fragment,p),y=!0)},o(p){b(v.$$.fragment,p),y=!1},d(p){p&&n(k),p&&n(T),w(v,p)}}}function Pz(A){let k,$,T,v,y;return v=new I({props:{code:`import pandas as pd

table = pd.DataFrame.from_dict(data)`,highlighted:`<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

table = pd.DataFrame.from_dict(data)`}}),{c(){k=o("p"),$=a("Example:"),T=l(),h(v.$$.fragment)},l(p){k=r(p,"P",{});var P=s(k);$=i(P,"Example:"),P.forEach(n),T=c(p),u(v.$$.fragment,p)},m(p,P){f(p,k,P),e(k,$),f(p,T,P),g(v,p,P),y=!0},p:he,i(p){y||(_(v.$$.fragment,p),y=!0)},o(p){b(v.$$.fragment,p),y=!1},d(p){p&&n(k),p&&n(T),w(v,p)}}}function Tz(A){let k,$,T,v,y;return v=new I({props:{code:`text2text_generator = pipeline("text2text-generation")
text2text_generator("question: What is 42 ? context: 42 is the answer to life, the universe and everything")`,highlighted:`text2text_generator = pipeline(<span class="hljs-string">&quot;text2text-generation&quot;</span>)
text2text_generator(<span class="hljs-string">&quot;question: What is 42 ? context: 42 is the answer to life, the universe and everything&quot;</span>)`}}),{c(){k=o("p"),$=a("Usage:"),T=l(),h(v.$$.fragment)},l(p){k=r(p,"P",{});var P=s(k);$=i(P,"Usage:"),P.forEach(n),T=c(p),u(v.$$.fragment,p)},m(p,P){f(p,k,P),e(k,$),f(p,T,P),g(v,p,P),y=!0},p:he,i(p){y||(_(v.$$.fragment,p),y=!0)},o(p){b(v.$$.fragment,p),y=!1},d(p){p&&n(k),p&&n(T),w(v,p)}}}function yz(A){let k,$,T,v,y;return v=new I({props:{code:`en_fr_translator = pipeline("translation_en_to_fr")
en_fr_translator("How old are you?")`,highlighted:`en_fr_translator = pipeline(<span class="hljs-string">&quot;translation_en_to_fr&quot;</span>)
en_fr_translator(<span class="hljs-string">&quot;How old are you?&quot;</span>)`}}),{c(){k=o("p"),$=a("Usage:"),T=l(),h(v.$$.fragment)},l(p){k=r(p,"P",{});var P=s(k);$=i(P,"Usage:"),P.forEach(n),T=c(p),u(v.$$.fragment,p)},m(p,P){f(p,k,P),e(k,$),f(p,T,P),g(v,p,P),y=!0},p:he,i(p){y||(_(v.$$.fragment,p),y=!0)},o(p){b(v.$$.fragment,p),y=!1},d(p){p&&n(k),p&&n(T),w(v,p)}}}function xz(A){let k,$,T,v,y;return v=new I({props:{code:`# Explicitly ask for tensor allocation on CUDA device :0
pipe = pipeline(..., device=0)
with pipe.device_placement():
    # Every framework specific tensor allocation will be done on the request device
    output = pipe(...)`,highlighted:`<span class="hljs-comment"># Explicitly ask for tensor allocation on CUDA device :0</span>
pipe = pipeline(..., device=<span class="hljs-number">0</span>)
<span class="hljs-keyword">with</span> pipe.device_placement():
    <span class="hljs-comment"># Every framework specific tensor allocation will be done on the request device</span>
    output = pipe(...)`}}),{c(){k=o("p"),$=a("Examples:"),T=l(),h(v.$$.fragment)},l(p){k=r(p,"P",{});var P=s(k);$=i(P,"Examples:"),P.forEach(n),T=c(p),u(v.$$.fragment,p)},m(p,P){f(p,k,P),e(k,$),f(p,T,P),g(v,p,P),y=!0},p:he,i(p){y||(_(v.$$.fragment,p),y=!0)},o(p){b(v.$$.fragment,p),y=!1},d(p){p&&n(k),p&&n(T),w(v,p)}}}function $z(A){let k,$,T,v,y,p,P,Se,Hw,Ou,kn,Vw,Xi,Ww,Zw,Gu,Ji,Bw,Nu,Pn,ud,br,Yw,el,Kw,Xw,Jw,wr,gd,ev,tv,E,_d,tl,nv,ov,bd,nl,rv,sv,wd,ol,av,iv,vd,rl,lv,cv,kd,sl,dv,pv,Pd,al,mv,fv,Td,il,hv,uv,yd,ll,gv,_v,xd,cl,bv,wv,$d,dl,vv,kv,Ed,pl,Pv,Tv,qd,ml,yv,xv,Ad,fl,$v,Ev,jd,hl,qv,Av,Dd,ul,jv,Dv,Cd,gl,Cv,Iv,Id,_l,zv,Sv,zd,bl,Mv,Fv,Sd,wl,Lv,Uv,Md,vl,Ov,Gv,Fd,kl,Nv,Qv,Ld,Pl,Rv,Hv,Ud,Tl,Vv,Qu,dt,Tn,Od,vr,Wv,Gd,Zv,Ru,yn,Bv,Nd,Yv,Kv,Hu,yl,Xv,Vu,kr,Wu,xn,Jv,Pr,e1,t1,Zu,Tr,Bu,$n,n1,Qd,o1,r1,Yu,yr,Ku,En,s1,Rd,a1,i1,Xu,xr,Ju,xl,l1,eg,$r,tg,oe,Er,c1,qr,d1,$l,p1,m1,f1,Hd,h1,u1,pt,Ar,g1,El,_1,b1,w1,jr,v1,ql,k1,P1,T1,Vd,y1,x1,qn,ng,mt,An,Wd,Dr,$1,Zd,E1,og,Ne,q1,Bd,A1,j1,Yd,D1,C1,rg,Cr,sg,jn,ag,Ir,ig,zr,lg,Al,I1,cg,Sr,dg,Dn,z1,Kd,S1,M1,pg,Mr,mg,jl,F1,fg,Dl,L1,hg,ue,Xd,Jd,ep,U1,O1,tp,np,G1,N1,op,rp,Q1,R1,Fr,sp,H1,V1,ft,ap,W1,Z1,ip,B1,Y1,lp,K1,X1,cp,dp,J1,ug,ht,Cn,pp,Lr,ek,mp,tk,gg,Me,fp,nk,ok,hp,rk,sk,up,ak,ik,_g,Qe,lk,gp,ck,dk,_p,pk,mk,bg,Ur,wg,Cl,fk,vg,Or,kg,Il,hk,Pg,In,uk,bp,gk,_k,Tg,ut,zn,wp,Gr,bk,vp,wk,yg,zl,vk,xg,Sn,kk,kp,Pk,Tk,$g,Sl,yk,Eg,Ml,Pp,xk,qg,Nr,Ag,Fl,$k,jg,gt,Mn,Tp,Qr,Ek,yp,qk,Dg,Ll,Ul,Ak,Cg,_t,Fn,xp,Rr,jk,$p,Dk,Ig,bt,Ln,Ep,Hr,Ck,qp,Ik,zg,L,Vr,zk,Wr,Sk,Ap,Mk,Fk,Lk,Un,Uk,jp,Ol,Ok,Gk,wt,Nk,Gl,Qk,Rk,Dp,Hk,Vk,Wk,Zr,Zk,Br,Bk,Yk,Kk,On,Yr,Xk,Kr,Jk,Nl,eP,tP,Sg,vt,Gn,Cp,Xr,nP,Ip,oP,Mg,Z,Jr,rP,zp,sP,aP,Sp,iP,lP,Nn,cP,Mp,Ql,dP,pP,Qn,es,mP,ts,fP,Rl,hP,uP,Fg,kt,Rn,Fp,ns,gP,Lp,_P,Lg,U,os,bP,Fe,wP,Hl,vP,kP,Vl,PP,TP,Up,yP,xP,$P,Hn,EP,Vn,rs,qP,ss,AP,Op,jP,DP,CP,Wn,as,IP,Gp,zP,SP,Re,is,MP,Np,FP,LP,$e,UP,Qp,OP,GP,Rp,NP,QP,Hp,RP,HP,Vp,VP,WP,ZP,Zn,ls,BP,Le,YP,Wp,KP,XP,Zp,JP,eT,Bp,tT,nT,Ug,O,cs,oT,Yp,rT,sT,Bn,aT,Kp,Wl,iT,lT,Pt,cT,Zl,dT,pT,Xp,mT,fT,hT,Ee,uT,Jp,gT,_T,em,bT,wT,tm,vT,kT,ds,PT,TT,yT,Yn,ps,xT,nm,$T,Og,Tt,Kn,om,ms,ET,rm,qT,Gg,G,fs,AT,hs,jT,sm,DT,CT,IT,Xn,zT,am,Bl,ST,MT,yt,FT,Yl,LT,UT,im,OT,GT,NT,us,QT,gs,RT,HT,VT,Jn,_s,WT,lm,ZT,Ng,xt,eo,cm,bs,BT,dm,YT,Qg,N,ws,KT,vs,XT,pm,JT,e2,t2,to,n2,mm,Kl,o2,r2,$t,s2,Xl,a2,i2,fm,l2,c2,d2,ks,p2,Ps,m2,f2,h2,Ae,Ts,u2,ys,g2,hm,_2,b2,w2,um,v2,k2,Ue,gm,_m,P2,T2,bm,wm,y2,x2,vm,km,$2,E2,Pm,Tm,q2,Rg,Et,no,ym,xs,A2,xm,j2,Hg,Q,$s,D2,$m,C2,I2,oo,z2,Em,Jl,S2,M2,qt,F2,ec,L2,U2,qm,O2,G2,N2,Es,Q2,qs,R2,H2,V2,ro,As,W2,Am,Z2,Vg,At,so,jm,js,B2,Dm,Y2,Wg,S,Ds,K2,jt,X2,Cm,J2,ey,tc,ty,ny,oy,ao,ry,Im,nc,sy,ay,Dt,iy,oc,ly,cy,zm,dy,py,my,Cs,fy,Is,hy,uy,gy,io,_y,lo,zs,by,Sm,wy,Zg,Ct,co,Mm,Ss,vy,Fm,ky,Bg,re,Ms,Py,Fs,Ty,Lm,yy,xy,$y,It,Ey,rc,qy,Ay,Um,jy,Dy,Cy,Ls,Iy,Us,zy,Sy,My,po,Os,Fy,Om,Ly,Yg,zt,mo,Gm,Gs,Uy,Nm,Oy,Kg,se,Ns,Gy,Qs,Ny,Qm,Qy,Ry,Hy,St,Vy,sc,Wy,Zy,Rm,By,Yy,Ky,Rs,Xy,Hs,Jy,e0,t0,fo,Vs,n0,Hm,o0,Xg,Mt,ho,Vm,Ws,r0,Wm,s0,Jg,ae,Zs,a0,Bs,i0,Zm,l0,c0,d0,Bm,p0,m0,Ys,f0,Ks,h0,u0,g0,uo,Xs,_0,Ym,b0,e_,Ft,go,Km,Js,w0,Xm,v0,t_,M,ea,k0,Lt,P0,Jm,T0,y0,ac,x0,$0,E0,Ut,q0,ic,A0,j0,ef,D0,C0,I0,ta,z0,na,S0,M0,F0,He,oa,L0,tf,U0,O0,nf,G0,N0,_o,ra,Q0,of,R0,H0,bo,sa,V0,rf,W0,Z0,wo,aa,B0,sf,Y0,n_,vo,K0,lc,X0,J0,o_,Ot,ko,af,ia,ex,lf,tx,r_,ie,la,nx,ca,ox,cf,rx,sx,ax,Gt,ix,cc,lx,cx,df,dx,px,mx,da,fx,pa,hx,ux,gx,Po,ma,_x,pf,bx,s_,Nt,To,mf,fa,wx,ff,vx,a_,R,ha,kx,Qt,Px,hf,Tx,yx,dc,xx,$x,Ex,Rt,qx,pc,Ax,jx,uf,Dx,Cx,Ix,ua,zx,ga,Sx,Mx,Fx,yo,_a,Lx,gf,Ux,Ox,Ve,ba,Gx,Ht,Nx,_f,Qx,Rx,bf,Hx,Vx,Wx,wf,Zx,Bx,xo,wa,Yx,vf,Kx,i_,Vt,$o,kf,va,Xx,Pf,Jx,l_,B,ka,e$,Tf,t$,n$,Wt,o$,mc,r$,s$,yf,a$,i$,l$,F,c$,xf,d$,p$,$f,m$,f$,Ef,h$,u$,qf,g$,_$,Af,b$,w$,jf,v$,k$,Pa,P$,T$,Ta,y$,x$,Eo,$$,qo,ya,E$,Df,q$,c_,Zt,Ao,Cf,xa,A$,If,j$,d_,le,$a,D$,Ea,C$,zf,I$,z$,S$,Bt,M$,fc,F$,L$,Sf,U$,O$,G$,qa,N$,Aa,Q$,R$,H$,V,ja,V$,Mf,W$,Z$,Y,Ff,Lf,B$,Y$,Uf,Of,K$,X$,Gf,Nf,J$,e4,Qf,Rf,t4,n4,Hf,Vf,o4,r4,Wf,Zf,s4,a4,Bf,Yf,i4,l4,Da,c4,Kf,d4,p4,m4,jo,f4,Xf,h4,u4,Do,p_,Yt,Co,Jf,Ca,g4,eh,_4,m_,K,Ia,b4,Kt,w4,th,v4,k4,hc,P4,T4,y4,Xt,x4,uc,$4,E4,nh,q4,A4,j4,za,D4,oh,C4,I4,z4,Sa,S4,Ma,M4,F4,L4,Io,Fa,U4,rh,O4,f_,Jt,zo,sh,La,G4,ah,N4,h_,ce,Ua,Q4,Oa,R4,ih,H4,V4,W4,en,Z4,gc,B4,Y4,lh,K4,X4,J4,Ga,eE,Na,tE,nE,oE,So,Qa,rE,ch,sE,u_,tn,Mo,dh,Ra,aE,ph,iE,g_,H,Ha,lE,mh,cE,dE,nn,pE,_c,mE,fE,fh,hE,uE,gE,Fo,_E,Va,bE,wE,Wa,vE,kE,Lo,PE,Uo,Za,TE,hh,yE,xE,Oo,Ba,$E,uh,EE,__,on,Go,gh,Ya,qE,_h,AE,b_,z,Ka,jE,rn,DE,bh,CE,IE,bc,zE,SE,ME,sn,FE,wc,LE,UE,wh,OE,GE,NE,Xa,QE,Ja,RE,HE,VE,No,ei,WE,vh,ZE,BE,We,ti,YE,kh,KE,XE,Ph,JE,e3,Qo,ni,t3,Th,n3,o3,Ro,oi,r3,yh,s3,a3,Ho,ri,i3,xh,l3,w_,an,Vo,$h,si,c3,Eh,d3,v_,X,ai,p3,qh,m3,f3,ln,h3,vc,u3,g3,Ah,_3,b3,w3,Wo,v3,ii,k3,P3,li,T3,y3,Zo,x3,Bo,ci,$3,jh,E3,k_,cn,Yo,Dh,di,q3,Ch,A3,P_,de,pi,j3,mi,D3,Ih,C3,I3,z3,dn,S3,kc,M3,F3,zh,L3,U3,O3,fi,G3,hi,N3,Q3,R3,Ze,ui,H3,Sh,V3,W3,Oe,Mh,Fh,Z3,B3,Lh,Uh,Y3,K3,Oh,Gh,X3,J3,Nh,Qh,e5,T_,pn,Ko,Rh,gi,t5,Hh,n5,y_,J,_i,o5,bi,r5,Vh,s5,a5,i5,Ge,l5,Wh,c5,d5,Zh,p5,m5,Bh,f5,h5,u5,mn,g5,Pc,_5,b5,Yh,w5,v5,k5,wi,P5,vi,T5,y5,x5,Xo,ki,$5,Pi,E5,Tc,q5,A5,x_,fn,Jo,Kh,Ti,j5,Xh,D5,$_,pe,yi,C5,hn,I5,Jh,z5,S5,eu,M5,F5,L5,un,U5,yc,O5,G5,tu,N5,Q5,R5,xi,H5,$i,V5,W5,Z5,er,Ei,B5,nu,Y5,E_,gn,tr,ou,qi,K5,ru,X5,q_,me,Ai,J5,_n,eq,su,tq,nq,au,oq,rq,sq,bn,aq,xc,iq,lq,iu,cq,dq,pq,ji,mq,Di,fq,hq,uq,nr,Ci,gq,lu,_q,A_,wn,or,cu,Ii,bq,$c,wq,du,vq,j_,j,zi,kq,pu,Pq,Tq,mu,yq,xq,fu,$q,Eq,hu,qq,Aq,qe,jq,Ec,Dq,Cq,uu,Iq,zq,gu,Sq,Mq,_u,Fq,Lq,Uq,rr,Si,Oq,bu,Gq,Nq,Be,Mi,Qq,wu,Rq,Hq,sr,Vq,ar,Fi,Wq,vu,Zq,Bq,ir,Li,Yq,Ui,Kq,ku,Xq,Jq,eA,lr,Oi,tA,Gi,nA,Pu,oA,rA,sA,cr,Ni,aA,vn,iA,Tu,lA,cA,yu,dA,pA,mA,dr,Qi,fA,xu,hA,uA,pr,Ri,gA,Hi,_A,$u,bA,wA,D_;return p=new D({}),vr=new D({}),kr=new I({props:{code:`pipe = pipeline("text-classification")
pipe("This restaurant is awesome")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>pipe = pipeline(<span class="hljs-string">&quot;text-classification&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>pipe(<span class="hljs-string">&quot;This restaurant is awesome&quot;</span>)
[{<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;POSITIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.9998743534088135</span>}]`}}),Tr=new I({props:{code:`pipe = pipeline(model="roberta-large-mnli")
pipe("This restaurant is awesome")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>pipe = pipeline(model=<span class="hljs-string">&quot;roberta-large-mnli&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>pipe(<span class="hljs-string">&quot;This restaurant is awesome&quot;</span>)
[{<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;POSITIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.9998743534088135</span>}]`}}),yr=new I({props:{code:`pipe = pipeline("text-classification")
pipe(["This restaurant is awesome", "This restaurant is aweful"])`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>pipe = pipeline(<span class="hljs-string">&quot;text-classification&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>pipe([<span class="hljs-string">&quot;This restaurant is awesome&quot;</span>, <span class="hljs-string">&quot;This restaurant is aweful&quot;</span>])
[{<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;POSITIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.9998743534088135</span>},
 {<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;NEGATIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.9996669292449951</span>}]`}}),xr=new I({props:{code:`import datasets
from transformers import pipeline
from transformers.pipelines.pt_utils import KeyDataset
from tqdm.auto import tqdm

pipe = pipeline("automatic-speech-recognition", model="facebook/wav2vec2-base-960h", device=0)
dataset = datasets.load_dataset("superb", name="asr", split="test")

# KeyDataset (only *pt*) will simply return the item in the dict returned by the dataset item
# as we're not interested in the *target* part of the dataset. For sentence pair use KeyPairDataset
for out in tqdm(pipe(KeyDataset(dataset, "file"))):
    print(out)
    # {"text": "NUMBER TEN FRESH NELLY IS WAITING ON YOU GOOD NIGHT HUSBAND"}
    # {"text": ....}
    # ....`,highlighted:`<span class="hljs-keyword">import</span> datasets
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline
<span class="hljs-keyword">from</span> transformers.pipelines.pt_utils <span class="hljs-keyword">import</span> KeyDataset
<span class="hljs-keyword">from</span> tqdm.auto <span class="hljs-keyword">import</span> tqdm

pipe = pipeline(<span class="hljs-string">&quot;automatic-speech-recognition&quot;</span>, model=<span class="hljs-string">&quot;facebook/wav2vec2-base-960h&quot;</span>, device=<span class="hljs-number">0</span>)
dataset = datasets.load_dataset(<span class="hljs-string">&quot;superb&quot;</span>, name=<span class="hljs-string">&quot;asr&quot;</span>, split=<span class="hljs-string">&quot;test&quot;</span>)

<span class="hljs-comment"># KeyDataset (only *pt*) will simply return the item in the dict returned by the dataset item</span>
<span class="hljs-comment"># as we&#x27;re not interested in the *target* part of the dataset. For sentence pair use KeyPairDataset</span>
<span class="hljs-keyword">for</span> out <span class="hljs-keyword">in</span> tqdm(pipe(KeyDataset(dataset, <span class="hljs-string">&quot;file&quot;</span>))):
    <span class="hljs-built_in">print</span>(out)
    <span class="hljs-comment"># {&quot;text&quot;: &quot;NUMBER TEN FRESH NELLY IS WAITING ON YOU GOOD NIGHT HUSBAND&quot;}</span>
    <span class="hljs-comment"># {&quot;text&quot;: ....}</span>
    <span class="hljs-comment"># ....</span>`}}),$r=new I({props:{code:`from transformers import pipeline

pipe = pipeline("text-classification")


def data():
    while True:
        # This could come from a dataset, a database, a queue or HTTP request
        # in a server
        # Caveat: because this is iterative, you cannot use \`num_workers > 1\` variable
        # to use multiple threads to preprocess data. You can still have 1 thread that
        # does the preprocessing while the main runs the big inference
        yield "This is a test"


for out in pipe(data()):
    print(out)
    # {"text": "NUMBER TEN FRESH NELLY IS WAITING ON YOU GOOD NIGHT HUSBAND"}
    # {"text": ....}
    # ....`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

pipe = pipeline(<span class="hljs-string">&quot;text-classification&quot;</span>)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">data</span>():
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-comment"># This could come from a dataset, a database, a queue or HTTP request</span>
        <span class="hljs-comment"># in a server</span>
        <span class="hljs-comment"># Caveat: because this is iterative, you cannot use \`num_workers &gt; 1\` variable</span>
        <span class="hljs-comment"># to use multiple threads to preprocess data. You can still have 1 thread that</span>
        <span class="hljs-comment"># does the preprocessing while the main runs the big inference</span>
        <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;This is a test&quot;</span>


<span class="hljs-keyword">for</span> out <span class="hljs-keyword">in</span> pipe(data()):
    <span class="hljs-built_in">print</span>(out)
    <span class="hljs-comment"># {&quot;text&quot;: &quot;NUMBER TEN FRESH NELLY IS WAITING ON YOU GOOD NIGHT HUSBAND&quot;}</span>
    <span class="hljs-comment"># {&quot;text&quot;: ....}</span>
    <span class="hljs-comment"># ....</span>`}}),Er=new x({props:{name:"transformers.pipeline",anchor:"transformers.pipeline",parameters:[{name:"task",val:": str = None"},{name:"model",val:": typing.Optional = None"},{name:"config",val:": typing.Union[str, transformers.configuration_utils.PretrainedConfig, NoneType] = None"},{name:"tokenizer",val:": typing.Union[str, transformers.tokenization_utils.PreTrainedTokenizer, transformers.tokenization_utils_fast.PreTrainedTokenizerFast, NoneType] = None"},{name:"feature_extractor",val:": typing.Union[str, ForwardRef('SequenceFeatureExtractor'), NoneType] = None"},{name:"framework",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"use_fast",val:": bool = True"},{name:"use_auth_token",val:": typing.Union[str, bool, NoneType] = None"},{name:"device",val:": typing.Union[int, str, ForwardRef('torch.device'), NoneType] = None"},{name:"device_map",val:" = None"},{name:"torch_dtype",val:" = None"},{name:"trust_remote_code",val:": typing.Optional[bool] = None"},{name:"model_kwargs",val:": typing.Dict[str, typing.Any] = None"},{name:"pipeline_class",val:": typing.Optional[typing.Any] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.pipeline.task",description:`<strong>task</strong> (<code>str</code>) &#x2014;
The task defining which pipeline will be returned. Currently accepted tasks are:</p>
<ul>
<li><code>&quot;audio-classification&quot;</code>: will return a <a href="/docs/transformers/main/en/main_classes/pipelines#transformers.AudioClassificationPipeline">AudioClassificationPipeline</a>.</li>
<li><code>&quot;automatic-speech-recognition&quot;</code>: will return a <a href="/docs/transformers/main/en/main_classes/pipelines#transformers.AutomaticSpeechRecognitionPipeline">AutomaticSpeechRecognitionPipeline</a>.</li>
<li><code>&quot;conversational&quot;</code>: will return a <a href="/docs/transformers/main/en/main_classes/pipelines#transformers.ConversationalPipeline">ConversationalPipeline</a>.</li>
<li><code>&quot;feature-extraction&quot;</code>: will return a <a href="/docs/transformers/main/en/main_classes/pipelines#transformers.FeatureExtractionPipeline">FeatureExtractionPipeline</a>.</li>
<li><code>&quot;fill-mask&quot;</code>: will return a <a href="/docs/transformers/main/en/main_classes/pipelines#transformers.FillMaskPipeline">FillMaskPipeline</a>:.</li>
<li><code>&quot;image-classification&quot;</code>: will return a <a href="/docs/transformers/main/en/main_classes/pipelines#transformers.ImageClassificationPipeline">ImageClassificationPipeline</a>.</li>
<li><code>&quot;question-answering&quot;</code>: will return a <a href="/docs/transformers/main/en/main_classes/pipelines#transformers.QuestionAnsweringPipeline">QuestionAnsweringPipeline</a>.</li>
<li><code>&quot;table-question-answering&quot;</code>: will return a <a href="/docs/transformers/main/en/main_classes/pipelines#transformers.TableQuestionAnsweringPipeline">TableQuestionAnsweringPipeline</a>.</li>
<li><code>&quot;text2text-generation&quot;</code>: will return a <a href="/docs/transformers/main/en/main_classes/pipelines#transformers.Text2TextGenerationPipeline">Text2TextGenerationPipeline</a>.</li>
<li><code>&quot;text-classification&quot;</code> (alias <code>&quot;sentiment-analysis&quot;</code> available): will return a
<a href="/docs/transformers/main/en/main_classes/pipelines#transformers.TextClassificationPipeline">TextClassificationPipeline</a>.</li>
<li><code>&quot;text-generation&quot;</code>: will return a <a href="/docs/transformers/main/en/main_classes/pipelines#transformers.TextGenerationPipeline">TextGenerationPipeline</a>:.</li>
<li><code>&quot;token-classification&quot;</code> (alias <code>&quot;ner&quot;</code> available): will return a <a href="/docs/transformers/main/en/main_classes/pipelines#transformers.TokenClassificationPipeline">TokenClassificationPipeline</a>.</li>
<li><code>&quot;translation&quot;</code>: will return a <a href="/docs/transformers/main/en/main_classes/pipelines#transformers.TranslationPipeline">TranslationPipeline</a>.</li>
<li><code>&quot;translation_xx_to_yy&quot;</code>: will return a <a href="/docs/transformers/main/en/main_classes/pipelines#transformers.TranslationPipeline">TranslationPipeline</a>.</li>
<li><code>&quot;summarization&quot;</code>: will return a <a href="/docs/transformers/main/en/main_classes/pipelines#transformers.SummarizationPipeline">SummarizationPipeline</a>.</li>
<li><code>&quot;zero-shot-classification&quot;</code>: will return a <a href="/docs/transformers/main/en/main_classes/pipelines#transformers.ZeroShotClassificationPipeline">ZeroShotClassificationPipeline</a>.</li>
</ul>`,name:"task"},{anchor:"transformers.pipeline.model",description:`<strong>model</strong> (<code>str</code> or <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>, <em>optional</em>) &#x2014;
The model that will be used by the pipeline to make predictions. This can be a model identifier or an
actual instance of a pretrained model inheriting from <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> (for PyTorch) or
<a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> (for TensorFlow).</p>
<p>If not provided, the default for the <code>task</code> will be loaded.`,name:"model"},{anchor:"transformers.pipeline.config",description:`<strong>config</strong> (<code>str</code> or <a href="/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig">PretrainedConfig</a>, <em>optional</em>) &#x2014;
The configuration that will be used by the pipeline to instantiate the model. This can be a model
identifier or an actual pretrained model configuration inheriting from <a href="/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig">PretrainedConfig</a>.</p>
<p>If not provided, the default configuration file for the requested model will be used. That means that if
<code>model</code> is given, its default configuration will be used. However, if <code>model</code> is not supplied, this
<code>task</code>&#x2019;s default model&#x2019;s config is used instead.`,name:"config"},{anchor:"transformers.pipeline.tokenizer",description:`<strong>tokenizer</strong> (<code>str</code> or <a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>, <em>optional</em>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This can be a model
identifier or an actual pretrained tokenizer inheriting from <a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.</p>
<p>If not provided, the default tokenizer for the given <code>model</code> will be loaded (if it is a string). If <code>model</code>
is not specified or not a string, then the default tokenizer for <code>config</code> is loaded (if it is a string).
However, if <code>config</code> is also not given or not a string, then the default tokenizer for the given <code>task</code>
will be loaded.`,name:"tokenizer"},{anchor:"transformers.pipeline.feature_extractor",description:`<strong>feature_extractor</strong> (<code>str</code> or <code>PreTrainedFeatureExtractor</code>, <em>optional</em>) &#x2014;
The feature extractor that will be used by the pipeline to encode data for the model. This can be a model
identifier or an actual pretrained feature extractor inheriting from <code>PreTrainedFeatureExtractor</code>.</p>
<p>Feature extractors are used for non-NLP models, such as Speech or Vision models as well as multi-modal
models. Multi-modal models will also require a tokenizer to be passed.</p>
<p>If not provided, the default feature extractor for the given <code>model</code> will be loaded (if it is a string). If
<code>model</code> is not specified or not a string, then the default feature extractor for <code>config</code> is loaded (if it
is a string). However, if <code>config</code> is also not given or not a string, then the default feature extractor
for the given <code>task</code> will be loaded.`,name:"feature_extractor"},{anchor:"transformers.pipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.pipeline.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;main&quot;</code>) &#x2014;
When passing a task name or a string model identifier: The specific model version to use. It can be a
branch name, a tag name, or a commit id, since we use a git-based system for storing models and other
artifacts on huggingface.co, so <code>revision</code> can be any identifier allowed by git.`,name:"revision"},{anchor:"transformers.pipeline.use_fast",description:`<strong>use_fast</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to use a Fast tokenizer if possible (a <a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast">PreTrainedTokenizerFast</a>).`,name:"use_fast"},{anchor:"transformers.pipeline.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code> or <em>bool</em>, <em>optional</em>) &#x2014;
The token to use as HTTP bearer authorization for remote files. If <code>True</code>, will use the token generated
when running <code>huggingface-cli login</code> (stored in <code>~/.huggingface</code>).`,name:"use_auth_token"},{anchor:"transformers.pipeline.device",description:`<strong>device</strong> (<code>int</code> or <code>str</code> or <code>torch.device</code>) &#x2014;
Defines the device (<em>e.g.</em>, <code>&quot;cpu&quot;</code>, <code>&quot;cuda:1&quot;</code>, <code>&quot;mps&quot;</code>, or a GPU ordinal rank like <code>1</code>) on which this
pipeline will be allocated.`,name:"device"},{anchor:"transformers.pipeline.device_map",description:`<strong>device_map</strong> (<code>str</code> or <code>Dict[str, Union[int, str, torch.device]</code>, <em>optional</em>) &#x2014;
Sent directly as <code>model_kwargs</code> (just a simpler shortcut). When <code>accelerate</code> library is present, set
<code>device_map=&quot;auto&quot;</code> to compute the most optimized <code>device_map</code> automatically. <a href="https://huggingface.co/docs/accelerate/main/en/big_modeling#accelerate.cpu_offload" rel="nofollow">More
information</a></p>
<div class="course-tip course-tip-orange bg-gradient-to-br dark:bg-gradient-to-r before:border-orange-500 dark:before:border-orange-800 from-orange-50 dark:from-gray-900 to-white dark:to-gray-950 border border-orange-50 text-orange-700 dark:text-gray-400">
						
<p>Do not use <code>device_map</code> AND <code>device</code> at the same time as they will conflict</p>

					</div>`,name:"device_map"},{anchor:"transformers.pipeline.torch_dtype",description:`<strong>torch_dtype</strong> (<code>str</code> or <code>torch.dtype</code>, <em>optional</em>) &#x2014;
Sent directly as <code>model_kwargs</code> (just a simpler shortcut) to use the available precision for this model
(<code>torch.float16</code>, <code>torch.bfloat16</code>, &#x2026; or <code>&quot;auto&quot;</code>).`,name:"torch_dtype"},{anchor:"transformers.pipeline.trust_remote_code",description:`<strong>trust_remote_code</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to allow for custom code defined on the Hub in their own modeling, configuration,
tokenization or even pipeline files. This option should only be set to <code>True</code> for repositories you trust
and in which you have read the code, as it will execute code present on the Hub on your local machine.
model_kwargs &#x2014;
Additional dictionary of keyword arguments passed along to the model&#x2019;s <code>from_pretrained(..., **model_kwargs)</code> function.
kwargs &#x2014;
Additional keyword arguments passed along to the specific pipeline init (see the documentation for the
corresponding pipeline class for possible values).`,name:"trust_remote_code"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/__init__.py#L459",returnDescription:`
<p>A suitable pipeline for the task.</p>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/pipelines#transformers.Pipeline"
>Pipeline</a></p>
`}}),qn=new fe({props:{anchor:"transformers.pipeline.example",$$slots:{default:[cz]},$$scope:{ctx:A}}}),Dr=new D({}),Cr=new I({props:{code:`from transformers import pipeline
from transformers.pipelines.pt_utils import KeyDataset
import datasets

dataset = datasets.load_dataset("imdb", name="plain_text", split="unsupervised")
pipe = pipeline("text-classification", device=0)
for out in pipe(KeyDataset(dataset, "text"), batch_size=8, truncation="only_first"):
    print(out)
    # [{'label': 'POSITIVE', 'score': 0.9998743534088135}]
    # Exactly the same output as before, but the content are passed
    # as batches to the model`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline
<span class="hljs-keyword">from</span> transformers.pipelines.pt_utils <span class="hljs-keyword">import</span> KeyDataset
<span class="hljs-keyword">import</span> datasets

dataset = datasets.load_dataset(<span class="hljs-string">&quot;imdb&quot;</span>, name=<span class="hljs-string">&quot;plain_text&quot;</span>, split=<span class="hljs-string">&quot;unsupervised&quot;</span>)
pipe = pipeline(<span class="hljs-string">&quot;text-classification&quot;</span>, device=<span class="hljs-number">0</span>)
<span class="hljs-keyword">for</span> out <span class="hljs-keyword">in</span> pipe(KeyDataset(dataset, <span class="hljs-string">&quot;text&quot;</span>), batch_size=<span class="hljs-number">8</span>, truncation=<span class="hljs-string">&quot;only_first&quot;</span>):
    <span class="hljs-built_in">print</span>(out)
    <span class="hljs-comment"># [{&#x27;label&#x27;: &#x27;POSITIVE&#x27;, &#x27;score&#x27;: 0.9998743534088135}]</span>
    <span class="hljs-comment"># Exactly the same output as before, but the content are passed</span>
    <span class="hljs-comment"># as batches to the model</span>`}}),jn=new oz({props:{warning:!0,$$slots:{default:[dz]},$$scope:{ctx:A}}}),Ir=new I({props:{code:`from transformers import pipeline
from torch.utils.data import Dataset
from tqdm.auto import tqdm

pipe = pipeline("text-classification", device=0)


class MyDataset(Dataset):
    def __len__(self):
        return 5000

    def __getitem__(self, i):
        return "This is a test"


dataset = MyDataset()

for batch_size in [1, 8, 64, 256]:
    print("-" * 30)
    print(f"Streaming batch_size={batch_size}")
    for out in tqdm(pipe(dataset, batch_size=batch_size), total=len(dataset)):
        pass`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline
<span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset
<span class="hljs-keyword">from</span> tqdm.auto <span class="hljs-keyword">import</span> tqdm

pipe = pipeline(<span class="hljs-string">&quot;text-classification&quot;</span>, device=<span class="hljs-number">0</span>)


<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDataset</span>(<span class="hljs-title class_ inherited__">Dataset</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-number">5000</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, i</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This is a test&quot;</span>


dataset = MyDataset()

<span class="hljs-keyword">for</span> batch_size <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">64</span>, <span class="hljs-number">256</span>]:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">30</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Streaming batch_size=<span class="hljs-subst">{batch_size}</span>&quot;</span>)
    <span class="hljs-keyword">for</span> out <span class="hljs-keyword">in</span> tqdm(pipe(dataset, batch_size=batch_size), total=<span class="hljs-built_in">len</span>(dataset)):
        <span class="hljs-keyword">pass</span>`}}),zr=new I({props:{code:`# On GTX 970
------------------------------
Streaming no batching
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:26<00:00, 187.52it/s]
------------------------------
Streaming batch_size=8
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:04<00:00, 1205.95it/s]
------------------------------
Streaming batch_size=64
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:02<00:00, 2478.24it/s]
------------------------------
Streaming batch_size=256
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:01<00:00, 2554.43it/s]
(diminishing returns, saturated the GPU)`,highlighted:`<span class="hljs-section"># On GTX 970
------------------------------</span>
Streaming no batching
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:26&lt;00:00, 187.52it/s]
<span class="hljs-code">------------------------------
Streaming batch_size=8
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:04&lt;00:00, 1205.95it/s]
------------------------------</span>
Streaming batch<span class="hljs-emphasis">_size=64
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:02&lt;00:00, 2478.24it/s]
------------------------------
Streaming batch_</span>size=256
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5000/5000 [00:01&lt;00:00, 2554.43it/s]
(diminishing returns, saturated the GPU)`}}),Sr=new I({props:{code:`class MyDataset(Dataset):
    def __len__(self):
        return 5000

    def __getitem__(self, i):
        if i % 64 == 0:
            n = 100
        else:
            n = 1
        return "This is a test" * n`,highlighted:`<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDataset</span>(<span class="hljs-title class_ inherited__">Dataset</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-number">5000</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, i</span>):
        <span class="hljs-keyword">if</span> i % <span class="hljs-number">64</span> == <span class="hljs-number">0</span>:
            n = <span class="hljs-number">100</span>
        <span class="hljs-keyword">else</span>:
            n = <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This is a test&quot;</span> * n`}}),Mr=new I({props:{code:`------------------------------
Streaming no batching
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:05<00:00, 183.69it/s]
------------------------------
Streaming batch_size=8
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:03<00:00, 265.74it/s]
------------------------------
Streaming batch_size=64
100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1000/1000 [00:26<00:00, 37.80it/s]
------------------------------
Streaming batch_size=256
  0%|                                                                                 | 0/1000 [00:00<?, ?it/s]
Traceback (most recent call last):
  File "/home/nicolas/src/transformers/test.py", line 42, in <module>
    for out in tqdm(pipe(dataset, batch_size=256), total=len(dataset)):
....
    q = q / math.sqrt(dim_per_head)  # (bs, n_heads, q_length, dim_per_head)
RuntimeError: CUDA out of memory. Tried to allocate 376.00 MiB (GPU 0; 3.95 GiB total capacity; 1.72 GiB already allocated; 354.88 MiB free; 2.46 GiB reserved in total by PyTorch)`,highlighted:`<span class="hljs-comment">------------------------------</span>
Streaming no batching
<span class="hljs-number">100</span>%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| <span class="hljs-number">1000</span>/<span class="hljs-number">1000</span> [<span class="hljs-number">00</span>:<span class="hljs-number">05</span>&lt;<span class="hljs-number">00</span>:<span class="hljs-number">00</span>, <span class="hljs-number">183.69</span><span class="hljs-keyword">it</span>/s]
<span class="hljs-comment">------------------------------</span>
Streaming batch_size=<span class="hljs-number">8</span>
<span class="hljs-number">100</span>%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| <span class="hljs-number">1000</span>/<span class="hljs-number">1000</span> [<span class="hljs-number">00</span>:<span class="hljs-number">03</span>&lt;<span class="hljs-number">00</span>:<span class="hljs-number">00</span>, <span class="hljs-number">265.74</span><span class="hljs-keyword">it</span>/s]
<span class="hljs-comment">------------------------------</span>
Streaming batch_size=<span class="hljs-number">64</span>
<span class="hljs-number">100</span>%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| <span class="hljs-number">1000</span>/<span class="hljs-number">1000</span> [<span class="hljs-number">00</span>:<span class="hljs-number">26</span>&lt;<span class="hljs-number">00</span>:<span class="hljs-number">00</span>, <span class="hljs-number">37.80</span><span class="hljs-keyword">it</span>/s]
<span class="hljs-comment">------------------------------</span>
Streaming batch_size=<span class="hljs-number">256</span>
  <span class="hljs-number">0</span>%|                                                                                 | <span class="hljs-number">0</span>/<span class="hljs-number">1000</span> [<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-meta">&lt;?</span>, ?<span class="hljs-keyword">it</span>/s]
Traceback (most recent call <span class="hljs-keyword">last</span>):
  File <span class="hljs-string">&quot;/home/nicolas/src/transformers/test.py&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">42</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    <span class="hljs-keyword">for</span> out <span class="hljs-keyword">in</span> tqdm(pipe(dataset, batch_size=<span class="hljs-number">256</span>), total=<span class="hljs-built_in">len</span>(dataset)):
....
    q = q / math.<span class="hljs-built_in">sqrt</span>(dim_per_head)  <span class="hljs-comment"># (bs, n_heads, q_length, dim_per_head)</span>
RuntimeError: CUDA out <span class="hljs-keyword">of</span> memory. Tried <span class="hljs-built_in">to</span> allocate <span class="hljs-number">376.00</span> MiB (GPU <span class="hljs-number">0</span>; <span class="hljs-number">3.95</span> GiB total capacity; <span class="hljs-number">1.72</span> GiB already allocated; <span class="hljs-number">354.88</span> MiB free; <span class="hljs-number">2.46</span> GiB reserved <span class="hljs-keyword">in</span> total <span class="hljs-keyword">by</span> PyTorch)`}}),Lr=new D({}),Ur=new I({props:{code:`preprocessed = pipe.preprocess(inputs)
model_outputs = pipe.forward(preprocessed)
outputs = pipe.postprocess(model_outputs)`,highlighted:`preprocessed = pipe.preprocess(inputs)
model_outputs = pipe.forward(preprocessed)
outputs = pipe.postprocess(model_outputs)`}}),Or=new I({props:{code:`all_model_outputs = []
for preprocessed in pipe.preprocess(inputs):
    model_outputs = pipe.forward(preprocessed)
    all_model_outputs.append(model_outputs)
outputs = pipe.postprocess(all_model_outputs)`,highlighted:`all_model_outputs = []
<span class="hljs-keyword">for</span> preprocessed <span class="hljs-keyword">in</span> pipe.preprocess(inputs):
    model_outputs = pipe.forward(preprocessed)
    all_model_outputs.append(model_outputs)
outputs = pipe.postprocess(all_model_outputs)`}}),Gr=new D({}),Nr=new I({props:{code:`class MyPipeline(TextClassificationPipeline):
    def postprocess():
        # Your code goes here
        scores = scores * 100
        # And here


my_pipeline = MyPipeline(model=model, tokenizer=tokenizer, ...)
# or if you use *pipeline* function, then:
my_pipeline = pipeline(model="xxxx", pipeline_class=MyPipeline)`,highlighted:`<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPipeline</span>(<span class="hljs-title class_ inherited__">TextClassificationPipeline</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">postprocess</span>():
        <span class="hljs-comment"># Your code goes here</span>
        scores = scores * <span class="hljs-number">100</span>
        <span class="hljs-comment"># And here</span>


my_pipeline = MyPipeline(model=model, tokenizer=tokenizer, ...)
<span class="hljs-comment"># or if you use *pipeline* function, then:</span>
my_pipeline = pipeline(model=<span class="hljs-string">&quot;xxxx&quot;</span>, pipeline_class=MyPipeline)`}}),Qr=new D({}),Rr=new D({}),Hr=new D({}),Vr=new x({props:{name:"class transformers.AudioClassificationPipeline",anchor:"transformers.AudioClassificationPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.AudioClassificationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.AudioClassificationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.AudioClassificationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.AudioClassificationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.AudioClassificationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.AudioClassificationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.AudioClassificationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.AudioClassificationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.AudioClassificationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.AudioClassificationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/audio_classification.py#L68"}}),Un=new fe({props:{anchor:"transformers.AudioClassificationPipeline.example",$$slots:{default:[pz]},$$scope:{ctx:A}}}),Yr=new x({props:{name:"__call__",anchor:"transformers.AudioClassificationPipeline.__call__",parameters:[{name:"inputs",val:": typing.Union[numpy.ndarray, bytes, str]"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.AudioClassificationPipeline.__call__.inputs",description:`<strong>inputs</strong> (<code>np.ndarray</code> or <code>bytes</code> or <code>str</code>) &#x2014;
The inputs is either a raw waveform (<code>np.ndarray</code> of shape (n, ) of type <code>np.float32</code> or <code>np.float64</code>)
at the correct sampling rate (no further check will be done) or a <code>str</code> that is the filename of the
audio file, the file will be read at the correct sampling rate to get the waveform using <em>ffmpeg</em>. This
requires <em>ffmpeg</em> to be installed on the system. If <em>inputs</em> is <code>bytes</code> it is supposed to be the
content of an audio file and is interpreted by <em>ffmpeg</em> in the same way.`,name:"inputs"},{anchor:"transformers.AudioClassificationPipeline.__call__.top_k",description:`<strong>top_k</strong> (<code>int</code>, <em>optional</em>, defaults to None) &#x2014;
The number of top labels that will be returned by the pipeline. If the provided number is <code>None</code> or
higher than the number of labels available in the model configuration, it will default to the number of
labels.`,name:"top_k"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/audio_classification.py#L109",returnDescription:`
<ul>
<li><strong>label</strong> (<code>str</code>) \u2014 The label predicted.</li>
<li><strong>score</strong> (<code>float</code>) \u2014 The corresponding probability.</li>
</ul>
`,returnType:`
<p>A list of <code>dict</code> with the following keys</p>
`}}),Xr=new D({}),Jr=new x({props:{name:"class transformers.AutomaticSpeechRecognitionPipeline",anchor:"transformers.AutomaticSpeechRecognitionPipeline",parameters:[{name:"feature_extractor",val:": typing.Union[ForwardRef('SequenceFeatureExtractor'), str]"},{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.AutomaticSpeechRecognitionPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.AutomaticSpeechRecognitionPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.AutomaticSpeechRecognitionPipeline.feature_extractor",description:`<strong>feature_extractor</strong> (<a href="/docs/transformers/main/en/main_classes/feature_extractor#transformers.SequenceFeatureExtractor">SequenceFeatureExtractor</a>) &#x2014;
The feature extractor that will be used by the pipeline to encode waveform for the model.`,name:"feature_extractor"},{anchor:"transformers.AutomaticSpeechRecognitionPipeline.chunk_length_s",description:`<strong>chunk_length_s</strong> (<code>float</code>, <em>optional</em>, defaults to 0) &#x2014;
The input length for in each chunk. If <code>chunk_length_s = 0</code> then chunking is disabled (default). Only
available for CTC models, e.g. <a href="/docs/transformers/main/en/model_doc/wav2vec2#transformers.Wav2Vec2ForCTC">Wav2Vec2ForCTC</a>.</p>
<div class="course-tip  bg-gradient-to-br dark:bg-gradient-to-r before:border-green-500 dark:before:border-green-800 from-green-50 dark:from-gray-900 to-white dark:to-gray-950 border border-green-50 text-green-700 dark:text-gray-400">
						
<p>For more information on how to effectively use <code>chunk_length_s</code>, please have a look at the <a href="https://huggingface.co/blog/asr-chunking" rel="nofollow">ASR chunking
blog post</a>.</p>

					</div>`,name:"chunk_length_s"},{anchor:"transformers.AutomaticSpeechRecognitionPipeline.stride_length_s",description:`<strong>stride_length_s</strong> (<code>float</code>, <em>optional</em>, defaults to <code>chunk_length_s / 6</code>) &#x2014;
The length of stride on the left and right of each chunk. Used only with <code>chunk_length_s &gt; 0</code>. This enables
the model to <em>see</em> more context and infer letters better than without this context but the pipeline
discards the stride bits at the end to make the final reconstitution as perfect as possible.</p>
<div class="course-tip  bg-gradient-to-br dark:bg-gradient-to-r before:border-green-500 dark:before:border-green-800 from-green-50 dark:from-gray-900 to-white dark:to-gray-950 border border-green-50 text-green-700 dark:text-gray-400">
						
<p>For more information on how to effectively use <code>stride_length_s</code>, please have a look at the <a href="https://huggingface.co/blog/asr-chunking" rel="nofollow">ASR chunking
blog post</a>.</p>

					</div>`,name:"stride_length_s"},{anchor:"transformers.AutomaticSpeechRecognitionPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed. If no framework is specified, will default to the one currently installed. If no framework is
specified and both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if
no model is provided.`,name:"framework"},{anchor:"transformers.AutomaticSpeechRecognitionPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"},{anchor:"transformers.AutomaticSpeechRecognitionPipeline.decoder",description:`<strong>decoder</strong> (<code>pyctcdecode.BeamSearchDecoderCTC</code>, <em>optional</em>) &#x2014;
<a href="https://github.com/kensho-technologies/pyctcdecode/blob/2fd33dc37c4111417e08d89ccd23d28e9b308d19/pyctcdecode/decoder.py#L180" rel="nofollow">PyCTCDecode&#x2019;s
BeamSearchDecoderCTC</a>
can be passed for language model boosted decoding. See <a href="/docs/transformers/main/en/model_doc/wav2vec2#transformers.Wav2Vec2ProcessorWithLM">Wav2Vec2ProcessorWithLM</a> for more information.`,name:"decoder"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/automatic_speech_recognition.py#L104"}}),Nn=new fe({props:{anchor:"transformers.AutomaticSpeechRecognitionPipeline.example",$$slots:{default:[mz]},$$scope:{ctx:A}}}),es=new x({props:{name:"__call__",anchor:"transformers.AutomaticSpeechRecognitionPipeline.__call__",parameters:[{name:"inputs",val:": typing.Union[numpy.ndarray, bytes, str]"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.AutomaticSpeechRecognitionPipeline.__call__.inputs",description:`<strong>inputs</strong> (<code>np.ndarray</code> or <code>bytes</code> or <code>str</code> or <code>dict</code>) &#x2014;
The inputs is either :<ul>
<li><code>str</code> that is the filename of the audio file, the file will be read at the correct sampling rate
to get the waveform using <em>ffmpeg</em>. This requires <em>ffmpeg</em> to be installed on the system.</li>
<li><code>bytes</code> it is supposed to be the content of an audio file and is interpreted by <em>ffmpeg</em> in the
same way.</li>
<li>(<code>np.ndarray</code> of shape (n, ) of type <code>np.float32</code> or <code>np.float64</code>)
Raw audio at the correct sampling rate (no further check will be done)</li>
<li><code>dict</code> form can be used to pass raw audio sampled at arbitrary <code>sampling_rate</code> and let this
pipeline do the resampling. The dict must be in the format <code>{&quot;sampling_rate&quot;: int, &quot;raw&quot;: np.array}</code> with optionally a <code>&quot;stride&quot;: (left: int, right: int)</code> than can ask the pipeline to
treat the first <code>left</code> samples and last <code>right</code> samples to be ignored in decoding (but used at
inference to provide more context to the model). Only use <code>stride</code> with CTC models.</li>
</ul>`,name:"inputs"},{anchor:"transformers.AutomaticSpeechRecognitionPipeline.__call__.return_timestamps",description:`<strong>return_timestamps</strong> (<em>optional</em>, <code>str</code>) &#x2014;
Only available for pure CTC models. If set to <code>&quot;char&quot;</code>, the pipeline will return <code>timestamps</code> along the
text for every character in the text. For instance if you get <code>[{&quot;text&quot;: &quot;h&quot;, &quot;timestamps&quot;: (0.5,0.6), {&quot;text&quot;: &quot;i&quot;, &quot;timestamps&quot;: (0.7, .9)}]</code>, then it means the model predicts that the letter &#x201C;h&#x201D; was
pronounced after <code>0.5</code> and before <code>0.6</code> seconds. If set to <code>&quot;word&quot;</code>, the pipeline will return
<code>timestamps</code> along the text for every word in the text. For instance if you get <code>[{&quot;text&quot;: &quot;hi &quot;, &quot;timestamps&quot;: (0.5,0.9), {&quot;text&quot;: &quot;there&quot;, &quot;timestamps&quot;: (1.0, .1.5)}]</code>, then it means the model
predicts that the word &#x201C;hi&#x201D; was pronounced after <code>0.5</code> and before <code>0.9</code> seconds.`,name:"return_timestamps"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/automatic_speech_recognition.py#L191",returnDescription:`
<p>A dictionary with the following keys:</p>
<ul>
<li><strong>text</strong> (<code>str</code> ) \u2014 The recognized text.</li>
<li><strong>chunks</strong> (<em>optional(, <code>List[Dict]</code>)
When using <code>return_timestamps</code>, the <code>chunks</code> will become a list containing all the various text
chunks identified by the model, </em>e.g.* <code>[&#123;"text": "hi ", "timestamps": (0.5,0.9), &#123;"text": "there", "timestamps": (1.0, 1.5)&#125;]</code>. The original full text can roughly be recovered by doing
<code>"".join(chunk["text"] for chunk in output["chunks"])</code>.</li>
</ul>
`,returnType:`
<p><code>Dict</code></p>
`}}),ns=new D({}),os=new x({props:{name:"class transformers.Conversation",anchor:"transformers.Conversation",parameters:[{name:"text",val:": str = None"},{name:"conversation_id",val:": UUID = None"},{name:"past_user_inputs",val:" = None"},{name:"generated_responses",val:" = None"}],parametersDescription:[{anchor:"transformers.Conversation.text",description:`<strong>text</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The initial user input to start the conversation. If not provided, a user input needs to be provided
manually using the <a href="/docs/transformers/main/en/main_classes/pipelines#transformers.Conversation.add_user_input">add_user_input()</a> method before the conversation can begin.`,name:"text"},{anchor:"transformers.Conversation.conversation_id",description:`<strong>conversation_id</strong> (<code>uuid.UUID</code>, <em>optional</em>) &#x2014;
Unique identifier for the conversation. If not provided, a random UUID4 id will be assigned to the
conversation.`,name:"conversation_id"},{anchor:"transformers.Conversation.past_user_inputs",description:`<strong>past_user_inputs</strong> (<code>List[str]</code>, <em>optional</em>) &#x2014;
Eventual past history of the conversation of the user. You don&#x2019;t need to pass it manually if you use the
pipeline interactively but if you want to recreate history you need to set both <code>past_user_inputs</code> and
<code>generated_responses</code> with equal length lists of strings`,name:"past_user_inputs"},{anchor:"transformers.Conversation.generated_responses",description:`<strong>generated_responses</strong> (<code>List[str]</code>, <em>optional</em>) &#x2014;
Eventual past history of the conversation of the model. You don&#x2019;t need to pass it manually if you use the
pipeline interactively but if you want to recreate history you need to set both <code>past_user_inputs</code> and
<code>generated_responses</code> with equal length lists of strings`,name:"generated_responses"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/conversational.py#L18"}}),Hn=new fe({props:{anchor:"transformers.Conversation.example",$$slots:{default:[fz]},$$scope:{ctx:A}}}),rs=new x({props:{name:"add_user_input",anchor:"transformers.Conversation.add_user_input",parameters:[{name:"text",val:": str"},{name:"overwrite",val:": bool = False"}],parametersDescription:[{anchor:"transformers.Conversation.add_user_input.text",description:"<strong>text</strong> (<code>str</code>) &#x2014; The user input for the next conversation round.",name:"text"},{anchor:"transformers.Conversation.add_user_input.overwrite",description:`<strong>overwrite</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not existing and unprocessed user input should be overwritten when this function is called.`,name:"overwrite"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/conversational.py#L82"}}),as=new x({props:{name:"append_response",anchor:"transformers.Conversation.append_response",parameters:[{name:"response",val:": str"}],parametersDescription:[{anchor:"transformers.Conversation.append_response.response",description:"<strong>response</strong> (<code>str</code>) &#x2014; The model generated response.",name:"response"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/conversational.py#L115"}}),is=new x({props:{name:"iter_texts",anchor:"transformers.Conversation.iter_texts",parameters:[],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/conversational.py#L124"}}),ls=new x({props:{name:"mark_processed",anchor:"transformers.Conversation.mark_processed",parameters:[],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/conversational.py#L106"}}),cs=new x({props:{name:"class transformers.ConversationalPipeline",anchor:"transformers.ConversationalPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.ConversationalPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.ConversationalPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.ConversationalPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.ConversationalPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.ConversationalPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.ConversationalPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.ConversationalPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.ConversationalPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.ConversationalPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.ConversationalPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"},{anchor:"transformers.ConversationalPipeline.min_length_for_response",description:`<strong>min_length_for_response</strong> (<code>int</code>, <em>optional</em>, defaults to 32) &#x2014;
The minimum length (in number of tokens) for a response.`,name:"min_length_for_response"},{anchor:"transformers.ConversationalPipeline.minimum_tokens",description:`<strong>minimum_tokens</strong> (<code>int</code>, <em>optional</em>, defaults to 10) &#x2014;
The minimum length of tokens to leave for a response.`,name:"minimum_tokens"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/conversational.py#L163"}}),Bn=new fe({props:{anchor:"transformers.ConversationalPipeline.example",$$slots:{default:[hz]},$$scope:{ctx:A}}}),ps=new x({props:{name:"__call__",anchor:"transformers.ConversationalPipeline.__call__",parameters:[{name:"conversations",val:": typing.Union[transformers.pipelines.conversational.Conversation, typing.List[transformers.pipelines.conversational.Conversation]]"},{name:"num_workers",val:" = 0"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.ConversationalPipeline.__call__.conversations",description:`<strong>conversations</strong> (a <a href="/docs/transformers/main/en/main_classes/pipelines#transformers.Conversation">Conversation</a> or a list of <a href="/docs/transformers/main/en/main_classes/pipelines#transformers.Conversation">Conversation</a>) &#x2014;
Conversations to generate responses for.`,name:"conversations"},{anchor:"transformers.ConversationalPipeline.__call__.clean_up_tokenization_spaces",description:`<strong>clean_up_tokenization_spaces</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to clean up the potential extra spaces in the text output.
generate_kwargs &#x2014;
Additional keyword arguments to pass along to the generate method of the model (see the generate method
corresponding to your framework <a href="./model#generative-models">here</a>).`,name:"clean_up_tokenization_spaces"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/conversational.py#L222",returnDescription:`
<p>Conversation(s) with updated generated responses for those
containing a new user input.</p>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/pipelines#transformers.Conversation"
>Conversation</a> or a list of <a
  href="/docs/transformers/main/en/main_classes/pipelines#transformers.Conversation"
>Conversation</a></p>
`}}),ms=new D({}),fs=new x({props:{name:"class transformers.DepthEstimationPipeline",anchor:"transformers.DepthEstimationPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.DepthEstimationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.DepthEstimationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.DepthEstimationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.DepthEstimationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.DepthEstimationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.DepthEstimationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.DepthEstimationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.DepthEstimationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.DepthEstimationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.DepthEstimationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/depth_estimation.py#L23"}}),Xn=new fe({props:{anchor:"transformers.DepthEstimationPipeline.example",$$slots:{default:[uz]},$$scope:{ctx:A}}}),_s=new x({props:{name:"__call__",anchor:"transformers.DepthEstimationPipeline.__call__",parameters:[{name:"images",val:": typing.Union[str, typing.List[str], ForwardRef('Image.Image'), typing.List[ForwardRef('Image.Image')]]"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.DepthEstimationPipeline.__call__.images",description:`<strong>images</strong> (<code>str</code>, <code>List[str]</code>, <code>PIL.Image</code> or <code>List[PIL.Image]</code>) &#x2014;
The pipeline handles three types of images:</p>
<ul>
<li>A string containing a http link pointing to an image</li>
<li>A string containing a local path to an image</li>
<li>An image loaded in PIL directly</li>
</ul>
<p>The pipeline accepts either a single image or a batch of images, which must then be passed as a string.
Images in a batch must all be in the same format: all as http links, all as local paths, or all as PIL
images.`,name:"images"},{anchor:"transformers.DepthEstimationPipeline.__call__.top_k",description:`<strong>top_k</strong> (<code>int</code>, <em>optional</em>, defaults to 5) &#x2014;
The number of top labels that will be returned by the pipeline. If the provided number is higher than
the number of labels available in the model configuration, it will default to the number of labels.`,name:"top_k"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/depth_estimation.py#L53",returnDescription:`
<p>A dictionary or a list of dictionaries containing result. If the input is a single image, will return a
dictionary, if the input is a list of several images, will return a list of dictionaries corresponding to
the images.</p>
<p>The dictionaries contain the following keys:</p>
<ul>
<li><strong>label</strong> (<code>str</code>) \u2014 The label identified by the model.</li>
<li><strong>score</strong> (<code>int</code>) \u2014 The score attributed by the model for that label.</li>
</ul>
`}}),bs=new D({}),ws=new x({props:{name:"class transformers.DocumentQuestionAnsweringPipeline",anchor:"transformers.DocumentQuestionAnsweringPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.DocumentQuestionAnsweringPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.DocumentQuestionAnsweringPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.DocumentQuestionAnsweringPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.DocumentQuestionAnsweringPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.DocumentQuestionAnsweringPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.DocumentQuestionAnsweringPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.DocumentQuestionAnsweringPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.DocumentQuestionAnsweringPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.DocumentQuestionAnsweringPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.DocumentQuestionAnsweringPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/document_question_answering.py#L102"}}),to=new fe({props:{anchor:"transformers.DocumentQuestionAnsweringPipeline.example",$$slots:{default:[gz]},$$scope:{ctx:A}}}),Ts=new x({props:{name:"__call__",anchor:"transformers.DocumentQuestionAnsweringPipeline.__call__",parameters:[{name:"image",val:": typing.Union[ForwardRef('Image.Image'), str]"},{name:"question",val:": typing.Optional[str] = None"},{name:"word_boxes",val:": typing.Tuple[str, typing.List[float]] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.DocumentQuestionAnsweringPipeline.__call__.image",description:`<strong>image</strong> (<code>str</code> or <code>PIL.Image</code>) &#x2014;
The pipeline handles three types of images:</p>
<ul>
<li>A string containing a http link pointing to an image</li>
<li>A string containing a local path to an image</li>
<li>An image loaded in PIL directly</li>
</ul>
<p>The pipeline accepts either a single image or a batch of images. If given a single image, it can be
broadcasted to multiple questions.`,name:"image"},{anchor:"transformers.DocumentQuestionAnsweringPipeline.__call__.question",description:`<strong>question</strong> (<code>str</code>) &#x2014;
A question to ask of the document.`,name:"question"},{anchor:"transformers.DocumentQuestionAnsweringPipeline.__call__.word_boxes",description:`<strong>word_boxes</strong> (<code>List[str, Tuple[float, float, float, float]]</code>, <em>optional</em>) &#x2014;
A list of words and bounding boxes (normalized 0-&gt;1000). If you provide this optional input, then the
pipeline will use these words and boxes instead of running OCR on the image to derive them for models
that need them (e.g. LayoutLM). This allows you to reuse OCR&#x2019;d results across many invocations of the
pipeline without having to re-run it each time.`,name:"word_boxes"},{anchor:"transformers.DocumentQuestionAnsweringPipeline.__call__.top_k",description:`<strong>top_k</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
The number of answers to return (will be chosen by order of likelihood). Note that we return less than
top_k answers if there are not enough options available within the context.`,name:"top_k"},{anchor:"transformers.DocumentQuestionAnsweringPipeline.__call__.doc_stride",description:`<strong>doc_stride</strong> (<code>int</code>, <em>optional</em>, defaults to 128) &#x2014;
If the words in the document are too long to fit with the question for the model, it will be split in
several chunks with some overlap. This argument controls the size of that overlap.`,name:"doc_stride"},{anchor:"transformers.DocumentQuestionAnsweringPipeline.__call__.max_answer_len",description:`<strong>max_answer_len</strong> (<code>int</code>, <em>optional</em>, defaults to 15) &#x2014;
The maximum length of predicted answers (e.g., only answers with a shorter length are considered).`,name:"max_answer_len"},{anchor:"transformers.DocumentQuestionAnsweringPipeline.__call__.max_seq_len",description:`<strong>max_seq_len</strong> (<code>int</code>, <em>optional</em>, defaults to 384) &#x2014;
The maximum length of the total sentence (context + question) in tokens of each chunk passed to the
model. The context will be split in several chunks (using <code>doc_stride</code> as overlap) if needed.`,name:"max_seq_len"},{anchor:"transformers.DocumentQuestionAnsweringPipeline.__call__.max_question_len",description:`<strong>max_question_len</strong> (<code>int</code>, <em>optional</em>, defaults to 64) &#x2014;
The maximum length of the question after tokenization. It will be truncated if needed.`,name:"max_question_len"},{anchor:"transformers.DocumentQuestionAnsweringPipeline.__call__.handle_impossible_answer",description:`<strong>handle_impossible_answer</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not we accept impossible as an answer.`,name:"handle_impossible_answer"},{anchor:"transformers.DocumentQuestionAnsweringPipeline.__call__.lang",description:`<strong>lang</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Language to use while running OCR. Defaults to english.`,name:"lang"},{anchor:"transformers.DocumentQuestionAnsweringPipeline.__call__.tesseract_config",description:`<strong>tesseract_config</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Additional flags to pass to tesseract while running OCR.`,name:"tesseract_config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/document_question_answering.py#L187",returnDescription:`
<p>Each result comes as a dictionary with the following keys:</p>
<ul>
<li><strong>score</strong> (<code>float</code>) \u2014 The probability associated to the answer.</li>
<li><strong>start</strong> (<code>int</code>) \u2014 The start word index of the answer (in the OCR\u2019d version of the input or provided
<code>word_boxes</code>).</li>
<li><strong>end</strong> (<code>int</code>) \u2014 The end word index of the answer (in the OCR\u2019d version of the input or provided
<code>word_boxes</code>).</li>
<li><strong>answer</strong> (<code>str</code>) \u2014 The answer to the question.</li>
<li><strong>words</strong> (<code>list[int]</code>) \u2014 The index of each word/box pair that is in the answer</li>
</ul>
`,returnType:`
<p>A <code>dict</code> or a list of <code>dict</code></p>
`}}),xs=new D({}),$s=new x({props:{name:"class transformers.FeatureExtractionPipeline",anchor:"transformers.FeatureExtractionPipeline",parameters:[{name:"model",val:": typing.Union[ForwardRef('PreTrainedModel'), ForwardRef('TFPreTrainedModel')]"},{name:"tokenizer",val:": typing.Optional[transformers.tokenization_utils.PreTrainedTokenizer] = None"},{name:"feature_extractor",val:": typing.Optional[ForwardRef('SequenceFeatureExtractor')] = None"},{name:"modelcard",val:": typing.Optional[transformers.modelcard.ModelCard] = None"},{name:"framework",val:": typing.Optional[str] = None"},{name:"task",val:": str = ''"},{name:"args_parser",val:": ArgumentHandler = None"},{name:"device",val:": typing.Union[int, str, ForwardRef('torch.device')] = -1"},{name:"binary_output",val:": bool = False"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.FeatureExtractionPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.FeatureExtractionPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.FeatureExtractionPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.FeatureExtractionPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.FeatureExtractionPipeline.return_tensor",description:`<strong>return_tensor</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
If <code>True</code>, returns a tensor according to the specified framework, otherwise returns a list.`,name:"return_tensor"},{anchor:"transformers.FeatureExtractionPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.FeatureExtractionPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.FeatureExtractionPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id.`,name:"device"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/feature_extraction.py#L7"}}),oo=new fe({props:{anchor:"transformers.FeatureExtractionPipeline.example",$$slots:{default:[_z]},$$scope:{ctx:A}}}),As=new x({props:{name:"__call__",anchor:"transformers.FeatureExtractionPipeline.__call__",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.FeatureExtractionPipeline.__call__.args",description:"<strong>args</strong> (<code>str</code> or <code>List[str]</code>) &#x2014; One or several texts (or one list of texts) to get the features of.",name:"args"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/feature_extraction.py#L95",returnDescription:`
<p>The features computed by the model.</p>
`,returnType:`
<p>A nested list of <code>float</code></p>
`}}),js=new D({}),Ds=new x({props:{name:"class transformers.FillMaskPipeline",anchor:"transformers.FillMaskPipeline",parameters:[{name:"model",val:": typing.Union[ForwardRef('PreTrainedModel'), ForwardRef('TFPreTrainedModel')]"},{name:"tokenizer",val:": typing.Optional[transformers.tokenization_utils.PreTrainedTokenizer] = None"},{name:"feature_extractor",val:": typing.Optional[ForwardRef('SequenceFeatureExtractor')] = None"},{name:"modelcard",val:": typing.Optional[transformers.modelcard.ModelCard] = None"},{name:"framework",val:": typing.Optional[str] = None"},{name:"task",val:": str = ''"},{name:"args_parser",val:": ArgumentHandler = None"},{name:"device",val:": typing.Union[int, str, ForwardRef('torch.device')] = -1"},{name:"binary_output",val:": bool = False"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.FillMaskPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.FillMaskPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.FillMaskPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.FillMaskPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.FillMaskPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.FillMaskPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.FillMaskPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.FillMaskPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.FillMaskPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.FillMaskPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"},{anchor:"transformers.FillMaskPipeline.top_k",description:`<strong>top_k</strong> (<code>int</code>, defaults to 5) &#x2014;
The number of predictions to return.`,name:"top_k"},{anchor:"transformers.FillMaskPipeline.targets",description:`<strong>targets</strong> (<code>str</code> or <code>List[str]</code>, <em>optional</em>) &#x2014;
When passed, the model will limit the scores to the passed targets instead of looking up in the whole
vocab. If the provided targets are not in the model vocab, they will be tokenized and the first resulting
token will be used (with a warning, and that might be slower).`,name:"targets"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/fill_mask.py#L34"}}),ao=new fe({props:{anchor:"transformers.FillMaskPipeline.example",$$slots:{default:[bz]},$$scope:{ctx:A}}}),io=new oz({props:{$$slots:{default:[wz]},$$scope:{ctx:A}}}),zs=new x({props:{name:"__call__",anchor:"transformers.FillMaskPipeline.__call__",parameters:[{name:"inputs",val:""},{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.FillMaskPipeline.__call__.args",description:`<strong>args</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
One or several texts (or one list of prompts) with masked tokens.`,name:"args"},{anchor:"transformers.FillMaskPipeline.__call__.targets",description:`<strong>targets</strong> (<code>str</code> or <code>List[str]</code>, <em>optional</em>) &#x2014;
When passed, the model will limit the scores to the passed targets instead of looking up in the whole
vocab. If the provided targets are not in the model vocab, they will be tokenized and the first
resulting token will be used (with a warning, and that might be slower).`,name:"targets"},{anchor:"transformers.FillMaskPipeline.__call__.top_k",description:`<strong>top_k</strong> (<code>int</code>, <em>optional</em>) &#x2014;
When passed, overrides the number of predictions to return.`,name:"top_k"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/fill_mask.py#L221",returnDescription:`
<p>Each result comes as list of dictionaries with the following keys:</p>
<ul>
<li><strong>sequence</strong> (<code>str</code>) \u2014 The corresponding input with the mask token prediction.</li>
<li><strong>score</strong> (<code>float</code>) \u2014 The corresponding probability.</li>
<li><strong>token</strong> (<code>int</code>) \u2014 The predicted token id (to replace the masked one).</li>
<li><strong>token</strong> (<code>str</code>) \u2014 The predicted token (to replace the masked one).</li>
</ul>
`,returnType:`
<p>A list or a list of list of <code>dict</code></p>
`}}),Ss=new D({}),Ms=new x({props:{name:"class transformers.ImageClassificationPipeline",anchor:"transformers.ImageClassificationPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.ImageClassificationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.ImageClassificationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.ImageClassificationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.ImageClassificationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.ImageClassificationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.ImageClassificationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.ImageClassificationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.ImageClassificationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.ImageClassificationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.ImageClassificationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/image_classification.py#L32"}}),Os=new x({props:{name:"__call__",anchor:"transformers.ImageClassificationPipeline.__call__",parameters:[{name:"images",val:": typing.Union[str, typing.List[str], ForwardRef('Image.Image'), typing.List[ForwardRef('Image.Image')]]"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.ImageClassificationPipeline.__call__.images",description:`<strong>images</strong> (<code>str</code>, <code>List[str]</code>, <code>PIL.Image</code> or <code>List[PIL.Image]</code>) &#x2014;
The pipeline handles three types of images:</p>
<ul>
<li>A string containing a http link pointing to an image</li>
<li>A string containing a local path to an image</li>
<li>An image loaded in PIL directly</li>
</ul>
<p>The pipeline accepts either a single image or a batch of images, which must then be passed as a string.
Images in a batch must all be in the same format: all as http links, all as local paths, or all as PIL
images.`,name:"images"},{anchor:"transformers.ImageClassificationPipeline.__call__.top_k",description:`<strong>top_k</strong> (<code>int</code>, <em>optional</em>, defaults to 5) &#x2014;
The number of top labels that will be returned by the pipeline. If the provided number is higher than
the number of labels available in the model configuration, it will default to the number of labels.`,name:"top_k"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/image_classification.py#L59",returnDescription:`
<p>A dictionary or a list of dictionaries containing result. If the input is a single image, will return a
dictionary, if the input is a list of several images, will return a list of dictionaries corresponding to
the images.</p>
<p>The dictionaries contain the following keys:</p>
<ul>
<li><strong>label</strong> (<code>str</code>) \u2014 The label identified by the model.</li>
<li><strong>score</strong> (<code>int</code>) \u2014 The score attributed by the model for that label.</li>
</ul>
`}}),Gs=new D({}),Ns=new x({props:{name:"class transformers.ImageSegmentationPipeline",anchor:"transformers.ImageSegmentationPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.ImageSegmentationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.ImageSegmentationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.ImageSegmentationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.ImageSegmentationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.ImageSegmentationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.ImageSegmentationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.ImageSegmentationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.ImageSegmentationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.ImageSegmentationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.ImageSegmentationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/image_segmentation.py#L30"}}),Vs=new x({props:{name:"__call__",anchor:"transformers.ImageSegmentationPipeline.__call__",parameters:[{name:"images",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.ImageSegmentationPipeline.__call__.images",description:`<strong>images</strong> (<code>str</code>, <code>List[str]</code>, <code>PIL.Image</code> or <code>List[PIL.Image]</code>) &#x2014;
The pipeline handles three types of images:</p>
<ul>
<li>A string containing an HTTP(S) link pointing to an image</li>
<li>A string containing a local path to an image</li>
<li>An image loaded in PIL directly</li>
</ul>
<p>The pipeline accepts either a single image or a batch of images. Images in a batch must all be in the
same format: all as HTTP(S) links, all as local paths, or all as PIL images.`,name:"images"},{anchor:"transformers.ImageSegmentationPipeline.__call__.subtask",description:`<strong>subtask</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Segmentation task to be performed, choose [<code>semantic</code>, <code>instance</code> and <code>panoptic</code>] depending on model
capabilities. If not set, the pipeline will attempt tp resolve in the following order:
<code>panoptic</code>, <code>instance</code>, <code>semantic</code>.`,name:"subtask"},{anchor:"transformers.ImageSegmentationPipeline.__call__.threshold",description:`<strong>threshold</strong> (<code>float</code>, <em>optional</em>, defaults to 0.9) &#x2014;
Probability threshold to filter out predicted masks.`,name:"threshold"},{anchor:"transformers.ImageSegmentationPipeline.__call__.mask_threshold",description:`<strong>mask_threshold</strong> (<code>float</code>, <em>optional</em>, defaults to 0.5) &#x2014;
Threshold to use when turning the predicted masks into binary values.`,name:"mask_threshold"},{anchor:"transformers.ImageSegmentationPipeline.__call__.overlap_mask_area_threshold",description:`<strong>overlap_mask_area_threshold</strong> (<code>float</code>, <em>optional</em>, defaults to 0.5) &#x2014;
Mask overlap threshold to eliminate small, disconnected segments.`,name:"overlap_mask_area_threshold"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/image_segmentation.py#L70",returnDescription:`
<p>A dictionary or a list of dictionaries containing the result. If the input is a single image, will return a
list of dictionaries, if the input is a list of several images, will return a list of list of dictionaries
corresponding to each image.</p>
<p>The dictionaries contain the mask, label and score (where applicable) of each detected object and contains
the following keys:</p>
<ul>
<li><strong>label</strong> (<code>str</code>) \u2014 The class label identified by the model.</li>
<li><strong>mask</strong> (<code>PIL.Image</code>) \u2014 A binary mask of the detected object as a Pil Image of shape (width, height) of
the original image. Returns a mask filled with zeros if no object is found.</li>
<li><strong>score</strong> (<em>optional</em> <code>float</code>) \u2014 Optionally, when the model is capable of estimating a confidence of the
\u201Cobject\u201D described by the label and the mask.</li>
</ul>
`}}),Ws=new D({}),Zs=new x({props:{name:"class transformers.ImageToTextPipeline",anchor:"transformers.ImageToTextPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.ImageToTextPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.ImageToTextPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.ImageToTextPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.ImageToTextPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.ImageToTextPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.ImageToTextPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.ImageToTextPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.ImageToTextPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.ImageToTextPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.ImageToTextPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/image_to_text.py#L29"}}),Xs=new x({props:{name:"__call__",anchor:"transformers.ImageToTextPipeline.__call__",parameters:[{name:"images",val:": typing.Union[str, typing.List[str], ForwardRef('Image.Image'), typing.List[ForwardRef('Image.Image')]]"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.ImageToTextPipeline.__call__.images",description:`<strong>images</strong> (<code>str</code>, <code>List[str]</code>, <code>PIL.Image</code> or <code>List[PIL.Image]</code>) &#x2014;
The pipeline handles three types of images:</p>
<ul>
<li>A string containing a HTTP(s) link pointing to an image</li>
<li>A string containing a local path to an image</li>
<li>An image loaded in PIL directly</li>
</ul>
<p>The pipeline accepts either a single image or a batch of images.`,name:"images"},{anchor:"transformers.ImageToTextPipeline.__call__.max_new_tokens",description:`<strong>max_new_tokens</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The amount of maximum tokens to generate. By default it will use <code>generate</code> default.`,name:"max_new_tokens"},{anchor:"transformers.ImageToTextPipeline.__call__.generate_kwargs",description:`<strong>generate_kwargs</strong> (<code>Dict</code>, <em>optional</em>) &#x2014;
Pass it to send all of these arguments directly to <code>generate</code> allowing full control of this function.`,name:"generate_kwargs"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/image_to_text.py#L62",returnDescription:`
<p>Each result comes as a dictionary with the following key:</p>
<ul>
<li><strong>generated_text</strong> (<code>str</code>) \u2014 The generated text.</li>
</ul>
`,returnType:`
<p>A list or a list of list of <code>dict</code></p>
`}}),Js=new D({}),ea=new x({props:{name:"class transformers.TokenClassificationPipeline",anchor:"transformers.TokenClassificationPipeline",parameters:[{name:"args_parser",val:" = <transformers.pipelines.token_classification.TokenClassificationArgumentHandler object at 0x7f538ad05f70>"},{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TokenClassificationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.TokenClassificationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.TokenClassificationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.TokenClassificationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.TokenClassificationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.TokenClassificationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.TokenClassificationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.TokenClassificationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.TokenClassificationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.TokenClassificationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"},{anchor:"transformers.TokenClassificationPipeline.ignore_labels",description:`<strong>ignore_labels</strong> (<code>List[str]</code>, defaults to <code>[&quot;O&quot;]</code>) &#x2014;
A list of labels to ignore.`,name:"ignore_labels"},{anchor:"transformers.TokenClassificationPipeline.grouped_entities",description:`<strong>grouped_entities</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
DEPRECATED, use <code>aggregation_strategy</code> instead. Whether or not to group the tokens corresponding to the
same entity together in the predictions or not.`,name:"grouped_entities"},{anchor:"transformers.TokenClassificationPipeline.aggregation_strategy",description:`<strong>aggregation_strategy</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;none&quot;</code>) &#x2014;
The strategy to fuse (or not) tokens based on the model prediction.</p>
<ul>
<li>&#x201C;none&#x201D; : Will simply not do any aggregation and simply return raw results from the model</li>
<li>&#x201C;simple&#x201D; : Will attempt to group entities following the default schema. (A, B-TAG), (B, I-TAG), (C,
I-TAG), (D, B-TAG2) (E, B-TAG2) will end up being [{&#x201C;word&#x201D;: ABC, &#x201C;entity&#x201D;: &#x201C;TAG&#x201D;}, {&#x201C;word&#x201D;: &#x201C;D&#x201D;,
&#x201C;entity&#x201D;: &#x201C;TAG2&#x201D;}, {&#x201C;word&#x201D;: &#x201C;E&#x201D;, &#x201C;entity&#x201D;: &#x201C;TAG2&#x201D;}] Notice that two consecutive B tags will end up as
different entities. On word based languages, we might end up splitting words undesirably : Imagine
Microsoft being tagged as [{&#x201C;word&#x201D;: &#x201C;Micro&#x201D;, &#x201C;entity&#x201D;: &#x201C;ENTERPRISE&#x201D;}, {&#x201C;word&#x201D;: &#x201C;soft&#x201D;, &#x201C;entity&#x201D;:
&#x201C;NAME&#x201D;}]. Look for FIRST, MAX, AVERAGE for ways to mitigate that and disambiguate words (on languages
that support that meaning, which is basically tokens separated by a space). These mitigations will
only work on real words, &#x201C;New york&#x201D; might still be tagged with two different entities.</li>
<li>&#x201C;first&#x201D; : (works only on word based models) Will use the <code>SIMPLE</code> strategy except that words, cannot
end up with different tags. Words will simply use the tag of the first token of the word when there
is ambiguity.</li>
<li>&#x201C;average&#x201D; : (works only on word based models) Will use the <code>SIMPLE</code> strategy except that words,
cannot end up with different tags. scores will be averaged first across tokens, and then the maximum
label is applied.</li>
<li>&#x201C;max&#x201D; : (works only on word based models) Will use the <code>SIMPLE</code> strategy except that words, cannot
end up with different tags. Word entity will simply be the token with the maximum score.</li>
</ul>`,name:"aggregation_strategy"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/token_classification.py#L86"}}),oa=new x({props:{name:"aggregate_words",anchor:"transformers.TokenClassificationPipeline.aggregate_words",parameters:[{name:"entities",val:": typing.List[dict]"},{name:"aggregation_strategy",val:": AggregationStrategy"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/token_classification.py#L369"}}),ra=new x({props:{name:"gather_pre_entities",anchor:"transformers.TokenClassificationPipeline.gather_pre_entities",parameters:[{name:"sentence",val:": str"},{name:"input_ids",val:": ndarray"},{name:"scores",val:": ndarray"},{name:"offset_mapping",val:": typing.Union[typing.List[typing.Tuple[int, int]], NoneType]"},{name:"special_tokens_mask",val:": ndarray"},{name:"aggregation_strategy",val:": AggregationStrategy"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/token_classification.py#L258"}}),sa=new x({props:{name:"group_entities",anchor:"transformers.TokenClassificationPipeline.group_entities",parameters:[{name:"entities",val:": typing.List[dict]"}],parametersDescription:[{anchor:"transformers.TokenClassificationPipeline.group_entities.entities",description:"<strong>entities</strong> (<code>dict</code>) &#x2014; The entities predicted by the pipeline.",name:"entities"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/token_classification.py#L431"}}),aa=new x({props:{name:"group_sub_entities",anchor:"transformers.TokenClassificationPipeline.group_sub_entities",parameters:[{name:"entities",val:": typing.List[dict]"}],parametersDescription:[{anchor:"transformers.TokenClassificationPipeline.group_sub_entities.entities",description:"<strong>entities</strong> (<code>dict</code>) &#x2014; The entities predicted by the pipeline.",name:"entities"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/token_classification.py#L396"}}),ia=new D({}),la=new x({props:{name:"class transformers.ObjectDetectionPipeline",anchor:"transformers.ObjectDetectionPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.ObjectDetectionPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.ObjectDetectionPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.ObjectDetectionPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.ObjectDetectionPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.ObjectDetectionPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.ObjectDetectionPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.ObjectDetectionPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.ObjectDetectionPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.ObjectDetectionPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.ObjectDetectionPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/object_detection.py#L24"}}),ma=new x({props:{name:"__call__",anchor:"transformers.ObjectDetectionPipeline.__call__",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.ObjectDetectionPipeline.__call__.images",description:`<strong>images</strong> (<code>str</code>, <code>List[str]</code>, <code>PIL.Image</code> or <code>List[PIL.Image]</code>) &#x2014;
The pipeline handles three types of images:</p>
<ul>
<li>A string containing an HTTP(S) link pointing to an image</li>
<li>A string containing a local path to an image</li>
<li>An image loaded in PIL directly</li>
</ul>
<p>The pipeline accepts either a single image or a batch of images. Images in a batch must all be in the
same format: all as HTTP(S) links, all as local paths, or all as PIL images.`,name:"images"},{anchor:"transformers.ObjectDetectionPipeline.__call__.threshold",description:`<strong>threshold</strong> (<code>float</code>, <em>optional</em>, defaults to 0.9) &#x2014;
The probability necessary to make a prediction.`,name:"threshold"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/object_detection.py#L52",returnDescription:`
<p>A list of dictionaries or a list of list of dictionaries containing the result. If the input is a single
image, will return a list of dictionaries, if the input is a list of several images, will return a list of
list of dictionaries corresponding to each image.</p>
<p>The dictionaries contain the following keys:</p>
<ul>
<li><strong>label</strong> (<code>str</code>) \u2014 The class label identified by the model.</li>
<li><strong>score</strong> (<code>float</code>) \u2014 The score attributed by the model for that label.</li>
<li><strong>box</strong> (<code>List[Dict[str, int]]</code>) \u2014 The bounding box of detected object in image\u2019s original size.</li>
</ul>
`}}),fa=new D({}),ha=new x({props:{name:"class transformers.QuestionAnsweringPipeline",anchor:"transformers.QuestionAnsweringPipeline",parameters:[{name:"model",val:": typing.Union[ForwardRef('PreTrainedModel'), ForwardRef('TFPreTrainedModel')]"},{name:"tokenizer",val:": PreTrainedTokenizer"},{name:"modelcard",val:": typing.Optional[transformers.modelcard.ModelCard] = None"},{name:"framework",val:": typing.Optional[str] = None"},{name:"device",val:": int = -1"},{name:"task",val:": str = ''"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.QuestionAnsweringPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.QuestionAnsweringPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.QuestionAnsweringPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.QuestionAnsweringPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.QuestionAnsweringPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.QuestionAnsweringPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.QuestionAnsweringPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.QuestionAnsweringPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.QuestionAnsweringPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.QuestionAnsweringPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/question_answering.py#L224"}}),_a=new x({props:{name:"__call__",anchor:"transformers.QuestionAnsweringPipeline.__call__",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.QuestionAnsweringPipeline.__call__.args",description:`<strong>args</strong> (<code>SquadExample</code> or a list of <code>SquadExample</code>) &#x2014;
One or several <code>SquadExample</code> containing the question and context.`,name:"args"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.X",description:`<strong>X</strong> (<code>SquadExample</code> or a list of <code>SquadExample</code>, <em>optional</em>) &#x2014;
One or several <code>SquadExample</code> containing the question and context (will be treated the same way as if
passed as the first positional argument).`,name:"X"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.data",description:`<strong>data</strong> (<code>SquadExample</code> or a list of <code>SquadExample</code>, <em>optional</em>) &#x2014;
One or several <code>SquadExample</code> containing the question and context (will be treated the same way as if
passed as the first positional argument).`,name:"data"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.question",description:`<strong>question</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
One or several question(s) (must be used in conjunction with the <code>context</code> argument).`,name:"question"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.context",description:`<strong>context</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
One or several context(s) associated with the question(s) (must be used in conjunction with the
<code>question</code> argument).`,name:"context"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.topk",description:`<strong>topk</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
The number of answers to return (will be chosen by order of likelihood). Note that we return less than
topk answers if there are not enough options available within the context.`,name:"topk"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.doc_stride",description:`<strong>doc_stride</strong> (<code>int</code>, <em>optional</em>, defaults to 128) &#x2014;
If the context is too long to fit with the question for the model, it will be split in several chunks
with some overlap. This argument controls the size of that overlap.`,name:"doc_stride"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.max_answer_len",description:`<strong>max_answer_len</strong> (<code>int</code>, <em>optional</em>, defaults to 15) &#x2014;
The maximum length of predicted answers (e.g., only answers with a shorter length are considered).`,name:"max_answer_len"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.max_seq_len",description:`<strong>max_seq_len</strong> (<code>int</code>, <em>optional</em>, defaults to 384) &#x2014;
The maximum length of the total sentence (context + question) in tokens of each chunk passed to the
model. The context will be split in several chunks (using <code>doc_stride</code> as overlap) if needed.`,name:"max_seq_len"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.max_question_len",description:`<strong>max_question_len</strong> (<code>int</code>, <em>optional</em>, defaults to 64) &#x2014;
The maximum length of the question after tokenization. It will be truncated if needed.`,name:"max_question_len"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.handle_impossible_answer",description:`<strong>handle_impossible_answer</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not we accept impossible as an answer.`,name:"handle_impossible_answer"},{anchor:"transformers.QuestionAnsweringPipeline.__call__.align_to_words",description:`<strong>align_to_words</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Attempts to align the answer to real words. Improves quality on space separated langages. Might hurt on
non-space-separated languages (like Japanese or Chinese)`,name:"align_to_words"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/question_answering.py#L330",returnDescription:`
<p>Each result comes as a dictionary with the following keys:</p>
<ul>
<li><strong>score</strong> (<code>float</code>) \u2014 The probability associated to the answer.</li>
<li><strong>start</strong> (<code>int</code>) \u2014 The character start index of the answer (in the tokenized version of the input).</li>
<li><strong>end</strong> (<code>int</code>) \u2014 The character end index of the answer (in the tokenized version of the input).</li>
<li><strong>answer</strong> (<code>str</code>) \u2014 The answer to the question.</li>
</ul>
`,returnType:`
<p>A <code>dict</code> or a list of <code>dict</code></p>
`}}),ba=new x({props:{name:"create_sample",anchor:"transformers.QuestionAnsweringPipeline.create_sample",parameters:[{name:"question",val:": typing.Union[str, typing.List[str]]"},{name:"context",val:": typing.Union[str, typing.List[str]]"}],parametersDescription:[{anchor:"transformers.QuestionAnsweringPipeline.create_sample.question",description:"<strong>question</strong> (<code>str</code> or <code>List[str]</code>) &#x2014; The question(s) asked.",name:"question"},{anchor:"transformers.QuestionAnsweringPipeline.create_sample.context",description:"<strong>context</strong> (<code>str</code> or <code>List[str]</code>) &#x2014; The context(s) in which we will look for the answer.",name:"context"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/question_answering.py#L265",returnDescription:`
<p>The corresponding <code>SquadExample</code> grouping question and context.</p>
`,returnType:`
<p>One or a list of <code>SquadExample</code></p>
`}}),wa=new x({props:{name:"span_to_answer",anchor:"transformers.QuestionAnsweringPipeline.span_to_answer",parameters:[{name:"text",val:": str"},{name:"start",val:": int"},{name:"end",val:": int"}],parametersDescription:[{anchor:"transformers.QuestionAnsweringPipeline.span_to_answer.text",description:"<strong>text</strong> (<code>str</code>) &#x2014; The actual context to extract the answer from.",name:"text"},{anchor:"transformers.QuestionAnsweringPipeline.span_to_answer.start",description:"<strong>start</strong> (<code>int</code>) &#x2014; The answer starting token index.",name:"start"},{anchor:"transformers.QuestionAnsweringPipeline.span_to_answer.end",description:"<strong>end</strong> (<code>int</code>) &#x2014; The answer end token index.",name:"end"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/question_answering.py#L606",returnDescription:`
<p>str, \u2018start\u2019: int, \u2018end\u2019: int}\`</p>
`,returnType:`
<p>Dictionary like \`{\u2018answer\u2019</p>
`}}),va=new D({}),ka=new x({props:{name:"class transformers.SummarizationPipeline",anchor:"transformers.SummarizationPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.SummarizationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.SummarizationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.SummarizationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.SummarizationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.SummarizationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.SummarizationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.SummarizationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.SummarizationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.SummarizationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.SummarizationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/text2text_generation.py#L198"}}),Eo=new fe({props:{anchor:"transformers.SummarizationPipeline.example",$$slots:{default:[vz]},$$scope:{ctx:A}}}),ya=new x({props:{name:"__call__",anchor:"transformers.SummarizationPipeline.__call__",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.SummarizationPipeline.__call__.documents",description:`<strong>documents</strong> (<em>str</em> or <code>List[str]</code>) &#x2014;
One or several articles (or one list of articles) to summarize.`,name:"documents"},{anchor:"transformers.SummarizationPipeline.__call__.return_text",description:`<strong>return_text</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to include the decoded texts in the outputs`,name:"return_text"},{anchor:"transformers.SummarizationPipeline.__call__.return_tensors",description:`<strong>return_tensors</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to include the tensors of predictions (as token indices) in the outputs.`,name:"return_tensors"},{anchor:"transformers.SummarizationPipeline.__call__.clean_up_tokenization_spaces",description:`<strong>clean_up_tokenization_spaces</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to clean up the potential extra spaces in the text output.
generate_kwargs &#x2014;
Additional keyword arguments to pass along to the generate method of the model (see the generate method
corresponding to your framework <a href="./model#generative-models">here</a>).`,name:"clean_up_tokenization_spaces"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/text2text_generation.py#L226",returnDescription:`
<p>Each result comes as a dictionary with the following keys:</p>
<ul>
<li><strong>summary_text</strong> (<code>str</code>, present when <code>return_text=True</code>) \u2014 The summary of the corresponding input.</li>
<li><strong>summary_token_ids</strong> (<code>torch.Tensor</code> or <code>tf.Tensor</code>, present when <code>return_tensors=True</code>) \u2014 The token
ids of the summary.</li>
</ul>
`,returnType:`
<p>A list or a list of list of <code>dict</code></p>
`}}),xa=new D({}),$a=new x({props:{name:"class transformers.TableQuestionAnsweringPipeline",anchor:"transformers.TableQuestionAnsweringPipeline",parameters:[{name:"args_parser",val:" = <transformers.pipelines.table_question_answering.TableQuestionAnsweringArgumentHandler object at 0x7f538acfa6a0>"},{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TableQuestionAnsweringPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.TableQuestionAnsweringPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.TableQuestionAnsweringPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.TableQuestionAnsweringPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.TableQuestionAnsweringPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.TableQuestionAnsweringPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.TableQuestionAnsweringPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.TableQuestionAnsweringPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.TableQuestionAnsweringPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.TableQuestionAnsweringPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/table_question_answering.py#L89"}}),ja=new x({props:{name:"__call__",anchor:"transformers.TableQuestionAnsweringPipeline.__call__",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TableQuestionAnsweringPipeline.__call__.table",description:`<strong>table</strong> (<code>pd.DataFrame</code> or <code>Dict</code>) &#x2014;
Pandas DataFrame or dictionary that will be converted to a DataFrame containing all the table values.
See above for an example of dictionary.`,name:"table"},{anchor:"transformers.TableQuestionAnsweringPipeline.__call__.query",description:`<strong>query</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
Query or list of queries that will be sent to the model alongside the table.`,name:"query"},{anchor:"transformers.TableQuestionAnsweringPipeline.__call__.sequential",description:`<strong>sequential</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to do inference sequentially or as a batch. Batching is faster, but models like SQA require the
inference to be done sequentially to extract relations within sequences, given their conversational
nature.`,name:"sequential"},{anchor:"transformers.TableQuestionAnsweringPipeline.__call__.padding",description:`<strong>padding</strong> (<code>bool</code>, <code>str</code> or <a href="/docs/transformers/main/en/internal/file_utils#transformers.utils.PaddingStrategy">PaddingStrategy</a>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Activates and controls padding. Accepts the following values:</p>
<ul>
<li><code>True</code> or <code>&apos;longest&apos;</code>: Pad to the longest sequence in the batch (or no padding if only a single
sequence if provided).</li>
<li><code>&apos;max_length&apos;</code>: Pad to a maximum length specified with the argument <code>max_length</code> or to the maximum
acceptable input length for the model if that argument is not provided.</li>
<li><code>False</code> or <code>&apos;do_not_pad&apos;</code> (default): No padding (i.e., can output a batch with sequences of different
lengths).</li>
</ul>`,name:"padding"},{anchor:"transformers.TableQuestionAnsweringPipeline.__call__.truncation",description:`<strong>truncation</strong> (<code>bool</code>, <code>str</code> or <code>TapasTruncationStrategy</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Activates and controls truncation. Accepts the following values:</p>
<ul>
<li><code>True</code> or <code>&apos;drop_rows_to_fit&apos;</code>: Truncate to a maximum length specified with the argument <code>max_length</code>
or to the maximum acceptable input length for the model if that argument is not provided. This will
truncate row by row, removing rows from the table.</li>
<li><code>False</code> or <code>&apos;do_not_truncate&apos;</code> (default): No truncation (i.e., can output batch with sequence lengths
greater than the model maximum admissible input size).</li>
</ul>`,name:"truncation"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/table_question_answering.py#L256",returnDescription:`
<p>Each result is a dictionary with the following
keys:</p>
<ul>
<li><strong>answer</strong> (<code>str</code>) \u2014 The answer of the query given the table. If there is an aggregator, the answer will
be preceded by <code>AGGREGATOR &gt;</code>.</li>
<li><strong>coordinates</strong> (<code>List[Tuple[int, int]]</code>) \u2014 Coordinates of the cells of the answers.</li>
<li><strong>cells</strong> (<code>List[str]</code>) \u2014 List of strings made up of the answer cell values.</li>
<li><strong>aggregator</strong> (<code>str</code>) \u2014 If the model has an aggregator, this returns the aggregator.</li>
</ul>
`,returnType:`
<p>A dictionary or a list of dictionaries containing results</p>
`}}),jo=new fe({props:{anchor:"transformers.TableQuestionAnsweringPipeline.__call__.example",$$slots:{default:[kz]},$$scope:{ctx:A}}}),Do=new fe({props:{anchor:"transformers.TableQuestionAnsweringPipeline.__call__.example-2",$$slots:{default:[Pz]},$$scope:{ctx:A}}}),Ca=new D({}),Ia=new x({props:{name:"class transformers.TextClassificationPipeline",anchor:"transformers.TextClassificationPipeline",parameters:[{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TextClassificationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.TextClassificationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.TextClassificationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.TextClassificationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.TextClassificationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.TextClassificationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.TextClassificationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.TextClassificationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.TextClassificationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.TextClassificationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"},{anchor:"transformers.TextClassificationPipeline.return_all_scores",description:`<strong>return_all_scores</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to return all prediction scores or just the one of the predicted class.`,name:"return_all_scores"},{anchor:"transformers.TextClassificationPipeline.function_to_apply",description:`<strong>function_to_apply</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;default&quot;</code>) &#x2014;
The function to apply to the model outputs in order to retrieve the scores. Accepts four different values:</p>
<ul>
<li><code>&quot;default&quot;</code>: if the model has a single label, will apply the sigmoid function on the output. If the model
has several labels, will apply the softmax function on the output.</li>
<li><code>&quot;sigmoid&quot;</code>: Applies the sigmoid function on the output.</li>
<li><code>&quot;softmax&quot;</code>: Applies the softmax function on the output.</li>
<li><code>&quot;none&quot;</code>: Does not apply any function on the output.</li>
</ul>`,name:"function_to_apply"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/text_classification.py#L48"}}),Fa=new x({props:{name:"__call__",anchor:"transformers.TextClassificationPipeline.__call__",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TextClassificationPipeline.__call__.args",description:`<strong>args</strong> (<code>str</code> or <code>List[str]</code> or <code>Dict[str]</code>, or <code>List[Dict[str]]</code>) &#x2014;
One or several texts to classify. In order to use text pairs for your classification, you can send a
dictionnary containing <code>{&quot;text&quot;, &quot;text_pair&quot;}</code> keys, or a list of those.`,name:"args"},{anchor:"transformers.TextClassificationPipeline.__call__.top_k",description:`<strong>top_k</strong> (<code>int</code>, <em>optional</em>, defaults to <code>1</code>) &#x2014;
How many results to return.`,name:"top_k"},{anchor:"transformers.TextClassificationPipeline.__call__.function_to_apply",description:`<strong>function_to_apply</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;default&quot;</code>) &#x2014;
The function to apply to the model outputs in order to retrieve the scores. Accepts four different
values:</p>
<p>If this argument is not specified, then it will apply the following functions according to the number
of labels:</p>
<ul>
<li>If the model has a single label, will apply the sigmoid function on the output.</li>
<li>If the model has several labels, will apply the softmax function on the output.</li>
</ul>
<p>Possible values are:</p>
<ul>
<li><code>&quot;sigmoid&quot;</code>: Applies the sigmoid function on the output.</li>
<li><code>&quot;softmax&quot;</code>: Applies the softmax function on the output.</li>
<li><code>&quot;none&quot;</code>: Does not apply any function on the output.</li>
</ul>`,name:"function_to_apply"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/text_classification.py#L106",returnDescription:`
<p>Each result comes as list of dictionaries with the following keys:</p>
<ul>
<li><strong>label</strong> (<code>str</code>) \u2014 The label predicted.</li>
<li><strong>score</strong> (<code>float</code>) \u2014 The corresponding probability.</li>
</ul>
<p>If <code>top_k</code> is used, one such dictionary is returned per label.</p>
`,returnType:`
<p>A list or a list of list of <code>dict</code></p>
`}}),La=new D({}),Ua=new x({props:{name:"class transformers.TextGenerationPipeline",anchor:"transformers.TextGenerationPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TextGenerationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.TextGenerationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.TextGenerationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.TextGenerationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.TextGenerationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.TextGenerationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.TextGenerationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.TextGenerationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.TextGenerationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.TextGenerationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/text_generation.py#L21"}}),Qa=new x({props:{name:"__call__",anchor:"transformers.TextGenerationPipeline.__call__",parameters:[{name:"text_inputs",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TextGenerationPipeline.__call__.args",description:`<strong>args</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
One or several prompts (or one list of prompts) to complete.`,name:"args"},{anchor:"transformers.TextGenerationPipeline.__call__.return_tensors",description:`<strong>return_tensors</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to include the tensors of predictions (as token indices) in the outputs.`,name:"return_tensors"},{anchor:"transformers.TextGenerationPipeline.__call__.return_text",description:`<strong>return_text</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to include the decoded texts in the outputs.`,name:"return_text"},{anchor:"transformers.TextGenerationPipeline.__call__.return_full_text",description:`<strong>return_full_text</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
If set to <code>False</code> only added text is returned, otherwise the full text is returned Only meaningful if
<em>return_text</em> is set to True.`,name:"return_full_text"},{anchor:"transformers.TextGenerationPipeline.__call__.clean_up_tokenization_spaces",description:`<strong>clean_up_tokenization_spaces</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to clean up the potential extra spaces in the text output.`,name:"clean_up_tokenization_spaces"},{anchor:"transformers.TextGenerationPipeline.__call__.prefix",description:`<strong>prefix</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Prefix added to prompt.`,name:"prefix"},{anchor:"transformers.TextGenerationPipeline.__call__.handle_long_generation",description:`<strong>handle_long_generation</strong> (<code>str</code>, <em>optional</em>) &#x2014;
By default, this pipelines does not handle long generation (ones that exceed in one form or the other
the model maximum length). There is no perfect way to adress this (more info
:<a href="https://github.com/huggingface/transformers/issues/14033#issuecomment-948385227" rel="nofollow">https://github.com/huggingface/transformers/issues/14033#issuecomment-948385227</a>). This provides common
strategies to work around that problem depending on your use case.</p>
<ul>
<li><code>None</code> : default strategy where nothing in particular happens</li>
<li><code>&quot;hole&quot;</code>: Truncates left of input, and leaves a gap wide enough to let generation happen (might
truncate a lot of the prompt and not suitable when generation exceed the model capacity)</li>
</ul>
<p>generate_kwargs &#x2014;
Additional keyword arguments to pass along to the generate method of the model (see the generate method
corresponding to your framework <a href="./model#generative-models">here</a>).`,name:"handle_long_generation"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/text_generation.py#L148",returnDescription:`
<p>Each result comes as a dictionary with the following keys:</p>
<ul>
<li><strong>generated_text</strong> (<code>str</code>, present when <code>return_text=True</code>) \u2014 The generated text.</li>
<li><strong>generated_token_ids</strong> (<code>torch.Tensor</code> or <code>tf.Tensor</code>, present when <code>return_tensors=True</code>) \u2014 The token
ids of the generated text.</li>
</ul>
`,returnType:`
<p>A list or a list of list of <code>dict</code></p>
`}}),Ra=new D({}),Ha=new x({props:{name:"class transformers.Text2TextGenerationPipeline",anchor:"transformers.Text2TextGenerationPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.Text2TextGenerationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.Text2TextGenerationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.Text2TextGenerationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.Text2TextGenerationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.Text2TextGenerationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.Text2TextGenerationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.Text2TextGenerationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.Text2TextGenerationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.Text2TextGenerationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.Text2TextGenerationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/text2text_generation.py#L26"}}),Lo=new fe({props:{anchor:"transformers.Text2TextGenerationPipeline.example",$$slots:{default:[Tz]},$$scope:{ctx:A}}}),Za=new x({props:{name:"__call__",anchor:"transformers.Text2TextGenerationPipeline.__call__",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.Text2TextGenerationPipeline.__call__.args",description:`<strong>args</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
Input text for the encoder.`,name:"args"},{anchor:"transformers.Text2TextGenerationPipeline.__call__.return_tensors",description:`<strong>return_tensors</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to include the tensors of predictions (as token indices) in the outputs.`,name:"return_tensors"},{anchor:"transformers.Text2TextGenerationPipeline.__call__.return_text",description:`<strong>return_text</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to include the decoded texts in the outputs.`,name:"return_text"},{anchor:"transformers.Text2TextGenerationPipeline.__call__.clean_up_tokenization_spaces",description:`<strong>clean_up_tokenization_spaces</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to clean up the potential extra spaces in the text output.`,name:"clean_up_tokenization_spaces"},{anchor:"transformers.Text2TextGenerationPipeline.__call__.truncation",description:`<strong>truncation</strong> (<code>TruncationStrategy</code>, <em>optional</em>, defaults to <code>TruncationStrategy.DO_NOT_TRUNCATE</code>) &#x2014;
The truncation strategy for the tokenization within the pipeline. <code>TruncationStrategy.DO_NOT_TRUNCATE</code>
(default) will never truncate, but it is sometimes desirable to truncate the input to fit the model&#x2019;s
max_length instead of throwing an error down the line.
generate_kwargs &#x2014;
Additional keyword arguments to pass along to the generate method of the model (see the generate method
corresponding to your framework <a href="./model#generative-models">here</a>).`,name:"truncation"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/text2text_generation.py#L121",returnDescription:`
<p>Each result comes as a dictionary with the following keys:</p>
<ul>
<li><strong>generated_text</strong> (<code>str</code>, present when <code>return_text=True</code>) \u2014 The generated text.</li>
<li><strong>generated_token_ids</strong> (<code>torch.Tensor</code> or <code>tf.Tensor</code>, present when <code>return_tensors=True</code>) \u2014 The token
ids of the generated text.</li>
</ul>
`,returnType:`
<p>A list or a list of list of <code>dict</code></p>
`}}),Ba=new x({props:{name:"check_inputs",anchor:"transformers.Text2TextGenerationPipeline.check_inputs",parameters:[{name:"input_length",val:": int"},{name:"min_length",val:": int"},{name:"max_length",val:": int"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/text2text_generation.py#L94"}}),Ya=new D({}),Ka=new x({props:{name:"class transformers.TokenClassificationPipeline",anchor:"transformers.TokenClassificationPipeline",parameters:[{name:"args_parser",val:" = <transformers.pipelines.token_classification.TokenClassificationArgumentHandler object at 0x7f538ad05f70>"},{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TokenClassificationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.TokenClassificationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.TokenClassificationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.TokenClassificationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.TokenClassificationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.TokenClassificationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.TokenClassificationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.TokenClassificationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.TokenClassificationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.TokenClassificationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"},{anchor:"transformers.TokenClassificationPipeline.ignore_labels",description:`<strong>ignore_labels</strong> (<code>List[str]</code>, defaults to <code>[&quot;O&quot;]</code>) &#x2014;
A list of labels to ignore.`,name:"ignore_labels"},{anchor:"transformers.TokenClassificationPipeline.grouped_entities",description:`<strong>grouped_entities</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
DEPRECATED, use <code>aggregation_strategy</code> instead. Whether or not to group the tokens corresponding to the
same entity together in the predictions or not.`,name:"grouped_entities"},{anchor:"transformers.TokenClassificationPipeline.aggregation_strategy",description:`<strong>aggregation_strategy</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;none&quot;</code>) &#x2014;
The strategy to fuse (or not) tokens based on the model prediction.</p>
<ul>
<li>&#x201C;none&#x201D; : Will simply not do any aggregation and simply return raw results from the model</li>
<li>&#x201C;simple&#x201D; : Will attempt to group entities following the default schema. (A, B-TAG), (B, I-TAG), (C,
I-TAG), (D, B-TAG2) (E, B-TAG2) will end up being [{&#x201C;word&#x201D;: ABC, &#x201C;entity&#x201D;: &#x201C;TAG&#x201D;}, {&#x201C;word&#x201D;: &#x201C;D&#x201D;,
&#x201C;entity&#x201D;: &#x201C;TAG2&#x201D;}, {&#x201C;word&#x201D;: &#x201C;E&#x201D;, &#x201C;entity&#x201D;: &#x201C;TAG2&#x201D;}] Notice that two consecutive B tags will end up as
different entities. On word based languages, we might end up splitting words undesirably : Imagine
Microsoft being tagged as [{&#x201C;word&#x201D;: &#x201C;Micro&#x201D;, &#x201C;entity&#x201D;: &#x201C;ENTERPRISE&#x201D;}, {&#x201C;word&#x201D;: &#x201C;soft&#x201D;, &#x201C;entity&#x201D;:
&#x201C;NAME&#x201D;}]. Look for FIRST, MAX, AVERAGE for ways to mitigate that and disambiguate words (on languages
that support that meaning, which is basically tokens separated by a space). These mitigations will
only work on real words, &#x201C;New york&#x201D; might still be tagged with two different entities.</li>
<li>&#x201C;first&#x201D; : (works only on word based models) Will use the <code>SIMPLE</code> strategy except that words, cannot
end up with different tags. Words will simply use the tag of the first token of the word when there
is ambiguity.</li>
<li>&#x201C;average&#x201D; : (works only on word based models) Will use the <code>SIMPLE</code> strategy except that words,
cannot end up with different tags. scores will be averaged first across tokens, and then the maximum
label is applied.</li>
<li>&#x201C;max&#x201D; : (works only on word based models) Will use the <code>SIMPLE</code> strategy except that words, cannot
end up with different tags. Word entity will simply be the token with the maximum score.</li>
</ul>`,name:"aggregation_strategy"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/token_classification.py#L86"}}),ei=new x({props:{name:"__call__",anchor:"transformers.TokenClassificationPipeline.__call__",parameters:[{name:"inputs",val:": typing.Union[str, typing.List[str]]"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TokenClassificationPipeline.__call__.inputs",description:`<strong>inputs</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
One or several texts (or one list of texts) for token classification.`,name:"inputs"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/token_classification.py#L162",returnDescription:`
<p>Each result comes as a list of dictionaries (one for each token in the
corresponding input, or each entity if this pipeline was instantiated with an aggregation_strategy) with
the following keys:</p>
<ul>
<li><strong>word</strong> (<code>str</code>) \u2014 The token/word classified. This is obtained by decoding the selected tokens. If you
want to have the exact string in the original sentence, use <code>start</code> and <code>end</code>.</li>
<li><strong>score</strong> (<code>float</code>) \u2014 The corresponding probability for <code>entity</code>.</li>
<li><strong>entity</strong> (<code>str</code>) \u2014 The entity predicted for that token/word (it is named <em>entity_group</em> when
<em>aggregation_strategy</em> is not <code>"none"</code>.</li>
<li><strong>index</strong> (<code>int</code>, only present when <code>aggregation_strategy="none"</code>) \u2014 The index of the corresponding
token in the sentence.</li>
<li><strong>start</strong> (<code>int</code>, <em>optional</em>) \u2014 The index of the start of the corresponding entity in the sentence. Only
exists if the offsets are available within the tokenizer</li>
<li><strong>end</strong> (<code>int</code>, <em>optional</em>) \u2014 The index of the end of the corresponding entity in the sentence. Only
exists if the offsets are available within the tokenizer</li>
</ul>
`,returnType:`
<p>A list or a list of list of <code>dict</code></p>
`}}),ti=new x({props:{name:"aggregate_words",anchor:"transformers.TokenClassificationPipeline.aggregate_words",parameters:[{name:"entities",val:": typing.List[dict]"},{name:"aggregation_strategy",val:": AggregationStrategy"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/token_classification.py#L369"}}),ni=new x({props:{name:"gather_pre_entities",anchor:"transformers.TokenClassificationPipeline.gather_pre_entities",parameters:[{name:"sentence",val:": str"},{name:"input_ids",val:": ndarray"},{name:"scores",val:": ndarray"},{name:"offset_mapping",val:": typing.Union[typing.List[typing.Tuple[int, int]], NoneType]"},{name:"special_tokens_mask",val:": ndarray"},{name:"aggregation_strategy",val:": AggregationStrategy"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/token_classification.py#L258"}}),oi=new x({props:{name:"group_entities",anchor:"transformers.TokenClassificationPipeline.group_entities",parameters:[{name:"entities",val:": typing.List[dict]"}],parametersDescription:[{anchor:"transformers.TokenClassificationPipeline.group_entities.entities",description:"<strong>entities</strong> (<code>dict</code>) &#x2014; The entities predicted by the pipeline.",name:"entities"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/token_classification.py#L431"}}),ri=new x({props:{name:"group_sub_entities",anchor:"transformers.TokenClassificationPipeline.group_sub_entities",parameters:[{name:"entities",val:": typing.List[dict]"}],parametersDescription:[{anchor:"transformers.TokenClassificationPipeline.group_sub_entities.entities",description:"<strong>entities</strong> (<code>dict</code>) &#x2014; The entities predicted by the pipeline.",name:"entities"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/token_classification.py#L396"}}),si=new D({}),ai=new x({props:{name:"class transformers.TranslationPipeline",anchor:"transformers.TranslationPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TranslationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.TranslationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.TranslationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.TranslationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.TranslationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.TranslationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.TranslationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.TranslationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.TranslationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.TranslationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/text2text_generation.py#L267"}}),Zo=new fe({props:{anchor:"transformers.TranslationPipeline.example",$$slots:{default:[yz]},$$scope:{ctx:A}}}),ci=new x({props:{name:"__call__",anchor:"transformers.TranslationPipeline.__call__",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TranslationPipeline.__call__.args",description:`<strong>args</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
Texts to be translated.`,name:"args"},{anchor:"transformers.TranslationPipeline.__call__.return_tensors",description:`<strong>return_tensors</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to include the tensors of predictions (as token indices) in the outputs.`,name:"return_tensors"},{anchor:"transformers.TranslationPipeline.__call__.return_text",description:`<strong>return_text</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to include the decoded texts in the outputs.`,name:"return_text"},{anchor:"transformers.TranslationPipeline.__call__.clean_up_tokenization_spaces",description:`<strong>clean_up_tokenization_spaces</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to clean up the potential extra spaces in the text output.`,name:"clean_up_tokenization_spaces"},{anchor:"transformers.TranslationPipeline.__call__.src_lang",description:`<strong>src_lang</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The language of the input. Might be required for multilingual models. Will not have any effect for
single pair translation models`,name:"src_lang"},{anchor:"transformers.TranslationPipeline.__call__.tgt_lang",description:`<strong>tgt_lang</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The language of the desired output. Might be required for multilingual models. Will not have any effect
for single pair translation models
generate_kwargs &#x2014;
Additional keyword arguments to pass along to the generate method of the model (see the generate method
corresponding to your framework <a href="./model#generative-models">here</a>).`,name:"tgt_lang"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/text2text_generation.py#L321",returnDescription:`
<p>Each result comes as a dictionary with the following keys:</p>
<ul>
<li><strong>translation_text</strong> (<code>str</code>, present when <code>return_text=True</code>) \u2014 The translation.</li>
<li><strong>translation_token_ids</strong> (<code>torch.Tensor</code> or <code>tf.Tensor</code>, present when <code>return_tensors=True</code>) \u2014 The
token ids of the translation.</li>
</ul>
`,returnType:`
<p>A list or a list of list of <code>dict</code></p>
`}}),di=new D({}),pi=new x({props:{name:"class transformers.VisualQuestionAnsweringPipeline",anchor:"transformers.VisualQuestionAnsweringPipeline",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.VisualQuestionAnsweringPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.VisualQuestionAnsweringPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.VisualQuestionAnsweringPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.VisualQuestionAnsweringPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.VisualQuestionAnsweringPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.VisualQuestionAnsweringPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.VisualQuestionAnsweringPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.VisualQuestionAnsweringPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.VisualQuestionAnsweringPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.VisualQuestionAnsweringPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/visual_question_answering.py#L19"}}),ui=new x({props:{name:"__call__",anchor:"transformers.VisualQuestionAnsweringPipeline.__call__",parameters:[{name:"image",val:": typing.Union[ForwardRef('Image.Image'), str]"},{name:"question",val:": str = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.VisualQuestionAnsweringPipeline.__call__.image",description:`<strong>image</strong> (<code>str</code>, <code>List[str]</code>, <code>PIL.Image</code> or <code>List[PIL.Image]</code>) &#x2014;
The pipeline handles three types of images:</p>
<ul>
<li>A string containing a http link pointing to an image</li>
<li>A string containing a local path to an image</li>
<li>An image loaded in PIL directly</li>
</ul>
<p>The pipeline accepts either a single image or a batch of images. If given a single image, it can be
broadcasted to multiple questions.`,name:"image"},{anchor:"transformers.VisualQuestionAnsweringPipeline.__call__.question",description:`<strong>question</strong> (<code>str</code>, <code>List[str]</code>) &#x2014;
The question(s) asked. If given a single question, it can be broadcasted to multiple images.`,name:"question"},{anchor:"transformers.VisualQuestionAnsweringPipeline.__call__.top_k",description:`<strong>top_k</strong> (<code>int</code>, <em>optional</em>, defaults to 5) &#x2014;
The number of top labels that will be returned by the pipeline. If the provided number is higher than
the number of labels available in the model configuration, it will default to the number of labels.`,name:"top_k"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/visual_question_answering.py#L46",returnDescription:`
<ul>
<li><strong>label</strong> (<code>str</code>) \u2014 The label identified by the model.</li>
<li><strong>score</strong> (<code>int</code>) \u2014 The score attributed by the model for that label.</li>
</ul>
`,returnType:`
<p>A dictionary or a list of dictionaries containing the result. The dictionaries contain the following keys</p>
`}}),gi=new D({}),_i=new x({props:{name:"class transformers.ZeroShotClassificationPipeline",anchor:"transformers.ZeroShotClassificationPipeline",parameters:[{name:"args_parser",val:" = <transformers.pipelines.zero_shot_classification.ZeroShotClassificationArgumentHandler object at 0x7f538ad12be0>"},{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.ZeroShotClassificationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.ZeroShotClassificationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.ZeroShotClassificationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.ZeroShotClassificationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.ZeroShotClassificationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.ZeroShotClassificationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.ZeroShotClassificationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.ZeroShotClassificationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.ZeroShotClassificationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.ZeroShotClassificationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/zero_shot_classification.py#L46"}}),ki=new x({props:{name:"__call__",anchor:"transformers.ZeroShotClassificationPipeline.__call__",parameters:[{name:"sequences",val:": typing.Union[str, typing.List[str]]"},{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.ZeroShotClassificationPipeline.__call__.sequences",description:`<strong>sequences</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
The sequence(s) to classify, will be truncated if the model input is too large.`,name:"sequences"},{anchor:"transformers.ZeroShotClassificationPipeline.__call__.candidate_labels",description:`<strong>candidate_labels</strong> (<code>str</code> or <code>List[str]</code>) &#x2014;
The set of possible class labels to classify each sequence into. Can be a single label, a string of
comma-separated labels, or a list of labels.`,name:"candidate_labels"},{anchor:"transformers.ZeroShotClassificationPipeline.__call__.hypothesis_template",description:`<strong>hypothesis_template</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;This example is {}.&quot;</code>) &#x2014;
The template used to turn each label into an NLI-style hypothesis. This template must include a {} or
similar syntax for the candidate label to be inserted into the template. For example, the default
template is <code>&quot;This example is {}.&quot;</code> With the candidate label <code>&quot;sports&quot;</code>, this would be fed into the
model like <code>&quot;&lt;cls&gt; sequence to classify &lt;sep&gt; This example is sports . &lt;sep&gt;&quot;</code>. The default template
works well in many cases, but it may be worthwhile to experiment with different templates depending on
the task setting.`,name:"hypothesis_template"},{anchor:"transformers.ZeroShotClassificationPipeline.__call__.multi_label",description:`<strong>multi_label</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not multiple candidate labels can be true. If <code>False</code>, the scores are normalized such that
the sum of the label likelihoods for each sequence is 1. If <code>True</code>, the labels are considered
independent and probabilities are normalized for each candidate by doing a softmax of the entailment
score vs. the contradiction score.`,name:"multi_label"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/zero_shot_classification.py#L139",returnDescription:`
<p>Each result comes as a dictionary with the following keys:</p>
<ul>
<li><strong>sequence</strong> (<code>str</code>) \u2014 The sequence for which this is the output.</li>
<li><strong>labels</strong> (<code>List[str]</code>) \u2014 The labels sorted by order of likelihood.</li>
<li><strong>scores</strong> (<code>List[float]</code>) \u2014 The probabilities for each of the labels.</li>
</ul>
`,returnType:`
<p>A <code>dict</code> or a list of <code>dict</code></p>
`}}),Ti=new D({}),yi=new x({props:{name:"class transformers.ZeroShotImageClassificationPipeline",anchor:"transformers.ZeroShotImageClassificationPipeline",parameters:[{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.ZeroShotImageClassificationPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.ZeroShotImageClassificationPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.ZeroShotImageClassificationPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.ZeroShotImageClassificationPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.ZeroShotImageClassificationPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.ZeroShotImageClassificationPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.ZeroShotImageClassificationPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.ZeroShotImageClassificationPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.ZeroShotImageClassificationPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.ZeroShotImageClassificationPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/zero_shot_image_classification.py#L31"}}),Ei=new x({props:{name:"__call__",anchor:"transformers.ZeroShotImageClassificationPipeline.__call__",parameters:[{name:"images",val:": typing.Union[str, typing.List[str], ForwardRef('Image'), typing.List[ForwardRef('Image')]]"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.ZeroShotImageClassificationPipeline.__call__.images",description:`<strong>images</strong> (<code>str</code>, <code>List[str]</code>, <code>PIL.Image</code> or <code>List[PIL.Image]</code>) &#x2014;
The pipeline handles three types of images:</p>
<ul>
<li>A string containing a http link pointing to an image</li>
<li>A string containing a local path to an image</li>
<li>An image loaded in PIL directly</li>
</ul>`,name:"images"},{anchor:"transformers.ZeroShotImageClassificationPipeline.__call__.candidate_labels",description:`<strong>candidate_labels</strong> (<code>List[str]</code>) &#x2014;
The candidate labels for this image`,name:"candidate_labels"},{anchor:"transformers.ZeroShotImageClassificationPipeline.__call__.hypothesis_template",description:`<strong>hypothesis_template</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;This is a photo of {}&quot;</code>) &#x2014;
The sentence used in cunjunction with <em>candidate_labels</em> to attempt the image classification by
replacing the placeholder with the candidate_labels. Then likelihood is estimated by using
logits_per_image`,name:"hypothesis_template"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/zero_shot_image_classification.py#L50",returnDescription:`
<p>A list of dictionaries containing result, one dictionnary per proposed label. The dictionaries contain the
following keys:</p>
<ul>
<li><strong>label</strong> (<code>str</code>) \u2014 The label identified by the model. It is one of the suggested <code>candidate_label</code>.</li>
<li><strong>score</strong> (<code>float</code>) \u2014 The score attributed by the model for that label (between 0 and 1).</li>
</ul>
`}}),qi=new D({}),Ai=new x({props:{name:"class transformers.ZeroShotObjectDetectionPipeline",anchor:"transformers.ZeroShotObjectDetectionPipeline",parameters:[{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.ZeroShotObjectDetectionPipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.ZeroShotObjectDetectionPipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.ZeroShotObjectDetectionPipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.ZeroShotObjectDetectionPipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.ZeroShotObjectDetectionPipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.ZeroShotObjectDetectionPipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.ZeroShotObjectDetectionPipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.ZeroShotObjectDetectionPipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.ZeroShotObjectDetectionPipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.ZeroShotObjectDetectionPipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/zero_shot_object_detection.py#L31"}}),Ci=new x({props:{name:"__call__",anchor:"transformers.ZeroShotObjectDetectionPipeline.__call__",parameters:[{name:"images",val:": typing.Union[str, typing.List[str], ForwardRef('Image.Image'), typing.List[ForwardRef('Image.Image')]]"},{name:"text_queries",val:": typing.Union[str, typing.List[str], typing.List[typing.List[str]]] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.ZeroShotObjectDetectionPipeline.__call__.images",description:`<strong>images</strong> (<code>str</code>, <code>List[str]</code>, <code>PIL.Image</code> or <code>List[PIL.Image]</code>) &#x2014;
The pipeline handles three types of images:</p>
<ul>
<li>A string containing an http url pointing to an image</li>
<li>A string containing a local path to an image</li>
<li>An image loaded in PIL directly</li>
</ul>`,name:"images"},{anchor:"transformers.ZeroShotObjectDetectionPipeline.__call__.text_queries",description:"<strong>text_queries</strong> (<code>str</code> or <code>List[str]</code> or <code>List[List[str]]</code>) &#x2014; Text queries to query the target image with.",name:"text_queries"},{anchor:"transformers.ZeroShotObjectDetectionPipeline.__call__.If",description:"<strong>If</strong> given multiple images, <code>text_queries</code> should be provided as a list of lists, where each nested list &#x2014;",name:"If"},{anchor:"transformers.ZeroShotObjectDetectionPipeline.__call__.contains",description:"<strong>contains</strong> the text queries for the corresponding image. &#x2014;",name:"contains"},{anchor:"transformers.ZeroShotObjectDetectionPipeline.__call__.threshold",description:`<strong>threshold</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The probability necessary to make a prediction.`,name:"threshold"},{anchor:"transformers.ZeroShotObjectDetectionPipeline.__call__.top_k",description:`<strong>top_k</strong> (<code>int</code>, <em>optional</em>, defaults to None) &#x2014;
The number of top predictions that will be returned by the pipeline. If the provided number is <code>None</code>
or higher than the number of predictions available, it will default to the number of predictions.`,name:"top_k"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/zero_shot_object_detection.py#L52",returnDescription:`
<p>A list of lists containing prediction results, one list per input image. Each list contains dictionaries
with the following keys:</p>
<ul>
<li><strong>label</strong> (<code>str</code>) \u2014 Text query corresponding to the found object.</li>
<li><strong>score</strong> (<code>float</code>) \u2014 Score corresponding to the object (between 0 and 1).</li>
<li><strong>box</strong> (<code>Dict[str,int]</code>) \u2014 Bounding box of the detected object in image\u2019s original size. It is a
dictionary with <code>x_min</code>, <code>x_max</code>, <code>y_min</code>, <code>y_max</code> keys.</li>
</ul>
`}}),Ii=new D({}),zi=new x({props:{name:"class transformers.Pipeline",anchor:"transformers.Pipeline",parameters:[{name:"model",val:": typing.Union[ForwardRef('PreTrainedModel'), ForwardRef('TFPreTrainedModel')]"},{name:"tokenizer",val:": typing.Optional[transformers.tokenization_utils.PreTrainedTokenizer] = None"},{name:"feature_extractor",val:": typing.Optional[ForwardRef('SequenceFeatureExtractor')] = None"},{name:"modelcard",val:": typing.Optional[transformers.modelcard.ModelCard] = None"},{name:"framework",val:": typing.Optional[str] = None"},{name:"task",val:": str = ''"},{name:"args_parser",val:": ArgumentHandler = None"},{name:"device",val:": typing.Union[int, str, ForwardRef('torch.device')] = -1"},{name:"binary_output",val:": bool = False"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.Pipeline.model",description:`<strong>model</strong> (<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> or <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a>) &#x2014;
The model that will be used by the pipeline to make predictions. This needs to be a model inheriting from
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a> for PyTorch and <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel">TFPreTrainedModel</a> for TensorFlow.`,name:"model"},{anchor:"transformers.Pipeline.tokenizer",description:`<strong>tokenizer</strong> (<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>) &#x2014;
The tokenizer that will be used by the pipeline to encode data for the model. This object inherits from
<a href="/docs/transformers/main/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>.`,name:"tokenizer"},{anchor:"transformers.Pipeline.modelcard",description:`<strong>modelcard</strong> (<code>str</code> or <code>ModelCard</code>, <em>optional</em>) &#x2014;
Model card attributed to the model for this pipeline.`,name:"modelcard"},{anchor:"transformers.Pipeline.framework",description:`<strong>framework</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The framework to use, either <code>&quot;pt&quot;</code> for PyTorch or <code>&quot;tf&quot;</code> for TensorFlow. The specified framework must be
installed.</p>
<p>If no framework is specified, will default to the one currently installed. If no framework is specified and
both frameworks are installed, will default to the framework of the <code>model</code>, or to PyTorch if no model is
provided.`,name:"framework"},{anchor:"transformers.Pipeline.task",description:`<strong>task</strong> (<code>str</code>, defaults to <code>&quot;&quot;</code>) &#x2014;
A task-identifier for the pipeline.`,name:"task"},{anchor:"transformers.Pipeline.num_workers",description:`<strong>num_workers</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the number of
workers to be used.`,name:"num_workers"},{anchor:"transformers.Pipeline.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
When the pipeline will use <em>DataLoader</em> (when passing a dataset, on GPU for a Pytorch model), the size of
the batch to use, for inference this is not always beneficial, please read <a href="https://huggingface.co/transformers/main_classes/pipelines.html#pipeline-batching" rel="nofollow">Batching with
pipelines</a> .`,name:"batch_size"},{anchor:"transformers.Pipeline.args_parser",description:`<strong>args_parser</strong> (<a href="/docs/transformers/main/en/internal/pipelines_utils#transformers.pipelines.ArgumentHandler">ArgumentHandler</a>, <em>optional</em>) &#x2014;
Reference to the object in charge of parsing supplied pipeline parameters.`,name:"args_parser"},{anchor:"transformers.Pipeline.device",description:`<strong>device</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run the model on
the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"},{anchor:"transformers.Pipeline.binary_output",description:`<strong>binary_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag indicating if the output the pipeline should happen in a binary format (i.e., pickle) or as raw text.`,name:"binary_output"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/base.py#L722"}}),Si=new x({props:{name:"check_model_type",anchor:"transformers.Pipeline.check_model_type",parameters:[{name:"supported_models",val:": typing.Union[typing.List[str], dict]"}],parametersDescription:[{anchor:"transformers.Pipeline.check_model_type.supported_models",description:`<strong>supported_models</strong> (<code>List[str]</code> or <code>dict</code>) &#x2014;
The list of models supported by the pipeline, or a dictionary with model class values.`,name:"supported_models"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/base.py#L907"}}),Mi=new x({props:{name:"device_placement",anchor:"transformers.Pipeline.device_placement",parameters:[],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/base.py#L847",returnDescription:`
<p>Context manager</p>
`}}),sr=new fe({props:{anchor:"transformers.Pipeline.device_placement.example",$$slots:{default:[xz]},$$scope:{ctx:A}}}),Fi=new x({props:{name:"ensure_tensor_on_device",anchor:"transformers.Pipeline.ensure_tensor_on_device",parameters:[{name:"**inputs",val:""}],parametersDescription:[{anchor:"transformers.Pipeline.ensure_tensor_on_device.inputs",description:`<strong>inputs</strong> (keyword arguments that should be <code>torch.Tensor</code>, the rest is ignored) &#x2014;
The tensors to place on <code>self.device</code>.`,name:"inputs"},{anchor:"transformers.Pipeline.ensure_tensor_on_device.Recursive",description:"<strong>Recursive</strong> on lists <strong>only</strong>. &#x2014;",name:"Recursive"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/base.py#L873",returnDescription:`
<p>The same as <code>inputs</code> but on the proper device.</p>
`,returnType:`
<p><code>Dict[str, torch.Tensor]</code></p>
`}}),Li=new x({props:{name:"postprocess",anchor:"transformers.Pipeline.postprocess",parameters:[{name:"model_outputs",val:": ModelOutput"},{name:"**postprocess_parameters",val:": typing.Dict"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/base.py#L964"}}),Oi=new x({props:{name:"predict",anchor:"transformers.Pipeline.predict",parameters:[{name:"X",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/base.py#L841"}}),Ni=new x({props:{name:"preprocess",anchor:"transformers.Pipeline.preprocess",parameters:[{name:"input_",val:": typing.Any"},{name:"**preprocess_parameters",val:": typing.Dict"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/base.py#L943"}}),Qi=new x({props:{name:"save_pretrained",anchor:"transformers.Pipeline.save_pretrained",parameters:[{name:"save_directory",val:": str"}],parametersDescription:[{anchor:"transformers.Pipeline.save_pretrained.save_directory",description:`<strong>save_directory</strong> (<code>str</code>) &#x2014;
A path to the directory where to saved. It will be created if it doesn&#x2019;t exist.`,name:"save_directory"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/base.py#L790"}}),Ri=new x({props:{name:"transform",anchor:"transformers.Pipeline.transform",parameters:[{name:"X",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/pipelines/base.py#L835"}}),{c(){k=o("meta"),$=l(),T=o("h1"),v=o("a"),y=o("span"),h(p.$$.fragment),P=l(),Se=o("span"),Hw=a("Pipelines"),Ou=l(),kn=o("p"),Vw=a(`The pipelines are a great and easy way to use models for inference. These pipelines are objects that abstract most of
the complex code from the library, offering a simple API dedicated to several tasks, including Named Entity
Recognition, Masked Language Modeling, Sentiment Analysis, Feature Extraction and Question Answering. See the
`),Xi=o("a"),Ww=a("task summary"),Zw=a(" for examples of use."),Gu=l(),Ji=o("p"),Bw=a("There are two categories of pipeline abstractions to be aware about:"),Nu=l(),Pn=o("ul"),ud=o("li"),br=o("p"),Yw=a("The "),el=o("a"),Kw=a("pipeline()"),Xw=a(" which is the most powerful object encapsulating all other pipelines."),Jw=l(),wr=o("li"),gd=o("p"),ev=a("The other task-specific pipelines:"),tv=l(),E=o("ul"),_d=o("li"),tl=o("a"),nv=a("AudioClassificationPipeline"),ov=l(),bd=o("li"),nl=o("a"),rv=a("AutomaticSpeechRecognitionPipeline"),sv=l(),wd=o("li"),ol=o("a"),av=a("ConversationalPipeline"),iv=l(),vd=o("li"),rl=o("a"),lv=a("DepthEstimationPipeline"),cv=l(),kd=o("li"),sl=o("a"),dv=a("DocumentQuestionAnsweringPipeline"),pv=l(),Pd=o("li"),al=o("a"),mv=a("FeatureExtractionPipeline"),fv=l(),Td=o("li"),il=o("a"),hv=a("FillMaskPipeline"),uv=l(),yd=o("li"),ll=o("a"),gv=a("ImageClassificationPipeline"),_v=l(),xd=o("li"),cl=o("a"),bv=a("ImageSegmentationPipeline"),wv=l(),$d=o("li"),dl=o("a"),vv=a("ImageToTextPipeline"),kv=l(),Ed=o("li"),pl=o("a"),Pv=a("ObjectDetectionPipeline"),Tv=l(),qd=o("li"),ml=o("a"),yv=a("QuestionAnsweringPipeline"),xv=l(),Ad=o("li"),fl=o("a"),$v=a("SummarizationPipeline"),Ev=l(),jd=o("li"),hl=o("a"),qv=a("TableQuestionAnsweringPipeline"),Av=l(),Dd=o("li"),ul=o("a"),jv=a("TextClassificationPipeline"),Dv=l(),Cd=o("li"),gl=o("a"),Cv=a("TextGenerationPipeline"),Iv=l(),Id=o("li"),_l=o("a"),zv=a("Text2TextGenerationPipeline"),Sv=l(),zd=o("li"),bl=o("a"),Mv=a("TokenClassificationPipeline"),Fv=l(),Sd=o("li"),wl=o("a"),Lv=a("TranslationPipeline"),Uv=l(),Md=o("li"),vl=o("a"),Ov=a("VisualQuestionAnsweringPipeline"),Gv=l(),Fd=o("li"),kl=o("a"),Nv=a("ZeroShotClassificationPipeline"),Qv=l(),Ld=o("li"),Pl=o("a"),Rv=a("ZeroShotImageClassificationPipeline"),Hv=l(),Ud=o("li"),Tl=o("a"),Vv=a("ZeroShotObjectDetectionPipeline"),Qu=l(),dt=o("h2"),Tn=o("a"),Od=o("span"),h(vr.$$.fragment),Wv=l(),Gd=o("span"),Zv=a("The pipeline abstraction"),Ru=l(),yn=o("p"),Bv=a("The "),Nd=o("em"),Yv=a("pipeline"),Kv=a(` abstraction is a wrapper around all the other available pipelines. It is instantiated as any other
pipeline but can provide additional quality of life.`),Hu=l(),yl=o("p"),Xv=a("Simple call on one item:"),Vu=l(),h(kr.$$.fragment),Wu=l(),xn=o("p"),Jv=a("If you want to use a specific model from the "),Pr=o("a"),e1=a("hub"),t1=a(` you can ignore the task if the model on
the hub already defines it:`),Zu=l(),h(Tr.$$.fragment),Bu=l(),$n=o("p"),n1=a("To call a pipeline on many items, you can either call with a "),Qd=o("em"),o1=a("list"),r1=a("."),Yu=l(),h(yr.$$.fragment),Ku=l(),En=o("p"),s1=a("To iterate of full datasets it is recommended to use a "),Rd=o("code"),a1=a("dataset"),i1=a(` directly. This means you don\u2019t need to allocate
the whole dataset at once, nor do you need to do batching yourself. This should work just as fast as custom loops on
GPU. If it doesn\u2019t don\u2019t hesitate to create an issue.`),Xu=l(),h(xr.$$.fragment),Ju=l(),xl=o("p"),l1=a("For ease of use, a generator is also possible:"),eg=l(),h($r.$$.fragment),tg=l(),oe=o("div"),h(Er.$$.fragment),c1=l(),qr=o("p"),d1=a("Utility factory method to build a "),$l=o("a"),p1=a("Pipeline"),m1=a("."),f1=l(),Hd=o("p"),h1=a("Pipelines are made of:"),u1=l(),pt=o("ul"),Ar=o("li"),g1=a("A "),El=o("a"),_1=a("tokenizer"),b1=a(" in charge of mapping raw textual input to token."),w1=l(),jr=o("li"),v1=a("A "),ql=o("a"),k1=a("model"),P1=a(" to make predictions from the inputs."),T1=l(),Vd=o("li"),y1=a("Some (optional) post processing for enhancing model\u2019s output."),x1=l(),h(qn.$$.fragment),ng=l(),mt=o("h2"),An=o("a"),Wd=o("span"),h(Dr.$$.fragment),$1=l(),Zd=o("span"),E1=a("Pipeline batching"),og=l(),Ne=o("p"),q1=a(`All pipelines can use batching. This will work
whenever the pipeline uses its streaming ability (so when passing lists or `),Bd=o("code"),A1=a("Dataset"),j1=a(" or "),Yd=o("code"),D1=a("generator"),C1=a(")."),rg=l(),h(Cr.$$.fragment),sg=l(),h(jn.$$.fragment),ag=l(),h(Ir.$$.fragment),ig=l(),h(zr.$$.fragment),lg=l(),Al=o("p"),I1=a("Example where it\u2019s most a slowdown:"),cg=l(),h(Sr.$$.fragment),dg=l(),Dn=o("p"),z1=a("This is a occasional very long sentence compared to the other. In that case, the "),Kd=o("strong"),S1=a("whole"),M1=a(` batch will need to be 400
tokens long, so the whole batch will be [64, 400] instead of [64, 4], leading to the high slowdown. Even worse, on
bigger batches, the program simply crashes.`),pg=l(),h(Mr.$$.fragment),mg=l(),jl=o("p"),F1=a(`There are no good (general) solutions for this problem, and your mileage may vary depending on your use cases. Rule of
thumb:`),fg=l(),Dl=o("p"),L1=a("For users, a rule of thumb is:"),hg=l(),ue=o("ul"),Xd=o("li"),Jd=o("p"),ep=o("strong"),U1=a(`Measure performance on your load, with your hardware. Measure, measure, and keep measuring. Real numbers are the
only way to go.`),O1=l(),tp=o("li"),np=o("p"),G1=a("If you are latency constrained (live product doing inference), don\u2019t batch"),N1=l(),op=o("li"),rp=o("p"),Q1=a("If you are using CPU, don\u2019t batch."),R1=l(),Fr=o("li"),sp=o("p"),H1=a("If you are using throughput (you want to run your model on a bunch of static data), on GPU, then:"),V1=l(),ft=o("ul"),ap=o("li"),W1=a(`If you have no clue about the size of the sequence_length (\u201Cnatural\u201D data), by default don\u2019t batch, measure and
try tentatively to add it, add OOM checks to recover when it will fail (and it will at some point if you don\u2019t
control the sequence_length.)`),Z1=l(),ip=o("li"),B1=a(`If your sequence_length is super regular, then batching is more likely to be VERY interesting, measure and push
it until you get OOMs.`),Y1=l(),lp=o("li"),K1=a("The larger the GPU the more likely batching is going to be more interesting"),X1=l(),cp=o("li"),dp=o("p"),J1=a("As soon as you enable batching, make sure you can handle OOMs nicely."),ug=l(),ht=o("h2"),Cn=o("a"),pp=o("span"),h(Lr.$$.fragment),ek=l(),mp=o("span"),tk=a("Pipeline chunk batching"),gg=l(),Me=o("p"),fp=o("code"),nk=a("zero-shot-classification"),ok=a(" and "),hp=o("code"),rk=a("question-answering"),sk=a(` are slightly specific in the sense, that a single input might yield
multiple forward pass of a model. Under normal circumstances, this would yield issues with `),up=o("code"),ak=a("batch_size"),ik=a(" argument."),_g=l(),Qe=o("p"),lk=a("In order to circumvent this issue, both of these pipelines are a bit specific, they are "),gp=o("code"),ck=a("ChunkPipeline"),dk=a(` instead of
regular `),_p=o("code"),pk=a("Pipeline"),mk=a(". In short:"),bg=l(),h(Ur.$$.fragment),wg=l(),Cl=o("p"),fk=a("Now becomes:"),vg=l(),h(Or.$$.fragment),kg=l(),Il=o("p"),hk=a(`This should be very transparent to your code because the pipelines are used in
the same way.`),Pg=l(),In=o("p"),uk=a(`This is a simplified view, since the pipeline can handle automatically the batch to ! Meaning you don\u2019t have to care
about how many forward passes you inputs are actually going to trigger, you can optimize the `),bp=o("code"),gk=a("batch_size"),_k=a(`
independently of the inputs. The caveats from the previous section still apply.`),Tg=l(),ut=o("h2"),zn=o("a"),wp=o("span"),h(Gr.$$.fragment),bk=l(),vp=o("span"),wk=a("Pipeline custom code"),yg=l(),zl=o("p"),vk=a("If you want to override a specific pipeline."),xg=l(),Sn=o("p"),kk=a(`Don\u2019t hesitate to create an issue for your task at hand, the goal of the pipeline is to be easy to use and support most
cases, so `),kp=o("code"),Pk=a("transformers"),Tk=a(" could maybe support your use case."),$g=l(),Sl=o("p"),yk=a("If you want to try simply you can:"),Eg=l(),Ml=o("ul"),Pp=o("li"),xk=a("Subclass your pipeline of choice"),qg=l(),h(Nr.$$.fragment),Ag=l(),Fl=o("p"),$k=a("That should enable you to do all the custom code you want."),jg=l(),gt=o("h2"),Mn=o("a"),Tp=o("span"),h(Qr.$$.fragment),Ek=l(),yp=o("span"),qk=a("Implementing a pipeline"),Dg=l(),Ll=o("p"),Ul=o("a"),Ak=a("Implementing a new pipeline"),Cg=l(),_t=o("h2"),Fn=o("a"),xp=o("span"),h(Rr.$$.fragment),jk=l(),$p=o("span"),Dk=a("The task specific pipelines"),Ig=l(),bt=o("h3"),Ln=o("a"),Ep=o("span"),h(Hr.$$.fragment),Ck=l(),qp=o("span"),Ik=a("AudioClassificationPipeline"),zg=l(),L=o("div"),h(Vr.$$.fragment),zk=l(),Wr=o("p"),Sk=a("Audio classification pipeline using any "),Ap=o("code"),Mk=a("AutoModelForAudioClassification"),Fk=a(`. This pipeline predicts the class of a
raw waveform or an audio file. In case of an audio file, ffmpeg should be installed to support multiple audio
formats.`),Lk=l(),h(Un.$$.fragment),Uk=l(),jp=o("p"),Ol=o("a"),Ok=a("Using pipelines in a webserver or with a dataset"),Gk=l(),wt=o("p"),Nk=a("This pipeline can currently be loaded from "),Gl=o("a"),Qk=a("pipeline()"),Rk=a(` using the following task identifier:
`),Dp=o("code"),Hk=a('"audio-classification"'),Vk=a("."),Wk=l(),Zr=o("p"),Zk=a(`See the list of available models on
`),Br=o("a"),Bk=a("huggingface.co/models"),Yk=a("."),Kk=l(),On=o("div"),h(Yr.$$.fragment),Xk=l(),Kr=o("p"),Jk=a("Classify the sequence(s) given as inputs. See the "),Nl=o("a"),eP=a("AutomaticSpeechRecognitionPipeline"),tP=a(` documentation for more
information.`),Sg=l(),vt=o("h3"),Gn=o("a"),Cp=o("span"),h(Xr.$$.fragment),nP=l(),Ip=o("span"),oP=a("AutomaticSpeechRecognitionPipeline"),Mg=l(),Z=o("div"),h(Jr.$$.fragment),rP=l(),zp=o("p"),sP=a("Pipeline that aims at extracting spoken text contained within some audio."),aP=l(),Sp=o("p"),iP=a(`The input can be either a raw waveform or a audio file. In case of the audio file, ffmpeg should be installed for
to support multiple audio formats`),lP=l(),h(Nn.$$.fragment),cP=l(),Mp=o("p"),Ql=o("a"),dP=a("Using pipelines in a webserver or with a dataset"),pP=l(),Qn=o("div"),h(es.$$.fragment),mP=l(),ts=o("p"),fP=a("Transcribe the audio sequence(s) given as inputs to text. See the "),Rl=o("a"),hP=a("AutomaticSpeechRecognitionPipeline"),uP=a(`
documentation for more information.`),Fg=l(),kt=o("h3"),Rn=o("a"),Fp=o("span"),h(ns.$$.fragment),gP=l(),Lp=o("span"),_P=a("ConversationalPipeline"),Lg=l(),U=o("div"),h(os.$$.fragment),bP=l(),Fe=o("p"),wP=a(`Utility class containing a conversation and its history. This class is meant to be used as an input to the
`),Hl=o("a"),vP=a("ConversationalPipeline"),kP=a(`. The conversation contains a number of utility function to manage the addition of new
user input and generated model responses. A conversation needs to contain an unprocessed user input before being
passed to the `),Vl=o("a"),PP=a("ConversationalPipeline"),TP=a(`. This user input is either created when the class is instantiated, or by
calling `),Up=o("code"),yP=a('conversational_pipeline.append_response("input")'),xP=a(" after a conversation turn."),$P=l(),h(Hn.$$.fragment),EP=l(),Vn=o("div"),h(rs.$$.fragment),qP=l(),ss=o("p"),AP=a("Add a user input to the conversation for the next round. This populates the internal "),Op=o("code"),jP=a("new_user_input"),DP=a(" field."),CP=l(),Wn=o("div"),h(as.$$.fragment),IP=l(),Gp=o("p"),zP=a("Append a response to the list of generated responses."),SP=l(),Re=o("div"),h(is.$$.fragment),MP=l(),Np=o("p"),FP=a("Iterates over all blobs of the conversation."),LP=l(),$e=o("p"),UP=a("Returns: Iterator of (is_user, text_chunk) in chronological order of the conversation. "),Qp=o("code"),OP=a("is_user"),GP=a(" is a "),Rp=o("code"),NP=a("bool"),QP=a(`,
`),Hp=o("code"),RP=a("text_chunks"),HP=a(" is a "),Vp=o("code"),VP=a("str"),WP=a("."),ZP=l(),Zn=o("div"),h(ls.$$.fragment),BP=l(),Le=o("p"),YP=a("Mark the conversation as processed (moves the content of "),Wp=o("code"),KP=a("new_user_input"),XP=a(" to "),Zp=o("code"),JP=a("past_user_inputs"),eT=a(`) and empties
the `),Bp=o("code"),tT=a("new_user_input"),nT=a(" field."),Ug=l(),O=o("div"),h(cs.$$.fragment),oT=l(),Yp=o("p"),rT=a("Multi-turn conversational pipeline."),sT=l(),h(Bn.$$.fragment),aT=l(),Kp=o("p"),Wl=o("a"),iT=a("Using pipelines in a webserver or with a dataset"),lT=l(),Pt=o("p"),cT=a("This conversational pipeline can currently be loaded from "),Zl=o("a"),dT=a("pipeline()"),pT=a(` using the following task identifier:
`),Xp=o("code"),mT=a('"conversational"'),fT=a("."),hT=l(),Ee=o("p"),uT=a(`The models that this pipeline can use are models that have been fine-tuned on a multi-turn conversational task,
currently: `),Jp=o("em"),gT=a("\u2018microsoft/DialoGPT-small\u2019"),_T=a(", "),em=o("em"),bT=a("\u2018microsoft/DialoGPT-medium\u2019"),wT=a(", "),tm=o("em"),vT=a("\u2018microsoft/DialoGPT-large\u2019"),kT=a(`. See the
up-to-date list of available models on
`),ds=o("a"),PT=a("huggingface.co/models"),TT=a("."),yT=l(),Yn=o("div"),h(ps.$$.fragment),xT=l(),nm=o("p"),$T=a("Generate responses for the conversation(s) given as inputs."),Og=l(),Tt=o("h3"),Kn=o("a"),om=o("span"),h(ms.$$.fragment),ET=l(),rm=o("span"),qT=a("DepthEstimationPipeline"),Gg=l(),G=o("div"),h(fs.$$.fragment),AT=l(),hs=o("p"),jT=a("Depth estimation pipeline using any "),sm=o("code"),DT=a("AutoModelForDepthEstimation"),CT=a(". This pipeline predicts the depth of an image."),IT=l(),h(Xn.$$.fragment),zT=l(),am=o("p"),Bl=o("a"),ST=a("Using pipelines in a webserver or with a dataset"),MT=l(),yt=o("p"),FT=a("This depth estimation pipeline can currently be loaded from "),Yl=o("a"),LT=a("pipeline()"),UT=a(` using the following task identifier:
`),im=o("code"),OT=a('"depth-estimation"'),GT=a("."),NT=l(),us=o("p"),QT=a("See the list of available models on "),gs=o("a"),RT=a("huggingface.co/models"),HT=a("."),VT=l(),Jn=o("div"),h(_s.$$.fragment),WT=l(),lm=o("p"),ZT=a("Assign labels to the image(s) passed as inputs."),Ng=l(),xt=o("h3"),eo=o("a"),cm=o("span"),h(bs.$$.fragment),BT=l(),dm=o("span"),YT=a("DocumentQuestionAnsweringPipeline"),Qg=l(),N=o("div"),h(ws.$$.fragment),KT=l(),vs=o("p"),XT=a("Document Question Answering pipeline using any "),pm=o("code"),JT=a("AutoModelForDocumentQuestionAnswering"),e2=a(`. The inputs/outputs are
similar to the (extractive) question answering pipeline; however, the pipeline takes an image (and optional OCR\u2019d
words/boxes) as input instead of text context.`),t2=l(),h(to.$$.fragment),n2=l(),mm=o("p"),Kl=o("a"),o2=a("Using pipelines in a webserver or with a dataset"),r2=l(),$t=o("p"),s2=a("This document question answering pipeline can currently be loaded from "),Xl=o("a"),a2=a("pipeline()"),i2=a(` using the following task
identifier: `),fm=o("code"),l2=a('"document-question-answering"'),c2=a("."),d2=l(),ks=o("p"),p2=a(`The models that this pipeline can use are models that have been fine-tuned on a document question answering task.
See the up-to-date list of available models on
`),Ps=o("a"),m2=a("huggingface.co/models"),f2=a("."),h2=l(),Ae=o("div"),h(Ts.$$.fragment),u2=l(),ys=o("p"),g2=a(`Answer the question(s) given as inputs by using the document(s). A document is defined as an image and an
optional list of (word, box) tuples which represent the text in the document. If the `),hm=o("code"),_2=a("word_boxes"),b2=a(` are not
provided, it will use the Tesseract OCR engine (if available) to extract the words and boxes automatically for
LayoutLM-like models which require them as input. For Donut, no OCR is run.`),w2=l(),um=o("p"),v2=a("You can invoke the pipeline several ways:"),k2=l(),Ue=o("ul"),gm=o("li"),_m=o("code"),P2=a("pipeline(image=image, question=question)"),T2=l(),bm=o("li"),wm=o("code"),y2=a("pipeline(image=image, question=question, word_boxes=word_boxes)"),x2=l(),vm=o("li"),km=o("code"),$2=a('pipeline([{"image": image, "question": question}])'),E2=l(),Pm=o("li"),Tm=o("code"),q2=a('pipeline([{"image": image, "question": question, "word_boxes": word_boxes}])'),Rg=l(),Et=o("h3"),no=o("a"),ym=o("span"),h(xs.$$.fragment),A2=l(),xm=o("span"),j2=a("FeatureExtractionPipeline"),Hg=l(),Q=o("div"),h($s.$$.fragment),D2=l(),$m=o("p"),C2=a(`Feature extraction pipeline using no model head. This pipeline extracts the hidden states from the base
transformer, which can be used as features in downstream tasks.`),I2=l(),h(oo.$$.fragment),z2=l(),Em=o("p"),Jl=o("a"),S2=a("Using pipelines in a webserver or with a dataset"),M2=l(),qt=o("p"),F2=a("This feature extraction pipeline can currently be loaded from "),ec=o("a"),L2=a("pipeline()"),U2=a(` using the task identifier:
`),qm=o("code"),O2=a('"feature-extraction"'),G2=a("."),N2=l(),Es=o("p"),Q2=a(`All models may be used for this pipeline. See a list of all models, including community-contributed models on
`),qs=o("a"),R2=a("huggingface.co/models"),H2=a("."),V2=l(),ro=o("div"),h(As.$$.fragment),W2=l(),Am=o("p"),Z2=a("Extract the features of the input(s)."),Vg=l(),At=o("h3"),so=o("a"),jm=o("span"),h(js.$$.fragment),B2=l(),Dm=o("span"),Y2=a("FillMaskPipeline"),Wg=l(),S=o("div"),h(Ds.$$.fragment),K2=l(),jt=o("p"),X2=a("Masked language modeling prediction pipeline using any "),Cm=o("code"),J2=a("ModelWithLMHead"),ey=a(". See the "),tc=o("a"),ty=a(`masked language modeling
examples`),ny=a(" for more information."),oy=l(),h(ao.$$.fragment),ry=l(),Im=o("p"),nc=o("a"),sy=a("Using pipelines in a webserver or with a dataset"),ay=l(),Dt=o("p"),iy=a("This mask filling pipeline can currently be loaded from "),oc=o("a"),ly=a("pipeline()"),cy=a(` using the following task identifier:
`),zm=o("code"),dy=a('"fill-mask"'),py=a("."),my=l(),Cs=o("p"),fy=a(`The models that this pipeline can use are models that have been trained with a masked language modeling objective,
which includes the bi-directional models in the library. See the up-to-date list of available models on
`),Is=o("a"),hy=a("huggingface.co/models"),uy=a("."),gy=l(),h(io.$$.fragment),_y=l(),lo=o("div"),h(zs.$$.fragment),by=l(),Sm=o("p"),wy=a("Fill the masked token in the text(s) given as inputs."),Zg=l(),Ct=o("h3"),co=o("a"),Mm=o("span"),h(Ss.$$.fragment),vy=l(),Fm=o("span"),ky=a("ImageClassificationPipeline"),Bg=l(),re=o("div"),h(Ms.$$.fragment),Py=l(),Fs=o("p"),Ty=a("Image classification pipeline using any "),Lm=o("code"),yy=a("AutoModelForImageClassification"),xy=a(`. This pipeline predicts the class of an
image.`),$y=l(),It=o("p"),Ey=a("This image classification pipeline can currently be loaded from "),rc=o("a"),qy=a("pipeline()"),Ay=a(` using the following task identifier:
`),Um=o("code"),jy=a('"image-classification"'),Dy=a("."),Cy=l(),Ls=o("p"),Iy=a(`See the list of available models on
`),Us=o("a"),zy=a("huggingface.co/models"),Sy=a("."),My=l(),po=o("div"),h(Os.$$.fragment),Fy=l(),Om=o("p"),Ly=a("Assign labels to the image(s) passed as inputs."),Yg=l(),zt=o("h3"),mo=o("a"),Gm=o("span"),h(Gs.$$.fragment),Uy=l(),Nm=o("span"),Oy=a("ImageSegmentationPipeline"),Kg=l(),se=o("div"),h(Ns.$$.fragment),Gy=l(),Qs=o("p"),Ny=a("Image segmentation pipeline using any "),Qm=o("code"),Qy=a("AutoModelForXXXSegmentation"),Ry=a(`. This pipeline predicts masks of objects and
their classes.`),Hy=l(),St=o("p"),Vy=a("This image segmentation pipeline can currently be loaded from "),sc=o("a"),Wy=a("pipeline()"),Zy=a(` using the following task identifier:
`),Rm=o("code"),By=a('"image-segmentation"'),Yy=a("."),Ky=l(),Rs=o("p"),Xy=a(`See the list of available models on
`),Hs=o("a"),Jy=a("huggingface.co/models"),e0=a("."),t0=l(),fo=o("div"),h(Vs.$$.fragment),n0=l(),Hm=o("p"),o0=a("Perform segmentation (detect masks & classes) in the image(s) passed as inputs."),Xg=l(),Mt=o("h3"),ho=o("a"),Vm=o("span"),h(Ws.$$.fragment),r0=l(),Wm=o("span"),s0=a("ImageToTextPipeline"),Jg=l(),ae=o("div"),h(Zs.$$.fragment),a0=l(),Bs=o("p"),i0=a("Image To Text pipeline using a "),Zm=o("code"),l0=a("AutoModelForVision2Seq"),c0=a(". This pipeline predicts a caption for a given image."),d0=l(),Bm=o("p"),p0=a(`This image to text pipeline can currently be loaded from pipeline() using the following task identifier:
\u201Cimage-to-text\u201D.`),m0=l(),Ys=o("p"),f0=a(`See the list of available models on
`),Ks=o("a"),h0=a("huggingface.co/models"),u0=a("."),g0=l(),uo=o("div"),h(Xs.$$.fragment),_0=l(),Ym=o("p"),b0=a("Assign labels to the image(s) passed as inputs."),e_=l(),Ft=o("h3"),go=o("a"),Km=o("span"),h(Js.$$.fragment),w0=l(),Xm=o("span"),v0=a("NerPipeline"),t_=l(),M=o("div"),h(ea.$$.fragment),k0=l(),Lt=o("p"),P0=a("Named Entity Recognition pipeline using any "),Jm=o("code"),T0=a("ModelForTokenClassification"),y0=a(". See the "),ac=o("a"),x0=a(`named entity recognition
examples`),$0=a(" for more information."),E0=l(),Ut=o("p"),q0=a("This token recognition pipeline can currently be loaded from "),ic=o("a"),A0=a("pipeline()"),j0=a(` using the following task identifier:
`),ef=o("code"),D0=a('"ner"'),C0=a(" (for predicting the classes of tokens in a sequence: person, organisation, location or miscellaneous)."),I0=l(),ta=o("p"),z0=a(`The models that this pipeline can use are models that have been fine-tuned on a token classification task. See the
up-to-date list of available models on
`),na=o("a"),S0=a("huggingface.co/models"),M0=a("."),F0=l(),He=o("div"),h(oa.$$.fragment),L0=l(),tf=o("p"),U0=a("Override tokens from a given word that disagree to force agreement on word boundaries."),O0=l(),nf=o("p"),G0=a(`Example: micro|soft| com|pany| B-ENT I-NAME I-ENT I-ENT will be rewritten with first strategy as microsoft|
company| B-ENT I-ENT`),N0=l(),_o=o("div"),h(ra.$$.fragment),Q0=l(),of=o("p"),R0=a("Fuse various numpy arrays into dicts with all the information needed for aggregation"),H0=l(),bo=o("div"),h(sa.$$.fragment),V0=l(),rf=o("p"),W0=a("Find and group together the adjacent tokens with the same entity predicted."),Z0=l(),wo=o("div"),h(aa.$$.fragment),B0=l(),sf=o("p"),Y0=a("Group together the adjacent tokens with the same entity predicted."),n_=l(),vo=o("p"),K0=a("See "),lc=o("a"),X0=a("TokenClassificationPipeline"),J0=a(" for all details."),o_=l(),Ot=o("h3"),ko=o("a"),af=o("span"),h(ia.$$.fragment),ex=l(),lf=o("span"),tx=a("ObjectDetectionPipeline"),r_=l(),ie=o("div"),h(la.$$.fragment),nx=l(),ca=o("p"),ox=a("Object detection pipeline using any "),cf=o("code"),rx=a("AutoModelForObjectDetection"),sx=a(`. This pipeline predicts bounding boxes of objects
and their classes.`),ax=l(),Gt=o("p"),ix=a("This object detection pipeline can currently be loaded from "),cc=o("a"),lx=a("pipeline()"),cx=a(` using the following task identifier:
`),df=o("code"),dx=a('"object-detection"'),px=a("."),mx=l(),da=o("p"),fx=a("See the list of available models on "),pa=o("a"),hx=a("huggingface.co/models"),ux=a("."),gx=l(),Po=o("div"),h(ma.$$.fragment),_x=l(),pf=o("p"),bx=a("Detect objects (bounding boxes & classes) in the image(s) passed as inputs."),s_=l(),Nt=o("h3"),To=o("a"),mf=o("span"),h(fa.$$.fragment),wx=l(),ff=o("span"),vx=a("QuestionAnsweringPipeline"),a_=l(),R=o("div"),h(ha.$$.fragment),kx=l(),Qt=o("p"),Px=a("Question Answering pipeline using any "),hf=o("code"),Tx=a("ModelForQuestionAnswering"),yx=a(". See the "),dc=o("a"),xx=a(`question answering
examples`),$x=a(" for more information."),Ex=l(),Rt=o("p"),qx=a("This question answering pipeline can currently be loaded from "),pc=o("a"),Ax=a("pipeline()"),jx=a(` using the following task identifier:
`),uf=o("code"),Dx=a('"question-answering"'),Cx=a("."),Ix=l(),ua=o("p"),zx=a(`The models that this pipeline can use are models that have been fine-tuned on a question answering task. See the
up-to-date list of available models on
`),ga=o("a"),Sx=a("huggingface.co/models"),Mx=a("."),Fx=l(),yo=o("div"),h(_a.$$.fragment),Lx=l(),gf=o("p"),Ux=a("Answer the question(s) given as inputs by using the context(s)."),Ox=l(),Ve=o("div"),h(ba.$$.fragment),Gx=l(),Ht=o("p"),Nx=a("QuestionAnsweringPipeline leverages the "),_f=o("code"),Qx=a("SquadExample"),Rx=a(` internally. This helper method encapsulate all the
logic for converting question(s) and context(s) to `),bf=o("code"),Hx=a("SquadExample"),Vx=a("."),Wx=l(),wf=o("p"),Zx=a("We currently support extractive question answering."),Bx=l(),xo=o("div"),h(wa.$$.fragment),Yx=l(),vf=o("p"),Kx=a("When decoding from token probabilities, this method maps token indexes to actual word in the initial context."),i_=l(),Vt=o("h3"),$o=o("a"),kf=o("span"),h(va.$$.fragment),Xx=l(),Pf=o("span"),Jx=a("SummarizationPipeline"),l_=l(),B=o("div"),h(ka.$$.fragment),e$=l(),Tf=o("p"),t$=a("Summarize news articles and other documents."),n$=l(),Wt=o("p"),o$=a("This summarizing pipeline can currently be loaded from "),mc=o("a"),r$=a("pipeline()"),s$=a(` using the following task identifier:
`),yf=o("code"),a$=a('"summarization"'),i$=a("."),l$=l(),F=o("p"),c$=a(`The models that this pipeline can use are models that have been fine-tuned on a summarization task, which is
currently, \u2019`),xf=o("em"),d$=a("bart-large-cnn"),p$=a("\u2019, \u2019"),$f=o("em"),m$=a("t5-small"),f$=a("\u2019, \u2019"),Ef=o("em"),h$=a("t5-base"),u$=a("\u2019, \u2019"),qf=o("em"),g$=a("t5-large"),_$=a("\u2019, \u2019"),Af=o("em"),b$=a("t5-3b"),w$=a("\u2019, \u2019"),jf=o("em"),v$=a("t5-11b"),k$=a(`\u2019. See the up-to-date
list of available models on `),Pa=o("a"),P$=a("huggingface.co/models"),T$=a(`. For a list
of available parameters, see the `),Ta=o("a"),y$=a(`following
documentation`),x$=l(),h(Eo.$$.fragment),$$=l(),qo=o("div"),h(ya.$$.fragment),E$=l(),Df=o("p"),q$=a("Summarize the text(s) given as inputs."),c_=l(),Zt=o("h3"),Ao=o("a"),Cf=o("span"),h(xa.$$.fragment),A$=l(),If=o("span"),j$=a("TableQuestionAnsweringPipeline"),d_=l(),le=o("div"),h($a.$$.fragment),D$=l(),Ea=o("p"),C$=a("Table Question Answering pipeline using a "),zf=o("code"),I$=a("ModelForTableQuestionAnswering"),z$=a(`. This pipeline is only available in
PyTorch.`),S$=l(),Bt=o("p"),M$=a("This tabular question answering pipeline can currently be loaded from "),fc=o("a"),F$=a("pipeline()"),L$=a(` using the following task
identifier: `),Sf=o("code"),U$=a('"table-question-answering"'),O$=a("."),G$=l(),qa=o("p"),N$=a(`The models that this pipeline can use are models that have been fine-tuned on a tabular question answering task.
See the up-to-date list of available models on
`),Aa=o("a"),Q$=a("huggingface.co/models"),R$=a("."),H$=l(),V=o("div"),h(ja.$$.fragment),V$=l(),Mf=o("p"),W$=a("Answers queries according to a table. The pipeline accepts several types of inputs which are detailed below:"),Z$=l(),Y=o("ul"),Ff=o("li"),Lf=o("code"),B$=a("pipeline(table, query)"),Y$=l(),Uf=o("li"),Of=o("code"),K$=a("pipeline(table, [query])"),X$=l(),Gf=o("li"),Nf=o("code"),J$=a("pipeline(table=table, query=query)"),e4=l(),Qf=o("li"),Rf=o("code"),t4=a("pipeline(table=table, query=[query])"),n4=l(),Hf=o("li"),Vf=o("code"),o4=a('pipeline({"table": table, "query": query})'),r4=l(),Wf=o("li"),Zf=o("code"),s4=a('pipeline({"table": table, "query": [query]})'),a4=l(),Bf=o("li"),Yf=o("code"),i4=a('pipeline([{"table": table, "query": query}, {"table": table, "query": query}])'),l4=l(),Da=o("p"),c4=a("The "),Kf=o("code"),d4=a("table"),p4=a(" argument should be a dict or a DataFrame built from that dict, containing the whole table:"),m4=l(),h(jo.$$.fragment),f4=l(),Xf=o("p"),h4=a("This dictionary can be passed in as such, or can be converted to a pandas DataFrame:"),u4=l(),h(Do.$$.fragment),p_=l(),Yt=o("h3"),Co=o("a"),Jf=o("span"),h(Ca.$$.fragment),g4=l(),eh=o("span"),_4=a("TextClassificationPipeline"),m_=l(),K=o("div"),h(Ia.$$.fragment),b4=l(),Kt=o("p"),w4=a("Text classification pipeline using any "),th=o("code"),v4=a("ModelForSequenceClassification"),k4=a(". See the "),hc=o("a"),P4=a(`sequence classification
examples`),T4=a(" for more information."),y4=l(),Xt=o("p"),x4=a("This text classification pipeline can currently be loaded from "),uc=o("a"),$4=a("pipeline()"),E4=a(` using the following task identifier:
`),nh=o("code"),q4=a('"sentiment-analysis"'),A4=a(" (for classifying sequences according to positive or negative sentiments)."),j4=l(),za=o("p"),D4=a("If multiple classification labels are available ("),oh=o("code"),C4=a("model.config.num_labels >= 2"),I4=a(`), the pipeline will run a softmax
over the results. If there is a single label, the pipeline will run a sigmoid over the result.`),z4=l(),Sa=o("p"),S4=a(`The models that this pipeline can use are models that have been fine-tuned on a sequence classification task. See
the up-to-date list of available models on
`),Ma=o("a"),M4=a("huggingface.co/models"),F4=a("."),L4=l(),Io=o("div"),h(Fa.$$.fragment),U4=l(),rh=o("p"),O4=a("Classify the text(s) given as inputs."),f_=l(),Jt=o("h3"),zo=o("a"),sh=o("span"),h(La.$$.fragment),G4=l(),ah=o("span"),N4=a("TextGenerationPipeline"),h_=l(),ce=o("div"),h(Ua.$$.fragment),Q4=l(),Oa=o("p"),R4=a("Language generation pipeline using any "),ih=o("code"),H4=a("ModelWithLMHead"),V4=a(`. This pipeline predicts the words that will follow a
specified text prompt.`),W4=l(),en=o("p"),Z4=a("This language generation pipeline can currently be loaded from "),gc=o("a"),B4=a("pipeline()"),Y4=a(` using the following task identifier:
`),lh=o("code"),K4=a('"text-generation"'),X4=a("."),J4=l(),Ga=o("p"),eE=a(`The models that this pipeline can use are models that have been trained with an autoregressive language modeling
objective, which includes the uni-directional models in the library (e.g. gpt2). See the list of available models
on `),Na=o("a"),tE=a("huggingface.co/models"),nE=a("."),oE=l(),So=o("div"),h(Qa.$$.fragment),rE=l(),ch=o("p"),sE=a("Complete the prompt(s) given as inputs."),u_=l(),tn=o("h3"),Mo=o("a"),dh=o("span"),h(Ra.$$.fragment),aE=l(),ph=o("span"),iE=a("Text2TextGenerationPipeline"),g_=l(),H=o("div"),h(Ha.$$.fragment),lE=l(),mh=o("p"),cE=a("Pipeline for text to text generation using seq2seq models."),dE=l(),nn=o("p"),pE=a("This Text2TextGenerationPipeline pipeline can currently be loaded from "),_c=o("a"),mE=a("pipeline()"),fE=a(` using the following task
identifier: `),fh=o("code"),hE=a('"text2text-generation"'),uE=a("."),gE=l(),Fo=o("p"),_E=a(`The models that this pipeline can use are models that have been fine-tuned on a translation task. See the
up-to-date list of available models on
`),Va=o("a"),bE=a("huggingface.co/models"),wE=a(`. For a list of available
parameters, see the `),Wa=o("a"),vE=a(`following
documentation`),kE=l(),h(Lo.$$.fragment),PE=l(),Uo=o("div"),h(Za.$$.fragment),TE=l(),hh=o("p"),yE=a("Generate the output text(s) using text(s) given as inputs."),xE=l(),Oo=o("div"),h(Ba.$$.fragment),$E=l(),uh=o("p"),EE=a("Checks whether there might be something wrong with given input with regard to the model."),__=l(),on=o("h3"),Go=o("a"),gh=o("span"),h(Ya.$$.fragment),qE=l(),_h=o("span"),AE=a("TokenClassificationPipeline"),b_=l(),z=o("div"),h(Ka.$$.fragment),jE=l(),rn=o("p"),DE=a("Named Entity Recognition pipeline using any "),bh=o("code"),CE=a("ModelForTokenClassification"),IE=a(". See the "),bc=o("a"),zE=a(`named entity recognition
examples`),SE=a(" for more information."),ME=l(),sn=o("p"),FE=a("This token recognition pipeline can currently be loaded from "),wc=o("a"),LE=a("pipeline()"),UE=a(` using the following task identifier:
`),wh=o("code"),OE=a('"ner"'),GE=a(" (for predicting the classes of tokens in a sequence: person, organisation, location or miscellaneous)."),NE=l(),Xa=o("p"),QE=a(`The models that this pipeline can use are models that have been fine-tuned on a token classification task. See the
up-to-date list of available models on
`),Ja=o("a"),RE=a("huggingface.co/models"),HE=a("."),VE=l(),No=o("div"),h(ei.$$.fragment),WE=l(),vh=o("p"),ZE=a("Classify each token of the text(s) given as inputs."),BE=l(),We=o("div"),h(ti.$$.fragment),YE=l(),kh=o("p"),KE=a("Override tokens from a given word that disagree to force agreement on word boundaries."),XE=l(),Ph=o("p"),JE=a(`Example: micro|soft| com|pany| B-ENT I-NAME I-ENT I-ENT will be rewritten with first strategy as microsoft|
company| B-ENT I-ENT`),e3=l(),Qo=o("div"),h(ni.$$.fragment),t3=l(),Th=o("p"),n3=a("Fuse various numpy arrays into dicts with all the information needed for aggregation"),o3=l(),Ro=o("div"),h(oi.$$.fragment),r3=l(),yh=o("p"),s3=a("Find and group together the adjacent tokens with the same entity predicted."),a3=l(),Ho=o("div"),h(ri.$$.fragment),i3=l(),xh=o("p"),l3=a("Group together the adjacent tokens with the same entity predicted."),w_=l(),an=o("h3"),Vo=o("a"),$h=o("span"),h(si.$$.fragment),c3=l(),Eh=o("span"),d3=a("TranslationPipeline"),v_=l(),X=o("div"),h(ai.$$.fragment),p3=l(),qh=o("p"),m3=a("Translates from one language to another."),f3=l(),ln=o("p"),h3=a("This translation pipeline can currently be loaded from "),vc=o("a"),u3=a("pipeline()"),g3=a(` using the following task identifier:
`),Ah=o("code"),_3=a('"translation_xx_to_yy"'),b3=a("."),w3=l(),Wo=o("p"),v3=a(`The models that this pipeline can use are models that have been fine-tuned on a translation task. See the
up-to-date list of available models on `),ii=o("a"),k3=a("huggingface.co/models"),P3=a(`.
For a list of available parameters, see the `),li=o("a"),T3=a(`following
documentation`),y3=l(),h(Zo.$$.fragment),x3=l(),Bo=o("div"),h(ci.$$.fragment),$3=l(),jh=o("p"),E3=a("Translate the text(s) given as inputs."),k_=l(),cn=o("h3"),Yo=o("a"),Dh=o("span"),h(di.$$.fragment),q3=l(),Ch=o("span"),A3=a("VisualQuestionAnsweringPipeline"),P_=l(),de=o("div"),h(pi.$$.fragment),j3=l(),mi=o("p"),D3=a("Visual Question Answering pipeline using a "),Ih=o("code"),C3=a("AutoModelForVisualQuestionAnswering"),I3=a(`. This pipeline is currently only
available in PyTorch.`),z3=l(),dn=o("p"),S3=a("This visual question answering pipeline can currently be loaded from "),kc=o("a"),M3=a("pipeline()"),F3=a(` using the following task
identifiers: `),zh=o("code"),L3=a('"visual-question-answering", "vqa"'),U3=a("."),O3=l(),fi=o("p"),G3=a(`The models that this pipeline can use are models that have been fine-tuned on a visual question answering task. See
the up-to-date list of available models on
`),hi=o("a"),N3=a("huggingface.co/models"),Q3=a("."),R3=l(),Ze=o("div"),h(ui.$$.fragment),H3=l(),Sh=o("p"),V3=a(`Answers open-ended questions about images. The pipeline accepts several types of inputs which are detailed
below:`),W3=l(),Oe=o("ul"),Mh=o("li"),Fh=o("code"),Z3=a("pipeline(image=image, question=question)"),B3=l(),Lh=o("li"),Uh=o("code"),Y3=a('pipeline({"image": image, "question": question})'),K3=l(),Oh=o("li"),Gh=o("code"),X3=a('pipeline([{"image": image, "question": question}])'),J3=l(),Nh=o("li"),Qh=o("code"),e5=a('pipeline([{"image": image, "question": question}, {"image": image, "question": question}])'),T_=l(),pn=o("h3"),Ko=o("a"),Rh=o("span"),h(gi.$$.fragment),t5=l(),Hh=o("span"),n5=a("ZeroShotClassificationPipeline"),y_=l(),J=o("div"),h(_i.$$.fragment),o5=l(),bi=o("p"),r5=a("NLI-based zero-shot classification pipeline using a "),Vh=o("code"),s5=a("ModelForSequenceClassification"),a5=a(` trained on NLI (natural
language inference) tasks.`),i5=l(),Ge=o("p"),l5=a(`Any combination of sequences and labels can be passed and each combination will be posed as a premise/hypothesis
pair and passed to the pretrained model. Then, the logit for `),Wh=o("em"),c5=a("entailment"),d5=a(` is taken as the logit for the candidate
label being valid. Any NLI model can be used, but the id of the `),Zh=o("em"),p5=a("entailment"),m5=a(` label must be included in the model
config\u2019s :attr:`),Bh=o("em"),f5=a("~transformers.PretrainedConfig.label2id"),h5=a("."),u5=l(),mn=o("p"),g5=a("This NLI pipeline can currently be loaded from "),Pc=o("a"),_5=a("pipeline()"),b5=a(` using the following task identifier:
`),Yh=o("code"),w5=a('"zero-shot-classification"'),v5=a("."),k5=l(),wi=o("p"),P5=a(`The models that this pipeline can use are models that have been fine-tuned on an NLI task. See the up-to-date list
of available models on `),vi=o("a"),T5=a("huggingface.co/models"),y5=a("."),x5=l(),Xo=o("div"),h(ki.$$.fragment),$5=l(),Pi=o("p"),E5=a("Classify the sequence(s) given as inputs. See the "),Tc=o("a"),q5=a("ZeroShotClassificationPipeline"),A5=a(` documentation for more
information.`),x_=l(),fn=o("h3"),Jo=o("a"),Kh=o("span"),h(Ti.$$.fragment),j5=l(),Xh=o("span"),D5=a("ZeroShotImageClassificationPipeline"),$_=l(),pe=o("div"),h(yi.$$.fragment),C5=l(),hn=o("p"),I5=a("Zero shot image classification pipeline using "),Jh=o("code"),z5=a("CLIPModel"),S5=a(`. This pipeline predicts the class of an image when you
provide an image and a set of `),eu=o("code"),M5=a("candidate_labels"),F5=a("."),L5=l(),un=o("p"),U5=a("This image classification pipeline can currently be loaded from "),yc=o("a"),O5=a("pipeline()"),G5=a(` using the following task identifier:
`),tu=o("code"),N5=a('"zero-shot-image-classification"'),Q5=a("."),R5=l(),xi=o("p"),H5=a(`See the list of available models on
`),$i=o("a"),V5=a("huggingface.co/models"),W5=a("."),Z5=l(),er=o("div"),h(Ei.$$.fragment),B5=l(),nu=o("p"),Y5=a("Assign labels to the image(s) passed as inputs."),E_=l(),gn=o("h3"),tr=o("a"),ou=o("span"),h(qi.$$.fragment),K5=l(),ru=o("span"),X5=a("ZeroShotObjectDetectionPipeline"),q_=l(),me=o("div"),h(Ai.$$.fragment),J5=l(),_n=o("p"),eq=a("Zero shot object detection pipeline using "),su=o("code"),tq=a("OwlViTForObjectDetection"),nq=a(`. This pipeline predicts bounding boxes of
objects when you provide an image and a set of `),au=o("code"),oq=a("candidate_labels"),rq=a("."),sq=l(),bn=o("p"),aq=a("This object detection pipeline can currently be loaded from "),xc=o("a"),iq=a("pipeline()"),lq=a(` using the following task identifier:
`),iu=o("code"),cq=a('"zero-shot-object-detection"'),dq=a("."),pq=l(),ji=o("p"),mq=a(`See the list of available models on
`),Di=o("a"),fq=a("huggingface.co/models"),hq=a("."),uq=l(),nr=o("div"),h(Ci.$$.fragment),gq=l(),lu=o("p"),_q=a("Detect objects (bounding boxes & classes) in the image(s) passed as inputs."),A_=l(),wn=o("h2"),or=o("a"),cu=o("span"),h(Ii.$$.fragment),bq=l(),$c=o("span"),wq=a("Parent class: "),du=o("code"),vq=a("Pipeline"),j_=l(),j=o("div"),h(zi.$$.fragment),kq=l(),pu=o("p"),Pq=a(`The Pipeline class is the class from which all pipelines inherit. Refer to this class for methods shared across
different pipelines.`),Tq=l(),mu=o("p"),yq=a(`Base class implementing pipelined operations. Pipeline workflow is defined as a sequence of the following
operations:`),xq=l(),fu=o("p"),$q=a("Input -> Tokenization -> Model Inference -> Post-Processing (task dependent) -> Output"),Eq=l(),hu=o("p"),qq=a("Pipeline supports running on CPU or GPU through the device argument (see below)."),Aq=l(),qe=o("p"),jq=a("Some pipeline, like for instance "),Ec=o("a"),Dq=a("FeatureExtractionPipeline"),Cq=a(" ("),uu=o("code"),Iq=a("'feature-extraction'"),zq=a(`) output large tensor object
as nested-lists. In order to avoid dumping such large structure as textual data we provide the `),gu=o("code"),Sq=a("binary_output"),Mq=a(`
constructor argument. If set to `),_u=o("code"),Fq=a("True"),Lq=a(", the output will be stored in the pickle format."),Uq=l(),rr=o("div"),h(Si.$$.fragment),Oq=l(),bu=o("p"),Gq=a("Check if the model class is in supported by the pipeline."),Nq=l(),Be=o("div"),h(Mi.$$.fragment),Qq=l(),wu=o("p"),Rq=a("Context Manager allowing tensor allocation on the user-specified device in framework agnostic way."),Hq=l(),h(sr.$$.fragment),Vq=l(),ar=o("div"),h(Fi.$$.fragment),Wq=l(),vu=o("p"),Zq=a("Ensure PyTorch tensors are on the specified device."),Bq=l(),ir=o("div"),h(Li.$$.fragment),Yq=l(),Ui=o("p"),Kq=a("Postprocess will receive the raw outputs of the "),ku=o("code"),Xq=a("_forward"),Jq=a(` method, generally tensors, and reformat them into
something more friendly. Generally it will output a list or a dict or results (containing just strings and
numbers).`),eA=l(),lr=o("div"),h(Oi.$$.fragment),tA=l(),Gi=o("p"),nA=a("Scikit / Keras interface to transformers\u2019 pipelines. This method will forward to "),Pu=o("strong"),oA=a("call"),rA=a("()."),sA=l(),cr=o("div"),h(Ni.$$.fragment),aA=l(),vn=o("p"),iA=a("Preprocess will take the "),Tu=o("code"),lA=a("input_"),cA=a(` of a specific pipeline and return a dictionnary of everything necessary for
`),yu=o("code"),dA=a("_forward"),pA=a(" to run properly. It should contain at least one tensor, but might have arbitrary other items."),mA=l(),dr=o("div"),h(Qi.$$.fragment),fA=l(),xu=o("p"),hA=a("Save the pipeline\u2019s model and tokenizer."),uA=l(),pr=o("div"),h(Ri.$$.fragment),gA=l(),Hi=o("p"),_A=a("Scikit / Keras interface to transformers\u2019 pipelines. This method will forward to "),$u=o("strong"),bA=a("call"),wA=a("()."),this.h()},l(t){const m=iz('[data-svelte="svelte-1phssyn"]',document.head);k=r(m,"META",{name:!0,content:!0}),m.forEach(n),$=c(t),T=r(t,"H1",{class:!0});var Vi=s(T);v=r(Vi,"A",{id:!0,class:!0,href:!0});var Eu=s(v);y=r(Eu,"SPAN",{});var qu=s(y);u(p.$$.fragment,qu),qu.forEach(n),Eu.forEach(n),P=c(Vi),Se=r(Vi,"SPAN",{});var Au=s(Se);Hw=i(Au,"Pipelines"),Au.forEach(n),Vi.forEach(n),Ou=c(t),kn=r(t,"P",{});var Wi=s(kn);Vw=i(Wi,`The pipelines are a great and easy way to use models for inference. These pipelines are objects that abstract most of
the complex code from the library, offering a simple API dedicated to several tasks, including Named Entity
Recognition, Masked Language Modeling, Sentiment Analysis, Feature Extraction and Question Answering. See the
`),Xi=r(Wi,"A",{href:!0});var ju=s(Xi);Ww=i(ju,"task summary"),ju.forEach(n),Zw=i(Wi," for examples of use."),Wi.forEach(n),Gu=c(t),Ji=r(t,"P",{});var Du=s(Ji);Bw=i(Du,"There are two categories of pipeline abstractions to be aware about:"),Du.forEach(n),Nu=c(t),Pn=r(t,"UL",{});var Zi=s(Pn);ud=r(Zi,"LI",{});var Cu=s(ud);br=r(Cu,"P",{});var Bi=s(br);Yw=i(Bi,"The "),el=r(Bi,"A",{href:!0});var Iu=s(el);Kw=i(Iu,"pipeline()"),Iu.forEach(n),Xw=i(Bi," which is the most powerful object encapsulating all other pipelines."),Bi.forEach(n),Cu.forEach(n),Jw=c(Zi),wr=r(Zi,"LI",{});var Yi=s(wr);gd=r(Yi,"P",{});var zu=s(gd);ev=i(zu,"The other task-specific pipelines:"),zu.forEach(n),tv=c(Yi),E=r(Yi,"UL",{});var q=s(E);_d=r(q,"LI",{});var Su=s(_d);tl=r(Su,"A",{href:!0});var Mu=s(tl);nv=i(Mu,"AudioClassificationPipeline"),Mu.forEach(n),Su.forEach(n),ov=c(q),bd=r(q,"LI",{});var Fu=s(bd);nl=r(Fu,"A",{href:!0});var kA=s(nl);rv=i(kA,"AutomaticSpeechRecognitionPipeline"),kA.forEach(n),Fu.forEach(n),sv=c(q),wd=r(q,"LI",{});var PA=s(wd);ol=r(PA,"A",{href:!0});var TA=s(ol);av=i(TA,"ConversationalPipeline"),TA.forEach(n),PA.forEach(n),iv=c(q),vd=r(q,"LI",{});var yA=s(vd);rl=r(yA,"A",{href:!0});var xA=s(rl);lv=i(xA,"DepthEstimationPipeline"),xA.forEach(n),yA.forEach(n),cv=c(q),kd=r(q,"LI",{});var $A=s(kd);sl=r($A,"A",{href:!0});var EA=s(sl);dv=i(EA,"DocumentQuestionAnsweringPipeline"),EA.forEach(n),$A.forEach(n),pv=c(q),Pd=r(q,"LI",{});var qA=s(Pd);al=r(qA,"A",{href:!0});var AA=s(al);mv=i(AA,"FeatureExtractionPipeline"),AA.forEach(n),qA.forEach(n),fv=c(q),Td=r(q,"LI",{});var jA=s(Td);il=r(jA,"A",{href:!0});var DA=s(il);hv=i(DA,"FillMaskPipeline"),DA.forEach(n),jA.forEach(n),uv=c(q),yd=r(q,"LI",{});var CA=s(yd);ll=r(CA,"A",{href:!0});var IA=s(ll);gv=i(IA,"ImageClassificationPipeline"),IA.forEach(n),CA.forEach(n),_v=c(q),xd=r(q,"LI",{});var zA=s(xd);cl=r(zA,"A",{href:!0});var SA=s(cl);bv=i(SA,"ImageSegmentationPipeline"),SA.forEach(n),zA.forEach(n),wv=c(q),$d=r(q,"LI",{});var MA=s($d);dl=r(MA,"A",{href:!0});var FA=s(dl);vv=i(FA,"ImageToTextPipeline"),FA.forEach(n),MA.forEach(n),kv=c(q),Ed=r(q,"LI",{});var LA=s(Ed);pl=r(LA,"A",{href:!0});var UA=s(pl);Pv=i(UA,"ObjectDetectionPipeline"),UA.forEach(n),LA.forEach(n),Tv=c(q),qd=r(q,"LI",{});var OA=s(qd);ml=r(OA,"A",{href:!0});var GA=s(ml);yv=i(GA,"QuestionAnsweringPipeline"),GA.forEach(n),OA.forEach(n),xv=c(q),Ad=r(q,"LI",{});var NA=s(Ad);fl=r(NA,"A",{href:!0});var QA=s(fl);$v=i(QA,"SummarizationPipeline"),QA.forEach(n),NA.forEach(n),Ev=c(q),jd=r(q,"LI",{});var RA=s(jd);hl=r(RA,"A",{href:!0});var HA=s(hl);qv=i(HA,"TableQuestionAnsweringPipeline"),HA.forEach(n),RA.forEach(n),Av=c(q),Dd=r(q,"LI",{});var VA=s(Dd);ul=r(VA,"A",{href:!0});var WA=s(ul);jv=i(WA,"TextClassificationPipeline"),WA.forEach(n),VA.forEach(n),Dv=c(q),Cd=r(q,"LI",{});var ZA=s(Cd);gl=r(ZA,"A",{href:!0});var BA=s(gl);Cv=i(BA,"TextGenerationPipeline"),BA.forEach(n),ZA.forEach(n),Iv=c(q),Id=r(q,"LI",{});var YA=s(Id);_l=r(YA,"A",{href:!0});var KA=s(_l);zv=i(KA,"Text2TextGenerationPipeline"),KA.forEach(n),YA.forEach(n),Sv=c(q),zd=r(q,"LI",{});var XA=s(zd);bl=r(XA,"A",{href:!0});var JA=s(bl);Mv=i(JA,"TokenClassificationPipeline"),JA.forEach(n),XA.forEach(n),Fv=c(q),Sd=r(q,"LI",{});var e6=s(Sd);wl=r(e6,"A",{href:!0});var t6=s(wl);Lv=i(t6,"TranslationPipeline"),t6.forEach(n),e6.forEach(n),Uv=c(q),Md=r(q,"LI",{});var n6=s(Md);vl=r(n6,"A",{href:!0});var o6=s(vl);Ov=i(o6,"VisualQuestionAnsweringPipeline"),o6.forEach(n),n6.forEach(n),Gv=c(q),Fd=r(q,"LI",{});var r6=s(Fd);kl=r(r6,"A",{href:!0});var s6=s(kl);Nv=i(s6,"ZeroShotClassificationPipeline"),s6.forEach(n),r6.forEach(n),Qv=c(q),Ld=r(q,"LI",{});var a6=s(Ld);Pl=r(a6,"A",{href:!0});var i6=s(Pl);Rv=i(i6,"ZeroShotImageClassificationPipeline"),i6.forEach(n),a6.forEach(n),Hv=c(q),Ud=r(q,"LI",{});var l6=s(Ud);Tl=r(l6,"A",{href:!0});var c6=s(Tl);Vv=i(c6,"ZeroShotObjectDetectionPipeline"),c6.forEach(n),l6.forEach(n),q.forEach(n),Yi.forEach(n),Zi.forEach(n),Qu=c(t),dt=r(t,"H2",{class:!0});var C_=s(dt);Tn=r(C_,"A",{id:!0,class:!0,href:!0});var d6=s(Tn);Od=r(d6,"SPAN",{});var p6=s(Od);u(vr.$$.fragment,p6),p6.forEach(n),d6.forEach(n),Wv=c(C_),Gd=r(C_,"SPAN",{});var m6=s(Gd);Zv=i(m6,"The pipeline abstraction"),m6.forEach(n),C_.forEach(n),Ru=c(t),yn=r(t,"P",{});var I_=s(yn);Bv=i(I_,"The "),Nd=r(I_,"EM",{});var f6=s(Nd);Yv=i(f6,"pipeline"),f6.forEach(n),Kv=i(I_,` abstraction is a wrapper around all the other available pipelines. It is instantiated as any other
pipeline but can provide additional quality of life.`),I_.forEach(n),Hu=c(t),yl=r(t,"P",{});var h6=s(yl);Xv=i(h6,"Simple call on one item:"),h6.forEach(n),Vu=c(t),u(kr.$$.fragment,t),Wu=c(t),xn=r(t,"P",{});var z_=s(xn);Jv=i(z_,"If you want to use a specific model from the "),Pr=r(z_,"A",{href:!0,rel:!0});var u6=s(Pr);e1=i(u6,"hub"),u6.forEach(n),t1=i(z_,` you can ignore the task if the model on
the hub already defines it:`),z_.forEach(n),Zu=c(t),u(Tr.$$.fragment,t),Bu=c(t),$n=r(t,"P",{});var S_=s($n);n1=i(S_,"To call a pipeline on many items, you can either call with a "),Qd=r(S_,"EM",{});var g6=s(Qd);o1=i(g6,"list"),g6.forEach(n),r1=i(S_,"."),S_.forEach(n),Yu=c(t),u(yr.$$.fragment,t),Ku=c(t),En=r(t,"P",{});var M_=s(En);s1=i(M_,"To iterate of full datasets it is recommended to use a "),Rd=r(M_,"CODE",{});var _6=s(Rd);a1=i(_6,"dataset"),_6.forEach(n),i1=i(M_,` directly. This means you don\u2019t need to allocate
the whole dataset at once, nor do you need to do batching yourself. This should work just as fast as custom loops on
GPU. If it doesn\u2019t don\u2019t hesitate to create an issue.`),M_.forEach(n),Xu=c(t),u(xr.$$.fragment,t),Ju=c(t),xl=r(t,"P",{});var b6=s(xl);l1=i(b6,"For ease of use, a generator is also possible:"),b6.forEach(n),eg=c(t),u($r.$$.fragment,t),tg=c(t),oe=r(t,"DIV",{class:!0});var Ye=s(oe);u(Er.$$.fragment,Ye),c1=c(Ye),qr=r(Ye,"P",{});var F_=s(qr);d1=i(F_,"Utility factory method to build a "),$l=r(F_,"A",{href:!0});var w6=s($l);p1=i(w6,"Pipeline"),w6.forEach(n),m1=i(F_,"."),F_.forEach(n),f1=c(Ye),Hd=r(Ye,"P",{});var v6=s(Hd);h1=i(v6,"Pipelines are made of:"),v6.forEach(n),u1=c(Ye),pt=r(Ye,"UL",{});var qc=s(pt);Ar=r(qc,"LI",{});var L_=s(Ar);g1=i(L_,"A "),El=r(L_,"A",{href:!0});var k6=s(El);_1=i(k6,"tokenizer"),k6.forEach(n),b1=i(L_," in charge of mapping raw textual input to token."),L_.forEach(n),w1=c(qc),jr=r(qc,"LI",{});var U_=s(jr);v1=i(U_,"A "),ql=r(U_,"A",{href:!0});var P6=s(ql);k1=i(P6,"model"),P6.forEach(n),P1=i(U_," to make predictions from the inputs."),U_.forEach(n),T1=c(qc),Vd=r(qc,"LI",{});var T6=s(Vd);y1=i(T6,"Some (optional) post processing for enhancing model\u2019s output."),T6.forEach(n),qc.forEach(n),x1=c(Ye),u(qn.$$.fragment,Ye),Ye.forEach(n),ng=c(t),mt=r(t,"H2",{class:!0});var O_=s(mt);An=r(O_,"A",{id:!0,class:!0,href:!0});var y6=s(An);Wd=r(y6,"SPAN",{});var x6=s(Wd);u(Dr.$$.fragment,x6),x6.forEach(n),y6.forEach(n),$1=c(O_),Zd=r(O_,"SPAN",{});var $6=s(Zd);E1=i($6,"Pipeline batching"),$6.forEach(n),O_.forEach(n),og=c(t),Ne=r(t,"P",{});var Ac=s(Ne);q1=i(Ac,`All pipelines can use batching. This will work
whenever the pipeline uses its streaming ability (so when passing lists or `),Bd=r(Ac,"CODE",{});var E6=s(Bd);A1=i(E6,"Dataset"),E6.forEach(n),j1=i(Ac," or "),Yd=r(Ac,"CODE",{});var q6=s(Yd);D1=i(q6,"generator"),q6.forEach(n),C1=i(Ac,")."),Ac.forEach(n),rg=c(t),u(Cr.$$.fragment,t),sg=c(t),u(jn.$$.fragment,t),ag=c(t),u(Ir.$$.fragment,t),ig=c(t),u(zr.$$.fragment,t),lg=c(t),Al=r(t,"P",{});var A6=s(Al);I1=i(A6,"Example where it\u2019s most a slowdown:"),A6.forEach(n),cg=c(t),u(Sr.$$.fragment,t),dg=c(t),Dn=r(t,"P",{});var G_=s(Dn);z1=i(G_,"This is a occasional very long sentence compared to the other. In that case, the "),Kd=r(G_,"STRONG",{});var j6=s(Kd);S1=i(j6,"whole"),j6.forEach(n),M1=i(G_,` batch will need to be 400
tokens long, so the whole batch will be [64, 400] instead of [64, 4], leading to the high slowdown. Even worse, on
bigger batches, the program simply crashes.`),G_.forEach(n),pg=c(t),u(Mr.$$.fragment,t),mg=c(t),jl=r(t,"P",{});var D6=s(jl);F1=i(D6,`There are no good (general) solutions for this problem, and your mileage may vary depending on your use cases. Rule of
thumb:`),D6.forEach(n),fg=c(t),Dl=r(t,"P",{});var C6=s(Dl);L1=i(C6,"For users, a rule of thumb is:"),C6.forEach(n),hg=c(t),ue=r(t,"UL",{});var Ke=s(ue);Xd=r(Ke,"LI",{});var I6=s(Xd);Jd=r(I6,"P",{});var z6=s(Jd);ep=r(z6,"STRONG",{});var S6=s(ep);U1=i(S6,`Measure performance on your load, with your hardware. Measure, measure, and keep measuring. Real numbers are the
only way to go.`),S6.forEach(n),z6.forEach(n),I6.forEach(n),O1=c(Ke),tp=r(Ke,"LI",{});var M6=s(tp);np=r(M6,"P",{});var F6=s(np);G1=i(F6,"If you are latency constrained (live product doing inference), don\u2019t batch"),F6.forEach(n),M6.forEach(n),N1=c(Ke),op=r(Ke,"LI",{});var L6=s(op);rp=r(L6,"P",{});var U6=s(rp);Q1=i(U6,"If you are using CPU, don\u2019t batch."),U6.forEach(n),L6.forEach(n),R1=c(Ke),Fr=r(Ke,"LI",{});var N_=s(Fr);sp=r(N_,"P",{});var O6=s(sp);H1=i(O6,"If you are using throughput (you want to run your model on a bunch of static data), on GPU, then:"),O6.forEach(n),V1=c(N_),ft=r(N_,"UL",{});var jc=s(ft);ap=r(jc,"LI",{});var G6=s(ap);W1=i(G6,`If you have no clue about the size of the sequence_length (\u201Cnatural\u201D data), by default don\u2019t batch, measure and
try tentatively to add it, add OOM checks to recover when it will fail (and it will at some point if you don\u2019t
control the sequence_length.)`),G6.forEach(n),Z1=c(jc),ip=r(jc,"LI",{});var N6=s(ip);B1=i(N6,`If your sequence_length is super regular, then batching is more likely to be VERY interesting, measure and push
it until you get OOMs.`),N6.forEach(n),Y1=c(jc),lp=r(jc,"LI",{});var Q6=s(lp);K1=i(Q6,"The larger the GPU the more likely batching is going to be more interesting"),Q6.forEach(n),jc.forEach(n),N_.forEach(n),X1=c(Ke),cp=r(Ke,"LI",{});var R6=s(cp);dp=r(R6,"P",{});var H6=s(dp);J1=i(H6,"As soon as you enable batching, make sure you can handle OOMs nicely."),H6.forEach(n),R6.forEach(n),Ke.forEach(n),ug=c(t),ht=r(t,"H2",{class:!0});var Q_=s(ht);Cn=r(Q_,"A",{id:!0,class:!0,href:!0});var V6=s(Cn);pp=r(V6,"SPAN",{});var W6=s(pp);u(Lr.$$.fragment,W6),W6.forEach(n),V6.forEach(n),ek=c(Q_),mp=r(Q_,"SPAN",{});var Z6=s(mp);tk=i(Z6,"Pipeline chunk batching"),Z6.forEach(n),Q_.forEach(n),gg=c(t),Me=r(t,"P",{});var Ki=s(Me);fp=r(Ki,"CODE",{});var B6=s(fp);nk=i(B6,"zero-shot-classification"),B6.forEach(n),ok=i(Ki," and "),hp=r(Ki,"CODE",{});var Y6=s(hp);rk=i(Y6,"question-answering"),Y6.forEach(n),sk=i(Ki,` are slightly specific in the sense, that a single input might yield
multiple forward pass of a model. Under normal circumstances, this would yield issues with `),up=r(Ki,"CODE",{});var K6=s(up);ak=i(K6,"batch_size"),K6.forEach(n),ik=i(Ki," argument."),Ki.forEach(n),_g=c(t),Qe=r(t,"P",{});var Dc=s(Qe);lk=i(Dc,"In order to circumvent this issue, both of these pipelines are a bit specific, they are "),gp=r(Dc,"CODE",{});var X6=s(gp);ck=i(X6,"ChunkPipeline"),X6.forEach(n),dk=i(Dc,` instead of
regular `),_p=r(Dc,"CODE",{});var J6=s(_p);pk=i(J6,"Pipeline"),J6.forEach(n),mk=i(Dc,". In short:"),Dc.forEach(n),bg=c(t),u(Ur.$$.fragment,t),wg=c(t),Cl=r(t,"P",{});var e7=s(Cl);fk=i(e7,"Now becomes:"),e7.forEach(n),vg=c(t),u(Or.$$.fragment,t),kg=c(t),Il=r(t,"P",{});var t7=s(Il);hk=i(t7,`This should be very transparent to your code because the pipelines are used in
the same way.`),t7.forEach(n),Pg=c(t),In=r(t,"P",{});var R_=s(In);uk=i(R_,`This is a simplified view, since the pipeline can handle automatically the batch to ! Meaning you don\u2019t have to care
about how many forward passes you inputs are actually going to trigger, you can optimize the `),bp=r(R_,"CODE",{});var n7=s(bp);gk=i(n7,"batch_size"),n7.forEach(n),_k=i(R_,`
independently of the inputs. The caveats from the previous section still apply.`),R_.forEach(n),Tg=c(t),ut=r(t,"H2",{class:!0});var H_=s(ut);zn=r(H_,"A",{id:!0,class:!0,href:!0});var o7=s(zn);wp=r(o7,"SPAN",{});var r7=s(wp);u(Gr.$$.fragment,r7),r7.forEach(n),o7.forEach(n),bk=c(H_),vp=r(H_,"SPAN",{});var s7=s(vp);wk=i(s7,"Pipeline custom code"),s7.forEach(n),H_.forEach(n),yg=c(t),zl=r(t,"P",{});var a7=s(zl);vk=i(a7,"If you want to override a specific pipeline."),a7.forEach(n),xg=c(t),Sn=r(t,"P",{});var V_=s(Sn);kk=i(V_,`Don\u2019t hesitate to create an issue for your task at hand, the goal of the pipeline is to be easy to use and support most
cases, so `),kp=r(V_,"CODE",{});var i7=s(kp);Pk=i(i7,"transformers"),i7.forEach(n),Tk=i(V_," could maybe support your use case."),V_.forEach(n),$g=c(t),Sl=r(t,"P",{});var l7=s(Sl);yk=i(l7,"If you want to try simply you can:"),l7.forEach(n),Eg=c(t),Ml=r(t,"UL",{});var c7=s(Ml);Pp=r(c7,"LI",{});var d7=s(Pp);xk=i(d7,"Subclass your pipeline of choice"),d7.forEach(n),c7.forEach(n),qg=c(t),u(Nr.$$.fragment,t),Ag=c(t),Fl=r(t,"P",{});var p7=s(Fl);$k=i(p7,"That should enable you to do all the custom code you want."),p7.forEach(n),jg=c(t),gt=r(t,"H2",{class:!0});var W_=s(gt);Mn=r(W_,"A",{id:!0,class:!0,href:!0});var m7=s(Mn);Tp=r(m7,"SPAN",{});var f7=s(Tp);u(Qr.$$.fragment,f7),f7.forEach(n),m7.forEach(n),Ek=c(W_),yp=r(W_,"SPAN",{});var h7=s(yp);qk=i(h7,"Implementing a pipeline"),h7.forEach(n),W_.forEach(n),Dg=c(t),Ll=r(t,"P",{});var u7=s(Ll);Ul=r(u7,"A",{href:!0});var g7=s(Ul);Ak=i(g7,"Implementing a new pipeline"),g7.forEach(n),u7.forEach(n),Cg=c(t),_t=r(t,"H2",{class:!0});var Z_=s(_t);Fn=r(Z_,"A",{id:!0,class:!0,href:!0});var _7=s(Fn);xp=r(_7,"SPAN",{});var b7=s(xp);u(Rr.$$.fragment,b7),b7.forEach(n),_7.forEach(n),jk=c(Z_),$p=r(Z_,"SPAN",{});var w7=s($p);Dk=i(w7,"The task specific pipelines"),w7.forEach(n),Z_.forEach(n),Ig=c(t),bt=r(t,"H3",{class:!0});var B_=s(bt);Ln=r(B_,"A",{id:!0,class:!0,href:!0});var v7=s(Ln);Ep=r(v7,"SPAN",{});var k7=s(Ep);u(Hr.$$.fragment,k7),k7.forEach(n),v7.forEach(n),Ck=c(B_),qp=r(B_,"SPAN",{});var P7=s(qp);Ik=i(P7,"AudioClassificationPipeline"),P7.forEach(n),B_.forEach(n),zg=c(t),L=r(t,"DIV",{class:!0});var ge=s(L);u(Vr.$$.fragment,ge),zk=c(ge),Wr=r(ge,"P",{});var Y_=s(Wr);Sk=i(Y_,"Audio classification pipeline using any "),Ap=r(Y_,"CODE",{});var T7=s(Ap);Mk=i(T7,"AutoModelForAudioClassification"),T7.forEach(n),Fk=i(Y_,`. This pipeline predicts the class of a
raw waveform or an audio file. In case of an audio file, ffmpeg should be installed to support multiple audio
formats.`),Y_.forEach(n),Lk=c(ge),u(Un.$$.fragment,ge),Uk=c(ge),jp=r(ge,"P",{});var y7=s(jp);Ol=r(y7,"A",{href:!0});var x7=s(Ol);Ok=i(x7,"Using pipelines in a webserver or with a dataset"),x7.forEach(n),y7.forEach(n),Gk=c(ge),wt=r(ge,"P",{});var Cc=s(wt);Nk=i(Cc,"This pipeline can currently be loaded from "),Gl=r(Cc,"A",{href:!0});var $7=s(Gl);Qk=i($7,"pipeline()"),$7.forEach(n),Rk=i(Cc,` using the following task identifier:
`),Dp=r(Cc,"CODE",{});var E7=s(Dp);Hk=i(E7,'"audio-classification"'),E7.forEach(n),Vk=i(Cc,"."),Cc.forEach(n),Wk=c(ge),Zr=r(ge,"P",{});var K_=s(Zr);Zk=i(K_,`See the list of available models on
`),Br=r(K_,"A",{href:!0,rel:!0});var q7=s(Br);Bk=i(q7,"huggingface.co/models"),q7.forEach(n),Yk=i(K_,"."),K_.forEach(n),Kk=c(ge),On=r(ge,"DIV",{class:!0});var X_=s(On);u(Yr.$$.fragment,X_),Xk=c(X_),Kr=r(X_,"P",{});var J_=s(Kr);Jk=i(J_,"Classify the sequence(s) given as inputs. See the "),Nl=r(J_,"A",{href:!0});var A7=s(Nl);eP=i(A7,"AutomaticSpeechRecognitionPipeline"),A7.forEach(n),tP=i(J_,` documentation for more
information.`),J_.forEach(n),X_.forEach(n),ge.forEach(n),Sg=c(t),vt=r(t,"H3",{class:!0});var eb=s(vt);Gn=r(eb,"A",{id:!0,class:!0,href:!0});var j7=s(Gn);Cp=r(j7,"SPAN",{});var D7=s(Cp);u(Xr.$$.fragment,D7),D7.forEach(n),j7.forEach(n),nP=c(eb),Ip=r(eb,"SPAN",{});var C7=s(Ip);oP=i(C7,"AutomaticSpeechRecognitionPipeline"),C7.forEach(n),eb.forEach(n),Mg=c(t),Z=r(t,"DIV",{class:!0});var je=s(Z);u(Jr.$$.fragment,je),rP=c(je),zp=r(je,"P",{});var I7=s(zp);sP=i(I7,"Pipeline that aims at extracting spoken text contained within some audio."),I7.forEach(n),aP=c(je),Sp=r(je,"P",{});var z7=s(Sp);iP=i(z7,`The input can be either a raw waveform or a audio file. In case of the audio file, ffmpeg should be installed for
to support multiple audio formats`),z7.forEach(n),lP=c(je),u(Nn.$$.fragment,je),cP=c(je),Mp=r(je,"P",{});var S7=s(Mp);Ql=r(S7,"A",{href:!0});var M7=s(Ql);dP=i(M7,"Using pipelines in a webserver or with a dataset"),M7.forEach(n),S7.forEach(n),pP=c(je),Qn=r(je,"DIV",{class:!0});var tb=s(Qn);u(es.$$.fragment,tb),mP=c(tb),ts=r(tb,"P",{});var nb=s(ts);fP=i(nb,"Transcribe the audio sequence(s) given as inputs to text. See the "),Rl=r(nb,"A",{href:!0});var F7=s(Rl);hP=i(F7,"AutomaticSpeechRecognitionPipeline"),F7.forEach(n),uP=i(nb,`
documentation for more information.`),nb.forEach(n),tb.forEach(n),je.forEach(n),Fg=c(t),kt=r(t,"H3",{class:!0});var ob=s(kt);Rn=r(ob,"A",{id:!0,class:!0,href:!0});var L7=s(Rn);Fp=r(L7,"SPAN",{});var U7=s(Fp);u(ns.$$.fragment,U7),U7.forEach(n),L7.forEach(n),gP=c(ob),Lp=r(ob,"SPAN",{});var O7=s(Lp);_P=i(O7,"ConversationalPipeline"),O7.forEach(n),ob.forEach(n),Lg=c(t),U=r(t,"DIV",{class:!0});var _e=s(U);u(os.$$.fragment,_e),bP=c(_e),Fe=r(_e,"P",{});var mr=s(Fe);wP=i(mr,`Utility class containing a conversation and its history. This class is meant to be used as an input to the
`),Hl=r(mr,"A",{href:!0});var G7=s(Hl);vP=i(G7,"ConversationalPipeline"),G7.forEach(n),kP=i(mr,`. The conversation contains a number of utility function to manage the addition of new
user input and generated model responses. A conversation needs to contain an unprocessed user input before being
passed to the `),Vl=r(mr,"A",{href:!0});var N7=s(Vl);PP=i(N7,"ConversationalPipeline"),N7.forEach(n),TP=i(mr,`. This user input is either created when the class is instantiated, or by
calling `),Up=r(mr,"CODE",{});var Q7=s(Up);yP=i(Q7,'conversational_pipeline.append_response("input")'),Q7.forEach(n),xP=i(mr," after a conversation turn."),mr.forEach(n),$P=c(_e),u(Hn.$$.fragment,_e),EP=c(_e),Vn=r(_e,"DIV",{class:!0});var rb=s(Vn);u(rs.$$.fragment,rb),qP=c(rb),ss=r(rb,"P",{});var sb=s(ss);AP=i(sb,"Add a user input to the conversation for the next round. This populates the internal "),Op=r(sb,"CODE",{});var R7=s(Op);jP=i(R7,"new_user_input"),R7.forEach(n),DP=i(sb," field."),sb.forEach(n),rb.forEach(n),CP=c(_e),Wn=r(_e,"DIV",{class:!0});var ab=s(Wn);u(as.$$.fragment,ab),IP=c(ab),Gp=r(ab,"P",{});var H7=s(Gp);zP=i(H7,"Append a response to the list of generated responses."),H7.forEach(n),ab.forEach(n),SP=c(_e),Re=r(_e,"DIV",{class:!0});var Ic=s(Re);u(is.$$.fragment,Ic),MP=c(Ic),Np=r(Ic,"P",{});var V7=s(Np);FP=i(V7,"Iterates over all blobs of the conversation."),V7.forEach(n),LP=c(Ic),$e=r(Ic,"P",{});var Xe=s($e);UP=i(Xe,"Returns: Iterator of (is_user, text_chunk) in chronological order of the conversation. "),Qp=r(Xe,"CODE",{});var W7=s(Qp);OP=i(W7,"is_user"),W7.forEach(n),GP=i(Xe," is a "),Rp=r(Xe,"CODE",{});var Z7=s(Rp);NP=i(Z7,"bool"),Z7.forEach(n),QP=i(Xe,`,
`),Hp=r(Xe,"CODE",{});var B7=s(Hp);RP=i(B7,"text_chunks"),B7.forEach(n),HP=i(Xe," is a "),Vp=r(Xe,"CODE",{});var Y7=s(Vp);VP=i(Y7,"str"),Y7.forEach(n),WP=i(Xe,"."),Xe.forEach(n),Ic.forEach(n),ZP=c(_e),Zn=r(_e,"DIV",{class:!0});var ib=s(Zn);u(ls.$$.fragment,ib),BP=c(ib),Le=r(ib,"P",{});var fr=s(Le);YP=i(fr,"Mark the conversation as processed (moves the content of "),Wp=r(fr,"CODE",{});var K7=s(Wp);KP=i(K7,"new_user_input"),K7.forEach(n),XP=i(fr," to "),Zp=r(fr,"CODE",{});var X7=s(Zp);JP=i(X7,"past_user_inputs"),X7.forEach(n),eT=i(fr,`) and empties
the `),Bp=r(fr,"CODE",{});var J7=s(Bp);tT=i(J7,"new_user_input"),J7.forEach(n),nT=i(fr," field."),fr.forEach(n),ib.forEach(n),_e.forEach(n),Ug=c(t),O=r(t,"DIV",{class:!0});var be=s(O);u(cs.$$.fragment,be),oT=c(be),Yp=r(be,"P",{});var e8=s(Yp);rT=i(e8,"Multi-turn conversational pipeline."),e8.forEach(n),sT=c(be),u(Bn.$$.fragment,be),aT=c(be),Kp=r(be,"P",{});var t8=s(Kp);Wl=r(t8,"A",{href:!0});var n8=s(Wl);iT=i(n8,"Using pipelines in a webserver or with a dataset"),n8.forEach(n),t8.forEach(n),lT=c(be),Pt=r(be,"P",{});var zc=s(Pt);cT=i(zc,"This conversational pipeline can currently be loaded from "),Zl=r(zc,"A",{href:!0});var o8=s(Zl);dT=i(o8,"pipeline()"),o8.forEach(n),pT=i(zc,` using the following task identifier:
`),Xp=r(zc,"CODE",{});var r8=s(Xp);mT=i(r8,'"conversational"'),r8.forEach(n),fT=i(zc,"."),zc.forEach(n),hT=c(be),Ee=r(be,"P",{});var Je=s(Ee);uT=i(Je,`The models that this pipeline can use are models that have been fine-tuned on a multi-turn conversational task,
currently: `),Jp=r(Je,"EM",{});var s8=s(Jp);gT=i(s8,"\u2018microsoft/DialoGPT-small\u2019"),s8.forEach(n),_T=i(Je,", "),em=r(Je,"EM",{});var a8=s(em);bT=i(a8,"\u2018microsoft/DialoGPT-medium\u2019"),a8.forEach(n),wT=i(Je,", "),tm=r(Je,"EM",{});var i8=s(tm);vT=i(i8,"\u2018microsoft/DialoGPT-large\u2019"),i8.forEach(n),kT=i(Je,`. See the
up-to-date list of available models on
`),ds=r(Je,"A",{href:!0,rel:!0});var l8=s(ds);PT=i(l8,"huggingface.co/models"),l8.forEach(n),TT=i(Je,"."),Je.forEach(n),yT=c(be),Yn=r(be,"DIV",{class:!0});var lb=s(Yn);u(ps.$$.fragment,lb),xT=c(lb),nm=r(lb,"P",{});var c8=s(nm);$T=i(c8,"Generate responses for the conversation(s) given as inputs."),c8.forEach(n),lb.forEach(n),be.forEach(n),Og=c(t),Tt=r(t,"H3",{class:!0});var cb=s(Tt);Kn=r(cb,"A",{id:!0,class:!0,href:!0});var d8=s(Kn);om=r(d8,"SPAN",{});var p8=s(om);u(ms.$$.fragment,p8),p8.forEach(n),d8.forEach(n),ET=c(cb),rm=r(cb,"SPAN",{});var m8=s(rm);qT=i(m8,"DepthEstimationPipeline"),m8.forEach(n),cb.forEach(n),Gg=c(t),G=r(t,"DIV",{class:!0});var we=s(G);u(fs.$$.fragment,we),AT=c(we),hs=r(we,"P",{});var db=s(hs);jT=i(db,"Depth estimation pipeline using any "),sm=r(db,"CODE",{});var f8=s(sm);DT=i(f8,"AutoModelForDepthEstimation"),f8.forEach(n),CT=i(db,". This pipeline predicts the depth of an image."),db.forEach(n),IT=c(we),u(Xn.$$.fragment,we),zT=c(we),am=r(we,"P",{});var h8=s(am);Bl=r(h8,"A",{href:!0});var u8=s(Bl);ST=i(u8,"Using pipelines in a webserver or with a dataset"),u8.forEach(n),h8.forEach(n),MT=c(we),yt=r(we,"P",{});var Sc=s(yt);FT=i(Sc,"This depth estimation pipeline can currently be loaded from "),Yl=r(Sc,"A",{href:!0});var g8=s(Yl);LT=i(g8,"pipeline()"),g8.forEach(n),UT=i(Sc,` using the following task identifier:
`),im=r(Sc,"CODE",{});var _8=s(im);OT=i(_8,'"depth-estimation"'),_8.forEach(n),GT=i(Sc,"."),Sc.forEach(n),NT=c(we),us=r(we,"P",{});var pb=s(us);QT=i(pb,"See the list of available models on "),gs=r(pb,"A",{href:!0,rel:!0});var b8=s(gs);RT=i(b8,"huggingface.co/models"),b8.forEach(n),HT=i(pb,"."),pb.forEach(n),VT=c(we),Jn=r(we,"DIV",{class:!0});var mb=s(Jn);u(_s.$$.fragment,mb),WT=c(mb),lm=r(mb,"P",{});var w8=s(lm);ZT=i(w8,"Assign labels to the image(s) passed as inputs."),w8.forEach(n),mb.forEach(n),we.forEach(n),Ng=c(t),xt=r(t,"H3",{class:!0});var fb=s(xt);eo=r(fb,"A",{id:!0,class:!0,href:!0});var v8=s(eo);cm=r(v8,"SPAN",{});var k8=s(cm);u(bs.$$.fragment,k8),k8.forEach(n),v8.forEach(n),BT=c(fb),dm=r(fb,"SPAN",{});var P8=s(dm);YT=i(P8,"DocumentQuestionAnsweringPipeline"),P8.forEach(n),fb.forEach(n),Qg=c(t),N=r(t,"DIV",{class:!0});var ve=s(N);u(ws.$$.fragment,ve),KT=c(ve),vs=r(ve,"P",{});var hb=s(vs);XT=i(hb,"Document Question Answering pipeline using any "),pm=r(hb,"CODE",{});var T8=s(pm);JT=i(T8,"AutoModelForDocumentQuestionAnswering"),T8.forEach(n),e2=i(hb,`. The inputs/outputs are
similar to the (extractive) question answering pipeline; however, the pipeline takes an image (and optional OCR\u2019d
words/boxes) as input instead of text context.`),hb.forEach(n),t2=c(ve),u(to.$$.fragment,ve),n2=c(ve),mm=r(ve,"P",{});var y8=s(mm);Kl=r(y8,"A",{href:!0});var x8=s(Kl);o2=i(x8,"Using pipelines in a webserver or with a dataset"),x8.forEach(n),y8.forEach(n),r2=c(ve),$t=r(ve,"P",{});var Mc=s($t);s2=i(Mc,"This document question answering pipeline can currently be loaded from "),Xl=r(Mc,"A",{href:!0});var $8=s(Xl);a2=i($8,"pipeline()"),$8.forEach(n),i2=i(Mc,` using the following task
identifier: `),fm=r(Mc,"CODE",{});var E8=s(fm);l2=i(E8,'"document-question-answering"'),E8.forEach(n),c2=i(Mc,"."),Mc.forEach(n),d2=c(ve),ks=r(ve,"P",{});var ub=s(ks);p2=i(ub,`The models that this pipeline can use are models that have been fine-tuned on a document question answering task.
See the up-to-date list of available models on
`),Ps=r(ub,"A",{href:!0,rel:!0});var q8=s(Ps);m2=i(q8,"huggingface.co/models"),q8.forEach(n),f2=i(ub,"."),ub.forEach(n),h2=c(ve),Ae=r(ve,"DIV",{class:!0});var hr=s(Ae);u(Ts.$$.fragment,hr),u2=c(hr),ys=r(hr,"P",{});var gb=s(ys);g2=i(gb,`Answer the question(s) given as inputs by using the document(s). A document is defined as an image and an
optional list of (word, box) tuples which represent the text in the document. If the `),hm=r(gb,"CODE",{});var A8=s(hm);_2=i(A8,"word_boxes"),A8.forEach(n),b2=i(gb,` are not
provided, it will use the Tesseract OCR engine (if available) to extract the words and boxes automatically for
LayoutLM-like models which require them as input. For Donut, no OCR is run.`),gb.forEach(n),w2=c(hr),um=r(hr,"P",{});var j8=s(um);v2=i(j8,"You can invoke the pipeline several ways:"),j8.forEach(n),k2=c(hr),Ue=r(hr,"UL",{});var ur=s(Ue);gm=r(ur,"LI",{});var D8=s(gm);_m=r(D8,"CODE",{});var C8=s(_m);P2=i(C8,"pipeline(image=image, question=question)"),C8.forEach(n),D8.forEach(n),T2=c(ur),bm=r(ur,"LI",{});var I8=s(bm);wm=r(I8,"CODE",{});var z8=s(wm);y2=i(z8,"pipeline(image=image, question=question, word_boxes=word_boxes)"),z8.forEach(n),I8.forEach(n),x2=c(ur),vm=r(ur,"LI",{});var S8=s(vm);km=r(S8,"CODE",{});var M8=s(km);$2=i(M8,'pipeline([{"image": image, "question": question}])'),M8.forEach(n),S8.forEach(n),E2=c(ur),Pm=r(ur,"LI",{});var F8=s(Pm);Tm=r(F8,"CODE",{});var L8=s(Tm);q2=i(L8,'pipeline([{"image": image, "question": question, "word_boxes": word_boxes}])'),L8.forEach(n),F8.forEach(n),ur.forEach(n),hr.forEach(n),ve.forEach(n),Rg=c(t),Et=r(t,"H3",{class:!0});var _b=s(Et);no=r(_b,"A",{id:!0,class:!0,href:!0});var U8=s(no);ym=r(U8,"SPAN",{});var O8=s(ym);u(xs.$$.fragment,O8),O8.forEach(n),U8.forEach(n),A2=c(_b),xm=r(_b,"SPAN",{});var G8=s(xm);j2=i(G8,"FeatureExtractionPipeline"),G8.forEach(n),_b.forEach(n),Hg=c(t),Q=r(t,"DIV",{class:!0});var ke=s(Q);u($s.$$.fragment,ke),D2=c(ke),$m=r(ke,"P",{});var N8=s($m);C2=i(N8,`Feature extraction pipeline using no model head. This pipeline extracts the hidden states from the base
transformer, which can be used as features in downstream tasks.`),N8.forEach(n),I2=c(ke),u(oo.$$.fragment,ke),z2=c(ke),Em=r(ke,"P",{});var Q8=s(Em);Jl=r(Q8,"A",{href:!0});var R8=s(Jl);S2=i(R8,"Using pipelines in a webserver or with a dataset"),R8.forEach(n),Q8.forEach(n),M2=c(ke),qt=r(ke,"P",{});var Fc=s(qt);F2=i(Fc,"This feature extraction pipeline can currently be loaded from "),ec=r(Fc,"A",{href:!0});var H8=s(ec);L2=i(H8,"pipeline()"),H8.forEach(n),U2=i(Fc,` using the task identifier:
`),qm=r(Fc,"CODE",{});var V8=s(qm);O2=i(V8,'"feature-extraction"'),V8.forEach(n),G2=i(Fc,"."),Fc.forEach(n),N2=c(ke),Es=r(ke,"P",{});var bb=s(Es);Q2=i(bb,`All models may be used for this pipeline. See a list of all models, including community-contributed models on
`),qs=r(bb,"A",{href:!0,rel:!0});var W8=s(qs);R2=i(W8,"huggingface.co/models"),W8.forEach(n),H2=i(bb,"."),bb.forEach(n),V2=c(ke),ro=r(ke,"DIV",{class:!0});var wb=s(ro);u(As.$$.fragment,wb),W2=c(wb),Am=r(wb,"P",{});var Z8=s(Am);Z2=i(Z8,"Extract the features of the input(s)."),Z8.forEach(n),wb.forEach(n),ke.forEach(n),Vg=c(t),At=r(t,"H3",{class:!0});var vb=s(At);so=r(vb,"A",{id:!0,class:!0,href:!0});var B8=s(so);jm=r(B8,"SPAN",{});var Y8=s(jm);u(js.$$.fragment,Y8),Y8.forEach(n),B8.forEach(n),B2=c(vb),Dm=r(vb,"SPAN",{});var K8=s(Dm);Y2=i(K8,"FillMaskPipeline"),K8.forEach(n),vb.forEach(n),Wg=c(t),S=r(t,"DIV",{class:!0});var te=s(S);u(Ds.$$.fragment,te),K2=c(te),jt=r(te,"P",{});var Lc=s(jt);X2=i(Lc,"Masked language modeling prediction pipeline using any "),Cm=r(Lc,"CODE",{});var X8=s(Cm);J2=i(X8,"ModelWithLMHead"),X8.forEach(n),ey=i(Lc,". See the "),tc=r(Lc,"A",{href:!0});var J8=s(tc);ty=i(J8,`masked language modeling
examples`),J8.forEach(n),ny=i(Lc," for more information."),Lc.forEach(n),oy=c(te),u(ao.$$.fragment,te),ry=c(te),Im=r(te,"P",{});var ej=s(Im);nc=r(ej,"A",{href:!0});var tj=s(nc);sy=i(tj,"Using pipelines in a webserver or with a dataset"),tj.forEach(n),ej.forEach(n),ay=c(te),Dt=r(te,"P",{});var Uc=s(Dt);iy=i(Uc,"This mask filling pipeline can currently be loaded from "),oc=r(Uc,"A",{href:!0});var nj=s(oc);ly=i(nj,"pipeline()"),nj.forEach(n),cy=i(Uc,` using the following task identifier:
`),zm=r(Uc,"CODE",{});var oj=s(zm);dy=i(oj,'"fill-mask"'),oj.forEach(n),py=i(Uc,"."),Uc.forEach(n),my=c(te),Cs=r(te,"P",{});var kb=s(Cs);fy=i(kb,`The models that this pipeline can use are models that have been trained with a masked language modeling objective,
which includes the bi-directional models in the library. See the up-to-date list of available models on
`),Is=r(kb,"A",{href:!0,rel:!0});var rj=s(Is);hy=i(rj,"huggingface.co/models"),rj.forEach(n),uy=i(kb,"."),kb.forEach(n),gy=c(te),u(io.$$.fragment,te),_y=c(te),lo=r(te,"DIV",{class:!0});var Pb=s(lo);u(zs.$$.fragment,Pb),by=c(Pb),Sm=r(Pb,"P",{});var sj=s(Sm);wy=i(sj,"Fill the masked token in the text(s) given as inputs."),sj.forEach(n),Pb.forEach(n),te.forEach(n),Zg=c(t),Ct=r(t,"H3",{class:!0});var Tb=s(Ct);co=r(Tb,"A",{id:!0,class:!0,href:!0});var aj=s(co);Mm=r(aj,"SPAN",{});var ij=s(Mm);u(Ss.$$.fragment,ij),ij.forEach(n),aj.forEach(n),vy=c(Tb),Fm=r(Tb,"SPAN",{});var lj=s(Fm);ky=i(lj,"ImageClassificationPipeline"),lj.forEach(n),Tb.forEach(n),Bg=c(t),re=r(t,"DIV",{class:!0});var et=s(re);u(Ms.$$.fragment,et),Py=c(et),Fs=r(et,"P",{});var yb=s(Fs);Ty=i(yb,"Image classification pipeline using any "),Lm=r(yb,"CODE",{});var cj=s(Lm);yy=i(cj,"AutoModelForImageClassification"),cj.forEach(n),xy=i(yb,`. This pipeline predicts the class of an
image.`),yb.forEach(n),$y=c(et),It=r(et,"P",{});var Oc=s(It);Ey=i(Oc,"This image classification pipeline can currently be loaded from "),rc=r(Oc,"A",{href:!0});var dj=s(rc);qy=i(dj,"pipeline()"),dj.forEach(n),Ay=i(Oc,` using the following task identifier:
`),Um=r(Oc,"CODE",{});var pj=s(Um);jy=i(pj,'"image-classification"'),pj.forEach(n),Dy=i(Oc,"."),Oc.forEach(n),Cy=c(et),Ls=r(et,"P",{});var xb=s(Ls);Iy=i(xb,`See the list of available models on
`),Us=r(xb,"A",{href:!0,rel:!0});var mj=s(Us);zy=i(mj,"huggingface.co/models"),mj.forEach(n),Sy=i(xb,"."),xb.forEach(n),My=c(et),po=r(et,"DIV",{class:!0});var $b=s(po);u(Os.$$.fragment,$b),Fy=c($b),Om=r($b,"P",{});var fj=s(Om);Ly=i(fj,"Assign labels to the image(s) passed as inputs."),fj.forEach(n),$b.forEach(n),et.forEach(n),Yg=c(t),zt=r(t,"H3",{class:!0});var Eb=s(zt);mo=r(Eb,"A",{id:!0,class:!0,href:!0});var hj=s(mo);Gm=r(hj,"SPAN",{});var uj=s(Gm);u(Gs.$$.fragment,uj),uj.forEach(n),hj.forEach(n),Uy=c(Eb),Nm=r(Eb,"SPAN",{});var gj=s(Nm);Oy=i(gj,"ImageSegmentationPipeline"),gj.forEach(n),Eb.forEach(n),Kg=c(t),se=r(t,"DIV",{class:!0});var tt=s(se);u(Ns.$$.fragment,tt),Gy=c(tt),Qs=r(tt,"P",{});var qb=s(Qs);Ny=i(qb,"Image segmentation pipeline using any "),Qm=r(qb,"CODE",{});var _j=s(Qm);Qy=i(_j,"AutoModelForXXXSegmentation"),_j.forEach(n),Ry=i(qb,`. This pipeline predicts masks of objects and
their classes.`),qb.forEach(n),Hy=c(tt),St=r(tt,"P",{});var Gc=s(St);Vy=i(Gc,"This image segmentation pipeline can currently be loaded from "),sc=r(Gc,"A",{href:!0});var bj=s(sc);Wy=i(bj,"pipeline()"),bj.forEach(n),Zy=i(Gc,` using the following task identifier:
`),Rm=r(Gc,"CODE",{});var wj=s(Rm);By=i(wj,'"image-segmentation"'),wj.forEach(n),Yy=i(Gc,"."),Gc.forEach(n),Ky=c(tt),Rs=r(tt,"P",{});var Ab=s(Rs);Xy=i(Ab,`See the list of available models on
`),Hs=r(Ab,"A",{href:!0,rel:!0});var vj=s(Hs);Jy=i(vj,"huggingface.co/models"),vj.forEach(n),e0=i(Ab,"."),Ab.forEach(n),t0=c(tt),fo=r(tt,"DIV",{class:!0});var jb=s(fo);u(Vs.$$.fragment,jb),n0=c(jb),Hm=r(jb,"P",{});var kj=s(Hm);o0=i(kj,"Perform segmentation (detect masks & classes) in the image(s) passed as inputs."),kj.forEach(n),jb.forEach(n),tt.forEach(n),Xg=c(t),Mt=r(t,"H3",{class:!0});var Db=s(Mt);ho=r(Db,"A",{id:!0,class:!0,href:!0});var Pj=s(ho);Vm=r(Pj,"SPAN",{});var Tj=s(Vm);u(Ws.$$.fragment,Tj),Tj.forEach(n),Pj.forEach(n),r0=c(Db),Wm=r(Db,"SPAN",{});var yj=s(Wm);s0=i(yj,"ImageToTextPipeline"),yj.forEach(n),Db.forEach(n),Jg=c(t),ae=r(t,"DIV",{class:!0});var nt=s(ae);u(Zs.$$.fragment,nt),a0=c(nt),Bs=r(nt,"P",{});var Cb=s(Bs);i0=i(Cb,"Image To Text pipeline using a "),Zm=r(Cb,"CODE",{});var xj=s(Zm);l0=i(xj,"AutoModelForVision2Seq"),xj.forEach(n),c0=i(Cb,". This pipeline predicts a caption for a given image."),Cb.forEach(n),d0=c(nt),Bm=r(nt,"P",{});var $j=s(Bm);p0=i($j,`This image to text pipeline can currently be loaded from pipeline() using the following task identifier:
\u201Cimage-to-text\u201D.`),$j.forEach(n),m0=c(nt),Ys=r(nt,"P",{});var Ib=s(Ys);f0=i(Ib,`See the list of available models on
`),Ks=r(Ib,"A",{href:!0,rel:!0});var Ej=s(Ks);h0=i(Ej,"huggingface.co/models"),Ej.forEach(n),u0=i(Ib,"."),Ib.forEach(n),g0=c(nt),uo=r(nt,"DIV",{class:!0});var zb=s(uo);u(Xs.$$.fragment,zb),_0=c(zb),Ym=r(zb,"P",{});var qj=s(Ym);b0=i(qj,"Assign labels to the image(s) passed as inputs."),qj.forEach(n),zb.forEach(n),nt.forEach(n),e_=c(t),Ft=r(t,"H3",{class:!0});var Sb=s(Ft);go=r(Sb,"A",{id:!0,class:!0,href:!0});var Aj=s(go);Km=r(Aj,"SPAN",{});var jj=s(Km);u(Js.$$.fragment,jj),jj.forEach(n),Aj.forEach(n),w0=c(Sb),Xm=r(Sb,"SPAN",{});var Dj=s(Xm);v0=i(Dj,"NerPipeline"),Dj.forEach(n),Sb.forEach(n),t_=c(t),M=r(t,"DIV",{class:!0});var ne=s(M);u(ea.$$.fragment,ne),k0=c(ne),Lt=r(ne,"P",{});var Nc=s(Lt);P0=i(Nc,"Named Entity Recognition pipeline using any "),Jm=r(Nc,"CODE",{});var Cj=s(Jm);T0=i(Cj,"ModelForTokenClassification"),Cj.forEach(n),y0=i(Nc,". See the "),ac=r(Nc,"A",{href:!0});var Ij=s(ac);x0=i(Ij,`named entity recognition
examples`),Ij.forEach(n),$0=i(Nc," for more information."),Nc.forEach(n),E0=c(ne),Ut=r(ne,"P",{});var Qc=s(Ut);q0=i(Qc,"This token recognition pipeline can currently be loaded from "),ic=r(Qc,"A",{href:!0});var zj=s(ic);A0=i(zj,"pipeline()"),zj.forEach(n),j0=i(Qc,` using the following task identifier:
`),ef=r(Qc,"CODE",{});var Sj=s(ef);D0=i(Sj,'"ner"'),Sj.forEach(n),C0=i(Qc," (for predicting the classes of tokens in a sequence: person, organisation, location or miscellaneous)."),Qc.forEach(n),I0=c(ne),ta=r(ne,"P",{});var Mb=s(ta);z0=i(Mb,`The models that this pipeline can use are models that have been fine-tuned on a token classification task. See the
up-to-date list of available models on
`),na=r(Mb,"A",{href:!0,rel:!0});var Mj=s(na);S0=i(Mj,"huggingface.co/models"),Mj.forEach(n),M0=i(Mb,"."),Mb.forEach(n),F0=c(ne),He=r(ne,"DIV",{class:!0});var Rc=s(He);u(oa.$$.fragment,Rc),L0=c(Rc),tf=r(Rc,"P",{});var Fj=s(tf);U0=i(Fj,"Override tokens from a given word that disagree to force agreement on word boundaries."),Fj.forEach(n),O0=c(Rc),nf=r(Rc,"P",{});var Lj=s(nf);G0=i(Lj,`Example: micro|soft| com|pany| B-ENT I-NAME I-ENT I-ENT will be rewritten with first strategy as microsoft|
company| B-ENT I-ENT`),Lj.forEach(n),Rc.forEach(n),N0=c(ne),_o=r(ne,"DIV",{class:!0});var Fb=s(_o);u(ra.$$.fragment,Fb),Q0=c(Fb),of=r(Fb,"P",{});var Uj=s(of);R0=i(Uj,"Fuse various numpy arrays into dicts with all the information needed for aggregation"),Uj.forEach(n),Fb.forEach(n),H0=c(ne),bo=r(ne,"DIV",{class:!0});var Lb=s(bo);u(sa.$$.fragment,Lb),V0=c(Lb),rf=r(Lb,"P",{});var Oj=s(rf);W0=i(Oj,"Find and group together the adjacent tokens with the same entity predicted."),Oj.forEach(n),Lb.forEach(n),Z0=c(ne),wo=r(ne,"DIV",{class:!0});var Ub=s(wo);u(aa.$$.fragment,Ub),B0=c(Ub),sf=r(Ub,"P",{});var Gj=s(sf);Y0=i(Gj,"Group together the adjacent tokens with the same entity predicted."),Gj.forEach(n),Ub.forEach(n),ne.forEach(n),n_=c(t),vo=r(t,"P",{});var Ob=s(vo);K0=i(Ob,"See "),lc=r(Ob,"A",{href:!0});var Nj=s(lc);X0=i(Nj,"TokenClassificationPipeline"),Nj.forEach(n),J0=i(Ob," for all details."),Ob.forEach(n),o_=c(t),Ot=r(t,"H3",{class:!0});var Gb=s(Ot);ko=r(Gb,"A",{id:!0,class:!0,href:!0});var Qj=s(ko);af=r(Qj,"SPAN",{});var Rj=s(af);u(ia.$$.fragment,Rj),Rj.forEach(n),Qj.forEach(n),ex=c(Gb),lf=r(Gb,"SPAN",{});var Hj=s(lf);tx=i(Hj,"ObjectDetectionPipeline"),Hj.forEach(n),Gb.forEach(n),r_=c(t),ie=r(t,"DIV",{class:!0});var ot=s(ie);u(la.$$.fragment,ot),nx=c(ot),ca=r(ot,"P",{});var Nb=s(ca);ox=i(Nb,"Object detection pipeline using any "),cf=r(Nb,"CODE",{});var Vj=s(cf);rx=i(Vj,"AutoModelForObjectDetection"),Vj.forEach(n),sx=i(Nb,`. This pipeline predicts bounding boxes of objects
and their classes.`),Nb.forEach(n),ax=c(ot),Gt=r(ot,"P",{});var Hc=s(Gt);ix=i(Hc,"This object detection pipeline can currently be loaded from "),cc=r(Hc,"A",{href:!0});var Wj=s(cc);lx=i(Wj,"pipeline()"),Wj.forEach(n),cx=i(Hc,` using the following task identifier:
`),df=r(Hc,"CODE",{});var Zj=s(df);dx=i(Zj,'"object-detection"'),Zj.forEach(n),px=i(Hc,"."),Hc.forEach(n),mx=c(ot),da=r(ot,"P",{});var Qb=s(da);fx=i(Qb,"See the list of available models on "),pa=r(Qb,"A",{href:!0,rel:!0});var Bj=s(pa);hx=i(Bj,"huggingface.co/models"),Bj.forEach(n),ux=i(Qb,"."),Qb.forEach(n),gx=c(ot),Po=r(ot,"DIV",{class:!0});var Rb=s(Po);u(ma.$$.fragment,Rb),_x=c(Rb),pf=r(Rb,"P",{});var Yj=s(pf);bx=i(Yj,"Detect objects (bounding boxes & classes) in the image(s) passed as inputs."),Yj.forEach(n),Rb.forEach(n),ot.forEach(n),s_=c(t),Nt=r(t,"H3",{class:!0});var Hb=s(Nt);To=r(Hb,"A",{id:!0,class:!0,href:!0});var Kj=s(To);mf=r(Kj,"SPAN",{});var Xj=s(mf);u(fa.$$.fragment,Xj),Xj.forEach(n),Kj.forEach(n),wx=c(Hb),ff=r(Hb,"SPAN",{});var Jj=s(ff);vx=i(Jj,"QuestionAnsweringPipeline"),Jj.forEach(n),Hb.forEach(n),a_=c(t),R=r(t,"DIV",{class:!0});var Pe=s(R);u(ha.$$.fragment,Pe),kx=c(Pe),Qt=r(Pe,"P",{});var Vc=s(Qt);Px=i(Vc,"Question Answering pipeline using any "),hf=r(Vc,"CODE",{});var eD=s(hf);Tx=i(eD,"ModelForQuestionAnswering"),eD.forEach(n),yx=i(Vc,". See the "),dc=r(Vc,"A",{href:!0});var tD=s(dc);xx=i(tD,`question answering
examples`),tD.forEach(n),$x=i(Vc," for more information."),Vc.forEach(n),Ex=c(Pe),Rt=r(Pe,"P",{});var Wc=s(Rt);qx=i(Wc,"This question answering pipeline can currently be loaded from "),pc=r(Wc,"A",{href:!0});var nD=s(pc);Ax=i(nD,"pipeline()"),nD.forEach(n),jx=i(Wc,` using the following task identifier:
`),uf=r(Wc,"CODE",{});var oD=s(uf);Dx=i(oD,'"question-answering"'),oD.forEach(n),Cx=i(Wc,"."),Wc.forEach(n),Ix=c(Pe),ua=r(Pe,"P",{});var Vb=s(ua);zx=i(Vb,`The models that this pipeline can use are models that have been fine-tuned on a question answering task. See the
up-to-date list of available models on
`),ga=r(Vb,"A",{href:!0,rel:!0});var rD=s(ga);Sx=i(rD,"huggingface.co/models"),rD.forEach(n),Mx=i(Vb,"."),Vb.forEach(n),Fx=c(Pe),yo=r(Pe,"DIV",{class:!0});var Wb=s(yo);u(_a.$$.fragment,Wb),Lx=c(Wb),gf=r(Wb,"P",{});var sD=s(gf);Ux=i(sD,"Answer the question(s) given as inputs by using the context(s)."),sD.forEach(n),Wb.forEach(n),Ox=c(Pe),Ve=r(Pe,"DIV",{class:!0});var Zc=s(Ve);u(ba.$$.fragment,Zc),Gx=c(Zc),Ht=r(Zc,"P",{});var Bc=s(Ht);Nx=i(Bc,"QuestionAnsweringPipeline leverages the "),_f=r(Bc,"CODE",{});var aD=s(_f);Qx=i(aD,"SquadExample"),aD.forEach(n),Rx=i(Bc,` internally. This helper method encapsulate all the
logic for converting question(s) and context(s) to `),bf=r(Bc,"CODE",{});var iD=s(bf);Hx=i(iD,"SquadExample"),iD.forEach(n),Vx=i(Bc,"."),Bc.forEach(n),Wx=c(Zc),wf=r(Zc,"P",{});var lD=s(wf);Zx=i(lD,"We currently support extractive question answering."),lD.forEach(n),Zc.forEach(n),Bx=c(Pe),xo=r(Pe,"DIV",{class:!0});var Zb=s(xo);u(wa.$$.fragment,Zb),Yx=c(Zb),vf=r(Zb,"P",{});var cD=s(vf);Kx=i(cD,"When decoding from token probabilities, this method maps token indexes to actual word in the initial context."),cD.forEach(n),Zb.forEach(n),Pe.forEach(n),i_=c(t),Vt=r(t,"H3",{class:!0});var Bb=s(Vt);$o=r(Bb,"A",{id:!0,class:!0,href:!0});var dD=s($o);kf=r(dD,"SPAN",{});var pD=s(kf);u(va.$$.fragment,pD),pD.forEach(n),dD.forEach(n),Xx=c(Bb),Pf=r(Bb,"SPAN",{});var mD=s(Pf);Jx=i(mD,"SummarizationPipeline"),mD.forEach(n),Bb.forEach(n),l_=c(t),B=r(t,"DIV",{class:!0});var De=s(B);u(ka.$$.fragment,De),e$=c(De),Tf=r(De,"P",{});var fD=s(Tf);t$=i(fD,"Summarize news articles and other documents."),fD.forEach(n),n$=c(De),Wt=r(De,"P",{});var Yc=s(Wt);o$=i(Yc,"This summarizing pipeline can currently be loaded from "),mc=r(Yc,"A",{href:!0});var hD=s(mc);r$=i(hD,"pipeline()"),hD.forEach(n),s$=i(Yc,` using the following task identifier:
`),yf=r(Yc,"CODE",{});var uD=s(yf);a$=i(uD,'"summarization"'),uD.forEach(n),i$=i(Yc,"."),Yc.forEach(n),l$=c(De),F=r(De,"P",{});var ee=s(F);c$=i(ee,`The models that this pipeline can use are models that have been fine-tuned on a summarization task, which is
currently, \u2019`),xf=r(ee,"EM",{});var gD=s(xf);d$=i(gD,"bart-large-cnn"),gD.forEach(n),p$=i(ee,"\u2019, \u2019"),$f=r(ee,"EM",{});var _D=s($f);m$=i(_D,"t5-small"),_D.forEach(n),f$=i(ee,"\u2019, \u2019"),Ef=r(ee,"EM",{});var bD=s(Ef);h$=i(bD,"t5-base"),bD.forEach(n),u$=i(ee,"\u2019, \u2019"),qf=r(ee,"EM",{});var wD=s(qf);g$=i(wD,"t5-large"),wD.forEach(n),_$=i(ee,"\u2019, \u2019"),Af=r(ee,"EM",{});var vD=s(Af);b$=i(vD,"t5-3b"),vD.forEach(n),w$=i(ee,"\u2019, \u2019"),jf=r(ee,"EM",{});var kD=s(jf);v$=i(kD,"t5-11b"),kD.forEach(n),k$=i(ee,`\u2019. See the up-to-date
list of available models on `),Pa=r(ee,"A",{href:!0,rel:!0});var PD=s(Pa);P$=i(PD,"huggingface.co/models"),PD.forEach(n),T$=i(ee,`. For a list
of available parameters, see the `),Ta=r(ee,"A",{href:!0,rel:!0});var TD=s(Ta);y$=i(TD,`following
documentation`),TD.forEach(n),ee.forEach(n),x$=c(De),u(Eo.$$.fragment,De),$$=c(De),qo=r(De,"DIV",{class:!0});var Yb=s(qo);u(ya.$$.fragment,Yb),E$=c(Yb),Df=r(Yb,"P",{});var yD=s(Df);q$=i(yD,"Summarize the text(s) given as inputs."),yD.forEach(n),Yb.forEach(n),De.forEach(n),c_=c(t),Zt=r(t,"H3",{class:!0});var Kb=s(Zt);Ao=r(Kb,"A",{id:!0,class:!0,href:!0});var xD=s(Ao);Cf=r(xD,"SPAN",{});var $D=s(Cf);u(xa.$$.fragment,$D),$D.forEach(n),xD.forEach(n),A$=c(Kb),If=r(Kb,"SPAN",{});var ED=s(If);j$=i(ED,"TableQuestionAnsweringPipeline"),ED.forEach(n),Kb.forEach(n),d_=c(t),le=r(t,"DIV",{class:!0});var rt=s(le);u($a.$$.fragment,rt),D$=c(rt),Ea=r(rt,"P",{});var Xb=s(Ea);C$=i(Xb,"Table Question Answering pipeline using a "),zf=r(Xb,"CODE",{});var qD=s(zf);I$=i(qD,"ModelForTableQuestionAnswering"),qD.forEach(n),z$=i(Xb,`. This pipeline is only available in
PyTorch.`),Xb.forEach(n),S$=c(rt),Bt=r(rt,"P",{});var Kc=s(Bt);M$=i(Kc,"This tabular question answering pipeline can currently be loaded from "),fc=r(Kc,"A",{href:!0});var AD=s(fc);F$=i(AD,"pipeline()"),AD.forEach(n),L$=i(Kc,` using the following task
identifier: `),Sf=r(Kc,"CODE",{});var jD=s(Sf);U$=i(jD,'"table-question-answering"'),jD.forEach(n),O$=i(Kc,"."),Kc.forEach(n),G$=c(rt),qa=r(rt,"P",{});var Jb=s(qa);N$=i(Jb,`The models that this pipeline can use are models that have been fine-tuned on a tabular question answering task.
See the up-to-date list of available models on
`),Aa=r(Jb,"A",{href:!0,rel:!0});var DD=s(Aa);Q$=i(DD,"huggingface.co/models"),DD.forEach(n),R$=i(Jb,"."),Jb.forEach(n),H$=c(rt),V=r(rt,"DIV",{class:!0});var Te=s(V);u(ja.$$.fragment,Te),V$=c(Te),Mf=r(Te,"P",{});var CD=s(Mf);W$=i(CD,"Answers queries according to a table. The pipeline accepts several types of inputs which are detailed below:"),CD.forEach(n),Z$=c(Te),Y=r(Te,"UL",{});var ye=s(Y);Ff=r(ye,"LI",{});var ID=s(Ff);Lf=r(ID,"CODE",{});var zD=s(Lf);B$=i(zD,"pipeline(table, query)"),zD.forEach(n),ID.forEach(n),Y$=c(ye),Uf=r(ye,"LI",{});var SD=s(Uf);Of=r(SD,"CODE",{});var MD=s(Of);K$=i(MD,"pipeline(table, [query])"),MD.forEach(n),SD.forEach(n),X$=c(ye),Gf=r(ye,"LI",{});var FD=s(Gf);Nf=r(FD,"CODE",{});var LD=s(Nf);J$=i(LD,"pipeline(table=table, query=query)"),LD.forEach(n),FD.forEach(n),e4=c(ye),Qf=r(ye,"LI",{});var UD=s(Qf);Rf=r(UD,"CODE",{});var OD=s(Rf);t4=i(OD,"pipeline(table=table, query=[query])"),OD.forEach(n),UD.forEach(n),n4=c(ye),Hf=r(ye,"LI",{});var GD=s(Hf);Vf=r(GD,"CODE",{});var ND=s(Vf);o4=i(ND,'pipeline({"table": table, "query": query})'),ND.forEach(n),GD.forEach(n),r4=c(ye),Wf=r(ye,"LI",{});var QD=s(Wf);Zf=r(QD,"CODE",{});var RD=s(Zf);s4=i(RD,'pipeline({"table": table, "query": [query]})'),RD.forEach(n),QD.forEach(n),a4=c(ye),Bf=r(ye,"LI",{});var HD=s(Bf);Yf=r(HD,"CODE",{});var VD=s(Yf);i4=i(VD,'pipeline([{"table": table, "query": query}, {"table": table, "query": query}])'),VD.forEach(n),HD.forEach(n),ye.forEach(n),l4=c(Te),Da=r(Te,"P",{});var ew=s(Da);c4=i(ew,"The "),Kf=r(ew,"CODE",{});var WD=s(Kf);d4=i(WD,"table"),WD.forEach(n),p4=i(ew," argument should be a dict or a DataFrame built from that dict, containing the whole table:"),ew.forEach(n),m4=c(Te),u(jo.$$.fragment,Te),f4=c(Te),Xf=r(Te,"P",{});var ZD=s(Xf);h4=i(ZD,"This dictionary can be passed in as such, or can be converted to a pandas DataFrame:"),ZD.forEach(n),u4=c(Te),u(Do.$$.fragment,Te),Te.forEach(n),rt.forEach(n),p_=c(t),Yt=r(t,"H3",{class:!0});var tw=s(Yt);Co=r(tw,"A",{id:!0,class:!0,href:!0});var BD=s(Co);Jf=r(BD,"SPAN",{});var YD=s(Jf);u(Ca.$$.fragment,YD),YD.forEach(n),BD.forEach(n),g4=c(tw),eh=r(tw,"SPAN",{});var KD=s(eh);_4=i(KD,"TextClassificationPipeline"),KD.forEach(n),tw.forEach(n),m_=c(t),K=r(t,"DIV",{class:!0});var Ce=s(K);u(Ia.$$.fragment,Ce),b4=c(Ce),Kt=r(Ce,"P",{});var Xc=s(Kt);w4=i(Xc,"Text classification pipeline using any "),th=r(Xc,"CODE",{});var XD=s(th);v4=i(XD,"ModelForSequenceClassification"),XD.forEach(n),k4=i(Xc,". See the "),hc=r(Xc,"A",{href:!0});var JD=s(hc);P4=i(JD,`sequence classification
examples`),JD.forEach(n),T4=i(Xc," for more information."),Xc.forEach(n),y4=c(Ce),Xt=r(Ce,"P",{});var Jc=s(Xt);x4=i(Jc,"This text classification pipeline can currently be loaded from "),uc=r(Jc,"A",{href:!0});var eC=s(uc);$4=i(eC,"pipeline()"),eC.forEach(n),E4=i(Jc,` using the following task identifier:
`),nh=r(Jc,"CODE",{});var tC=s(nh);q4=i(tC,'"sentiment-analysis"'),tC.forEach(n),A4=i(Jc," (for classifying sequences according to positive or negative sentiments)."),Jc.forEach(n),j4=c(Ce),za=r(Ce,"P",{});var nw=s(za);D4=i(nw,"If multiple classification labels are available ("),oh=r(nw,"CODE",{});var nC=s(oh);C4=i(nC,"model.config.num_labels >= 2"),nC.forEach(n),I4=i(nw,`), the pipeline will run a softmax
over the results. If there is a single label, the pipeline will run a sigmoid over the result.`),nw.forEach(n),z4=c(Ce),Sa=r(Ce,"P",{});var ow=s(Sa);S4=i(ow,`The models that this pipeline can use are models that have been fine-tuned on a sequence classification task. See
the up-to-date list of available models on
`),Ma=r(ow,"A",{href:!0,rel:!0});var oC=s(Ma);M4=i(oC,"huggingface.co/models"),oC.forEach(n),F4=i(ow,"."),ow.forEach(n),L4=c(Ce),Io=r(Ce,"DIV",{class:!0});var rw=s(Io);u(Fa.$$.fragment,rw),U4=c(rw),rh=r(rw,"P",{});var rC=s(rh);O4=i(rC,"Classify the text(s) given as inputs."),rC.forEach(n),rw.forEach(n),Ce.forEach(n),f_=c(t),Jt=r(t,"H3",{class:!0});var sw=s(Jt);zo=r(sw,"A",{id:!0,class:!0,href:!0});var sC=s(zo);sh=r(sC,"SPAN",{});var aC=s(sh);u(La.$$.fragment,aC),aC.forEach(n),sC.forEach(n),G4=c(sw),ah=r(sw,"SPAN",{});var iC=s(ah);N4=i(iC,"TextGenerationPipeline"),iC.forEach(n),sw.forEach(n),h_=c(t),ce=r(t,"DIV",{class:!0});var st=s(ce);u(Ua.$$.fragment,st),Q4=c(st),Oa=r(st,"P",{});var aw=s(Oa);R4=i(aw,"Language generation pipeline using any "),ih=r(aw,"CODE",{});var lC=s(ih);H4=i(lC,"ModelWithLMHead"),lC.forEach(n),V4=i(aw,`. This pipeline predicts the words that will follow a
specified text prompt.`),aw.forEach(n),W4=c(st),en=r(st,"P",{});var ed=s(en);Z4=i(ed,"This language generation pipeline can currently be loaded from "),gc=r(ed,"A",{href:!0});var cC=s(gc);B4=i(cC,"pipeline()"),cC.forEach(n),Y4=i(ed,` using the following task identifier:
`),lh=r(ed,"CODE",{});var dC=s(lh);K4=i(dC,'"text-generation"'),dC.forEach(n),X4=i(ed,"."),ed.forEach(n),J4=c(st),Ga=r(st,"P",{});var iw=s(Ga);eE=i(iw,`The models that this pipeline can use are models that have been trained with an autoregressive language modeling
objective, which includes the uni-directional models in the library (e.g. gpt2). See the list of available models
on `),Na=r(iw,"A",{href:!0,rel:!0});var pC=s(Na);tE=i(pC,"huggingface.co/models"),pC.forEach(n),nE=i(iw,"."),iw.forEach(n),oE=c(st),So=r(st,"DIV",{class:!0});var lw=s(So);u(Qa.$$.fragment,lw),rE=c(lw),ch=r(lw,"P",{});var mC=s(ch);sE=i(mC,"Complete the prompt(s) given as inputs."),mC.forEach(n),lw.forEach(n),st.forEach(n),u_=c(t),tn=r(t,"H3",{class:!0});var cw=s(tn);Mo=r(cw,"A",{id:!0,class:!0,href:!0});var fC=s(Mo);dh=r(fC,"SPAN",{});var hC=s(dh);u(Ra.$$.fragment,hC),hC.forEach(n),fC.forEach(n),aE=c(cw),ph=r(cw,"SPAN",{});var uC=s(ph);iE=i(uC,"Text2TextGenerationPipeline"),uC.forEach(n),cw.forEach(n),g_=c(t),H=r(t,"DIV",{class:!0});var xe=s(H);u(Ha.$$.fragment,xe),lE=c(xe),mh=r(xe,"P",{});var gC=s(mh);cE=i(gC,"Pipeline for text to text generation using seq2seq models."),gC.forEach(n),dE=c(xe),nn=r(xe,"P",{});var td=s(nn);pE=i(td,"This Text2TextGenerationPipeline pipeline can currently be loaded from "),_c=r(td,"A",{href:!0});var _C=s(_c);mE=i(_C,"pipeline()"),_C.forEach(n),fE=i(td,` using the following task
identifier: `),fh=r(td,"CODE",{});var bC=s(fh);hE=i(bC,'"text2text-generation"'),bC.forEach(n),uE=i(td,"."),td.forEach(n),gE=c(xe),Fo=r(xe,"P",{});var Lu=s(Fo);_E=i(Lu,`The models that this pipeline can use are models that have been fine-tuned on a translation task. See the
up-to-date list of available models on
`),Va=r(Lu,"A",{href:!0,rel:!0});var wC=s(Va);bE=i(wC,"huggingface.co/models"),wC.forEach(n),wE=i(Lu,`. For a list of available
parameters, see the `),Wa=r(Lu,"A",{href:!0,rel:!0});var vC=s(Wa);vE=i(vC,`following
documentation`),vC.forEach(n),Lu.forEach(n),kE=c(xe),u(Lo.$$.fragment,xe),PE=c(xe),Uo=r(xe,"DIV",{class:!0});var dw=s(Uo);u(Za.$$.fragment,dw),TE=c(dw),hh=r(dw,"P",{});var kC=s(hh);yE=i(kC,"Generate the output text(s) using text(s) given as inputs."),kC.forEach(n),dw.forEach(n),xE=c(xe),Oo=r(xe,"DIV",{class:!0});var pw=s(Oo);u(Ba.$$.fragment,pw),$E=c(pw),uh=r(pw,"P",{});var PC=s(uh);EE=i(PC,"Checks whether there might be something wrong with given input with regard to the model."),PC.forEach(n),pw.forEach(n),xe.forEach(n),__=c(t),on=r(t,"H3",{class:!0});var mw=s(on);Go=r(mw,"A",{id:!0,class:!0,href:!0});var TC=s(Go);gh=r(TC,"SPAN",{});var yC=s(gh);u(Ya.$$.fragment,yC),yC.forEach(n),TC.forEach(n),qE=c(mw),_h=r(mw,"SPAN",{});var xC=s(_h);AE=i(xC,"TokenClassificationPipeline"),xC.forEach(n),mw.forEach(n),b_=c(t),z=r(t,"DIV",{class:!0});var W=s(z);u(Ka.$$.fragment,W),jE=c(W),rn=r(W,"P",{});var nd=s(rn);DE=i(nd,"Named Entity Recognition pipeline using any "),bh=r(nd,"CODE",{});var $C=s(bh);CE=i($C,"ModelForTokenClassification"),$C.forEach(n),IE=i(nd,". See the "),bc=r(nd,"A",{href:!0});var EC=s(bc);zE=i(EC,`named entity recognition
examples`),EC.forEach(n),SE=i(nd," for more information."),nd.forEach(n),ME=c(W),sn=r(W,"P",{});var od=s(sn);FE=i(od,"This token recognition pipeline can currently be loaded from "),wc=r(od,"A",{href:!0});var qC=s(wc);LE=i(qC,"pipeline()"),qC.forEach(n),UE=i(od,` using the following task identifier:
`),wh=r(od,"CODE",{});var AC=s(wh);OE=i(AC,'"ner"'),AC.forEach(n),GE=i(od," (for predicting the classes of tokens in a sequence: person, organisation, location or miscellaneous)."),od.forEach(n),NE=c(W),Xa=r(W,"P",{});var fw=s(Xa);QE=i(fw,`The models that this pipeline can use are models that have been fine-tuned on a token classification task. See the
up-to-date list of available models on
`),Ja=r(fw,"A",{href:!0,rel:!0});var jC=s(Ja);RE=i(jC,"huggingface.co/models"),jC.forEach(n),HE=i(fw,"."),fw.forEach(n),VE=c(W),No=r(W,"DIV",{class:!0});var hw=s(No);u(ei.$$.fragment,hw),WE=c(hw),vh=r(hw,"P",{});var DC=s(vh);ZE=i(DC,"Classify each token of the text(s) given as inputs."),DC.forEach(n),hw.forEach(n),BE=c(W),We=r(W,"DIV",{class:!0});var rd=s(We);u(ti.$$.fragment,rd),YE=c(rd),kh=r(rd,"P",{});var CC=s(kh);KE=i(CC,"Override tokens from a given word that disagree to force agreement on word boundaries."),CC.forEach(n),XE=c(rd),Ph=r(rd,"P",{});var IC=s(Ph);JE=i(IC,`Example: micro|soft| com|pany| B-ENT I-NAME I-ENT I-ENT will be rewritten with first strategy as microsoft|
company| B-ENT I-ENT`),IC.forEach(n),rd.forEach(n),e3=c(W),Qo=r(W,"DIV",{class:!0});var uw=s(Qo);u(ni.$$.fragment,uw),t3=c(uw),Th=r(uw,"P",{});var zC=s(Th);n3=i(zC,"Fuse various numpy arrays into dicts with all the information needed for aggregation"),zC.forEach(n),uw.forEach(n),o3=c(W),Ro=r(W,"DIV",{class:!0});var gw=s(Ro);u(oi.$$.fragment,gw),r3=c(gw),yh=r(gw,"P",{});var SC=s(yh);s3=i(SC,"Find and group together the adjacent tokens with the same entity predicted."),SC.forEach(n),gw.forEach(n),a3=c(W),Ho=r(W,"DIV",{class:!0});var _w=s(Ho);u(ri.$$.fragment,_w),i3=c(_w),xh=r(_w,"P",{});var MC=s(xh);l3=i(MC,"Group together the adjacent tokens with the same entity predicted."),MC.forEach(n),_w.forEach(n),W.forEach(n),w_=c(t),an=r(t,"H3",{class:!0});var bw=s(an);Vo=r(bw,"A",{id:!0,class:!0,href:!0});var FC=s(Vo);$h=r(FC,"SPAN",{});var LC=s($h);u(si.$$.fragment,LC),LC.forEach(n),FC.forEach(n),c3=c(bw),Eh=r(bw,"SPAN",{});var UC=s(Eh);d3=i(UC,"TranslationPipeline"),UC.forEach(n),bw.forEach(n),v_=c(t),X=r(t,"DIV",{class:!0});var Ie=s(X);u(ai.$$.fragment,Ie),p3=c(Ie),qh=r(Ie,"P",{});var OC=s(qh);m3=i(OC,"Translates from one language to another."),OC.forEach(n),f3=c(Ie),ln=r(Ie,"P",{});var sd=s(ln);h3=i(sd,"This translation pipeline can currently be loaded from "),vc=r(sd,"A",{href:!0});var GC=s(vc);u3=i(GC,"pipeline()"),GC.forEach(n),g3=i(sd,` using the following task identifier:
`),Ah=r(sd,"CODE",{});var NC=s(Ah);_3=i(NC,'"translation_xx_to_yy"'),NC.forEach(n),b3=i(sd,"."),sd.forEach(n),w3=c(Ie),Wo=r(Ie,"P",{});var Uu=s(Wo);v3=i(Uu,`The models that this pipeline can use are models that have been fine-tuned on a translation task. See the
up-to-date list of available models on `),ii=r(Uu,"A",{href:!0,rel:!0});var QC=s(ii);k3=i(QC,"huggingface.co/models"),QC.forEach(n),P3=i(Uu,`.
For a list of available parameters, see the `),li=r(Uu,"A",{href:!0,rel:!0});var RC=s(li);T3=i(RC,`following
documentation`),RC.forEach(n),Uu.forEach(n),y3=c(Ie),u(Zo.$$.fragment,Ie),x3=c(Ie),Bo=r(Ie,"DIV",{class:!0});var ww=s(Bo);u(ci.$$.fragment,ww),$3=c(ww),jh=r(ww,"P",{});var HC=s(jh);E3=i(HC,"Translate the text(s) given as inputs."),HC.forEach(n),ww.forEach(n),Ie.forEach(n),k_=c(t),cn=r(t,"H3",{class:!0});var vw=s(cn);Yo=r(vw,"A",{id:!0,class:!0,href:!0});var VC=s(Yo);Dh=r(VC,"SPAN",{});var WC=s(Dh);u(di.$$.fragment,WC),WC.forEach(n),VC.forEach(n),q3=c(vw),Ch=r(vw,"SPAN",{});var ZC=s(Ch);A3=i(ZC,"VisualQuestionAnsweringPipeline"),ZC.forEach(n),vw.forEach(n),P_=c(t),de=r(t,"DIV",{class:!0});var at=s(de);u(pi.$$.fragment,at),j3=c(at),mi=r(at,"P",{});var kw=s(mi);D3=i(kw,"Visual Question Answering pipeline using a "),Ih=r(kw,"CODE",{});var BC=s(Ih);C3=i(BC,"AutoModelForVisualQuestionAnswering"),BC.forEach(n),I3=i(kw,`. This pipeline is currently only
available in PyTorch.`),kw.forEach(n),z3=c(at),dn=r(at,"P",{});var ad=s(dn);S3=i(ad,"This visual question answering pipeline can currently be loaded from "),kc=r(ad,"A",{href:!0});var YC=s(kc);M3=i(YC,"pipeline()"),YC.forEach(n),F3=i(ad,` using the following task
identifiers: `),zh=r(ad,"CODE",{});var KC=s(zh);L3=i(KC,'"visual-question-answering", "vqa"'),KC.forEach(n),U3=i(ad,"."),ad.forEach(n),O3=c(at),fi=r(at,"P",{});var Pw=s(fi);G3=i(Pw,`The models that this pipeline can use are models that have been fine-tuned on a visual question answering task. See
the up-to-date list of available models on
`),hi=r(Pw,"A",{href:!0,rel:!0});var XC=s(hi);N3=i(XC,"huggingface.co/models"),XC.forEach(n),Q3=i(Pw,"."),Pw.forEach(n),R3=c(at),Ze=r(at,"DIV",{class:!0});var id=s(Ze);u(ui.$$.fragment,id),H3=c(id),Sh=r(id,"P",{});var JC=s(Sh);V3=i(JC,`Answers open-ended questions about images. The pipeline accepts several types of inputs which are detailed
below:`),JC.forEach(n),W3=c(id),Oe=r(id,"UL",{});var gr=s(Oe);Mh=r(gr,"LI",{});var eI=s(Mh);Fh=r(eI,"CODE",{});var tI=s(Fh);Z3=i(tI,"pipeline(image=image, question=question)"),tI.forEach(n),eI.forEach(n),B3=c(gr),Lh=r(gr,"LI",{});var nI=s(Lh);Uh=r(nI,"CODE",{});var oI=s(Uh);Y3=i(oI,'pipeline({"image": image, "question": question})'),oI.forEach(n),nI.forEach(n),K3=c(gr),Oh=r(gr,"LI",{});var rI=s(Oh);Gh=r(rI,"CODE",{});var sI=s(Gh);X3=i(sI,'pipeline([{"image": image, "question": question}])'),sI.forEach(n),rI.forEach(n),J3=c(gr),Nh=r(gr,"LI",{});var aI=s(Nh);Qh=r(aI,"CODE",{});var iI=s(Qh);e5=i(iI,'pipeline([{"image": image, "question": question}, {"image": image, "question": question}])'),iI.forEach(n),aI.forEach(n),gr.forEach(n),id.forEach(n),at.forEach(n),T_=c(t),pn=r(t,"H3",{class:!0});var Tw=s(pn);Ko=r(Tw,"A",{id:!0,class:!0,href:!0});var lI=s(Ko);Rh=r(lI,"SPAN",{});var cI=s(Rh);u(gi.$$.fragment,cI),cI.forEach(n),lI.forEach(n),t5=c(Tw),Hh=r(Tw,"SPAN",{});var dI=s(Hh);n5=i(dI,"ZeroShotClassificationPipeline"),dI.forEach(n),Tw.forEach(n),y_=c(t),J=r(t,"DIV",{class:!0});var ze=s(J);u(_i.$$.fragment,ze),o5=c(ze),bi=r(ze,"P",{});var yw=s(bi);r5=i(yw,"NLI-based zero-shot classification pipeline using a "),Vh=r(yw,"CODE",{});var pI=s(Vh);s5=i(pI,"ModelForSequenceClassification"),pI.forEach(n),a5=i(yw,` trained on NLI (natural
language inference) tasks.`),yw.forEach(n),i5=c(ze),Ge=r(ze,"P",{});var _r=s(Ge);l5=i(_r,`Any combination of sequences and labels can be passed and each combination will be posed as a premise/hypothesis
pair and passed to the pretrained model. Then, the logit for `),Wh=r(_r,"EM",{});var mI=s(Wh);c5=i(mI,"entailment"),mI.forEach(n),d5=i(_r,` is taken as the logit for the candidate
label being valid. Any NLI model can be used, but the id of the `),Zh=r(_r,"EM",{});var fI=s(Zh);p5=i(fI,"entailment"),fI.forEach(n),m5=i(_r,` label must be included in the model
config\u2019s :attr:`),Bh=r(_r,"EM",{});var hI=s(Bh);f5=i(hI,"~transformers.PretrainedConfig.label2id"),hI.forEach(n),h5=i(_r,"."),_r.forEach(n),u5=c(ze),mn=r(ze,"P",{});var ld=s(mn);g5=i(ld,"This NLI pipeline can currently be loaded from "),Pc=r(ld,"A",{href:!0});var uI=s(Pc);_5=i(uI,"pipeline()"),uI.forEach(n),b5=i(ld,` using the following task identifier:
`),Yh=r(ld,"CODE",{});var gI=s(Yh);w5=i(gI,'"zero-shot-classification"'),gI.forEach(n),v5=i(ld,"."),ld.forEach(n),k5=c(ze),wi=r(ze,"P",{});var xw=s(wi);P5=i(xw,`The models that this pipeline can use are models that have been fine-tuned on an NLI task. See the up-to-date list
of available models on `),vi=r(xw,"A",{href:!0,rel:!0});var _I=s(vi);T5=i(_I,"huggingface.co/models"),_I.forEach(n),y5=i(xw,"."),xw.forEach(n),x5=c(ze),Xo=r(ze,"DIV",{class:!0});var $w=s(Xo);u(ki.$$.fragment,$w),$5=c($w),Pi=r($w,"P",{});var Ew=s(Pi);E5=i(Ew,"Classify the sequence(s) given as inputs. See the "),Tc=r(Ew,"A",{href:!0});var bI=s(Tc);q5=i(bI,"ZeroShotClassificationPipeline"),bI.forEach(n),A5=i(Ew,` documentation for more
information.`),Ew.forEach(n),$w.forEach(n),ze.forEach(n),x_=c(t),fn=r(t,"H3",{class:!0});var qw=s(fn);Jo=r(qw,"A",{id:!0,class:!0,href:!0});var wI=s(Jo);Kh=r(wI,"SPAN",{});var vI=s(Kh);u(Ti.$$.fragment,vI),vI.forEach(n),wI.forEach(n),j5=c(qw),Xh=r(qw,"SPAN",{});var kI=s(Xh);D5=i(kI,"ZeroShotImageClassificationPipeline"),kI.forEach(n),qw.forEach(n),$_=c(t),pe=r(t,"DIV",{class:!0});var it=s(pe);u(yi.$$.fragment,it),C5=c(it),hn=r(it,"P",{});var cd=s(hn);I5=i(cd,"Zero shot image classification pipeline using "),Jh=r(cd,"CODE",{});var PI=s(Jh);z5=i(PI,"CLIPModel"),PI.forEach(n),S5=i(cd,`. This pipeline predicts the class of an image when you
provide an image and a set of `),eu=r(cd,"CODE",{});var TI=s(eu);M5=i(TI,"candidate_labels"),TI.forEach(n),F5=i(cd,"."),cd.forEach(n),L5=c(it),un=r(it,"P",{});var dd=s(un);U5=i(dd,"This image classification pipeline can currently be loaded from "),yc=r(dd,"A",{href:!0});var yI=s(yc);O5=i(yI,"pipeline()"),yI.forEach(n),G5=i(dd,` using the following task identifier:
`),tu=r(dd,"CODE",{});var xI=s(tu);N5=i(xI,'"zero-shot-image-classification"'),xI.forEach(n),Q5=i(dd,"."),dd.forEach(n),R5=c(it),xi=r(it,"P",{});var Aw=s(xi);H5=i(Aw,`See the list of available models on
`),$i=r(Aw,"A",{href:!0,rel:!0});var $I=s($i);V5=i($I,"huggingface.co/models"),$I.forEach(n),W5=i(Aw,"."),Aw.forEach(n),Z5=c(it),er=r(it,"DIV",{class:!0});var jw=s(er);u(Ei.$$.fragment,jw),B5=c(jw),nu=r(jw,"P",{});var EI=s(nu);Y5=i(EI,"Assign labels to the image(s) passed as inputs."),EI.forEach(n),jw.forEach(n),it.forEach(n),E_=c(t),gn=r(t,"H3",{class:!0});var Dw=s(gn);tr=r(Dw,"A",{id:!0,class:!0,href:!0});var qI=s(tr);ou=r(qI,"SPAN",{});var AI=s(ou);u(qi.$$.fragment,AI),AI.forEach(n),qI.forEach(n),K5=c(Dw),ru=r(Dw,"SPAN",{});var jI=s(ru);X5=i(jI,"ZeroShotObjectDetectionPipeline"),jI.forEach(n),Dw.forEach(n),q_=c(t),me=r(t,"DIV",{class:!0});var lt=s(me);u(Ai.$$.fragment,lt),J5=c(lt),_n=r(lt,"P",{});var pd=s(_n);eq=i(pd,"Zero shot object detection pipeline using "),su=r(pd,"CODE",{});var DI=s(su);tq=i(DI,"OwlViTForObjectDetection"),DI.forEach(n),nq=i(pd,`. This pipeline predicts bounding boxes of
objects when you provide an image and a set of `),au=r(pd,"CODE",{});var CI=s(au);oq=i(CI,"candidate_labels"),CI.forEach(n),rq=i(pd,"."),pd.forEach(n),sq=c(lt),bn=r(lt,"P",{});var md=s(bn);aq=i(md,"This object detection pipeline can currently be loaded from "),xc=r(md,"A",{href:!0});var II=s(xc);iq=i(II,"pipeline()"),II.forEach(n),lq=i(md,` using the following task identifier:
`),iu=r(md,"CODE",{});var zI=s(iu);cq=i(zI,'"zero-shot-object-detection"'),zI.forEach(n),dq=i(md,"."),md.forEach(n),pq=c(lt),ji=r(lt,"P",{});var Cw=s(ji);mq=i(Cw,`See the list of available models on
`),Di=r(Cw,"A",{href:!0,rel:!0});var SI=s(Di);fq=i(SI,"huggingface.co/models"),SI.forEach(n),hq=i(Cw,"."),Cw.forEach(n),uq=c(lt),nr=r(lt,"DIV",{class:!0});var Iw=s(nr);u(Ci.$$.fragment,Iw),gq=c(Iw),lu=r(Iw,"P",{});var MI=s(lu);_q=i(MI,"Detect objects (bounding boxes & classes) in the image(s) passed as inputs."),MI.forEach(n),Iw.forEach(n),lt.forEach(n),A_=c(t),wn=r(t,"H2",{class:!0});var zw=s(wn);or=r(zw,"A",{id:!0,class:!0,href:!0});var FI=s(or);cu=r(FI,"SPAN",{});var LI=s(cu);u(Ii.$$.fragment,LI),LI.forEach(n),FI.forEach(n),bq=c(zw),$c=r(zw,"SPAN",{});var vA=s($c);wq=i(vA,"Parent class: "),du=r(vA,"CODE",{});var UI=s(du);vq=i(UI,"Pipeline"),UI.forEach(n),vA.forEach(n),zw.forEach(n),j_=c(t),j=r(t,"DIV",{class:!0});var C=s(j);u(zi.$$.fragment,C),kq=c(C),pu=r(C,"P",{});var OI=s(pu);Pq=i(OI,`The Pipeline class is the class from which all pipelines inherit. Refer to this class for methods shared across
different pipelines.`),OI.forEach(n),Tq=c(C),mu=r(C,"P",{});var GI=s(mu);yq=i(GI,`Base class implementing pipelined operations. Pipeline workflow is defined as a sequence of the following
operations:`),GI.forEach(n),xq=c(C),fu=r(C,"P",{});var NI=s(fu);$q=i(NI,"Input -> Tokenization -> Model Inference -> Post-Processing (task dependent) -> Output"),NI.forEach(n),Eq=c(C),hu=r(C,"P",{});var QI=s(hu);qq=i(QI,"Pipeline supports running on CPU or GPU through the device argument (see below)."),QI.forEach(n),Aq=c(C),qe=r(C,"P",{});var ct=s(qe);jq=i(ct,"Some pipeline, like for instance "),Ec=r(ct,"A",{href:!0});var RI=s(Ec);Dq=i(RI,"FeatureExtractionPipeline"),RI.forEach(n),Cq=i(ct," ("),uu=r(ct,"CODE",{});var HI=s(uu);Iq=i(HI,"'feature-extraction'"),HI.forEach(n),zq=i(ct,`) output large tensor object
as nested-lists. In order to avoid dumping such large structure as textual data we provide the `),gu=r(ct,"CODE",{});var VI=s(gu);Sq=i(VI,"binary_output"),VI.forEach(n),Mq=i(ct,`
constructor argument. If set to `),_u=r(ct,"CODE",{});var WI=s(_u);Fq=i(WI,"True"),WI.forEach(n),Lq=i(ct,", the output will be stored in the pickle format."),ct.forEach(n),Uq=c(C),rr=r(C,"DIV",{class:!0});var Sw=s(rr);u(Si.$$.fragment,Sw),Oq=c(Sw),bu=r(Sw,"P",{});var ZI=s(bu);Gq=i(ZI,"Check if the model class is in supported by the pipeline."),ZI.forEach(n),Sw.forEach(n),Nq=c(C),Be=r(C,"DIV",{class:!0});var fd=s(Be);u(Mi.$$.fragment,fd),Qq=c(fd),wu=r(fd,"P",{});var BI=s(wu);Rq=i(BI,"Context Manager allowing tensor allocation on the user-specified device in framework agnostic way."),BI.forEach(n),Hq=c(fd),u(sr.$$.fragment,fd),fd.forEach(n),Vq=c(C),ar=r(C,"DIV",{class:!0});var Mw=s(ar);u(Fi.$$.fragment,Mw),Wq=c(Mw),vu=r(Mw,"P",{});var YI=s(vu);Zq=i(YI,"Ensure PyTorch tensors are on the specified device."),YI.forEach(n),Mw.forEach(n),Bq=c(C),ir=r(C,"DIV",{class:!0});var Fw=s(ir);u(Li.$$.fragment,Fw),Yq=c(Fw),Ui=r(Fw,"P",{});var Lw=s(Ui);Kq=i(Lw,"Postprocess will receive the raw outputs of the "),ku=r(Lw,"CODE",{});var KI=s(ku);Xq=i(KI,"_forward"),KI.forEach(n),Jq=i(Lw,` method, generally tensors, and reformat them into
something more friendly. Generally it will output a list or a dict or results (containing just strings and
numbers).`),Lw.forEach(n),Fw.forEach(n),eA=c(C),lr=r(C,"DIV",{class:!0});var Uw=s(lr);u(Oi.$$.fragment,Uw),tA=c(Uw),Gi=r(Uw,"P",{});var Ow=s(Gi);nA=i(Ow,"Scikit / Keras interface to transformers\u2019 pipelines. This method will forward to "),Pu=r(Ow,"STRONG",{});var XI=s(Pu);oA=i(XI,"call"),XI.forEach(n),rA=i(Ow,"()."),Ow.forEach(n),Uw.forEach(n),sA=c(C),cr=r(C,"DIV",{class:!0});var Gw=s(cr);u(Ni.$$.fragment,Gw),aA=c(Gw),vn=r(Gw,"P",{});var hd=s(vn);iA=i(hd,"Preprocess will take the "),Tu=r(hd,"CODE",{});var JI=s(Tu);lA=i(JI,"input_"),JI.forEach(n),cA=i(hd,` of a specific pipeline and return a dictionnary of everything necessary for
`),yu=r(hd,"CODE",{});var ez=s(yu);dA=i(ez,"_forward"),ez.forEach(n),pA=i(hd," to run properly. It should contain at least one tensor, but might have arbitrary other items."),hd.forEach(n),Gw.forEach(n),mA=c(C),dr=r(C,"DIV",{class:!0});var Nw=s(dr);u(Qi.$$.fragment,Nw),fA=c(Nw),xu=r(Nw,"P",{});var tz=s(xu);hA=i(tz,"Save the pipeline\u2019s model and tokenizer."),tz.forEach(n),Nw.forEach(n),uA=c(C),pr=r(C,"DIV",{class:!0});var Qw=s(pr);u(Ri.$$.fragment,Qw),gA=c(Qw),Hi=r(Qw,"P",{});var Rw=s(Hi);_A=i(Rw,"Scikit / Keras interface to transformers\u2019 pipelines. This method will forward to "),$u=r(Rw,"STRONG",{});var nz=s($u);bA=i(nz,"call"),nz.forEach(n),wA=i(Rw,"()."),Rw.forEach(n),Qw.forEach(n),C.forEach(n),this.h()},h(){d(k,"name","hf:doc:metadata"),d(k,"content",JSON.stringify(Ez)),d(v,"id","pipelines"),d(v,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(v,"href","#pipelines"),d(T,"class","relative group"),d(Xi,"href","../task_summary"),d(el,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(tl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.AudioClassificationPipeline"),d(nl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.AutomaticSpeechRecognitionPipeline"),d(ol,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.ConversationalPipeline"),d(rl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.DepthEstimationPipeline"),d(sl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.DocumentQuestionAnsweringPipeline"),d(al,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.FeatureExtractionPipeline"),d(il,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.FillMaskPipeline"),d(ll,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.ImageClassificationPipeline"),d(cl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.ImageSegmentationPipeline"),d(dl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.ImageToTextPipeline"),d(pl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.ObjectDetectionPipeline"),d(ml,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.QuestionAnsweringPipeline"),d(fl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.SummarizationPipeline"),d(hl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.TableQuestionAnsweringPipeline"),d(ul,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.TextClassificationPipeline"),d(gl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.TextGenerationPipeline"),d(_l,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.Text2TextGenerationPipeline"),d(bl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.TokenClassificationPipeline"),d(wl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.TranslationPipeline"),d(vl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.VisualQuestionAnsweringPipeline"),d(kl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.ZeroShotClassificationPipeline"),d(Pl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.ZeroShotImageClassificationPipeline"),d(Tl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.ZeroShotObjectDetectionPipeline"),d(Tn,"id","transformers.pipeline"),d(Tn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Tn,"href","#transformers.pipeline"),d(dt,"class","relative group"),d(Pr,"href","https://huggingface.co"),d(Pr,"rel","nofollow"),d($l,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.Pipeline"),d(El,"href","tokenizer"),d(ql,"href","model"),d(oe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(An,"id","pipeline-batching"),d(An,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(An,"href","#pipeline-batching"),d(mt,"class","relative group"),d(Cn,"id","pipeline-chunk-batching"),d(Cn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Cn,"href","#pipeline-chunk-batching"),d(ht,"class","relative group"),d(zn,"id","pipeline-custom-code"),d(zn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(zn,"href","#pipeline-custom-code"),d(ut,"class","relative group"),d(Mn,"id","implementing-a-pipeline"),d(Mn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Mn,"href","#implementing-a-pipeline"),d(gt,"class","relative group"),d(Ul,"href","../add_new_pipeline"),d(Fn,"id","the-task-specific-pipelines"),d(Fn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Fn,"href","#the-task-specific-pipelines"),d(_t,"class","relative group"),d(Ln,"id","transformers.AudioClassificationPipeline"),d(Ln,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Ln,"href","#transformers.AudioClassificationPipeline"),d(bt,"class","relative group"),d(Ol,"href","../pipeline_tutorial"),d(Gl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(Br,"href","https://huggingface.co/models?filter=audio-classification"),d(Br,"rel","nofollow"),d(Nl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.AutomaticSpeechRecognitionPipeline"),d(On,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(L,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Gn,"id","transformers.AutomaticSpeechRecognitionPipeline"),d(Gn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Gn,"href","#transformers.AutomaticSpeechRecognitionPipeline"),d(vt,"class","relative group"),d(Ql,"href","../pipeline_tutorial"),d(Rl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.AutomaticSpeechRecognitionPipeline"),d(Qn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Rn,"id","transformers.Conversation"),d(Rn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Rn,"href","#transformers.Conversation"),d(kt,"class","relative group"),d(Hl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.ConversationalPipeline"),d(Vl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.ConversationalPipeline"),d(Vn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Wn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Re,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Zn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(U,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Wl,"href","../pipeline_tutorial"),d(Zl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(ds,"href","https://huggingface.co/models?filter=conversational"),d(ds,"rel","nofollow"),d(Yn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(O,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Kn,"id","transformers.DepthEstimationPipeline"),d(Kn,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Kn,"href","#transformers.DepthEstimationPipeline"),d(Tt,"class","relative group"),d(Bl,"href","../pipeline_tutorial"),d(Yl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(gs,"href","https://huggingface.co/models?filter=depth-estimation"),d(gs,"rel","nofollow"),d(Jn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(G,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(eo,"id","transformers.DocumentQuestionAnsweringPipeline"),d(eo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(eo,"href","#transformers.DocumentQuestionAnsweringPipeline"),d(xt,"class","relative group"),d(Kl,"href","../pipeline_tutorial"),d(Xl,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(Ps,"href","https://huggingface.co/models?filter=document-question-answering"),d(Ps,"rel","nofollow"),d(Ae,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(N,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(no,"id","transformers.FeatureExtractionPipeline"),d(no,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(no,"href","#transformers.FeatureExtractionPipeline"),d(Et,"class","relative group"),d(Jl,"href","../pipeline_tutorial"),d(ec,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(qs,"href","https://huggingface.co/models"),d(qs,"rel","nofollow"),d(ro,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(so,"id","transformers.FillMaskPipeline"),d(so,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(so,"href","#transformers.FillMaskPipeline"),d(At,"class","relative group"),d(tc,"href","../task_summary#masked-language-modeling"),d(nc,"href","../pipeline_tutorial"),d(oc,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(Is,"href","https://huggingface.co/models?filter=fill-mask"),d(Is,"rel","nofollow"),d(lo,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(S,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(co,"id","transformers.ImageClassificationPipeline"),d(co,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(co,"href","#transformers.ImageClassificationPipeline"),d(Ct,"class","relative group"),d(rc,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(Us,"href","https://huggingface.co/models?filter=image-classification"),d(Us,"rel","nofollow"),d(po,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(re,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(mo,"id","transformers.ImageSegmentationPipeline"),d(mo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(mo,"href","#transformers.ImageSegmentationPipeline"),d(zt,"class","relative group"),d(sc,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(Hs,"href","https://huggingface.co/models?filter=image-segmentation"),d(Hs,"rel","nofollow"),d(fo,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(se,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ho,"id","transformers.ImageToTextPipeline"),d(ho,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(ho,"href","#transformers.ImageToTextPipeline"),d(Mt,"class","relative group"),d(Ks,"href","https://huggingface.co/models?pipeline_tag=image-to-text"),d(Ks,"rel","nofollow"),d(uo,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ae,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(go,"id","transformers.TokenClassificationPipeline"),d(go,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(go,"href","#transformers.TokenClassificationPipeline"),d(Ft,"class","relative group"),d(ac,"href","../task_summary#named-entity-recognition"),d(ic,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(na,"href","https://huggingface.co/models?filter=token-classification"),d(na,"rel","nofollow"),d(He,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(_o,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(bo,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(wo,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(M,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(lc,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.TokenClassificationPipeline"),d(ko,"id","transformers.ObjectDetectionPipeline"),d(ko,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(ko,"href","#transformers.ObjectDetectionPipeline"),d(Ot,"class","relative group"),d(cc,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(pa,"href","https://huggingface.co/models?filter=object-detection"),d(pa,"rel","nofollow"),d(Po,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ie,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(To,"id","transformers.QuestionAnsweringPipeline"),d(To,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(To,"href","#transformers.QuestionAnsweringPipeline"),d(Nt,"class","relative group"),d(dc,"href","../task_summary#question-answering"),d(pc,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(ga,"href","https://huggingface.co/models?filter=question-answering"),d(ga,"rel","nofollow"),d(yo,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ve,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(xo,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(R,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d($o,"id","transformers.SummarizationPipeline"),d($o,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d($o,"href","#transformers.SummarizationPipeline"),d(Vt,"class","relative group"),d(mc,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(Pa,"href","https://huggingface.co/models?filter=summarization"),d(Pa,"rel","nofollow"),d(Ta,"href","https://huggingface.co/docs/transformers/en/main_classes/text_generation#transformers.generation.GenerationMixin.generate"),d(Ta,"rel","nofollow"),d(qo,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(B,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ao,"id","transformers.TableQuestionAnsweringPipeline"),d(Ao,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Ao,"href","#transformers.TableQuestionAnsweringPipeline"),d(Zt,"class","relative group"),d(fc,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(Aa,"href","https://huggingface.co/models?filter=table-question-answering"),d(Aa,"rel","nofollow"),d(V,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(le,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Co,"id","transformers.TextClassificationPipeline"),d(Co,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Co,"href","#transformers.TextClassificationPipeline"),d(Yt,"class","relative group"),d(hc,"href","../task_summary#sequence-classification"),d(uc,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(Ma,"href","https://huggingface.co/models?filter=text-classification"),d(Ma,"rel","nofollow"),d(Io,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(K,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(zo,"id","transformers.TextGenerationPipeline"),d(zo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(zo,"href","#transformers.TextGenerationPipeline"),d(Jt,"class","relative group"),d(gc,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(Na,"href","https://huggingface.co/models?filter=text-generation"),d(Na,"rel","nofollow"),d(So,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ce,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Mo,"id","transformers.Text2TextGenerationPipeline"),d(Mo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Mo,"href","#transformers.Text2TextGenerationPipeline"),d(tn,"class","relative group"),d(_c,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(Va,"href","https://huggingface.co/models?filter=text2text-generation"),d(Va,"rel","nofollow"),d(Wa,"href","https://huggingface.co/docs/transformers/en/main_classes/text_generation#transformers.generation.GenerationMixin.generate"),d(Wa,"rel","nofollow"),d(Uo,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Oo,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(H,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Go,"id","transformers.TokenClassificationPipeline"),d(Go,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Go,"href","#transformers.TokenClassificationPipeline"),d(on,"class","relative group"),d(bc,"href","../task_summary#named-entity-recognition"),d(wc,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(Ja,"href","https://huggingface.co/models?filter=token-classification"),d(Ja,"rel","nofollow"),d(No,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(We,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Qo,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ro,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ho,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Vo,"id","transformers.TranslationPipeline"),d(Vo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Vo,"href","#transformers.TranslationPipeline"),d(an,"class","relative group"),d(vc,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(ii,"href","https://huggingface.co/models?filter=translation"),d(ii,"rel","nofollow"),d(li,"href","https://huggingface.co/docs/transformers/en/main_classes/text_generation#transformers.generation.GenerationMixin.generate"),d(li,"rel","nofollow"),d(Bo,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(X,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Yo,"id","transformers.VisualQuestionAnsweringPipeline"),d(Yo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Yo,"href","#transformers.VisualQuestionAnsweringPipeline"),d(cn,"class","relative group"),d(kc,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(hi,"href","https://huggingface.co/models?filter=visual-question-answering"),d(hi,"rel","nofollow"),d(Ze,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(de,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ko,"id","transformers.ZeroShotClassificationPipeline"),d(Ko,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Ko,"href","#transformers.ZeroShotClassificationPipeline"),d(pn,"class","relative group"),d(Pc,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(vi,"href","https://huggingface.co/models?search=nli"),d(vi,"rel","nofollow"),d(Tc,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.ZeroShotClassificationPipeline"),d(Xo,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(J,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Jo,"id","transformers.ZeroShotImageClassificationPipeline"),d(Jo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Jo,"href","#transformers.ZeroShotImageClassificationPipeline"),d(fn,"class","relative group"),d(yc,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d($i,"href","https://huggingface.co/models?filter=zero-shot-image-classification"),d($i,"rel","nofollow"),d(er,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(tr,"id","transformers.ZeroShotObjectDetectionPipeline"),d(tr,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(tr,"href","#transformers.ZeroShotObjectDetectionPipeline"),d(gn,"class","relative group"),d(xc,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.pipeline"),d(Di,"href","https://huggingface.co/models?filter=zero-shot-object-detection"),d(Di,"rel","nofollow"),d(nr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(me,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(or,"id","transformers.Pipeline"),d(or,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(or,"href","#transformers.Pipeline"),d(wn,"class","relative group"),d(Ec,"href","/docs/transformers/main/en/main_classes/pipelines#transformers.FeatureExtractionPipeline"),d(rr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Be,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ar,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ir,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(lr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(cr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(dr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(pr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(j,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,m){e(document.head,k),f(t,$,m),f(t,T,m),e(T,v),e(v,y),g(p,y,null),e(T,P),e(T,Se),e(Se,Hw),f(t,Ou,m),f(t,kn,m),e(kn,Vw),e(kn,Xi),e(Xi,Ww),e(kn,Zw),f(t,Gu,m),f(t,Ji,m),e(Ji,Bw),f(t,Nu,m),f(t,Pn,m),e(Pn,ud),e(ud,br),e(br,Yw),e(br,el),e(el,Kw),e(br,Xw),e(Pn,Jw),e(Pn,wr),e(wr,gd),e(gd,ev),e(wr,tv),e(wr,E),e(E,_d),e(_d,tl),e(tl,nv),e(E,ov),e(E,bd),e(bd,nl),e(nl,rv),e(E,sv),e(E,wd),e(wd,ol),e(ol,av),e(E,iv),e(E,vd),e(vd,rl),e(rl,lv),e(E,cv),e(E,kd),e(kd,sl),e(sl,dv),e(E,pv),e(E,Pd),e(Pd,al),e(al,mv),e(E,fv),e(E,Td),e(Td,il),e(il,hv),e(E,uv),e(E,yd),e(yd,ll),e(ll,gv),e(E,_v),e(E,xd),e(xd,cl),e(cl,bv),e(E,wv),e(E,$d),e($d,dl),e(dl,vv),e(E,kv),e(E,Ed),e(Ed,pl),e(pl,Pv),e(E,Tv),e(E,qd),e(qd,ml),e(ml,yv),e(E,xv),e(E,Ad),e(Ad,fl),e(fl,$v),e(E,Ev),e(E,jd),e(jd,hl),e(hl,qv),e(E,Av),e(E,Dd),e(Dd,ul),e(ul,jv),e(E,Dv),e(E,Cd),e(Cd,gl),e(gl,Cv),e(E,Iv),e(E,Id),e(Id,_l),e(_l,zv),e(E,Sv),e(E,zd),e(zd,bl),e(bl,Mv),e(E,Fv),e(E,Sd),e(Sd,wl),e(wl,Lv),e(E,Uv),e(E,Md),e(Md,vl),e(vl,Ov),e(E,Gv),e(E,Fd),e(Fd,kl),e(kl,Nv),e(E,Qv),e(E,Ld),e(Ld,Pl),e(Pl,Rv),e(E,Hv),e(E,Ud),e(Ud,Tl),e(Tl,Vv),f(t,Qu,m),f(t,dt,m),e(dt,Tn),e(Tn,Od),g(vr,Od,null),e(dt,Wv),e(dt,Gd),e(Gd,Zv),f(t,Ru,m),f(t,yn,m),e(yn,Bv),e(yn,Nd),e(Nd,Yv),e(yn,Kv),f(t,Hu,m),f(t,yl,m),e(yl,Xv),f(t,Vu,m),g(kr,t,m),f(t,Wu,m),f(t,xn,m),e(xn,Jv),e(xn,Pr),e(Pr,e1),e(xn,t1),f(t,Zu,m),g(Tr,t,m),f(t,Bu,m),f(t,$n,m),e($n,n1),e($n,Qd),e(Qd,o1),e($n,r1),f(t,Yu,m),g(yr,t,m),f(t,Ku,m),f(t,En,m),e(En,s1),e(En,Rd),e(Rd,a1),e(En,i1),f(t,Xu,m),g(xr,t,m),f(t,Ju,m),f(t,xl,m),e(xl,l1),f(t,eg,m),g($r,t,m),f(t,tg,m),f(t,oe,m),g(Er,oe,null),e(oe,c1),e(oe,qr),e(qr,d1),e(qr,$l),e($l,p1),e(qr,m1),e(oe,f1),e(oe,Hd),e(Hd,h1),e(oe,u1),e(oe,pt),e(pt,Ar),e(Ar,g1),e(Ar,El),e(El,_1),e(Ar,b1),e(pt,w1),e(pt,jr),e(jr,v1),e(jr,ql),e(ql,k1),e(jr,P1),e(pt,T1),e(pt,Vd),e(Vd,y1),e(oe,x1),g(qn,oe,null),f(t,ng,m),f(t,mt,m),e(mt,An),e(An,Wd),g(Dr,Wd,null),e(mt,$1),e(mt,Zd),e(Zd,E1),f(t,og,m),f(t,Ne,m),e(Ne,q1),e(Ne,Bd),e(Bd,A1),e(Ne,j1),e(Ne,Yd),e(Yd,D1),e(Ne,C1),f(t,rg,m),g(Cr,t,m),f(t,sg,m),g(jn,t,m),f(t,ag,m),g(Ir,t,m),f(t,ig,m),g(zr,t,m),f(t,lg,m),f(t,Al,m),e(Al,I1),f(t,cg,m),g(Sr,t,m),f(t,dg,m),f(t,Dn,m),e(Dn,z1),e(Dn,Kd),e(Kd,S1),e(Dn,M1),f(t,pg,m),g(Mr,t,m),f(t,mg,m),f(t,jl,m),e(jl,F1),f(t,fg,m),f(t,Dl,m),e(Dl,L1),f(t,hg,m),f(t,ue,m),e(ue,Xd),e(Xd,Jd),e(Jd,ep),e(ep,U1),e(ue,O1),e(ue,tp),e(tp,np),e(np,G1),e(ue,N1),e(ue,op),e(op,rp),e(rp,Q1),e(ue,R1),e(ue,Fr),e(Fr,sp),e(sp,H1),e(Fr,V1),e(Fr,ft),e(ft,ap),e(ap,W1),e(ft,Z1),e(ft,ip),e(ip,B1),e(ft,Y1),e(ft,lp),e(lp,K1),e(ue,X1),e(ue,cp),e(cp,dp),e(dp,J1),f(t,ug,m),f(t,ht,m),e(ht,Cn),e(Cn,pp),g(Lr,pp,null),e(ht,ek),e(ht,mp),e(mp,tk),f(t,gg,m),f(t,Me,m),e(Me,fp),e(fp,nk),e(Me,ok),e(Me,hp),e(hp,rk),e(Me,sk),e(Me,up),e(up,ak),e(Me,ik),f(t,_g,m),f(t,Qe,m),e(Qe,lk),e(Qe,gp),e(gp,ck),e(Qe,dk),e(Qe,_p),e(_p,pk),e(Qe,mk),f(t,bg,m),g(Ur,t,m),f(t,wg,m),f(t,Cl,m),e(Cl,fk),f(t,vg,m),g(Or,t,m),f(t,kg,m),f(t,Il,m),e(Il,hk),f(t,Pg,m),f(t,In,m),e(In,uk),e(In,bp),e(bp,gk),e(In,_k),f(t,Tg,m),f(t,ut,m),e(ut,zn),e(zn,wp),g(Gr,wp,null),e(ut,bk),e(ut,vp),e(vp,wk),f(t,yg,m),f(t,zl,m),e(zl,vk),f(t,xg,m),f(t,Sn,m),e(Sn,kk),e(Sn,kp),e(kp,Pk),e(Sn,Tk),f(t,$g,m),f(t,Sl,m),e(Sl,yk),f(t,Eg,m),f(t,Ml,m),e(Ml,Pp),e(Pp,xk),f(t,qg,m),g(Nr,t,m),f(t,Ag,m),f(t,Fl,m),e(Fl,$k),f(t,jg,m),f(t,gt,m),e(gt,Mn),e(Mn,Tp),g(Qr,Tp,null),e(gt,Ek),e(gt,yp),e(yp,qk),f(t,Dg,m),f(t,Ll,m),e(Ll,Ul),e(Ul,Ak),f(t,Cg,m),f(t,_t,m),e(_t,Fn),e(Fn,xp),g(Rr,xp,null),e(_t,jk),e(_t,$p),e($p,Dk),f(t,Ig,m),f(t,bt,m),e(bt,Ln),e(Ln,Ep),g(Hr,Ep,null),e(bt,Ck),e(bt,qp),e(qp,Ik),f(t,zg,m),f(t,L,m),g(Vr,L,null),e(L,zk),e(L,Wr),e(Wr,Sk),e(Wr,Ap),e(Ap,Mk),e(Wr,Fk),e(L,Lk),g(Un,L,null),e(L,Uk),e(L,jp),e(jp,Ol),e(Ol,Ok),e(L,Gk),e(L,wt),e(wt,Nk),e(wt,Gl),e(Gl,Qk),e(wt,Rk),e(wt,Dp),e(Dp,Hk),e(wt,Vk),e(L,Wk),e(L,Zr),e(Zr,Zk),e(Zr,Br),e(Br,Bk),e(Zr,Yk),e(L,Kk),e(L,On),g(Yr,On,null),e(On,Xk),e(On,Kr),e(Kr,Jk),e(Kr,Nl),e(Nl,eP),e(Kr,tP),f(t,Sg,m),f(t,vt,m),e(vt,Gn),e(Gn,Cp),g(Xr,Cp,null),e(vt,nP),e(vt,Ip),e(Ip,oP),f(t,Mg,m),f(t,Z,m),g(Jr,Z,null),e(Z,rP),e(Z,zp),e(zp,sP),e(Z,aP),e(Z,Sp),e(Sp,iP),e(Z,lP),g(Nn,Z,null),e(Z,cP),e(Z,Mp),e(Mp,Ql),e(Ql,dP),e(Z,pP),e(Z,Qn),g(es,Qn,null),e(Qn,mP),e(Qn,ts),e(ts,fP),e(ts,Rl),e(Rl,hP),e(ts,uP),f(t,Fg,m),f(t,kt,m),e(kt,Rn),e(Rn,Fp),g(ns,Fp,null),e(kt,gP),e(kt,Lp),e(Lp,_P),f(t,Lg,m),f(t,U,m),g(os,U,null),e(U,bP),e(U,Fe),e(Fe,wP),e(Fe,Hl),e(Hl,vP),e(Fe,kP),e(Fe,Vl),e(Vl,PP),e(Fe,TP),e(Fe,Up),e(Up,yP),e(Fe,xP),e(U,$P),g(Hn,U,null),e(U,EP),e(U,Vn),g(rs,Vn,null),e(Vn,qP),e(Vn,ss),e(ss,AP),e(ss,Op),e(Op,jP),e(ss,DP),e(U,CP),e(U,Wn),g(as,Wn,null),e(Wn,IP),e(Wn,Gp),e(Gp,zP),e(U,SP),e(U,Re),g(is,Re,null),e(Re,MP),e(Re,Np),e(Np,FP),e(Re,LP),e(Re,$e),e($e,UP),e($e,Qp),e(Qp,OP),e($e,GP),e($e,Rp),e(Rp,NP),e($e,QP),e($e,Hp),e(Hp,RP),e($e,HP),e($e,Vp),e(Vp,VP),e($e,WP),e(U,ZP),e(U,Zn),g(ls,Zn,null),e(Zn,BP),e(Zn,Le),e(Le,YP),e(Le,Wp),e(Wp,KP),e(Le,XP),e(Le,Zp),e(Zp,JP),e(Le,eT),e(Le,Bp),e(Bp,tT),e(Le,nT),f(t,Ug,m),f(t,O,m),g(cs,O,null),e(O,oT),e(O,Yp),e(Yp,rT),e(O,sT),g(Bn,O,null),e(O,aT),e(O,Kp),e(Kp,Wl),e(Wl,iT),e(O,lT),e(O,Pt),e(Pt,cT),e(Pt,Zl),e(Zl,dT),e(Pt,pT),e(Pt,Xp),e(Xp,mT),e(Pt,fT),e(O,hT),e(O,Ee),e(Ee,uT),e(Ee,Jp),e(Jp,gT),e(Ee,_T),e(Ee,em),e(em,bT),e(Ee,wT),e(Ee,tm),e(tm,vT),e(Ee,kT),e(Ee,ds),e(ds,PT),e(Ee,TT),e(O,yT),e(O,Yn),g(ps,Yn,null),e(Yn,xT),e(Yn,nm),e(nm,$T),f(t,Og,m),f(t,Tt,m),e(Tt,Kn),e(Kn,om),g(ms,om,null),e(Tt,ET),e(Tt,rm),e(rm,qT),f(t,Gg,m),f(t,G,m),g(fs,G,null),e(G,AT),e(G,hs),e(hs,jT),e(hs,sm),e(sm,DT),e(hs,CT),e(G,IT),g(Xn,G,null),e(G,zT),e(G,am),e(am,Bl),e(Bl,ST),e(G,MT),e(G,yt),e(yt,FT),e(yt,Yl),e(Yl,LT),e(yt,UT),e(yt,im),e(im,OT),e(yt,GT),e(G,NT),e(G,us),e(us,QT),e(us,gs),e(gs,RT),e(us,HT),e(G,VT),e(G,Jn),g(_s,Jn,null),e(Jn,WT),e(Jn,lm),e(lm,ZT),f(t,Ng,m),f(t,xt,m),e(xt,eo),e(eo,cm),g(bs,cm,null),e(xt,BT),e(xt,dm),e(dm,YT),f(t,Qg,m),f(t,N,m),g(ws,N,null),e(N,KT),e(N,vs),e(vs,XT),e(vs,pm),e(pm,JT),e(vs,e2),e(N,t2),g(to,N,null),e(N,n2),e(N,mm),e(mm,Kl),e(Kl,o2),e(N,r2),e(N,$t),e($t,s2),e($t,Xl),e(Xl,a2),e($t,i2),e($t,fm),e(fm,l2),e($t,c2),e(N,d2),e(N,ks),e(ks,p2),e(ks,Ps),e(Ps,m2),e(ks,f2),e(N,h2),e(N,Ae),g(Ts,Ae,null),e(Ae,u2),e(Ae,ys),e(ys,g2),e(ys,hm),e(hm,_2),e(ys,b2),e(Ae,w2),e(Ae,um),e(um,v2),e(Ae,k2),e(Ae,Ue),e(Ue,gm),e(gm,_m),e(_m,P2),e(Ue,T2),e(Ue,bm),e(bm,wm),e(wm,y2),e(Ue,x2),e(Ue,vm),e(vm,km),e(km,$2),e(Ue,E2),e(Ue,Pm),e(Pm,Tm),e(Tm,q2),f(t,Rg,m),f(t,Et,m),e(Et,no),e(no,ym),g(xs,ym,null),e(Et,A2),e(Et,xm),e(xm,j2),f(t,Hg,m),f(t,Q,m),g($s,Q,null),e(Q,D2),e(Q,$m),e($m,C2),e(Q,I2),g(oo,Q,null),e(Q,z2),e(Q,Em),e(Em,Jl),e(Jl,S2),e(Q,M2),e(Q,qt),e(qt,F2),e(qt,ec),e(ec,L2),e(qt,U2),e(qt,qm),e(qm,O2),e(qt,G2),e(Q,N2),e(Q,Es),e(Es,Q2),e(Es,qs),e(qs,R2),e(Es,H2),e(Q,V2),e(Q,ro),g(As,ro,null),e(ro,W2),e(ro,Am),e(Am,Z2),f(t,Vg,m),f(t,At,m),e(At,so),e(so,jm),g(js,jm,null),e(At,B2),e(At,Dm),e(Dm,Y2),f(t,Wg,m),f(t,S,m),g(Ds,S,null),e(S,K2),e(S,jt),e(jt,X2),e(jt,Cm),e(Cm,J2),e(jt,ey),e(jt,tc),e(tc,ty),e(jt,ny),e(S,oy),g(ao,S,null),e(S,ry),e(S,Im),e(Im,nc),e(nc,sy),e(S,ay),e(S,Dt),e(Dt,iy),e(Dt,oc),e(oc,ly),e(Dt,cy),e(Dt,zm),e(zm,dy),e(Dt,py),e(S,my),e(S,Cs),e(Cs,fy),e(Cs,Is),e(Is,hy),e(Cs,uy),e(S,gy),g(io,S,null),e(S,_y),e(S,lo),g(zs,lo,null),e(lo,by),e(lo,Sm),e(Sm,wy),f(t,Zg,m),f(t,Ct,m),e(Ct,co),e(co,Mm),g(Ss,Mm,null),e(Ct,vy),e(Ct,Fm),e(Fm,ky),f(t,Bg,m),f(t,re,m),g(Ms,re,null),e(re,Py),e(re,Fs),e(Fs,Ty),e(Fs,Lm),e(Lm,yy),e(Fs,xy),e(re,$y),e(re,It),e(It,Ey),e(It,rc),e(rc,qy),e(It,Ay),e(It,Um),e(Um,jy),e(It,Dy),e(re,Cy),e(re,Ls),e(Ls,Iy),e(Ls,Us),e(Us,zy),e(Ls,Sy),e(re,My),e(re,po),g(Os,po,null),e(po,Fy),e(po,Om),e(Om,Ly),f(t,Yg,m),f(t,zt,m),e(zt,mo),e(mo,Gm),g(Gs,Gm,null),e(zt,Uy),e(zt,Nm),e(Nm,Oy),f(t,Kg,m),f(t,se,m),g(Ns,se,null),e(se,Gy),e(se,Qs),e(Qs,Ny),e(Qs,Qm),e(Qm,Qy),e(Qs,Ry),e(se,Hy),e(se,St),e(St,Vy),e(St,sc),e(sc,Wy),e(St,Zy),e(St,Rm),e(Rm,By),e(St,Yy),e(se,Ky),e(se,Rs),e(Rs,Xy),e(Rs,Hs),e(Hs,Jy),e(Rs,e0),e(se,t0),e(se,fo),g(Vs,fo,null),e(fo,n0),e(fo,Hm),e(Hm,o0),f(t,Xg,m),f(t,Mt,m),e(Mt,ho),e(ho,Vm),g(Ws,Vm,null),e(Mt,r0),e(Mt,Wm),e(Wm,s0),f(t,Jg,m),f(t,ae,m),g(Zs,ae,null),e(ae,a0),e(ae,Bs),e(Bs,i0),e(Bs,Zm),e(Zm,l0),e(Bs,c0),e(ae,d0),e(ae,Bm),e(Bm,p0),e(ae,m0),e(ae,Ys),e(Ys,f0),e(Ys,Ks),e(Ks,h0),e(Ys,u0),e(ae,g0),e(ae,uo),g(Xs,uo,null),e(uo,_0),e(uo,Ym),e(Ym,b0),f(t,e_,m),f(t,Ft,m),e(Ft,go),e(go,Km),g(Js,Km,null),e(Ft,w0),e(Ft,Xm),e(Xm,v0),f(t,t_,m),f(t,M,m),g(ea,M,null),e(M,k0),e(M,Lt),e(Lt,P0),e(Lt,Jm),e(Jm,T0),e(Lt,y0),e(Lt,ac),e(ac,x0),e(Lt,$0),e(M,E0),e(M,Ut),e(Ut,q0),e(Ut,ic),e(ic,A0),e(Ut,j0),e(Ut,ef),e(ef,D0),e(Ut,C0),e(M,I0),e(M,ta),e(ta,z0),e(ta,na),e(na,S0),e(ta,M0),e(M,F0),e(M,He),g(oa,He,null),e(He,L0),e(He,tf),e(tf,U0),e(He,O0),e(He,nf),e(nf,G0),e(M,N0),e(M,_o),g(ra,_o,null),e(_o,Q0),e(_o,of),e(of,R0),e(M,H0),e(M,bo),g(sa,bo,null),e(bo,V0),e(bo,rf),e(rf,W0),e(M,Z0),e(M,wo),g(aa,wo,null),e(wo,B0),e(wo,sf),e(sf,Y0),f(t,n_,m),f(t,vo,m),e(vo,K0),e(vo,lc),e(lc,X0),e(vo,J0),f(t,o_,m),f(t,Ot,m),e(Ot,ko),e(ko,af),g(ia,af,null),e(Ot,ex),e(Ot,lf),e(lf,tx),f(t,r_,m),f(t,ie,m),g(la,ie,null),e(ie,nx),e(ie,ca),e(ca,ox),e(ca,cf),e(cf,rx),e(ca,sx),e(ie,ax),e(ie,Gt),e(Gt,ix),e(Gt,cc),e(cc,lx),e(Gt,cx),e(Gt,df),e(df,dx),e(Gt,px),e(ie,mx),e(ie,da),e(da,fx),e(da,pa),e(pa,hx),e(da,ux),e(ie,gx),e(ie,Po),g(ma,Po,null),e(Po,_x),e(Po,pf),e(pf,bx),f(t,s_,m),f(t,Nt,m),e(Nt,To),e(To,mf),g(fa,mf,null),e(Nt,wx),e(Nt,ff),e(ff,vx),f(t,a_,m),f(t,R,m),g(ha,R,null),e(R,kx),e(R,Qt),e(Qt,Px),e(Qt,hf),e(hf,Tx),e(Qt,yx),e(Qt,dc),e(dc,xx),e(Qt,$x),e(R,Ex),e(R,Rt),e(Rt,qx),e(Rt,pc),e(pc,Ax),e(Rt,jx),e(Rt,uf),e(uf,Dx),e(Rt,Cx),e(R,Ix),e(R,ua),e(ua,zx),e(ua,ga),e(ga,Sx),e(ua,Mx),e(R,Fx),e(R,yo),g(_a,yo,null),e(yo,Lx),e(yo,gf),e(gf,Ux),e(R,Ox),e(R,Ve),g(ba,Ve,null),e(Ve,Gx),e(Ve,Ht),e(Ht,Nx),e(Ht,_f),e(_f,Qx),e(Ht,Rx),e(Ht,bf),e(bf,Hx),e(Ht,Vx),e(Ve,Wx),e(Ve,wf),e(wf,Zx),e(R,Bx),e(R,xo),g(wa,xo,null),e(xo,Yx),e(xo,vf),e(vf,Kx),f(t,i_,m),f(t,Vt,m),e(Vt,$o),e($o,kf),g(va,kf,null),e(Vt,Xx),e(Vt,Pf),e(Pf,Jx),f(t,l_,m),f(t,B,m),g(ka,B,null),e(B,e$),e(B,Tf),e(Tf,t$),e(B,n$),e(B,Wt),e(Wt,o$),e(Wt,mc),e(mc,r$),e(Wt,s$),e(Wt,yf),e(yf,a$),e(Wt,i$),e(B,l$),e(B,F),e(F,c$),e(F,xf),e(xf,d$),e(F,p$),e(F,$f),e($f,m$),e(F,f$),e(F,Ef),e(Ef,h$),e(F,u$),e(F,qf),e(qf,g$),e(F,_$),e(F,Af),e(Af,b$),e(F,w$),e(F,jf),e(jf,v$),e(F,k$),e(F,Pa),e(Pa,P$),e(F,T$),e(F,Ta),e(Ta,y$),e(B,x$),g(Eo,B,null),e(B,$$),e(B,qo),g(ya,qo,null),e(qo,E$),e(qo,Df),e(Df,q$),f(t,c_,m),f(t,Zt,m),e(Zt,Ao),e(Ao,Cf),g(xa,Cf,null),e(Zt,A$),e(Zt,If),e(If,j$),f(t,d_,m),f(t,le,m),g($a,le,null),e(le,D$),e(le,Ea),e(Ea,C$),e(Ea,zf),e(zf,I$),e(Ea,z$),e(le,S$),e(le,Bt),e(Bt,M$),e(Bt,fc),e(fc,F$),e(Bt,L$),e(Bt,Sf),e(Sf,U$),e(Bt,O$),e(le,G$),e(le,qa),e(qa,N$),e(qa,Aa),e(Aa,Q$),e(qa,R$),e(le,H$),e(le,V),g(ja,V,null),e(V,V$),e(V,Mf),e(Mf,W$),e(V,Z$),e(V,Y),e(Y,Ff),e(Ff,Lf),e(Lf,B$),e(Y,Y$),e(Y,Uf),e(Uf,Of),e(Of,K$),e(Y,X$),e(Y,Gf),e(Gf,Nf),e(Nf,J$),e(Y,e4),e(Y,Qf),e(Qf,Rf),e(Rf,t4),e(Y,n4),e(Y,Hf),e(Hf,Vf),e(Vf,o4),e(Y,r4),e(Y,Wf),e(Wf,Zf),e(Zf,s4),e(Y,a4),e(Y,Bf),e(Bf,Yf),e(Yf,i4),e(V,l4),e(V,Da),e(Da,c4),e(Da,Kf),e(Kf,d4),e(Da,p4),e(V,m4),g(jo,V,null),e(V,f4),e(V,Xf),e(Xf,h4),e(V,u4),g(Do,V,null),f(t,p_,m),f(t,Yt,m),e(Yt,Co),e(Co,Jf),g(Ca,Jf,null),e(Yt,g4),e(Yt,eh),e(eh,_4),f(t,m_,m),f(t,K,m),g(Ia,K,null),e(K,b4),e(K,Kt),e(Kt,w4),e(Kt,th),e(th,v4),e(Kt,k4),e(Kt,hc),e(hc,P4),e(Kt,T4),e(K,y4),e(K,Xt),e(Xt,x4),e(Xt,uc),e(uc,$4),e(Xt,E4),e(Xt,nh),e(nh,q4),e(Xt,A4),e(K,j4),e(K,za),e(za,D4),e(za,oh),e(oh,C4),e(za,I4),e(K,z4),e(K,Sa),e(Sa,S4),e(Sa,Ma),e(Ma,M4),e(Sa,F4),e(K,L4),e(K,Io),g(Fa,Io,null),e(Io,U4),e(Io,rh),e(rh,O4),f(t,f_,m),f(t,Jt,m),e(Jt,zo),e(zo,sh),g(La,sh,null),e(Jt,G4),e(Jt,ah),e(ah,N4),f(t,h_,m),f(t,ce,m),g(Ua,ce,null),e(ce,Q4),e(ce,Oa),e(Oa,R4),e(Oa,ih),e(ih,H4),e(Oa,V4),e(ce,W4),e(ce,en),e(en,Z4),e(en,gc),e(gc,B4),e(en,Y4),e(en,lh),e(lh,K4),e(en,X4),e(ce,J4),e(ce,Ga),e(Ga,eE),e(Ga,Na),e(Na,tE),e(Ga,nE),e(ce,oE),e(ce,So),g(Qa,So,null),e(So,rE),e(So,ch),e(ch,sE),f(t,u_,m),f(t,tn,m),e(tn,Mo),e(Mo,dh),g(Ra,dh,null),e(tn,aE),e(tn,ph),e(ph,iE),f(t,g_,m),f(t,H,m),g(Ha,H,null),e(H,lE),e(H,mh),e(mh,cE),e(H,dE),e(H,nn),e(nn,pE),e(nn,_c),e(_c,mE),e(nn,fE),e(nn,fh),e(fh,hE),e(nn,uE),e(H,gE),e(H,Fo),e(Fo,_E),e(Fo,Va),e(Va,bE),e(Fo,wE),e(Fo,Wa),e(Wa,vE),e(H,kE),g(Lo,H,null),e(H,PE),e(H,Uo),g(Za,Uo,null),e(Uo,TE),e(Uo,hh),e(hh,yE),e(H,xE),e(H,Oo),g(Ba,Oo,null),e(Oo,$E),e(Oo,uh),e(uh,EE),f(t,__,m),f(t,on,m),e(on,Go),e(Go,gh),g(Ya,gh,null),e(on,qE),e(on,_h),e(_h,AE),f(t,b_,m),f(t,z,m),g(Ka,z,null),e(z,jE),e(z,rn),e(rn,DE),e(rn,bh),e(bh,CE),e(rn,IE),e(rn,bc),e(bc,zE),e(rn,SE),e(z,ME),e(z,sn),e(sn,FE),e(sn,wc),e(wc,LE),e(sn,UE),e(sn,wh),e(wh,OE),e(sn,GE),e(z,NE),e(z,Xa),e(Xa,QE),e(Xa,Ja),e(Ja,RE),e(Xa,HE),e(z,VE),e(z,No),g(ei,No,null),e(No,WE),e(No,vh),e(vh,ZE),e(z,BE),e(z,We),g(ti,We,null),e(We,YE),e(We,kh),e(kh,KE),e(We,XE),e(We,Ph),e(Ph,JE),e(z,e3),e(z,Qo),g(ni,Qo,null),e(Qo,t3),e(Qo,Th),e(Th,n3),e(z,o3),e(z,Ro),g(oi,Ro,null),e(Ro,r3),e(Ro,yh),e(yh,s3),e(z,a3),e(z,Ho),g(ri,Ho,null),e(Ho,i3),e(Ho,xh),e(xh,l3),f(t,w_,m),f(t,an,m),e(an,Vo),e(Vo,$h),g(si,$h,null),e(an,c3),e(an,Eh),e(Eh,d3),f(t,v_,m),f(t,X,m),g(ai,X,null),e(X,p3),e(X,qh),e(qh,m3),e(X,f3),e(X,ln),e(ln,h3),e(ln,vc),e(vc,u3),e(ln,g3),e(ln,Ah),e(Ah,_3),e(ln,b3),e(X,w3),e(X,Wo),e(Wo,v3),e(Wo,ii),e(ii,k3),e(Wo,P3),e(Wo,li),e(li,T3),e(X,y3),g(Zo,X,null),e(X,x3),e(X,Bo),g(ci,Bo,null),e(Bo,$3),e(Bo,jh),e(jh,E3),f(t,k_,m),f(t,cn,m),e(cn,Yo),e(Yo,Dh),g(di,Dh,null),e(cn,q3),e(cn,Ch),e(Ch,A3),f(t,P_,m),f(t,de,m),g(pi,de,null),e(de,j3),e(de,mi),e(mi,D3),e(mi,Ih),e(Ih,C3),e(mi,I3),e(de,z3),e(de,dn),e(dn,S3),e(dn,kc),e(kc,M3),e(dn,F3),e(dn,zh),e(zh,L3),e(dn,U3),e(de,O3),e(de,fi),e(fi,G3),e(fi,hi),e(hi,N3),e(fi,Q3),e(de,R3),e(de,Ze),g(ui,Ze,null),e(Ze,H3),e(Ze,Sh),e(Sh,V3),e(Ze,W3),e(Ze,Oe),e(Oe,Mh),e(Mh,Fh),e(Fh,Z3),e(Oe,B3),e(Oe,Lh),e(Lh,Uh),e(Uh,Y3),e(Oe,K3),e(Oe,Oh),e(Oh,Gh),e(Gh,X3),e(Oe,J3),e(Oe,Nh),e(Nh,Qh),e(Qh,e5),f(t,T_,m),f(t,pn,m),e(pn,Ko),e(Ko,Rh),g(gi,Rh,null),e(pn,t5),e(pn,Hh),e(Hh,n5),f(t,y_,m),f(t,J,m),g(_i,J,null),e(J,o5),e(J,bi),e(bi,r5),e(bi,Vh),e(Vh,s5),e(bi,a5),e(J,i5),e(J,Ge),e(Ge,l5),e(Ge,Wh),e(Wh,c5),e(Ge,d5),e(Ge,Zh),e(Zh,p5),e(Ge,m5),e(Ge,Bh),e(Bh,f5),e(Ge,h5),e(J,u5),e(J,mn),e(mn,g5),e(mn,Pc),e(Pc,_5),e(mn,b5),e(mn,Yh),e(Yh,w5),e(mn,v5),e(J,k5),e(J,wi),e(wi,P5),e(wi,vi),e(vi,T5),e(wi,y5),e(J,x5),e(J,Xo),g(ki,Xo,null),e(Xo,$5),e(Xo,Pi),e(Pi,E5),e(Pi,Tc),e(Tc,q5),e(Pi,A5),f(t,x_,m),f(t,fn,m),e(fn,Jo),e(Jo,Kh),g(Ti,Kh,null),e(fn,j5),e(fn,Xh),e(Xh,D5),f(t,$_,m),f(t,pe,m),g(yi,pe,null),e(pe,C5),e(pe,hn),e(hn,I5),e(hn,Jh),e(Jh,z5),e(hn,S5),e(hn,eu),e(eu,M5),e(hn,F5),e(pe,L5),e(pe,un),e(un,U5),e(un,yc),e(yc,O5),e(un,G5),e(un,tu),e(tu,N5),e(un,Q5),e(pe,R5),e(pe,xi),e(xi,H5),e(xi,$i),e($i,V5),e(xi,W5),e(pe,Z5),e(pe,er),g(Ei,er,null),e(er,B5),e(er,nu),e(nu,Y5),f(t,E_,m),f(t,gn,m),e(gn,tr),e(tr,ou),g(qi,ou,null),e(gn,K5),e(gn,ru),e(ru,X5),f(t,q_,m),f(t,me,m),g(Ai,me,null),e(me,J5),e(me,_n),e(_n,eq),e(_n,su),e(su,tq),e(_n,nq),e(_n,au),e(au,oq),e(_n,rq),e(me,sq),e(me,bn),e(bn,aq),e(bn,xc),e(xc,iq),e(bn,lq),e(bn,iu),e(iu,cq),e(bn,dq),e(me,pq),e(me,ji),e(ji,mq),e(ji,Di),e(Di,fq),e(ji,hq),e(me,uq),e(me,nr),g(Ci,nr,null),e(nr,gq),e(nr,lu),e(lu,_q),f(t,A_,m),f(t,wn,m),e(wn,or),e(or,cu),g(Ii,cu,null),e(wn,bq),e(wn,$c),e($c,wq),e($c,du),e(du,vq),f(t,j_,m),f(t,j,m),g(zi,j,null),e(j,kq),e(j,pu),e(pu,Pq),e(j,Tq),e(j,mu),e(mu,yq),e(j,xq),e(j,fu),e(fu,$q),e(j,Eq),e(j,hu),e(hu,qq),e(j,Aq),e(j,qe),e(qe,jq),e(qe,Ec),e(Ec,Dq),e(qe,Cq),e(qe,uu),e(uu,Iq),e(qe,zq),e(qe,gu),e(gu,Sq),e(qe,Mq),e(qe,_u),e(_u,Fq),e(qe,Lq),e(j,Uq),e(j,rr),g(Si,rr,null),e(rr,Oq),e(rr,bu),e(bu,Gq),e(j,Nq),e(j,Be),g(Mi,Be,null),e(Be,Qq),e(Be,wu),e(wu,Rq),e(Be,Hq),g(sr,Be,null),e(j,Vq),e(j,ar),g(Fi,ar,null),e(ar,Wq),e(ar,vu),e(vu,Zq),e(j,Bq),e(j,ir),g(Li,ir,null),e(ir,Yq),e(ir,Ui),e(Ui,Kq),e(Ui,ku),e(ku,Xq),e(Ui,Jq),e(j,eA),e(j,lr),g(Oi,lr,null),e(lr,tA),e(lr,Gi),e(Gi,nA),e(Gi,Pu),e(Pu,oA),e(Gi,rA),e(j,sA),e(j,cr),g(Ni,cr,null),e(cr,aA),e(cr,vn),e(vn,iA),e(vn,Tu),e(Tu,lA),e(vn,cA),e(vn,yu),e(yu,dA),e(vn,pA),e(j,mA),e(j,dr),g(Qi,dr,null),e(dr,fA),e(dr,xu),e(xu,hA),e(j,uA),e(j,pr),g(Ri,pr,null),e(pr,gA),e(pr,Hi),e(Hi,_A),e(Hi,$u),e($u,bA),e(Hi,wA),D_=!0},p(t,[m]){const Vi={};m&2&&(Vi.$$scope={dirty:m,ctx:t}),qn.$set(Vi);const Eu={};m&2&&(Eu.$$scope={dirty:m,ctx:t}),jn.$set(Eu);const qu={};m&2&&(qu.$$scope={dirty:m,ctx:t}),Un.$set(qu);const Au={};m&2&&(Au.$$scope={dirty:m,ctx:t}),Nn.$set(Au);const Wi={};m&2&&(Wi.$$scope={dirty:m,ctx:t}),Hn.$set(Wi);const ju={};m&2&&(ju.$$scope={dirty:m,ctx:t}),Bn.$set(ju);const Du={};m&2&&(Du.$$scope={dirty:m,ctx:t}),Xn.$set(Du);const Zi={};m&2&&(Zi.$$scope={dirty:m,ctx:t}),to.$set(Zi);const Cu={};m&2&&(Cu.$$scope={dirty:m,ctx:t}),oo.$set(Cu);const Bi={};m&2&&(Bi.$$scope={dirty:m,ctx:t}),ao.$set(Bi);const Iu={};m&2&&(Iu.$$scope={dirty:m,ctx:t}),io.$set(Iu);const Yi={};m&2&&(Yi.$$scope={dirty:m,ctx:t}),Eo.$set(Yi);const zu={};m&2&&(zu.$$scope={dirty:m,ctx:t}),jo.$set(zu);const q={};m&2&&(q.$$scope={dirty:m,ctx:t}),Do.$set(q);const Su={};m&2&&(Su.$$scope={dirty:m,ctx:t}),Lo.$set(Su);const Mu={};m&2&&(Mu.$$scope={dirty:m,ctx:t}),Zo.$set(Mu);const Fu={};m&2&&(Fu.$$scope={dirty:m,ctx:t}),sr.$set(Fu)},i(t){D_||(_(p.$$.fragment,t),_(vr.$$.fragment,t),_(kr.$$.fragment,t),_(Tr.$$.fragment,t),_(yr.$$.fragment,t),_(xr.$$.fragment,t),_($r.$$.fragment,t),_(Er.$$.fragment,t),_(qn.$$.fragment,t),_(Dr.$$.fragment,t),_(Cr.$$.fragment,t),_(jn.$$.fragment,t),_(Ir.$$.fragment,t),_(zr.$$.fragment,t),_(Sr.$$.fragment,t),_(Mr.$$.fragment,t),_(Lr.$$.fragment,t),_(Ur.$$.fragment,t),_(Or.$$.fragment,t),_(Gr.$$.fragment,t),_(Nr.$$.fragment,t),_(Qr.$$.fragment,t),_(Rr.$$.fragment,t),_(Hr.$$.fragment,t),_(Vr.$$.fragment,t),_(Un.$$.fragment,t),_(Yr.$$.fragment,t),_(Xr.$$.fragment,t),_(Jr.$$.fragment,t),_(Nn.$$.fragment,t),_(es.$$.fragment,t),_(ns.$$.fragment,t),_(os.$$.fragment,t),_(Hn.$$.fragment,t),_(rs.$$.fragment,t),_(as.$$.fragment,t),_(is.$$.fragment,t),_(ls.$$.fragment,t),_(cs.$$.fragment,t),_(Bn.$$.fragment,t),_(ps.$$.fragment,t),_(ms.$$.fragment,t),_(fs.$$.fragment,t),_(Xn.$$.fragment,t),_(_s.$$.fragment,t),_(bs.$$.fragment,t),_(ws.$$.fragment,t),_(to.$$.fragment,t),_(Ts.$$.fragment,t),_(xs.$$.fragment,t),_($s.$$.fragment,t),_(oo.$$.fragment,t),_(As.$$.fragment,t),_(js.$$.fragment,t),_(Ds.$$.fragment,t),_(ao.$$.fragment,t),_(io.$$.fragment,t),_(zs.$$.fragment,t),_(Ss.$$.fragment,t),_(Ms.$$.fragment,t),_(Os.$$.fragment,t),_(Gs.$$.fragment,t),_(Ns.$$.fragment,t),_(Vs.$$.fragment,t),_(Ws.$$.fragment,t),_(Zs.$$.fragment,t),_(Xs.$$.fragment,t),_(Js.$$.fragment,t),_(ea.$$.fragment,t),_(oa.$$.fragment,t),_(ra.$$.fragment,t),_(sa.$$.fragment,t),_(aa.$$.fragment,t),_(ia.$$.fragment,t),_(la.$$.fragment,t),_(ma.$$.fragment,t),_(fa.$$.fragment,t),_(ha.$$.fragment,t),_(_a.$$.fragment,t),_(ba.$$.fragment,t),_(wa.$$.fragment,t),_(va.$$.fragment,t),_(ka.$$.fragment,t),_(Eo.$$.fragment,t),_(ya.$$.fragment,t),_(xa.$$.fragment,t),_($a.$$.fragment,t),_(ja.$$.fragment,t),_(jo.$$.fragment,t),_(Do.$$.fragment,t),_(Ca.$$.fragment,t),_(Ia.$$.fragment,t),_(Fa.$$.fragment,t),_(La.$$.fragment,t),_(Ua.$$.fragment,t),_(Qa.$$.fragment,t),_(Ra.$$.fragment,t),_(Ha.$$.fragment,t),_(Lo.$$.fragment,t),_(Za.$$.fragment,t),_(Ba.$$.fragment,t),_(Ya.$$.fragment,t),_(Ka.$$.fragment,t),_(ei.$$.fragment,t),_(ti.$$.fragment,t),_(ni.$$.fragment,t),_(oi.$$.fragment,t),_(ri.$$.fragment,t),_(si.$$.fragment,t),_(ai.$$.fragment,t),_(Zo.$$.fragment,t),_(ci.$$.fragment,t),_(di.$$.fragment,t),_(pi.$$.fragment,t),_(ui.$$.fragment,t),_(gi.$$.fragment,t),_(_i.$$.fragment,t),_(ki.$$.fragment,t),_(Ti.$$.fragment,t),_(yi.$$.fragment,t),_(Ei.$$.fragment,t),_(qi.$$.fragment,t),_(Ai.$$.fragment,t),_(Ci.$$.fragment,t),_(Ii.$$.fragment,t),_(zi.$$.fragment,t),_(Si.$$.fragment,t),_(Mi.$$.fragment,t),_(sr.$$.fragment,t),_(Fi.$$.fragment,t),_(Li.$$.fragment,t),_(Oi.$$.fragment,t),_(Ni.$$.fragment,t),_(Qi.$$.fragment,t),_(Ri.$$.fragment,t),D_=!0)},o(t){b(p.$$.fragment,t),b(vr.$$.fragment,t),b(kr.$$.fragment,t),b(Tr.$$.fragment,t),b(yr.$$.fragment,t),b(xr.$$.fragment,t),b($r.$$.fragment,t),b(Er.$$.fragment,t),b(qn.$$.fragment,t),b(Dr.$$.fragment,t),b(Cr.$$.fragment,t),b(jn.$$.fragment,t),b(Ir.$$.fragment,t),b(zr.$$.fragment,t),b(Sr.$$.fragment,t),b(Mr.$$.fragment,t),b(Lr.$$.fragment,t),b(Ur.$$.fragment,t),b(Or.$$.fragment,t),b(Gr.$$.fragment,t),b(Nr.$$.fragment,t),b(Qr.$$.fragment,t),b(Rr.$$.fragment,t),b(Hr.$$.fragment,t),b(Vr.$$.fragment,t),b(Un.$$.fragment,t),b(Yr.$$.fragment,t),b(Xr.$$.fragment,t),b(Jr.$$.fragment,t),b(Nn.$$.fragment,t),b(es.$$.fragment,t),b(ns.$$.fragment,t),b(os.$$.fragment,t),b(Hn.$$.fragment,t),b(rs.$$.fragment,t),b(as.$$.fragment,t),b(is.$$.fragment,t),b(ls.$$.fragment,t),b(cs.$$.fragment,t),b(Bn.$$.fragment,t),b(ps.$$.fragment,t),b(ms.$$.fragment,t),b(fs.$$.fragment,t),b(Xn.$$.fragment,t),b(_s.$$.fragment,t),b(bs.$$.fragment,t),b(ws.$$.fragment,t),b(to.$$.fragment,t),b(Ts.$$.fragment,t),b(xs.$$.fragment,t),b($s.$$.fragment,t),b(oo.$$.fragment,t),b(As.$$.fragment,t),b(js.$$.fragment,t),b(Ds.$$.fragment,t),b(ao.$$.fragment,t),b(io.$$.fragment,t),b(zs.$$.fragment,t),b(Ss.$$.fragment,t),b(Ms.$$.fragment,t),b(Os.$$.fragment,t),b(Gs.$$.fragment,t),b(Ns.$$.fragment,t),b(Vs.$$.fragment,t),b(Ws.$$.fragment,t),b(Zs.$$.fragment,t),b(Xs.$$.fragment,t),b(Js.$$.fragment,t),b(ea.$$.fragment,t),b(oa.$$.fragment,t),b(ra.$$.fragment,t),b(sa.$$.fragment,t),b(aa.$$.fragment,t),b(ia.$$.fragment,t),b(la.$$.fragment,t),b(ma.$$.fragment,t),b(fa.$$.fragment,t),b(ha.$$.fragment,t),b(_a.$$.fragment,t),b(ba.$$.fragment,t),b(wa.$$.fragment,t),b(va.$$.fragment,t),b(ka.$$.fragment,t),b(Eo.$$.fragment,t),b(ya.$$.fragment,t),b(xa.$$.fragment,t),b($a.$$.fragment,t),b(ja.$$.fragment,t),b(jo.$$.fragment,t),b(Do.$$.fragment,t),b(Ca.$$.fragment,t),b(Ia.$$.fragment,t),b(Fa.$$.fragment,t),b(La.$$.fragment,t),b(Ua.$$.fragment,t),b(Qa.$$.fragment,t),b(Ra.$$.fragment,t),b(Ha.$$.fragment,t),b(Lo.$$.fragment,t),b(Za.$$.fragment,t),b(Ba.$$.fragment,t),b(Ya.$$.fragment,t),b(Ka.$$.fragment,t),b(ei.$$.fragment,t),b(ti.$$.fragment,t),b(ni.$$.fragment,t),b(oi.$$.fragment,t),b(ri.$$.fragment,t),b(si.$$.fragment,t),b(ai.$$.fragment,t),b(Zo.$$.fragment,t),b(ci.$$.fragment,t),b(di.$$.fragment,t),b(pi.$$.fragment,t),b(ui.$$.fragment,t),b(gi.$$.fragment,t),b(_i.$$.fragment,t),b(ki.$$.fragment,t),b(Ti.$$.fragment,t),b(yi.$$.fragment,t),b(Ei.$$.fragment,t),b(qi.$$.fragment,t),b(Ai.$$.fragment,t),b(Ci.$$.fragment,t),b(Ii.$$.fragment,t),b(zi.$$.fragment,t),b(Si.$$.fragment,t),b(Mi.$$.fragment,t),b(sr.$$.fragment,t),b(Fi.$$.fragment,t),b(Li.$$.fragment,t),b(Oi.$$.fragment,t),b(Ni.$$.fragment,t),b(Qi.$$.fragment,t),b(Ri.$$.fragment,t),D_=!1},d(t){n(k),t&&n($),t&&n(T),w(p),t&&n(Ou),t&&n(kn),t&&n(Gu),t&&n(Ji),t&&n(Nu),t&&n(Pn),t&&n(Qu),t&&n(dt),w(vr),t&&n(Ru),t&&n(yn),t&&n(Hu),t&&n(yl),t&&n(Vu),w(kr,t),t&&n(Wu),t&&n(xn),t&&n(Zu),w(Tr,t),t&&n(Bu),t&&n($n),t&&n(Yu),w(yr,t),t&&n(Ku),t&&n(En),t&&n(Xu),w(xr,t),t&&n(Ju),t&&n(xl),t&&n(eg),w($r,t),t&&n(tg),t&&n(oe),w(Er),w(qn),t&&n(ng),t&&n(mt),w(Dr),t&&n(og),t&&n(Ne),t&&n(rg),w(Cr,t),t&&n(sg),w(jn,t),t&&n(ag),w(Ir,t),t&&n(ig),w(zr,t),t&&n(lg),t&&n(Al),t&&n(cg),w(Sr,t),t&&n(dg),t&&n(Dn),t&&n(pg),w(Mr,t),t&&n(mg),t&&n(jl),t&&n(fg),t&&n(Dl),t&&n(hg),t&&n(ue),t&&n(ug),t&&n(ht),w(Lr),t&&n(gg),t&&n(Me),t&&n(_g),t&&n(Qe),t&&n(bg),w(Ur,t),t&&n(wg),t&&n(Cl),t&&n(vg),w(Or,t),t&&n(kg),t&&n(Il),t&&n(Pg),t&&n(In),t&&n(Tg),t&&n(ut),w(Gr),t&&n(yg),t&&n(zl),t&&n(xg),t&&n(Sn),t&&n($g),t&&n(Sl),t&&n(Eg),t&&n(Ml),t&&n(qg),w(Nr,t),t&&n(Ag),t&&n(Fl),t&&n(jg),t&&n(gt),w(Qr),t&&n(Dg),t&&n(Ll),t&&n(Cg),t&&n(_t),w(Rr),t&&n(Ig),t&&n(bt),w(Hr),t&&n(zg),t&&n(L),w(Vr),w(Un),w(Yr),t&&n(Sg),t&&n(vt),w(Xr),t&&n(Mg),t&&n(Z),w(Jr),w(Nn),w(es),t&&n(Fg),t&&n(kt),w(ns),t&&n(Lg),t&&n(U),w(os),w(Hn),w(rs),w(as),w(is),w(ls),t&&n(Ug),t&&n(O),w(cs),w(Bn),w(ps),t&&n(Og),t&&n(Tt),w(ms),t&&n(Gg),t&&n(G),w(fs),w(Xn),w(_s),t&&n(Ng),t&&n(xt),w(bs),t&&n(Qg),t&&n(N),w(ws),w(to),w(Ts),t&&n(Rg),t&&n(Et),w(xs),t&&n(Hg),t&&n(Q),w($s),w(oo),w(As),t&&n(Vg),t&&n(At),w(js),t&&n(Wg),t&&n(S),w(Ds),w(ao),w(io),w(zs),t&&n(Zg),t&&n(Ct),w(Ss),t&&n(Bg),t&&n(re),w(Ms),w(Os),t&&n(Yg),t&&n(zt),w(Gs),t&&n(Kg),t&&n(se),w(Ns),w(Vs),t&&n(Xg),t&&n(Mt),w(Ws),t&&n(Jg),t&&n(ae),w(Zs),w(Xs),t&&n(e_),t&&n(Ft),w(Js),t&&n(t_),t&&n(M),w(ea),w(oa),w(ra),w(sa),w(aa),t&&n(n_),t&&n(vo),t&&n(o_),t&&n(Ot),w(ia),t&&n(r_),t&&n(ie),w(la),w(ma),t&&n(s_),t&&n(Nt),w(fa),t&&n(a_),t&&n(R),w(ha),w(_a),w(ba),w(wa),t&&n(i_),t&&n(Vt),w(va),t&&n(l_),t&&n(B),w(ka),w(Eo),w(ya),t&&n(c_),t&&n(Zt),w(xa),t&&n(d_),t&&n(le),w($a),w(ja),w(jo),w(Do),t&&n(p_),t&&n(Yt),w(Ca),t&&n(m_),t&&n(K),w(Ia),w(Fa),t&&n(f_),t&&n(Jt),w(La),t&&n(h_),t&&n(ce),w(Ua),w(Qa),t&&n(u_),t&&n(tn),w(Ra),t&&n(g_),t&&n(H),w(Ha),w(Lo),w(Za),w(Ba),t&&n(__),t&&n(on),w(Ya),t&&n(b_),t&&n(z),w(Ka),w(ei),w(ti),w(ni),w(oi),w(ri),t&&n(w_),t&&n(an),w(si),t&&n(v_),t&&n(X),w(ai),w(Zo),w(ci),t&&n(k_),t&&n(cn),w(di),t&&n(P_),t&&n(de),w(pi),w(ui),t&&n(T_),t&&n(pn),w(gi),t&&n(y_),t&&n(J),w(_i),w(ki),t&&n(x_),t&&n(fn),w(Ti),t&&n($_),t&&n(pe),w(yi),w(Ei),t&&n(E_),t&&n(gn),w(qi),t&&n(q_),t&&n(me),w(Ai),w(Ci),t&&n(A_),t&&n(wn),w(Ii),t&&n(j_),t&&n(j),w(zi),w(Si),w(Mi),w(sr),w(Fi),w(Li),w(Oi),w(Ni),w(Qi),w(Ri)}}}const Ez={local:"pipelines",sections:[{local:"transformers.pipeline",title:"The pipeline abstraction"},{local:"pipeline-batching",title:"Pipeline batching"},{local:"pipeline-chunk-batching",title:"Pipeline chunk batching"},{local:"pipeline-custom-code",title:"Pipeline custom code"},{local:"implementing-a-pipeline",title:"Implementing a pipeline"},{local:"the-task-specific-pipelines",sections:[{local:"transformers.AudioClassificationPipeline",title:"AudioClassificationPipeline"},{local:"transformers.AutomaticSpeechRecognitionPipeline",title:"AutomaticSpeechRecognitionPipeline"},{local:"transformers.Conversation",title:"ConversationalPipeline"},{local:"transformers.DepthEstimationPipeline",title:"DepthEstimationPipeline"},{local:"transformers.DocumentQuestionAnsweringPipeline",title:"DocumentQuestionAnsweringPipeline"},{local:"transformers.FeatureExtractionPipeline",title:"FeatureExtractionPipeline"},{local:"transformers.FillMaskPipeline",title:"FillMaskPipeline"},{local:"transformers.ImageClassificationPipeline",title:"ImageClassificationPipeline"},{local:"transformers.ImageSegmentationPipeline",title:"ImageSegmentationPipeline"},{local:"transformers.ImageToTextPipeline",title:"ImageToTextPipeline"},{local:"transformers.TokenClassificationPipeline",title:"NerPipeline"},{local:"transformers.ObjectDetectionPipeline",title:"ObjectDetectionPipeline"},{local:"transformers.QuestionAnsweringPipeline",title:"QuestionAnsweringPipeline"},{local:"transformers.SummarizationPipeline",title:"SummarizationPipeline"},{local:"transformers.TableQuestionAnsweringPipeline",title:"TableQuestionAnsweringPipeline"},{local:"transformers.TextClassificationPipeline",title:"TextClassificationPipeline"},{local:"transformers.TextGenerationPipeline",title:"TextGenerationPipeline"},{local:"transformers.Text2TextGenerationPipeline",title:"Text2TextGenerationPipeline"},{local:"transformers.TokenClassificationPipeline",title:"TokenClassificationPipeline"},{local:"transformers.TranslationPipeline",title:"TranslationPipeline"},{local:"transformers.VisualQuestionAnsweringPipeline",title:"VisualQuestionAnsweringPipeline"},{local:"transformers.ZeroShotClassificationPipeline",title:"ZeroShotClassificationPipeline"},{local:"transformers.ZeroShotImageClassificationPipeline",title:"ZeroShotImageClassificationPipeline"},{local:"transformers.ZeroShotObjectDetectionPipeline",title:"ZeroShotObjectDetectionPipeline"}],title:"The task specific pipelines"},{local:"transformers.Pipeline",title:"Parent class: `Pipeline`"}],title:"Pipelines"};function qz(A){return lz(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Sz extends rz{constructor(k){super();sz(this,k,qz,$z,az,{})}}export{Sz as default,Ez as metadata};
