import{S as Ot,i as Ht,s as Rt,e as r,k as c,w as Q,t as l,M as Dt,c as n,d as t,m as d,a,x as V,h as f,b as s,G as o,g as p,y as W,q as Y,o as Z,B as ee,v as Kt}from"../chunks/vendor-hf-doc-builder.js";import{T as Qt}from"../chunks/Tip-hf-doc-builder.js";import{I as ue}from"../chunks/IconCopyLink-hf-doc-builder.js";function Vt(_e){let m,E,_,u,y;return{c(){m=r("p"),E=l("for PyTorch >= 1.14.0. JIT-mode could benefit any models for prediction and evaluaion since dict input is supported in jit.trace"),_=c(),u=r("p"),y=l(`for PyTorch < 1.14.0. JIT-mode could benefit models whose forward parameter order matches the tuple input order in jit.trace, like question-answering model
In the case where the forward parameter order does not match the tuple input order in jit.trace, like text-classification models, jit.trace will fail and we are capturing this with the exception here to make it fallback. Logging is used to notify users.`)},l(h){m=n(h,"P",{});var v=a(m);E=f(v,"for PyTorch >= 1.14.0. JIT-mode could benefit any models for prediction and evaluaion since dict input is supported in jit.trace"),v.forEach(t),_=d(h),u=n(h,"P",{});var $=a(u);y=f($,`for PyTorch < 1.14.0. JIT-mode could benefit models whose forward parameter order matches the tuple input order in jit.trace, like question-answering model
In the case where the forward parameter order does not match the tuple input order in jit.trace, like text-classification models, jit.trace will fail and we are capturing this with the exception here to make it fallback. Logging is used to notify users.`),$.forEach(t)},m(h,v){p(h,m,v),o(m,E),p(h,_,v),p(h,u,v),o(u,y)},d(h){h&&t(m),h&&t(_),h&&t(u)}}}function Wt(_e){let m,E,_,u,y,h,v,$,Xe,ve,D,Ge,ye,w,b,te,L,Me,oe,Be,we,I,Fe,J,Oe,He,Pe,P,x,re,N,Re,ne,De,Te,k,Ke,U,Qe,Ve,ge,T,j,ae,X,We,ie,Ye,Ee,q,Ze,G,et,tt,$e,g,A,se,M,ot,le,rt,be,S,Ie,B,nt,F,at,xe,z,O,fe,it,st,K,lt,pe,ft,pt,H,he,ht,ct,C,dt,ce,mt,ut,de,_t,ke;return h=new ue({}),L=new ue({}),N=new ue({}),X=new ue({}),M=new ue({}),S=new Qt({props:{warning:!0,$$slots:{default:[Vt]},$$scope:{ctx:_e}}}),{c(){m=r("meta"),E=c(),_=r("h1"),u=r("a"),y=r("span"),Q(h.$$.fragment),v=c(),$=r("span"),Xe=l("Efficient Inference on CPU"),ve=c(),D=r("p"),Ge=l("This guide focuses on inferencing large models efficiently on CPU."),ye=c(),w=r("h2"),b=r("a"),te=r("span"),Q(L.$$.fragment),Me=c(),oe=r("span"),Be=l("PyTorch JIT-mode (TorchScript)"),we=l(`

TorchScript is a way to create serializable and optimizable models from PyTorch code. Any TorchScript program can be saved from a Python process and loaded in a process where there is no Python dependency.
Comparing to default eager mode, jit mode in PyTorch normally yields better performance for model inference from optimization methodologies like operator fusion.
`),I=r("p"),Fe=l("For a gentle introduction to TorchScript, see the Introduction to "),J=r("a"),Oe=l("PyTorch TorchScript tutorial"),He=l("."),Pe=c(),P=r("h3"),x=r("a"),re=r("span"),Q(N.$$.fragment),Re=c(),ne=r("span"),De=l("IPEX Graph Optimization with JIT-mode"),Te=l(`

Intel\xAE Extension for PyTorch provides further optimizations in jit mode for Transformers series models. It is highly recommended for users to take advantage of Intel\xAE Extension for PyTorch with jit mode. Some frequently used operator patterns from Transformers models are already supported in Intel\xAE Extension for PyTorch with jit mode fusions. Those fusion patterns like Multi-head-attention fusion, Concat Linear, Linear+Add, Linear+Gelu, Add+LayerNorm fusion and etc. are enabled and perform well. The benefit of the fusion is delivered to users in a transparent fashion. According to the analysis, ~70% of most popular NLP tasks in question-answering, text-classification, and token-classification can get performance benefits with these fusion patterns for both Float32 precision and BFloat16 Mixed precision.
`),k=r("p"),Ke=l("Check more detailed information for "),U=r("a"),Qe=l("IPEX Graph Optimization"),Ve=l("."),ge=c(),T=r("h4"),j=r("a"),ae=r("span"),Q(X.$$.fragment),We=c(),ie=r("span"),Ye=l("IPEX installation:"),Ee=c(),q=r("p"),Ze=l("IPEX release is following PyTorch, check the approaches for "),G=r("a"),et=l("IPEX installation"),tt=l("."),$e=c(),g=r("h3"),A=r("a"),se=r("span"),Q(M.$$.fragment),ot=c(),le=r("span"),rt=l("Usage of JIT-mode"),be=l(`

To enable JIT-mode in Trainer for evaluaion or prediction, users should add \`jit_mode_eval\` in Trainer command arguments.
`),Q(S.$$.fragment),Ie=c(),B=r("p"),nt=l("Take an example of the use cases on "),F=r("a"),at=l("Transformers question-answering"),xe=c(),z=r("ul"),O=r("li"),fe=r("p"),it=l("Inference using jit mode on CPU:"),st=c(),K=r("pre"),lt=l(`python run_qa.py \\
--model_name_or_path csarron/bert-base-uncased-squad-v1 \\
--dataset_name squad \\
--do_eval \\
--max_seq_length 384 \\
--doc_stride 128 \\
--output_dir /tmp/ \\
--no_cuda \\
`),pe=r("b"),ft=l("--jit_mode_eval "),pt=c(),H=r("li"),he=r("p"),ht=l("Inference with IPEX using jit mode on CPU:"),ct=c(),C=r("pre"),dt=l(`python run_qa.py \\
--model_name_or_path csarron/bert-base-uncased-squad-v1 \\
--dataset_name squad \\
--do_eval \\
--max_seq_length 384 \\
--doc_stride 128 \\
--output_dir /tmp/ \\
--no_cuda \\
`),ce=r("b"),mt=l("--use_ipex \\"),ut=l(`
`),de=r("b"),_t=l("--jit_mode_eval"),this.h()},l(e){const i=Dt('[data-svelte="svelte-1phssyn"]',document.head);m=n(i,"META",{name:!0,content:!0}),i.forEach(t),E=d(e),_=n(e,"H1",{class:!0});var R=a(_);u=n(R,"A",{id:!0,class:!0,href:!0});var wt=a(u);y=n(wt,"SPAN",{});var Pt=a(y);V(h.$$.fragment,Pt),Pt.forEach(t),wt.forEach(t),v=d(R),$=n(R,"SPAN",{});var Tt=a($);Xe=f(Tt,"Efficient Inference on CPU"),Tt.forEach(t),R.forEach(t),ve=d(e),D=n(e,"P",{});var gt=a(D);Ge=f(gt,"This guide focuses on inferencing large models efficiently on CPU."),gt.forEach(t),ye=d(e),w=n(e,"H2",{class:!0});var je=a(w);b=n(je,"A",{id:!0,class:!0,href:!0});var Et=a(b);te=n(Et,"SPAN",{});var $t=a(te);V(L.$$.fragment,$t),$t.forEach(t),Et.forEach(t),Me=d(je),oe=n(je,"SPAN",{});var bt=a(oe);Be=f(bt,"PyTorch JIT-mode (TorchScript)"),bt.forEach(t),je.forEach(t),we=f(e,`

TorchScript is a way to create serializable and optimizable models from PyTorch code. Any TorchScript program can be saved from a Python process and loaded in a process where there is no Python dependency.
Comparing to default eager mode, jit mode in PyTorch normally yields better performance for model inference from optimization methodologies like operator fusion.
`),I=n(e,"P",{});var qe=a(I);Fe=f(qe,"For a gentle introduction to TorchScript, see the Introduction to "),J=n(qe,"A",{href:!0,rel:!0});var It=a(J);Oe=f(It,"PyTorch TorchScript tutorial"),It.forEach(t),He=f(qe,"."),qe.forEach(t),Pe=d(e),P=n(e,"H3",{class:!0});var Ae=a(P);x=n(Ae,"A",{id:!0,class:!0,href:!0});var xt=a(x);re=n(xt,"SPAN",{});var kt=a(re);V(N.$$.fragment,kt),kt.forEach(t),xt.forEach(t),Re=d(Ae),ne=n(Ae,"SPAN",{});var jt=a(ne);De=f(jt,"IPEX Graph Optimization with JIT-mode"),jt.forEach(t),Ae.forEach(t),Te=f(e,`

Intel\xAE Extension for PyTorch provides further optimizations in jit mode for Transformers series models. It is highly recommended for users to take advantage of Intel\xAE Extension for PyTorch with jit mode. Some frequently used operator patterns from Transformers models are already supported in Intel\xAE Extension for PyTorch with jit mode fusions. Those fusion patterns like Multi-head-attention fusion, Concat Linear, Linear+Add, Linear+Gelu, Add+LayerNorm fusion and etc. are enabled and perform well. The benefit of the fusion is delivered to users in a transparent fashion. According to the analysis, ~70% of most popular NLP tasks in question-answering, text-classification, and token-classification can get performance benefits with these fusion patterns for both Float32 precision and BFloat16 Mixed precision.
`),k=n(e,"P",{});var Se=a(k);Ke=f(Se,"Check more detailed information for "),U=n(Se,"A",{href:!0,rel:!0});var qt=a(U);Qe=f(qt,"IPEX Graph Optimization"),qt.forEach(t),Ve=f(Se,"."),Se.forEach(t),ge=d(e),T=n(e,"H4",{class:!0});var ze=a(T);j=n(ze,"A",{id:!0,class:!0,href:!0});var At=a(j);ae=n(At,"SPAN",{});var St=a(ae);V(X.$$.fragment,St),St.forEach(t),At.forEach(t),We=d(ze),ie=n(ze,"SPAN",{});var zt=a(ie);Ye=f(zt,"IPEX installation:"),zt.forEach(t),ze.forEach(t),Ee=d(e),q=n(e,"P",{});var Ce=a(q);Ze=f(Ce,"IPEX release is following PyTorch, check the approaches for "),G=n(Ce,"A",{href:!0,rel:!0});var Ct=a(G);et=f(Ct,"IPEX installation"),Ct.forEach(t),tt=f(Ce,"."),Ce.forEach(t),$e=d(e),g=n(e,"H3",{class:!0});var Le=a(g);A=n(Le,"A",{id:!0,class:!0,href:!0});var Lt=a(A);se=n(Lt,"SPAN",{});var Jt=a(se);V(M.$$.fragment,Jt),Jt.forEach(t),Lt.forEach(t),ot=d(Le),le=n(Le,"SPAN",{});var Nt=a(le);rt=f(Nt,"Usage of JIT-mode"),Nt.forEach(t),Le.forEach(t),be=f(e,`

To enable JIT-mode in Trainer for evaluaion or prediction, users should add \`jit_mode_eval\` in Trainer command arguments.
`),V(S.$$.fragment,e),Ie=d(e),B=n(e,"P",{});var vt=a(B);nt=f(vt,"Take an example of the use cases on "),F=n(vt,"A",{href:!0,rel:!0});var Ut=a(F);at=f(Ut,"Transformers question-answering"),Ut.forEach(t),vt.forEach(t),xe=d(e),z=n(e,"UL",{});var Je=a(z);O=n(Je,"LI",{});var Ne=a(O);fe=n(Ne,"P",{});var Xt=a(fe);it=f(Xt,"Inference using jit mode on CPU:"),Xt.forEach(t),st=d(Ne),K=n(Ne,"PRE",{});var yt=a(K);lt=f(yt,`python run_qa.py \\
--model_name_or_path csarron/bert-base-uncased-squad-v1 \\
--dataset_name squad \\
--do_eval \\
--max_seq_length 384 \\
--doc_stride 128 \\
--output_dir /tmp/ \\
--no_cuda \\
`),pe=n(yt,"B",{});var Gt=a(pe);ft=f(Gt,"--jit_mode_eval "),Gt.forEach(t),yt.forEach(t),Ne.forEach(t),pt=d(Je),H=n(Je,"LI",{});var Ue=a(H);he=n(Ue,"P",{});var Mt=a(he);ht=f(Mt,"Inference with IPEX using jit mode on CPU:"),Mt.forEach(t),ct=d(Ue),C=n(Ue,"PRE",{});var me=a(C);dt=f(me,`python run_qa.py \\
--model_name_or_path csarron/bert-base-uncased-squad-v1 \\
--dataset_name squad \\
--do_eval \\
--max_seq_length 384 \\
--doc_stride 128 \\
--output_dir /tmp/ \\
--no_cuda \\
`),ce=n(me,"B",{});var Bt=a(ce);mt=f(Bt,"--use_ipex \\"),Bt.forEach(t),ut=f(me,`
`),de=n(me,"B",{});var Ft=a(de);_t=f(Ft,"--jit_mode_eval"),Ft.forEach(t),me.forEach(t),Ue.forEach(t),Je.forEach(t),this.h()},h(){s(m,"name","hf:doc:metadata"),s(m,"content",JSON.stringify(Yt)),s(u,"id","efficient-inference-on-cpu"),s(u,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),s(u,"href","#efficient-inference-on-cpu"),s(_,"class","relative group"),s(b,"id","pytorch-jitmode-torchscript"),s(b,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),s(b,"href","#pytorch-jitmode-torchscript"),s(w,"class","relative group"),s(J,"href","https://pytorch.org/tutorials/beginner/Intro_to_TorchScript_tutorial.html#tracing-modules"),s(J,"rel","nofollow"),s(x,"id","ipex-graph-optimization-with-jitmode"),s(x,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),s(x,"href","#ipex-graph-optimization-with-jitmode"),s(P,"class","relative group"),s(U,"href","https://intel.github.io/intel-extension-for-pytorch/cpu/latest/tutorials/features/graph_optimization.html"),s(U,"rel","nofollow"),s(j,"id","ipex-installation"),s(j,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),s(j,"href","#ipex-installation"),s(T,"class","relative group"),s(G,"href","https://intel.github.io/intel-extension-for-pytorch/"),s(G,"rel","nofollow"),s(A,"id","usage-of-jitmode"),s(A,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),s(A,"href","#usage-of-jitmode"),s(g,"class","relative group"),s(F,"href","https://github.com/huggingface/transformers/tree/main/examples/pytorch/question-answering"),s(F,"rel","nofollow")},m(e,i){o(document.head,m),p(e,E,i),p(e,_,i),o(_,u),o(u,y),W(h,y,null),o(_,v),o(_,$),o($,Xe),p(e,ve,i),p(e,D,i),o(D,Ge),p(e,ye,i),p(e,w,i),o(w,b),o(b,te),W(L,te,null),o(w,Me),o(w,oe),o(oe,Be),p(e,we,i),p(e,I,i),o(I,Fe),o(I,J),o(J,Oe),o(I,He),p(e,Pe,i),p(e,P,i),o(P,x),o(x,re),W(N,re,null),o(P,Re),o(P,ne),o(ne,De),p(e,Te,i),p(e,k,i),o(k,Ke),o(k,U),o(U,Qe),o(k,Ve),p(e,ge,i),p(e,T,i),o(T,j),o(j,ae),W(X,ae,null),o(T,We),o(T,ie),o(ie,Ye),p(e,Ee,i),p(e,q,i),o(q,Ze),o(q,G),o(G,et),o(q,tt),p(e,$e,i),p(e,g,i),o(g,A),o(A,se),W(M,se,null),o(g,ot),o(g,le),o(le,rt),p(e,be,i),W(S,e,i),p(e,Ie,i),p(e,B,i),o(B,nt),o(B,F),o(F,at),p(e,xe,i),p(e,z,i),o(z,O),o(O,fe),o(fe,it),o(O,st),o(O,K),o(K,lt),o(K,pe),o(pe,ft),o(z,pt),o(z,H),o(H,he),o(he,ht),o(H,ct),o(H,C),o(C,dt),o(C,ce),o(ce,mt),o(C,ut),o(C,de),o(de,_t),ke=!0},p(e,[i]){const R={};i&2&&(R.$$scope={dirty:i,ctx:e}),S.$set(R)},i(e){ke||(Y(h.$$.fragment,e),Y(L.$$.fragment,e),Y(N.$$.fragment,e),Y(X.$$.fragment,e),Y(M.$$.fragment,e),Y(S.$$.fragment,e),ke=!0)},o(e){Z(h.$$.fragment,e),Z(L.$$.fragment,e),Z(N.$$.fragment,e),Z(X.$$.fragment,e),Z(M.$$.fragment,e),Z(S.$$.fragment,e),ke=!1},d(e){t(m),e&&t(E),e&&t(_),ee(h),e&&t(ve),e&&t(D),e&&t(ye),e&&t(w),ee(L),e&&t(we),e&&t(I),e&&t(Pe),e&&t(P),ee(N),e&&t(Te),e&&t(k),e&&t(ge),e&&t(T),ee(X),e&&t(Ee),e&&t(q),e&&t($e),e&&t(g),ee(M),e&&t(be),ee(S,e),e&&t(Ie),e&&t(B),e&&t(xe),e&&t(z)}}}const Yt={local:"efficient-inference-on-cpu",sections:[{local:"pytorch-jitmode-torchscript",sections:[{local:"ipex-graph-optimization-with-jitmode",sections:[{local:"ipex-installation",title:"IPEX installation:"}],title:"IPEX Graph Optimization with JIT-mode"},{local:"usage-of-jitmode",title:"Usage of JIT-mode"}],title:"PyTorch JIT-mode (TorchScript)"}],title:"Efficient Inference on CPU"};function Zt(_e){return Kt(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class ro extends Ot{constructor(m){super();Ht(this,m,Zt,Wt,Rt,{})}}export{ro as default,Yt as metadata};
