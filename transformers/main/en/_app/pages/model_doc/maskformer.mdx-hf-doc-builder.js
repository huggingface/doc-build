import{S as il,i as cl,s as dl,e as r,k as l,w as F,t as s,M as ll,c as n,d as o,m,a as i,x as v,h as a,b as c,N as ml,G as e,g as f,y as w,q as x,o as y,B as M,v as pl,L as Ta}from"../../chunks/vendor-hf-doc-builder.js";import{T as ya}from"../../chunks/Tip-hf-doc-builder.js";import{D as A}from"../../chunks/Docstring-hf-doc-builder.js";import{C as $a}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as Re}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{E as Ma}from"../../chunks/ExampleCodeBlock-hf-doc-builder.js";import{P as hl}from"../../chunks/PipelineTag-hf-doc-builder.js";function fl(P){let p,b,u,g,k;return{c(){p=r("p"),b=s(`This is a recently introduced model so the API hasn\u2019t been tested extensively. There may be some bugs or slight
breaking changes to fix it in the future. If you see something strange, file a `),u=r("a"),g=s("Github Issue"),k=s("."),this.h()},l(d){p=n(d,"P",{});var _=i(p);b=a(_,`This is a recently introduced model so the API hasn\u2019t been tested extensively. There may be some bugs or slight
breaking changes to fix it in the future. If you see something strange, file a `),u=n(_,"A",{href:!0,rel:!0});var C=i(u);g=a(C,"Github Issue"),C.forEach(o),k=a(_,"."),_.forEach(o),this.h()},h(){c(u,"href","https://github.com/huggingface/transformers/issues/new?assignees=&labels=&template=bug-report.md&title"),c(u,"rel","nofollow")},m(d,_){f(d,p,_),e(p,b),e(p,u),e(u,g),e(p,k)},d(d){d&&o(p)}}}function gl(P){let p,b,u,g,k;return g=new $a({props:{code:`from transformers import MaskFormerConfig, MaskFormerModel

# Initializing a MaskFormer facebook/maskformer-swin-base-ade configuration
configuration = MaskFormerConfig()

# Initializing a model (with random weights) from the facebook/maskformer-swin-base-ade style configuration
model = MaskFormerModel(configuration)

# Accessing the model configuration
configuration = model.config`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> MaskFormerConfig, MaskFormerModel

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a MaskFormer facebook/maskformer-swin-base-ade configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = MaskFormerConfig()

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a model (with random weights) from the facebook/maskformer-swin-base-ade style configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = MaskFormerModel(configuration)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Accessing the model configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = model.config`}}),{c(){p=r("p"),b=s("Examples:"),u=l(),F(g.$$.fragment)},l(d){p=n(d,"P",{});var _=i(p);b=a(_,"Examples:"),_.forEach(o),u=m(d),v(g.$$.fragment,d)},m(d,_){f(d,p,_),e(p,b),f(d,u,_),w(g,d,_),k=!0},p:Ta,i(d){k||(x(g.$$.fragment,d),k=!0)},o(d){y(g.$$.fragment,d),k=!1},d(d){d&&o(p),d&&o(u),M(g,d)}}}function ul(P){let p,b;return{c(){p=r("p"),b=s(`NumPy arrays and PyTorch tensors are converted to PIL images when resizing, so the most efficient is to pass
PIL images.`)},l(u){p=n(u,"P",{});var g=i(p);b=a(g,`NumPy arrays and PyTorch tensors are converted to PIL images when resizing, so the most efficient is to pass
PIL images.`),g.forEach(o)},m(u,g){f(u,p,g),e(p,b)},d(u){u&&o(p)}}}function _l(P){let p,b,u,g,k;return{c(){p=r("p"),b=s("Although the recipe for forward pass needs to be defined within this function, one should call the "),u=r("code"),g=s("Module"),k=s(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(d){p=n(d,"P",{});var _=i(p);b=a(_,"Although the recipe for forward pass needs to be defined within this function, one should call the "),u=n(_,"CODE",{});var C=i(u);g=a(C,"Module"),C.forEach(o),k=a(_,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),_.forEach(o)},m(d,_){f(d,p,_),e(p,b),e(p,u),e(u,g),e(p,k)},d(d){d&&o(p)}}}function kl(P){let p,b,u,g,k;return g=new $a({props:{code:`from transformers import MaskFormerFeatureExtractor, MaskFormerModel
from PIL import Image
import requests

# load MaskFormer fine-tuned on ADE20k semantic segmentation
feature_extractor = MaskFormerFeatureExtractor.from_pretrained("facebook/maskformer-swin-base-ade")
model = MaskFormerModel.from_pretrained("facebook/maskformer-swin-base-ade")

url = "http://images.cocodataset.org/val2017/000000039769.jpg"
image = Image.open(requests.get(url, stream=True).raw)

inputs = feature_extractor(image, return_tensors="pt")

# forward pass
outputs = model(**inputs)

# the decoder of MaskFormer outputs hidden states of shape (batch_size, num_queries, hidden_size)
transformer_decoder_last_hidden_state = outputs.transformer_decoder_last_hidden_state
list(transformer_decoder_last_hidden_state.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> MaskFormerFeatureExtractor, MaskFormerModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> requests

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># load MaskFormer fine-tuned on ADE20k semantic segmentation</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>feature_extractor = MaskFormerFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;facebook/maskformer-swin-base-ade&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = MaskFormerModel.from_pretrained(<span class="hljs-string">&quot;facebook/maskformer-swin-base-ade&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>url = <span class="hljs-string">&quot;http://images.cocodataset.org/val2017/000000039769.jpg&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>image = Image.<span class="hljs-built_in">open</span>(requests.get(url, stream=<span class="hljs-literal">True</span>).raw)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = feature_extractor(image, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># forward pass</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># the decoder of MaskFormer outputs hidden states of shape (batch_size, num_queries, hidden_size)</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>transformer_decoder_last_hidden_state = outputs.transformer_decoder_last_hidden_state
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(transformer_decoder_last_hidden_state.shape)
[<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">256</span>]`}}),{c(){p=r("p"),b=s("Examples:"),u=l(),F(g.$$.fragment)},l(d){p=n(d,"P",{});var _=i(p);b=a(_,"Examples:"),_.forEach(o),u=m(d),v(g.$$.fragment,d)},m(d,_){f(d,p,_),e(p,b),f(d,u,_),w(g,d,_),k=!0},p:Ta,i(d){k||(x(g.$$.fragment,d),k=!0)},o(d){y(g.$$.fragment,d),k=!1},d(d){d&&o(p),d&&o(u),M(g,d)}}}function bl(P){let p,b,u,g,k;return{c(){p=r("p"),b=s("Although the recipe for forward pass needs to be defined within this function, one should call the "),u=r("code"),g=s("Module"),k=s(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(d){p=n(d,"P",{});var _=i(p);b=a(_,"Although the recipe for forward pass needs to be defined within this function, one should call the "),u=n(_,"CODE",{});var C=i(u);g=a(C,"Module"),C.forEach(o),k=a(_,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),_.forEach(o)},m(d,_){f(d,p,_),e(p,b),e(p,u),e(u,g),e(p,k)},d(d){d&&o(p)}}}function Fl(P){let p,b,u,g,k;return g=new $a({props:{code:`from transformers import MaskFormerFeatureExtractor, MaskFormerForInstanceSegmentation
from PIL import Image
import requests

# load MaskFormer fine-tuned on ADE20k semantic segmentation
feature_extractor = MaskFormerFeatureExtractor.from_pretrained("facebook/maskformer-swin-base-ade")
model = MaskFormerForInstanceSegmentation.from_pretrained("facebook/maskformer-swin-base-ade")

url = (
    "https://huggingface.co/datasets/hf-internal-testing/fixtures_ade20k/resolve/main/ADE_val_00000001.jpg"
)
image = Image.open(requests.get(url, stream=True).raw)
inputs = feature_extractor(images=image, return_tensors="pt")

outputs = model(**inputs)
# model predicts class_queries_logits of shape \`(batch_size, num_queries)\`
# and masks_queries_logits of shape \`(batch_size, num_queries, height, width)\`
class_queries_logits = outputs.class_queries_logits
masks_queries_logits = outputs.masks_queries_logits

# you can pass them to feature_extractor for postprocessing
predicted_semantic_map = feature_extractor.post_process_semantic_segmentation(
    outputs, target_sizes=[image.size[::-1]]
)[0]

# we refer to the demo notebooks for visualization (see "Resources" section in the MaskFormer docs)
list(predicted_semantic_map.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> MaskFormerFeatureExtractor, MaskFormerForInstanceSegmentation
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> requests

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># load MaskFormer fine-tuned on ADE20k semantic segmentation</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>feature_extractor = MaskFormerFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;facebook/maskformer-swin-base-ade&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = MaskFormerForInstanceSegmentation.from_pretrained(<span class="hljs-string">&quot;facebook/maskformer-swin-base-ade&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>url = (
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;https://huggingface.co/datasets/hf-internal-testing/fixtures_ade20k/resolve/main/ADE_val_00000001.jpg&quot;</span>
<span class="hljs-meta">... </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>image = Image.<span class="hljs-built_in">open</span>(requests.get(url, stream=<span class="hljs-literal">True</span>).raw)
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = feature_extractor(images=image, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># model predicts class_queries_logits of shape \`(batch_size, num_queries)\`</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># and masks_queries_logits of shape \`(batch_size, num_queries, height, width)\`</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>class_queries_logits = outputs.class_queries_logits
<span class="hljs-meta">&gt;&gt;&gt; </span>masks_queries_logits = outputs.masks_queries_logits

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># you can pass them to feature_extractor for postprocessing</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_semantic_map = feature_extractor.post_process_semantic_segmentation(
<span class="hljs-meta">... </span>    outputs, target_sizes=[image.size[::-<span class="hljs-number">1</span>]]
<span class="hljs-meta">... </span>)[<span class="hljs-number">0</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># we refer to the demo notebooks for visualization (see &quot;Resources&quot; section in the MaskFormer docs)</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(predicted_semantic_map.shape)
[<span class="hljs-number">512</span>, <span class="hljs-number">683</span>]`}}),{c(){p=r("p"),b=s("Semantic segmentation example:"),u=l(),F(g.$$.fragment)},l(d){p=n(d,"P",{});var _=i(p);b=a(_,"Semantic segmentation example:"),_.forEach(o),u=m(d),v(g.$$.fragment,d)},m(d,_){f(d,p,_),e(p,b),f(d,u,_),w(g,d,_),k=!0},p:Ta,i(d){k||(x(g.$$.fragment,d),k=!0)},o(d){y(g.$$.fragment,d),k=!1},d(d){d&&o(p),d&&o(u),M(g,d)}}}function vl(P){let p,b,u,g,k;return g=new $a({props:{code:`from transformers import MaskFormerFeatureExtractor, MaskFormerForInstanceSegmentation
from PIL import Image
import requests

# load MaskFormer fine-tuned on COCO panoptic segmentation
feature_extractor = MaskFormerFeatureExtractor.from_pretrained("facebook/maskformer-swin-base-coco")
model = MaskFormerForInstanceSegmentation.from_pretrained("facebook/maskformer-swin-base-coco")

url = "http://images.cocodataset.org/val2017/000000039769.jpg"
image = Image.open(requests.get(url, stream=True).raw)
inputs = feature_extractor(images=image, return_tensors="pt")

outputs = model(**inputs)
# model predicts class_queries_logits of shape \`(batch_size, num_queries)\`
# and masks_queries_logits of shape \`(batch_size, num_queries, height, width)\`
class_queries_logits = outputs.class_queries_logits
masks_queries_logits = outputs.masks_queries_logits

# you can pass them to feature_extractor for postprocessing
result = feature_extractor.post_process_panoptic_segmentation(outputs, target_sizes=[image.size[::-1]])[0]

# we refer to the demo notebooks for visualization (see "Resources" section in the MaskFormer docs)
predicted_panoptic_map = result["segmentation"]
list(predicted_panoptic_map.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> MaskFormerFeatureExtractor, MaskFormerForInstanceSegmentation
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> requests

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># load MaskFormer fine-tuned on COCO panoptic segmentation</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>feature_extractor = MaskFormerFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;facebook/maskformer-swin-base-coco&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = MaskFormerForInstanceSegmentation.from_pretrained(<span class="hljs-string">&quot;facebook/maskformer-swin-base-coco&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>url = <span class="hljs-string">&quot;http://images.cocodataset.org/val2017/000000039769.jpg&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>image = Image.<span class="hljs-built_in">open</span>(requests.get(url, stream=<span class="hljs-literal">True</span>).raw)
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = feature_extractor(images=image, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># model predicts class_queries_logits of shape \`(batch_size, num_queries)\`</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># and masks_queries_logits of shape \`(batch_size, num_queries, height, width)\`</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>class_queries_logits = outputs.class_queries_logits
<span class="hljs-meta">&gt;&gt;&gt; </span>masks_queries_logits = outputs.masks_queries_logits

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># you can pass them to feature_extractor for postprocessing</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>result = feature_extractor.post_process_panoptic_segmentation(outputs, target_sizes=[image.size[::-<span class="hljs-number">1</span>]])[<span class="hljs-number">0</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># we refer to the demo notebooks for visualization (see &quot;Resources&quot; section in the MaskFormer docs)</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_panoptic_map = result[<span class="hljs-string">&quot;segmentation&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(predicted_panoptic_map.shape)
[<span class="hljs-number">480</span>, <span class="hljs-number">640</span>]`}}),{c(){p=r("p"),b=s("Panoptic segmentation example:"),u=l(),F(g.$$.fragment)},l(d){p=n(d,"P",{});var _=i(p);b=a(_,"Panoptic segmentation example:"),_.forEach(o),u=m(d),v(g.$$.fragment,d)},m(d,_){f(d,p,_),e(p,b),f(d,u,_),w(g,d,_),k=!0},p:Ta,i(d){k||(x(g.$$.fragment,d),k=!0)},o(d){y(g.$$.fragment,d),k=!1},d(d){d&&o(p),d&&o(u),M(g,d)}}}function wl(P){let p,b,u,g,k,d,_,C,Ea,bs,he,Fs,ee,fe,xo,He,Ia,yo,Pa,vs,ge,ja,Ue,za,Oa,ws,Bt,La,xs,Wt,Mo,Aa,ys,Vt,Ca,Ms,R,D,qa,Gt,Da,Sa,To,Na,Ra,Kt,Ha,Ua,$o,Ba,Wa,Va,S,Ga,Eo,Ka,Qa,Io,Xa,Ya,Po,Ja,Za,Be,er,tr,or,We,sr,Qt,ar,rr,nr,N,ir,Xt,cr,dr,Yt,lr,mr,Jt,pr,hr,jo,fr,gr,Ts,ue,ur,Ve,_r,kr,$s,Ge,Pc,Es,X,br,Ke,Fr,vr,Qe,wr,xr,Is,te,_e,zo,Xe,yr,Oo,Mr,Ps,Ye,js,Zt,Je,Tr,Ze,$r,Er,zs,oe,ke,Lo,et,Ir,Ao,Pr,Os,se,tt,jr,ot,zr,eo,Or,Lr,Ls,B,st,Ar,at,Cr,to,qr,Dr,Sr,W,Nr,oo,Rr,Hr,so,Ur,Br,ao,Wr,Vr,As,ae,be,Co,rt,Gr,qo,Kr,Cs,I,nt,Qr,V,Xr,ro,Yr,Jr,it,Zr,en,ct,tn,on,sn,re,an,no,rn,nn,io,cn,dn,ln,dt,mn,co,pn,hn,fn,Fe,gn,ve,lt,un,mt,_n,lo,kn,bn,Fn,we,pt,vn,ht,wn,mo,xn,yn,qs,ne,xe,Do,ft,Mn,So,Tn,Ds,$,gt,$n,No,En,In,ut,Pn,po,jn,zn,On,E,_t,Ln,Ro,An,Cn,kt,qn,Ho,Dn,Sn,Nn,Uo,Rn,Hn,bt,Un,Bo,Bn,Wn,Vn,G,Gn,Wo,Kn,Qn,Vo,Xn,Yn,Go,Jn,Zn,ei,Ft,ti,Ko,oi,si,ai,ye,ri,T,vt,ni,Qo,ii,ci,ie,di,wt,li,mi,xt,pi,hi,fi,yt,gi,Xo,ui,_i,ki,Mt,bi,Yo,Fi,vi,wi,Jo,xi,yi,Tt,Mi,Zo,Ti,$i,Ei,K,Ii,es,Pi,ji,ts,zi,Oi,os,Li,Ai,Ci,$t,qi,ss,Di,Si,Ni,Me,Et,Ri,It,Hi,ho,Ui,Bi,Wi,Te,Pt,Vi,jt,Gi,as,Ki,Qi,Xi,$e,zt,Yi,Ot,Ji,rs,Zi,ec,Ss,ce,Ee,ns,Lt,tc,is,oc,Ns,Q,At,sc,Ct,ac,qt,rc,nc,ic,H,Dt,cc,de,dc,fo,lc,mc,cs,pc,hc,fc,Ie,gc,Pe,Rs,le,je,ds,St,uc,ls,_c,Hs,me,Nt,kc,z,Rt,bc,pe,Fc,go,vc,wc,ms,xc,yc,Mc,ze,Tc,ps,$c,Ec,Oe,Ic,Le,Us;return d=new Re({}),he=new ya({props:{$$slots:{default:[fl]},$$scope:{ctx:P}}}),He=new Re({}),Xe=new Re({}),Ye=new hl({props:{pipeline:"image-segmentation"}}),et=new Re({}),tt=new A({props:{name:"class transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput",anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput",parameters:[{name:"encoder_last_hidden_state",val:": typing.Optional[torch.FloatTensor] = None"},{name:"pixel_decoder_last_hidden_state",val:": typing.Optional[torch.FloatTensor] = None"},{name:"transformer_decoder_last_hidden_state",val:": typing.Optional[torch.FloatTensor] = None"},{name:"encoder_hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"pixel_decoder_hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"transformer_decoder_hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"attentions",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"}],parametersDescription:[{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput.encoder_last_hidden_state",description:`<strong>encoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Last hidden states (final feature map) of the last stage of the encoder model (backbone).`,name:"encoder_last_hidden_state"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput.pixel_decoder_last_hidden_state",description:`<strong>pixel_decoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Last hidden states (final feature map) of the last stage of the pixel decoder model (FPN).`,name:"pixel_decoder_last_hidden_state"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput.transformer_decoder_last_hidden_state",description:`<strong>transformer_decoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) &#x2014;
Last hidden states (final feature map) of the last stage of the transformer decoder model.`,name:"transformer_decoder_last_hidden_state"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput.encoder_hidden_states",description:`<strong>encoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also called feature maps) of the encoder
model at the output of each stage.`,name:"encoder_hidden_states"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput.pixel_decoder_hidden_states",description:`<strong>pixel_decoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also called feature maps) of the pixel
decoder model at the output of each stage.`,name:"pixel_decoder_hidden_states"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput.transformer_decoder_hidden_states",description:`<strong>transformer_decoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, sequence_length, hidden_size)</code>. Hidden-states (also called feature maps) of the
transformer decoder at the output of each stage.`,name:"transformer_decoder_hidden_states"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput.hidden_states",description:`<strong>hidden_states</strong> <code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> containing <code>encoder_hidden_states</code>, <code>pixel_decoder_hidden_states</code> and
<code>decoder_hidden_states</code>`,name:"hidden_states"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput.attentions",description:`<strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>. Attentions weights from Detr&#x2019;s decoder after the attention softmax, used to compute the
weighted average in the self-attention heads.`,name:"attentions"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/maskformer/modeling_maskformer.py#L214"}}),st=new A({props:{name:"class transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput",anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput",parameters:[{name:"loss",val:": typing.Optional[torch.FloatTensor] = None"},{name:"class_queries_logits",val:": FloatTensor = None"},{name:"masks_queries_logits",val:": FloatTensor = None"},{name:"auxiliary_logits",val:": FloatTensor = None"},{name:"encoder_last_hidden_state",val:": typing.Optional[torch.FloatTensor] = None"},{name:"pixel_decoder_last_hidden_state",val:": typing.Optional[torch.FloatTensor] = None"},{name:"transformer_decoder_last_hidden_state",val:": typing.Optional[torch.FloatTensor] = None"},{name:"encoder_hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"pixel_decoder_hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"transformer_decoder_hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"attentions",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"}],parametersDescription:[{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.loss",description:`<strong>loss</strong> (<code>torch.Tensor</code>, <em>optional</em>) &#x2014;
The computed loss, returned when labels are present.`,name:"loss"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.class_queries_logits",description:`<strong>class_queries_logits</strong> (<code>torch.FloatTensor</code>) &#x2014;
A tensor of shape <code>(batch_size, num_queries, num_labels + 1)</code> representing the proposed classes for each
query. Note the <code>+ 1</code> is needed because we incorporate the null class.`,name:"class_queries_logits"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.masks_queries_logits",description:`<strong>masks_queries_logits</strong> (<code>torch.FloatTensor</code>) &#x2014;
A tensor of shape <code>(batch_size, num_queries, height, width)</code> representing the proposed masks for each
query.`,name:"masks_queries_logits"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.encoder_last_hidden_state",description:`<strong>encoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Last hidden states (final feature map) of the last stage of the encoder model (backbone).`,name:"encoder_last_hidden_state"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.pixel_decoder_last_hidden_state",description:`<strong>pixel_decoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Last hidden states (final feature map) of the last stage of the pixel decoder model (FPN).`,name:"pixel_decoder_last_hidden_state"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.transformer_decoder_last_hidden_state",description:`<strong>transformer_decoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) &#x2014;
Last hidden states (final feature map) of the last stage of the transformer decoder model.`,name:"transformer_decoder_last_hidden_state"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.encoder_hidden_states",description:`<strong>encoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also called feature maps) of the encoder
model at the output of each stage.`,name:"encoder_hidden_states"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.pixel_decoder_hidden_states",description:`<strong>pixel_decoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also called feature maps) of the pixel
decoder model at the output of each stage.`,name:"pixel_decoder_hidden_states"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.transformer_decoder_hidden_states",description:`<strong>transformer_decoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, sequence_length, hidden_size)</code>. Hidden-states of the transformer decoder at the output
of each stage.`,name:"transformer_decoder_hidden_states"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.hidden_states",description:`<strong>hidden_states</strong> <code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> containing <code>encoder_hidden_states</code>, <code>pixel_decoder_hidden_states</code> and
<code>decoder_hidden_states</code>.`,name:"hidden_states"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.attentions",description:`<strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>. Attentions weights from Detr&#x2019;s decoder after the attention softmax, used to compute the
weighted average in the self-attention heads.`,name:"attentions"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/maskformer/modeling_maskformer.py#L257"}}),rt=new Re({}),nt=new A({props:{name:"class transformers.MaskFormerConfig",anchor:"transformers.MaskFormerConfig",parameters:[{name:"fpn_feature_size",val:": int = 256"},{name:"mask_feature_size",val:": int = 256"},{name:"no_object_weight",val:": float = 0.1"},{name:"use_auxiliary_loss",val:": bool = False"},{name:"backbone_config",val:": typing.Optional[typing.Dict] = None"},{name:"decoder_config",val:": typing.Optional[typing.Dict] = None"},{name:"init_std",val:": float = 0.02"},{name:"init_xavier_std",val:": float = 1.0"},{name:"dice_weight",val:": float = 1.0"},{name:"cross_entropy_weight",val:": float = 1.0"},{name:"mask_weight",val:": float = 20.0"},{name:"output_auxiliary_logits",val:": typing.Optional[bool] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.MaskFormerConfig.mask_feature_size",description:`<strong>mask_feature_size</strong> (<code>int</code>, <em>optional</em>, defaults to 256) &#x2014;
The masks&#x2019; features size, this value will also be used to specify the Feature Pyramid Network features&#x2019;
size.`,name:"mask_feature_size"},{anchor:"transformers.MaskFormerConfig.no_object_weight",description:`<strong>no_object_weight</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
Weight to apply to the null (no object) class.`,name:"no_object_weight"},{anchor:"transformers.MaskFormerConfig.use_auxiliary_loss(bool,",description:`<strong>use_auxiliary_loss(<code>bool</code>,</strong> <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code> <code>MaskFormerForInstanceSegmentationOutput</code> will contain the auxiliary losses computed using the
logits from each decoder&#x2019;s stage.`,name:"use_auxiliary_loss(bool,"},{anchor:"transformers.MaskFormerConfig.backbone_config",description:`<strong>backbone_config</strong> (<code>Dict</code>, <em>optional</em>) &#x2014;
The configuration passed to the backbone, if unset, the configuration corresponding to
<code>swin-base-patch4-window12-384</code> will be used.`,name:"backbone_config"},{anchor:"transformers.MaskFormerConfig.decoder_config",description:`<strong>decoder_config</strong> (<code>Dict</code>, <em>optional</em>) &#x2014;
The configuration passed to the transformer decoder model, if unset the base config for <code>detr-resnet-50</code>
will be used.`,name:"decoder_config"},{anchor:"transformers.MaskFormerConfig.init_std",description:`<strong>init_std</strong> (<code>float</code>, <em>optional</em>, defaults to 0.02) &#x2014;
The standard deviation of the truncated_normal_initializer for initializing all weight matrices.`,name:"init_std"},{anchor:"transformers.MaskFormerConfig.init_xavier_std",description:`<strong>init_xavier_std</strong> (<code>float</code>, <em>optional</em>, defaults to 1) &#x2014;
The scaling factor used for the Xavier initialization gain in the HM Attention map module.`,name:"init_xavier_std"},{anchor:"transformers.MaskFormerConfig.dice_weight",description:`<strong>dice_weight</strong> (<code>float</code>, <em>optional</em>, defaults to 1.0) &#x2014;
The weight for the dice loss.`,name:"dice_weight"},{anchor:"transformers.MaskFormerConfig.cross_entropy_weight",description:`<strong>cross_entropy_weight</strong> (<code>float</code>, <em>optional</em>, defaults to 1.0) &#x2014;
The weight for the cross entropy loss.`,name:"cross_entropy_weight"},{anchor:"transformers.MaskFormerConfig.mask_weight",description:`<strong>mask_weight</strong> (<code>float</code>, <em>optional</em>, defaults to 20.0) &#x2014;
The weight for the mask loss.`,name:"mask_weight"},{anchor:"transformers.MaskFormerConfig.output_auxiliary_logits",description:`<strong>output_auxiliary_logits</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Should the model output its <code>auxiliary_logits</code> or not.`,name:"output_auxiliary_logits"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/maskformer/configuration_maskformer.py#L36",raiseDescription:`
<ul>
<li><code>ValueError</code> \u2014
Raised if the backbone model type selected is not in <code>["swin"]</code> or the decoder model type selected is not
in <code>["detr"]</code></li>
</ul>
`,raiseType:`
<p><code>ValueError</code></p>
`}}),Fe=new Ma({props:{anchor:"transformers.MaskFormerConfig.example",$$slots:{default:[gl]},$$scope:{ctx:P}}}),lt=new A({props:{name:"from_backbone_and_decoder_configs",anchor:"transformers.MaskFormerConfig.from_backbone_and_decoder_configs",parameters:[{name:"backbone_config",val:": PretrainedConfig"},{name:"decoder_config",val:": PretrainedConfig"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.MaskFormerConfig.from_backbone_and_decoder_configs.backbone_config",description:`<strong>backbone_config</strong> (<a href="/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig">PretrainedConfig</a>) &#x2014;
The backbone configuration.`,name:"backbone_config"},{anchor:"transformers.MaskFormerConfig.from_backbone_and_decoder_configs.decoder_config",description:`<strong>decoder_config</strong> (<a href="/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig">PretrainedConfig</a>) &#x2014;
The transformer decoder configuration to use.`,name:"decoder_config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/maskformer/configuration_maskformer.py#L172",returnDescription:`
<p>An instance of a configuration object</p>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerConfig"
>MaskFormerConfig</a></p>
`}}),pt=new A({props:{name:"to_dict",anchor:"transformers.MaskFormerConfig.to_dict",parameters:[],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/maskformer/configuration_maskformer.py#L194",returnDescription:`
<p>Dictionary of all the attributes that make up this configuration instance,</p>
`,returnType:`
<p><code>Dict[str, any]</code></p>
`}}),ft=new Re({}),gt=new A({props:{name:"class transformers.MaskFormerFeatureExtractor",anchor:"transformers.MaskFormerFeatureExtractor",parameters:[{name:"do_resize",val:" = True"},{name:"size",val:" = 800"},{name:"max_size",val:" = 1333"},{name:"resample",val:" = <Resampling.BILINEAR: 2>"},{name:"size_divisibility",val:" = 32"},{name:"do_normalize",val:" = True"},{name:"image_mean",val:" = None"},{name:"image_std",val:" = None"},{name:"ignore_index",val:" = None"},{name:"reduce_labels",val:" = False"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.MaskFormerFeatureExtractor.do_resize",description:`<strong>do_resize</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to resize the input to a certain <code>size</code>.`,name:"do_resize"},{anchor:"transformers.MaskFormerFeatureExtractor.size",description:`<strong>size</strong> (<code>int</code>, <em>optional</em>, defaults to 800) &#x2014;
Resize the input to the given size. Only has an effect if <code>do_resize</code> is set to <code>True</code>. If size is a
sequence like <code>(width, height)</code>, output size will be matched to this. If size is an int, smaller edge of
the image will be matched to this number. i.e, if <code>height &gt; width</code>, then image will be rescaled to <code>(size * height / width, size)</code>.`,name:"size"},{anchor:"transformers.MaskFormerFeatureExtractor.max_size",description:`<strong>max_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1333) &#x2014;
The largest size an image dimension can have (otherwise it&#x2019;s capped). Only has an effect if <code>do_resize</code> is
set to <code>True</code>.`,name:"max_size"},{anchor:"transformers.MaskFormerFeatureExtractor.resample",description:`<strong>resample</strong> (<code>int</code>, <em>optional</em>, defaults to <code>PILImageResampling.BILINEAR</code>) &#x2014;
An optional resampling filter. This can be one of <code>PILImageResampling.NEAREST</code>, <code>PILImageResampling.BOX</code>,
<code>PILImageResampling.BILINEAR</code>, <code>PILImageResampling.HAMMING</code>, <code>PILImageResampling.BICUBIC</code> or
<code>PILImageResampling.LANCZOS</code>. Only has an effect if <code>do_resize</code> is set to <code>True</code>.`,name:"resample"},{anchor:"transformers.MaskFormerFeatureExtractor.size_divisibility",description:`<strong>size_divisibility</strong> (<code>int</code>, <em>optional</em>, defaults to 32) &#x2014;
Some backbones need images divisible by a certain number. If not passed, it defaults to the value used in
Swin Transformer.`,name:"size_divisibility"},{anchor:"transformers.MaskFormerFeatureExtractor.do_normalize",description:`<strong>do_normalize</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to normalize the input with mean and standard deviation.`,name:"do_normalize"},{anchor:"transformers.MaskFormerFeatureExtractor.image_mean",description:`<strong>image_mean</strong> (<code>int</code>, <em>optional</em>, defaults to <code>[0.485, 0.456, 0.406]</code>) &#x2014;
The sequence of means for each channel, to be used when normalizing images. Defaults to the ImageNet mean.`,name:"image_mean"},{anchor:"transformers.MaskFormerFeatureExtractor.image_std",description:`<strong>image_std</strong> (<code>int</code>, <em>optional</em>, defaults to <code>[0.229, 0.224, 0.225]</code>) &#x2014;
The sequence of standard deviations for each channel, to be used when normalizing images. Defaults to the
ImageNet std.`,name:"image_std"},{anchor:"transformers.MaskFormerFeatureExtractor.ignore_index",description:`<strong>ignore_index</strong> (<code>int</code>, <em>optional</em>) &#x2014;
Label to be assigned to background pixels in segmentation maps. If provided, segmentation map pixels
denoted with 0 (background) will be replaced with <code>ignore_index</code>. The ignore index of the loss function of
the model should then correspond to this ignore index.`,name:"ignore_index"},{anchor:"transformers.MaskFormerFeatureExtractor.reduce_labels",description:`<strong>reduce_labels</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to decrement all label values of segmentation maps by 1. Usually used for datasets where 0
is used for background, and background itself is not included in all classes of a dataset (e.g. ADE20k).
The background label will be replaced by <code>ignore_index</code>.`,name:"reduce_labels"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/maskformer/feature_extraction_maskformer.py#L193"}}),_t=new A({props:{name:"__call__",anchor:"transformers.MaskFormerFeatureExtractor.__call__",parameters:[{name:"images",val:": typing.Union[ForwardRef('PIL.Image.Image'), numpy.ndarray, ForwardRef('torch.Tensor'), typing.List[ForwardRef('PIL.Image.Image')], typing.List[numpy.ndarray], typing.List[ForwardRef('torch.Tensor')]]"},{name:"segmentation_maps",val:": typing.Union[ForwardRef('PIL.Image.Image'), numpy.ndarray, ForwardRef('torch.Tensor'), typing.List[ForwardRef('PIL.Image.Image')], typing.List[numpy.ndarray], typing.List[ForwardRef('torch.Tensor')]] = None"},{name:"pad_and_return_pixel_mask",val:": typing.Optional[bool] = True"},{name:"instance_id_to_semantic_id",val:": typing.Union[typing.List[typing.Dict[int, int]], typing.Dict[int, int], NoneType] = None"},{name:"return_tensors",val:": typing.Union[str, transformers.utils.generic.TensorType, NoneType] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.MaskFormerFeatureExtractor.__call__.images",description:`<strong>images</strong> (<code>PIL.Image.Image</code>, <code>np.ndarray</code>, <code>torch.Tensor</code>, <code>List[PIL.Image.Image]</code>, <code>List[np.ndarray]</code>, <code>List[torch.Tensor]</code>) &#x2014;
The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch
tensor. In case of a NumPy array/PyTorch tensor, each image should be of shape (C, H, W), where C is a
number of channels, H and W are image height and width.`,name:"images"},{anchor:"transformers.MaskFormerFeatureExtractor.__call__.segmentation_maps",description:`<strong>segmentation_maps</strong> (<code>PIL.Image.Image</code>, <code>np.ndarray</code>, <code>torch.Tensor</code>, <code>List[PIL.Image.Image]</code>, <code>List[np.ndarray]</code>, <code>List[torch.Tensor]</code>, <em>optional</em>) &#x2014;
The corresponding segmentation maps with the pixel-wise instance id, semantic id or segment id
annotations. Assumed to be semantic segmentation maps if no <code>instance_id_to_semantic_id map</code> is
provided.`,name:"segmentation_maps"},{anchor:"transformers.MaskFormerFeatureExtractor.__call__.pad_and_return_pixel_mask",description:`<strong>pad_and_return_pixel_mask</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to pad images up to the largest image in a batch and create a pixel mask.</p>
<p>If left to the default, will return a pixel mask that is:</p>
<ul>
<li>1 for pixels that are real (i.e. <strong>not masked</strong>),</li>
<li>0 for pixels that are padding (i.e. <strong>masked</strong>).</li>
</ul>`,name:"pad_and_return_pixel_mask"},{anchor:"transformers.MaskFormerFeatureExtractor.__call__.instance_id_to_semantic_id",description:`<strong>instance_id_to_semantic_id</strong> (<code>List[Dict[int, int]]</code> or <code>Dict[int, int]</code>, <em>optional</em>) &#x2014;
A mapping between instance/segment ids and semantic category ids. If passed, <code>segmentation_maps</code> is
treated as an instance or panoptic segmentation map where each pixel represents an instance or segment
id. Can be provided as a single dictionary with a global / dataset-level mapping or as a list of
dictionaries (one per image), to map instance ids in each image separately. Note that this assumes a
mapping before reduction of labels.`,name:"instance_id_to_semantic_id"},{anchor:"transformers.MaskFormerFeatureExtractor.__call__.return_tensors",description:`<strong>return_tensors</strong> (<code>str</code> or <a href="/docs/transformers/main/en/internal/file_utils#transformers.TensorType">TensorType</a>, <em>optional</em>) &#x2014;
If set, will return tensors instead of NumPy arrays. If set to <code>&apos;pt&apos;</code>, return PyTorch <code>torch.Tensor</code>
objects.`,name:"return_tensors"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/maskformer/feature_extraction_maskformer.py#L317",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/feature_extractor#transformers.BatchFeature"
>BatchFeature</a> with the following fields:</p>
<ul>
<li><strong>pixel_values</strong> \u2014 Pixel values to be fed to a model.</li>
<li><strong>pixel_mask</strong> \u2014 Pixel mask to be fed to a model (when <code>pad_and_return_pixel_mask=True</code> or if
<code>pixel_mask</code> is in <code>self.model_input_names</code>).</li>
<li><strong>mask_labels</strong> \u2014 Optional list of mask labels of shape <code>(num_class_labels, height, width)</code> to be fed to
a model (when <code>annotations</code> are provided).</li>
<li><strong>class_labels</strong> \u2014 Optional list of class labels of shape <code>(num_class_labels)</code> to be fed to a model
(when <code>annotations</code> are provided). They identify the labels of <code>mask_labels</code>, e.g. the label of
<code>mask_labels[i][j]</code> if <code>class_labels[i][j]</code>.</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/feature_extractor#transformers.BatchFeature"
>BatchFeature</a></p>
`}}),ye=new ya({props:{warning:!0,$$slots:{default:[ul]},$$scope:{ctx:P}}}),vt=new A({props:{name:"encode_inputs",anchor:"transformers.MaskFormerFeatureExtractor.encode_inputs",parameters:[{name:"pixel_values_list",val:": typing.Union[typing.List[ForwardRef('np.ndarray')], typing.List[ForwardRef('torch.Tensor')]]"},{name:"segmentation_maps",val:": typing.Union[ForwardRef('PIL.Image.Image'), numpy.ndarray, ForwardRef('torch.Tensor'), typing.List[ForwardRef('PIL.Image.Image')], typing.List[numpy.ndarray], typing.List[ForwardRef('torch.Tensor')]] = None"},{name:"pad_and_return_pixel_mask",val:": bool = True"},{name:"instance_id_to_semantic_id",val:": typing.Union[typing.List[typing.Dict[int, int]], typing.Dict[int, int], NoneType] = None"},{name:"return_tensors",val:": typing.Union[str, transformers.utils.generic.TensorType, NoneType] = None"}],parametersDescription:[{anchor:"transformers.MaskFormerFeatureExtractor.encode_inputs.pixel_values_list",description:`<strong>pixel_values_list</strong> (<code>List[np.ndarray]</code> or <code>List[torch.Tensor]</code>) &#x2014;
List of images (pixel values) to be padded. Each image should be a tensor of shape <code>(channels, height, width)</code>.`,name:"pixel_values_list"},{anchor:"transformers.MaskFormerFeatureExtractor.encode_inputs.segmentation_maps",description:`<strong>segmentation_maps</strong> (<code>PIL.Image.Image</code>, <code>np.ndarray</code>, <code>torch.Tensor</code>, <code>List[PIL.Image.Image]</code>, <code>List[np.ndarray]</code>, <code>List[torch.Tensor]</code>, <em>optional</em>) &#x2014;
The corresponding segmentation maps with the pixel-wise instance id, semantic id or segment id
annotations. Assumed to be semantic segmentation maps if no <code>instance_id_to_semantic_id map</code> is
provided.`,name:"segmentation_maps"},{anchor:"transformers.MaskFormerFeatureExtractor.encode_inputs.pad_and_return_pixel_mask",description:`<strong>pad_and_return_pixel_mask</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to pad images up to the largest image in a batch and create a pixel mask.</p>
<p>If left to the default, will return a pixel mask that is:</p>
<ul>
<li>1 for pixels that are real (i.e. <strong>not masked</strong>),</li>
<li>0 for pixels that are padding (i.e. <strong>masked</strong>).</li>
</ul>`,name:"pad_and_return_pixel_mask"},{anchor:"transformers.MaskFormerFeatureExtractor.encode_inputs.instance_id_to_semantic_id",description:`<strong>instance_id_to_semantic_id</strong> (<code>List[Dict[int, int]]</code> or <code>Dict[int, int]</code>, <em>optional</em>) &#x2014;
A mapping between instance/segment ids and semantic category ids. If passed, <code>segmentation_maps</code> is
treated as an instance or panoptic segmentation map where each pixel represents an instance or segment
id. Can be provided as a single dictionary with a global / dataset-level mapping or as a list of
dictionaries (one per image), to map instance ids in each image separately. Note that this assumes a
mapping before reduction of labels.`,name:"instance_id_to_semantic_id"},{anchor:"transformers.MaskFormerFeatureExtractor.encode_inputs.return_tensors",description:`<strong>return_tensors</strong> (<code>str</code> or <a href="/docs/transformers/main/en/internal/file_utils#transformers.TensorType">TensorType</a>, <em>optional</em>) &#x2014;
If set, will return tensors instead of NumPy arrays. If set to <code>&apos;pt&apos;</code>, return PyTorch <code>torch.Tensor</code>
objects.`,name:"return_tensors"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/maskformer/feature_extraction_maskformer.py#L526",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/feature_extractor#transformers.BatchFeature"
>BatchFeature</a> with the following fields:</p>
<ul>
<li><strong>pixel_values</strong> \u2014 Pixel values to be fed to a model.</li>
<li><strong>pixel_mask</strong> \u2014 Pixel mask to be fed to a model (when <code>pad_and_return_pixel_mask=True</code> or if
<code>pixel_mask</code> is in <code>self.model_input_names</code>).</li>
<li><strong>mask_labels</strong> \u2014 Optional list of mask labels of shape <code>(labels, height, width)</code> to be fed to a model
(when <code>annotations</code> are provided).</li>
<li><strong>class_labels</strong> \u2014 Optional list of class labels of shape <code>(labels)</code> to be fed to a model (when
<code>annotations</code> are provided). They identify the labels of <code>mask_labels</code>, e.g. the label of
<code>mask_labels[i][j]</code> if <code>class_labels[i][j]</code>.</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/feature_extractor#transformers.BatchFeature"
>BatchFeature</a></p>
`}}),Et=new A({props:{name:"post_process_semantic_segmentation",anchor:"transformers.MaskFormerFeatureExtractor.post_process_semantic_segmentation",parameters:[{name:"outputs",val:""},{name:"target_sizes",val:": typing.Union[typing.List[typing.Tuple[int, int]], NoneType] = None"}],parametersDescription:[{anchor:"transformers.MaskFormerFeatureExtractor.post_process_semantic_segmentation.outputs",description:`<strong>outputs</strong> (<a href="/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerForInstanceSegmentation">MaskFormerForInstanceSegmentation</a>) &#x2014;
Raw outputs of the model.`,name:"outputs"},{anchor:"transformers.MaskFormerFeatureExtractor.post_process_semantic_segmentation.target_sizes",description:`<strong>target_sizes</strong> (<code>List[Tuple[int, int]]</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
List of length (batch_size), where each list item (<code>Tuple[int, int]]</code>) corresponds to the requested
final size (height, width) of each prediction. If left to None, predictions will not be resized.`,name:"target_sizes"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/maskformer/feature_extraction_maskformer.py#L715",returnDescription:`
<p>A list of length <code>batch_size</code>, where each item is a semantic segmentation map of shape (height, width)
corresponding to the target_sizes entry (if <code>target_sizes</code> is specified). Each entry of each
<code>torch.Tensor</code> correspond to a semantic class id.</p>
`,returnType:`
<p><code>List[torch.Tensor]</code></p>
`}}),Pt=new A({props:{name:"post_process_instance_segmentation",anchor:"transformers.MaskFormerFeatureExtractor.post_process_instance_segmentation",parameters:[{name:"outputs",val:""},{name:"threshold",val:": float = 0.5"},{name:"mask_threshold",val:": float = 0.5"},{name:"overlap_mask_area_threshold",val:": float = 0.8"},{name:"target_sizes",val:": typing.Union[typing.List[typing.Tuple[int, int]], NoneType] = None"},{name:"return_coco_annotation",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"transformers.MaskFormerFeatureExtractor.post_process_instance_segmentation.outputs",description:`<strong>outputs</strong> (<a href="/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerForInstanceSegmentation">MaskFormerForInstanceSegmentation</a>) &#x2014;
Raw outputs of the model.`,name:"outputs"},{anchor:"transformers.MaskFormerFeatureExtractor.post_process_instance_segmentation.threshold",description:`<strong>threshold</strong> (<code>float</code>, <em>optional</em>, defaults to 0.5) &#x2014;
The probability score threshold to keep predicted instance masks.`,name:"threshold"},{anchor:"transformers.MaskFormerFeatureExtractor.post_process_instance_segmentation.mask_threshold",description:`<strong>mask_threshold</strong> (<code>float</code>, <em>optional</em>, defaults to 0.5) &#x2014;
Threshold to use when turning the predicted masks into binary values.`,name:"mask_threshold"},{anchor:"transformers.MaskFormerFeatureExtractor.post_process_instance_segmentation.overlap_mask_area_threshold",description:`<strong>overlap_mask_area_threshold</strong> (<code>float</code>, <em>optional</em>, defaults to 0.8) &#x2014;
The overlap mask area threshold to merge or discard small disconnected parts within each binary
instance mask.`,name:"overlap_mask_area_threshold"},{anchor:"transformers.MaskFormerFeatureExtractor.post_process_instance_segmentation.target_sizes",description:`<strong>target_sizes</strong> (<code>List[Tuple]</code>, <em>optional</em>) &#x2014;
List of length (batch_size), where each list item (<code>Tuple[int, int]]</code>) corresponds to the requested
final size (height, width) of each prediction. If left to None, predictions will not be resized.`,name:"target_sizes"},{anchor:"transformers.MaskFormerFeatureExtractor.post_process_instance_segmentation.return_coco_annotation",description:`<strong>return_coco_annotation</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Defaults to <code>False</code>. If set to <code>True</code>, segmentation maps are returned in COCO run-length encoding (RLE)
format.`,name:"return_coco_annotation"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/maskformer/feature_extraction_maskformer.py#L765",returnDescription:`
<p>A list of dictionaries, one per image, each dictionary containing two keys:</p>
<ul>
<li><strong>segmentation</strong> \u2014 A tensor of shape <code>(height, width)</code> where each pixel represents a <code>segment_id</code> or
<code>List[List]</code> run-length encoding (RLE) of the segmentation map if return_coco_annotation is set to
<code>True</code>. Set to <code>None</code> if no mask if found above <code>threshold</code>.</li>
<li><strong>segments_info</strong> \u2014 A dictionary that contains additional information on each segment.<ul>
<li><strong>id</strong> \u2014 An integer representing the <code>segment_id</code>.</li>
<li><strong>label_id</strong> \u2014 An integer representing the label / semantic class id corresponding to <code>segment_id</code>.</li>
<li><strong>score</strong> \u2014 Prediction score of segment with <code>segment_id</code>.</li>
</ul></li>
</ul>
`,returnType:`
<p><code>List[Dict]</code></p>
`}}),zt=new A({props:{name:"post_process_panoptic_segmentation",anchor:"transformers.MaskFormerFeatureExtractor.post_process_panoptic_segmentation",parameters:[{name:"outputs",val:""},{name:"threshold",val:": float = 0.5"},{name:"mask_threshold",val:": float = 0.5"},{name:"overlap_mask_area_threshold",val:": float = 0.8"},{name:"label_ids_to_fuse",val:": typing.Optional[typing.Set[int]] = None"},{name:"target_sizes",val:": typing.Union[typing.List[typing.Tuple[int, int]], NoneType] = None"}],parametersDescription:[{anchor:"transformers.MaskFormerFeatureExtractor.post_process_panoptic_segmentation.outputs",description:`<strong>outputs</strong> (<code>MaskFormerForInstanceSegmentationOutput</code>) &#x2014;
The outputs from <a href="/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerForInstanceSegmentation">MaskFormerForInstanceSegmentation</a>.`,name:"outputs"},{anchor:"transformers.MaskFormerFeatureExtractor.post_process_panoptic_segmentation.threshold",description:`<strong>threshold</strong> (<code>float</code>, <em>optional</em>, defaults to 0.5) &#x2014;
The probability score threshold to keep predicted instance masks.`,name:"threshold"},{anchor:"transformers.MaskFormerFeatureExtractor.post_process_panoptic_segmentation.mask_threshold",description:`<strong>mask_threshold</strong> (<code>float</code>, <em>optional</em>, defaults to 0.5) &#x2014;
Threshold to use when turning the predicted masks into binary values.`,name:"mask_threshold"},{anchor:"transformers.MaskFormerFeatureExtractor.post_process_panoptic_segmentation.overlap_mask_area_threshold",description:`<strong>overlap_mask_area_threshold</strong> (<code>float</code>, <em>optional</em>, defaults to 0.8) &#x2014;
The overlap mask area threshold to merge or discard small disconnected parts within each binary
instance mask.`,name:"overlap_mask_area_threshold"},{anchor:"transformers.MaskFormerFeatureExtractor.post_process_panoptic_segmentation.label_ids_to_fuse",description:`<strong>label_ids_to_fuse</strong> (<code>Set[int]</code>, <em>optional</em>) &#x2014;
The labels in this state will have all their instances be fused together. For instance we could say
there can only be one sky in an image, but several persons, so the label ID for sky would be in that
set, but not the one for person.`,name:"label_ids_to_fuse"},{anchor:"transformers.MaskFormerFeatureExtractor.post_process_panoptic_segmentation.target_sizes",description:`<strong>target_sizes</strong> (<code>List[Tuple]</code>, <em>optional</em>) &#x2014;
List of length (batch_size), where each list item (<code>Tuple[int, int]]</code>) corresponds to the requested
final size (height, width) of each prediction in batch. If left to None, predictions will not be
resized.`,name:"target_sizes"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/maskformer/feature_extraction_maskformer.py#L848",returnDescription:`
<p>A list of dictionaries, one per image, each dictionary containing two keys:</p>
<ul>
<li><strong>segmentation</strong> \u2014 a tensor of shape <code>(height, width)</code> where each pixel represents a <code>segment_id</code>, set
to <code>None</code> if no mask if found above <code>threshold</code>. If <code>target_sizes</code> is specified, segmentation is resized
to the corresponding <code>target_sizes</code> entry.</li>
<li><strong>segments_info</strong> \u2014 A dictionary that contains additional information on each segment.<ul>
<li><strong>id</strong> \u2014 an integer representing the <code>segment_id</code>.</li>
<li><strong>label_id</strong> \u2014 An integer representing the label / semantic class id corresponding to <code>segment_id</code>.</li>
<li><strong>was_fused</strong> \u2014 a boolean, <code>True</code> if <code>label_id</code> was in <code>label_ids_to_fuse</code>, <code>False</code> otherwise.
Multiple instances of the same class / label were fused and assigned a single <code>segment_id</code>.</li>
<li><strong>score</strong> \u2014 Prediction score of segment with <code>segment_id</code>.</li>
</ul></li>
</ul>
`,returnType:`
<p><code>List[Dict]</code></p>
`}}),Lt=new Re({}),At=new A({props:{name:"class transformers.MaskFormerModel",anchor:"transformers.MaskFormerModel",parameters:[{name:"config",val:": MaskFormerConfig"}],parametersDescription:[{anchor:"transformers.MaskFormerModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerConfig">MaskFormerConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/maskformer/modeling_maskformer.py#L2348"}}),Dt=new A({props:{name:"forward",anchor:"transformers.MaskFormerModel.forward",parameters:[{name:"pixel_values",val:": Tensor"},{name:"pixel_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.MaskFormerModel.forward.pixel_values",description:`<strong>pixel_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values. Pixel values can be obtained using <a href="/docs/transformers/main/en/model_doc/auto#transformers.AutoFeatureExtractor">AutoFeatureExtractor</a>. See
<code>AutoFeatureExtractor.__call__()</code> for details.`,name:"pixel_values"},{anchor:"transformers.MaskFormerModel.forward.pixel_mask",description:`<strong>pixel_mask</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, height, width)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding pixel values. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for pixels that are real (i.e. <strong>not masked</strong>),</li>
<li>0 for pixels that are padding (i.e. <strong>masked</strong>).</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"pixel_mask"},{anchor:"transformers.MaskFormerModel.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.MaskFormerModel.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of Detr&#x2019;s decoder attention layers.`,name:"output_attentions"},{anchor:"transformers.MaskFormerModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <code>~MaskFormerModelOutput</code> instead of a plain tuple.`,name:"return_dict"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/maskformer/modeling_maskformer.py#L2358",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/model_doc/maskformer#transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput"
>transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerConfig"
>MaskFormerConfig</a>) and inputs.</p>
<ul>
<li><strong>encoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) \u2014 Last hidden states (final feature map) of the last stage of the encoder model (backbone).</li>
<li><strong>pixel_decoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) \u2014 Last hidden states (final feature map) of the last stage of the pixel decoder model (FPN).</li>
<li><strong>transformer_decoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Last hidden states (final feature map) of the last stage of the transformer decoder model.</li>
<li><strong>encoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also called feature maps) of the encoder
model at the output of each stage.</li>
<li><strong>pixel_decoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also called feature maps) of the pixel
decoder model at the output of each stage.</li>
<li><strong>transformer_decoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, sequence_length, hidden_size)</code>. Hidden-states (also called feature maps) of the
transformer decoder at the output of each stage.</li>
<li><strong>hidden_states</strong> <code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> containing <code>encoder_hidden_states</code>, <code>pixel_decoder_hidden_states</code> and
<code>decoder_hidden_states</code></li>
<li><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>. Attentions weights from Detr\u2019s decoder after the attention softmax, used to compute the
weighted average in the self-attention heads.</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/model_doc/maskformer#transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput"
>transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Ie=new ya({props:{$$slots:{default:[_l]},$$scope:{ctx:P}}}),Pe=new Ma({props:{anchor:"transformers.MaskFormerModel.forward.example",$$slots:{default:[kl]},$$scope:{ctx:P}}}),St=new Re({}),Nt=new A({props:{name:"class transformers.MaskFormerForInstanceSegmentation",anchor:"transformers.MaskFormerForInstanceSegmentation",parameters:[{name:"config",val:": MaskFormerConfig"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/maskformer/modeling_maskformer.py#L2449"}}),Rt=new A({props:{name:"forward",anchor:"transformers.MaskFormerForInstanceSegmentation.forward",parameters:[{name:"pixel_values",val:": Tensor"},{name:"mask_labels",val:": typing.Optional[typing.List[torch.Tensor]] = None"},{name:"class_labels",val:": typing.Optional[typing.List[torch.Tensor]] = None"},{name:"pixel_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"output_auxiliary_logits",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.MaskFormerForInstanceSegmentation.forward.pixel_values",description:`<strong>pixel_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values. Pixel values can be obtained using <a href="/docs/transformers/main/en/model_doc/auto#transformers.AutoFeatureExtractor">AutoFeatureExtractor</a>. See
<code>AutoFeatureExtractor.__call__()</code> for details.`,name:"pixel_values"},{anchor:"transformers.MaskFormerForInstanceSegmentation.forward.pixel_mask",description:`<strong>pixel_mask</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, height, width)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding pixel values. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for pixels that are real (i.e. <strong>not masked</strong>),</li>
<li>0 for pixels that are padding (i.e. <strong>masked</strong>).</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"pixel_mask"},{anchor:"transformers.MaskFormerForInstanceSegmentation.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.MaskFormerForInstanceSegmentation.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of Detr&#x2019;s decoder attention layers.`,name:"output_attentions"},{anchor:"transformers.MaskFormerForInstanceSegmentation.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <code>~MaskFormerModelOutput</code> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.MaskFormerForInstanceSegmentation.forward.mask_labels",description:`<strong>mask_labels</strong> (<code>List[torch.Tensor]</code>, <em>optional</em>) &#x2014;
List of mask labels of shape <code>(num_labels, height, width)</code> to be fed to a model`,name:"mask_labels"},{anchor:"transformers.MaskFormerForInstanceSegmentation.forward.class_labels",description:`<strong>class_labels</strong> (<code>List[torch.LongTensor]</code>, <em>optional</em>) &#x2014;
list of target class labels of shape <code>(num_labels, height, width)</code> to be fed to a model. They identify the
labels of <code>mask_labels</code>, e.g. the label of <code>mask_labels[i][j]</code> if <code>class_labels[i][j]</code>.`,name:"class_labels"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/maskformer/modeling_maskformer.py#L2530",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/model_doc/maskformer#transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput"
>transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerConfig"
>MaskFormerConfig</a>) and inputs.</p>
<ul>
<li><strong>loss</strong> (<code>torch.Tensor</code>, <em>optional</em>) \u2014 The computed loss, returned when labels are present.</li>
<li><strong>class_queries_logits</strong> (<code>torch.FloatTensor</code>) \u2014 A tensor of shape <code>(batch_size, num_queries, num_labels + 1)</code> representing the proposed classes for each
query. Note the <code>+ 1</code> is needed because we incorporate the null class.</li>
<li><strong>masks_queries_logits</strong> (<code>torch.FloatTensor</code>) \u2014 A tensor of shape <code>(batch_size, num_queries, height, width)</code> representing the proposed masks for each
query.</li>
<li><strong>encoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) \u2014 Last hidden states (final feature map) of the last stage of the encoder model (backbone).</li>
<li><strong>pixel_decoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) \u2014 Last hidden states (final feature map) of the last stage of the pixel decoder model (FPN).</li>
<li><strong>transformer_decoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Last hidden states (final feature map) of the last stage of the transformer decoder model.</li>
<li><strong>encoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also called feature maps) of the encoder
model at the output of each stage.</li>
<li><strong>pixel_decoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also called feature maps) of the pixel
decoder model at the output of each stage.</li>
<li><strong>transformer_decoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, sequence_length, hidden_size)</code>. Hidden-states of the transformer decoder at the output
of each stage.</li>
<li><strong>hidden_states</strong> <code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> containing <code>encoder_hidden_states</code>, <code>pixel_decoder_hidden_states</code> and
<code>decoder_hidden_states</code>.</li>
<li><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>. Attentions weights from Detr\u2019s decoder after the attention softmax, used to compute the
weighted average in the self-attention heads.</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/model_doc/maskformer#transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput"
>transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),ze=new ya({props:{$$slots:{default:[bl]},$$scope:{ctx:P}}}),Oe=new Ma({props:{anchor:"transformers.MaskFormerForInstanceSegmentation.forward.example",$$slots:{default:[Fl]},$$scope:{ctx:P}}}),Le=new Ma({props:{anchor:"transformers.MaskFormerForInstanceSegmentation.forward.example-2",$$slots:{default:[vl]},$$scope:{ctx:P}}}),{c(){p=r("meta"),b=l(),u=r("h1"),g=r("a"),k=r("span"),F(d.$$.fragment),_=l(),C=r("span"),Ea=s("MaskFormer"),bs=l(),F(he.$$.fragment),Fs=l(),ee=r("h2"),fe=r("a"),xo=r("span"),F(He.$$.fragment),Ia=l(),yo=r("span"),Pa=s("Overview"),vs=l(),ge=r("p"),ja=s("The MaskFormer model was proposed in "),Ue=r("a"),za=s("Per-Pixel Classification is Not All You Need for Semantic Segmentation"),Oa=s(" by Bowen Cheng, Alexander G. Schwing, Alexander Kirillov. MaskFormer addresses semantic segmentation with a mask classification paradigm instead of performing classic pixel-level classification."),ws=l(),Bt=r("p"),La=s("The abstract from the paper is the following:"),xs=l(),Wt=r("p"),Mo=r("em"),Aa=s("Modern approaches typically formulate semantic segmentation as a per-pixel classification task, while instance-level segmentation is handled with an alternative mask classification. Our key insight: mask classification is sufficiently general to solve both semantic- and instance-level segmentation tasks in a unified manner using the exact same model, loss, and training procedure. Following this observation, we propose MaskFormer, a simple mask classification model which predicts a set of binary masks, each associated with a single global class label prediction. Overall, the proposed mask classification-based method simplifies the landscape of effective approaches to semantic and panoptic segmentation tasks and shows excellent empirical results. In particular, we observe that MaskFormer outperforms per-pixel classification baselines when the number of classes is large. Our mask classification-based method outperforms both current state-of-the-art semantic (55.6 mIoU on ADE20K) and panoptic segmentation (52.7 PQ on COCO) models."),ys=l(),Vt=r("p"),Ca=s("Tips:"),Ms=l(),R=r("ul"),D=r("li"),qa=s("MaskFormer\u2019s Transformer decoder is identical to the decoder of "),Gt=r("a"),Da=s("DETR"),Sa=s(". During training, the authors of DETR did find it helpful to use auxiliary losses in the decoder, especially to help the model output the correct number of objects of each class. If you set the parameter "),To=r("code"),Na=s("use_auxilary_loss"),Ra=s(" of "),Kt=r("a"),Ha=s("MaskFormerConfig"),Ua=s(" to "),$o=r("code"),Ba=s("True"),Wa=s(", then prediction feedforward neural networks and Hungarian losses are added after each decoder layer (with the FFNs sharing parameters)."),Va=l(),S=r("li"),Ga=s(`If you want to train the model in a distributed environment across multiple nodes, then one should update the
`),Eo=r("code"),Ka=s("get_num_masks"),Qa=s(" function inside in the "),Io=r("code"),Xa=s("MaskFormerLoss"),Ya=s(" class of "),Po=r("code"),Ja=s("modeling_maskformer.py"),Za=s(`. When training on multiple nodes, this should be
set to the average number of target masks across all nodes, as can be seen in the original implementation `),Be=r("a"),er=s("here"),tr=s("."),or=l(),We=r("li"),sr=s("One can use "),Qt=r("a"),ar=s("MaskFormerFeatureExtractor"),rr=s(" to prepare images for the model and optional targets for the model."),nr=l(),N=r("li"),ir=s("To get the final segmentation, depending on the task, you can call "),Xt=r("a"),cr=s("post_process_semantic_segmentation()"),dr=s(" or "),Yt=r("a"),lr=s("post_process_panoptic_segmentation()"),mr=s(". Both tasks can be solved using "),Jt=r("a"),pr=s("MaskFormerForInstanceSegmentation"),hr=s(" output, panoptic segmentation accepts an optional "),jo=r("code"),fr=s("label_ids_to_fuse"),gr=s(" argument to fuse instances of the target object/s (e.g. sky) together."),Ts=l(),ue=r("p"),ur=s("The figure below illustrates the architecture of MaskFormer. Taken from the "),Ve=r("a"),_r=s("original paper"),kr=s("."),$s=l(),Ge=r("img"),Es=l(),X=r("p"),br=s("This model was contributed by "),Ke=r("a"),Fr=s("francesco"),vr=s(". The original code can be found "),Qe=r("a"),wr=s("here"),xr=s("."),Is=l(),te=r("h2"),_e=r("a"),zo=r("span"),F(Xe.$$.fragment),yr=l(),Oo=r("span"),Mr=s("Resources"),Ps=l(),F(Ye.$$.fragment),js=l(),Zt=r("ul"),Je=r("li"),Tr=s("All notebooks that illustrate inference as well as fine-tuning on custom data with MaskFormer can be found "),Ze=r("a"),$r=s("here"),Er=s("."),zs=l(),oe=r("h2"),ke=r("a"),Lo=r("span"),F(et.$$.fragment),Ir=l(),Ao=r("span"),Pr=s("MaskFormer specific outputs"),Os=l(),se=r("div"),F(tt.$$.fragment),jr=l(),ot=r("p"),zr=s("Class for outputs of "),eo=r("a"),Or=s("MaskFormerModel"),Lr=s(". This class returns all the needed hidden states to compute the logits."),Ls=l(),B=r("div"),F(st.$$.fragment),Ar=l(),at=r("p"),Cr=s("Class for outputs of "),to=r("a"),qr=s("MaskFormerForInstanceSegmentation"),Dr=s("."),Sr=l(),W=r("p"),Nr=s("This output can be directly passed to "),oo=r("a"),Rr=s("post_process_semantic_segmentation()"),Hr=s(` or or
`),so=r("a"),Ur=s("post_process_instance_segmentation()"),Br=s(` or
`),ao=r("a"),Wr=s("post_process_panoptic_segmentation()"),Vr=s(" depending on the task. Please, see\n[`~MaskFormerFeatureExtractor] for details regarding usage."),As=l(),ae=r("h2"),be=r("a"),Co=r("span"),F(rt.$$.fragment),Gr=l(),qo=r("span"),Kr=s("MaskFormerConfig"),Cs=l(),I=r("div"),F(nt.$$.fragment),Qr=l(),V=r("p"),Xr=s("This is the configuration class to store the configuration of a "),ro=r("a"),Yr=s("MaskFormerModel"),Jr=s(`. It is used to instantiate a
MaskFormer model according to the specified arguments, defining the model architecture. Instantiating a
configuration with the defaults will yield a similar configuration to that of the MaskFormer
`),it=r("a"),Zr=s("facebook/maskformer-swin-base-ade"),en=s(` architecture trained
on `),ct=r("a"),tn=s("ADE20k-150"),on=s("."),sn=l(),re=r("p"),an=s("Configuration objects inherit from "),no=r("a"),rn=s("PretrainedConfig"),nn=s(` and can be used to control the model outputs. Read the
documentation from `),io=r("a"),cn=s("PretrainedConfig"),dn=s(" for more information."),ln=l(),dt=r("p"),mn=s("Currently, MaskFormer only supports the "),co=r("a"),pn=s("Swin Transformer"),hn=s(" as backbone."),fn=l(),F(Fe.$$.fragment),gn=l(),ve=r("div"),F(lt.$$.fragment),un=l(),mt=r("p"),_n=s("Instantiate a "),lo=r("a"),kn=s("MaskFormerConfig"),bn=s(` (or a derived class) from a pre-trained backbone model configuration and DETR model
configuration.`),Fn=l(),we=r("div"),F(pt.$$.fragment),vn=l(),ht=r("p"),wn=s("Serializes this instance to a Python dictionary. Override the default "),mo=r("a"),xn=s("to_dict()"),yn=s("."),qs=l(),ne=r("h2"),xe=r("a"),Do=r("span"),F(ft.$$.fragment),Mn=l(),So=r("span"),Tn=s("MaskFormerFeatureExtractor"),Ds=l(),$=r("div"),F(gt.$$.fragment),$n=l(),No=r("p"),En=s(`Constructs a MaskFormer feature extractor. The feature extractor can be used to prepare image(s) and optional
targets for the model.`),In=l(),ut=r("p"),Pn=s("This feature extractor inherits from "),po=r("a"),jn=s("FeatureExtractionMixin"),zn=s(` which contains most of the main methods. Users
should refer to this superclass for more information regarding those methods.`),On=l(),E=r("div"),F(_t.$$.fragment),Ln=l(),Ro=r("p"),An=s(`Main method to prepare for the model one or several image(s) and optional annotations. Images are by default
padded up to the largest image in a batch, and a pixel mask is created that indicates which pixels are
real/which are padding.`),Cn=l(),kt=r("p"),qn=s(`Segmentation maps can be instance, semantic or panoptic segmentation maps. In case of instance and panoptic
segmentation, one needs to provide `),Ho=r("code"),Dn=s("instance_id_to_semantic_id"),Sn=s(`, which is a mapping from instance/segment ids
to semantic category ids.`),Nn=l(),Uo=r("p"),Rn=s(`MaskFormer addresses all 3 forms of segmentation (instance, semantic and panoptic) in the same way, namely by
converting the segmentation maps to a set of binary masks with corresponding classes.`),Hn=l(),bt=r("p"),Un=s(`In case of instance segmentation, the segmentation maps contain the instance ids, and
`),Bo=r("code"),Bn=s("instance_id_to_semantic_id"),Wn=s(" maps instance IDs to their corresponding semantic category."),Vn=l(),G=r("p"),Gn=s(`In case of semantic segmentation, the segmentation maps contain the semantic category ids. Let\u2019s see an
example, assuming `),Wo=r("code"),Kn=s("segmentation_maps = [[2,6,7,9]]"),Qn=s(", the output will contain "),Vo=r("code"),Xn=s("mask_labels = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]"),Yn=s(" (four binary masks) and "),Go=r("code"),Jn=s("class_labels = [2,6,7,9]"),Zn=s(`, the labels for
each mask.`),ei=l(),Ft=r("p"),ti=s(`In case of panoptic segmentation, the segmentation maps contain the segment ids, and
`),Ko=r("code"),oi=s("instance_id_to_semantic_id"),si=s(" maps segment IDs to their corresponding semantic category."),ai=l(),F(ye.$$.fragment),ri=l(),T=r("div"),F(vt.$$.fragment),ni=l(),Qo=r("p"),ii=s("Encode a list of pixel values and an optional list of corresponding segmentation maps."),ci=l(),ie=r("p"),di=s(`This method is useful if you have resized and normalized your images and segmentation maps yourself, using a
library like `),wt=r("a"),li=s("torchvision"),mi=s(` or
`),xt=r("a"),pi=s("albumentations"),hi=s("."),fi=l(),yt=r("p"),gi=s("Images are padded up to the largest image in a batch, and a corresponding "),Xo=r("code"),ui=s("pixel_mask"),_i=s(" is created."),ki=l(),Mt=r("p"),bi=s(`Segmentation maps can be instance, semantic or panoptic segmentation maps. In case of instance and panoptic
segmentation, one needs to provide `),Yo=r("code"),Fi=s("instance_id_to_semantic_id"),vi=s(`, which is a mapping from instance/segment ids
to semantic category ids.`),wi=l(),Jo=r("p"),xi=s(`MaskFormer addresses all 3 forms of segmentation (instance, semantic and panoptic) in the same way, namely by
converting the segmentation maps to a set of binary masks with corresponding classes.`),yi=l(),Tt=r("p"),Mi=s(`In case of instance segmentation, the segmentation maps contain the instance ids, and
`),Zo=r("code"),Ti=s("instance_id_to_semantic_id"),$i=s(" maps instance IDs to their corresponding semantic category."),Ei=l(),K=r("p"),Ii=s(`In case of semantic segmentation, the segmentation maps contain the semantic category ids. Let\u2019s see an
example, assuming `),es=r("code"),Pi=s("segmentation_maps = [[2,6,7,9]]"),ji=s(", the output will contain "),ts=r("code"),zi=s("mask_labels = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]"),Oi=s(" (four binary masks) and "),os=r("code"),Li=s("class_labels = [2,6,7,9]"),Ai=s(`, the labels for
each mask.`),Ci=l(),$t=r("p"),qi=s(`In case of panoptic segmentation, the segmentation maps contain the segment ids, and
`),ss=r("code"),Di=s("instance_id_to_semantic_id"),Si=s(" maps segment IDs to their corresponding semantic category."),Ni=l(),Me=r("div"),F(Et.$$.fragment),Ri=l(),It=r("p"),Hi=s("Converts the output of "),ho=r("a"),Ui=s("MaskFormerForInstanceSegmentation"),Bi=s(` into semantic segmentation maps. Only supports
PyTorch.`),Wi=l(),Te=r("div"),F(Pt.$$.fragment),Vi=l(),jt=r("p"),Gi=s("Converts the output of "),as=r("code"),Ki=s("MaskFormerForInstanceSegmentationOutput"),Qi=s(` into instance segmentation predictions. Only
supports PyTorch.`),Xi=l(),$e=r("div"),F(zt.$$.fragment),Yi=l(),Ot=r("p"),Ji=s("Converts the output of "),rs=r("code"),Zi=s("MaskFormerForInstanceSegmentationOutput"),ec=s(` into image panoptic segmentation
predictions. Only supports PyTorch.`),Ss=l(),ce=r("h2"),Ee=r("a"),ns=r("span"),F(Lt.$$.fragment),tc=l(),is=r("span"),oc=s("MaskFormerModel"),Ns=l(),Q=r("div"),F(At.$$.fragment),sc=l(),Ct=r("p"),ac=s(`The bare MaskFormer Model outputting raw hidden-states without any specific head on top.
This model is a PyTorch `),qt=r("a"),rc=s("torch.nn.Module"),nc=s(` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),ic=l(),H=r("div"),F(Dt.$$.fragment),cc=l(),de=r("p"),dc=s("The "),fo=r("a"),lc=s("MaskFormerModel"),mc=s(" forward method, overrides the "),cs=r("code"),pc=s("__call__"),hc=s(" special method."),fc=l(),F(Ie.$$.fragment),gc=l(),F(Pe.$$.fragment),Rs=l(),le=r("h2"),je=r("a"),ds=r("span"),F(St.$$.fragment),uc=l(),ls=r("span"),_c=s("MaskFormerForInstanceSegmentation"),Hs=l(),me=r("div"),F(Nt.$$.fragment),kc=l(),z=r("div"),F(Rt.$$.fragment),bc=l(),pe=r("p"),Fc=s("The "),go=r("a"),vc=s("MaskFormerForInstanceSegmentation"),wc=s(" forward method, overrides the "),ms=r("code"),xc=s("__call__"),yc=s(" special method."),Mc=l(),F(ze.$$.fragment),Tc=l(),ps=r("p"),$c=s("Examples:"),Ec=l(),F(Oe.$$.fragment),Ic=l(),F(Le.$$.fragment),this.h()},l(t){const h=ll('[data-svelte="svelte-1phssyn"]',document.head);p=n(h,"META",{name:!0,content:!0}),h.forEach(o),b=m(t),u=n(t,"H1",{class:!0});var Ht=i(u);g=n(Ht,"A",{id:!0,class:!0,href:!0});var hs=i(g);k=n(hs,"SPAN",{});var fs=i(k);v(d.$$.fragment,fs),fs.forEach(o),hs.forEach(o),_=m(Ht),C=n(Ht,"SPAN",{});var gs=i(C);Ea=a(gs,"MaskFormer"),gs.forEach(o),Ht.forEach(o),bs=m(t),v(he.$$.fragment,t),Fs=m(t),ee=n(t,"H2",{class:!0});var Ut=i(ee);fe=n(Ut,"A",{id:!0,class:!0,href:!0});var us=i(fe);xo=n(us,"SPAN",{});var _s=i(xo);v(He.$$.fragment,_s),_s.forEach(o),us.forEach(o),Ia=m(Ut),yo=n(Ut,"SPAN",{});var ks=i(yo);Pa=a(ks,"Overview"),ks.forEach(o),Ut.forEach(o),vs=m(t),ge=n(t,"P",{});var Bs=i(ge);ja=a(Bs,"The MaskFormer model was proposed in "),Ue=n(Bs,"A",{href:!0,rel:!0});var jc=i(Ue);za=a(jc,"Per-Pixel Classification is Not All You Need for Semantic Segmentation"),jc.forEach(o),Oa=a(Bs," by Bowen Cheng, Alexander G. Schwing, Alexander Kirillov. MaskFormer addresses semantic segmentation with a mask classification paradigm instead of performing classic pixel-level classification."),Bs.forEach(o),ws=m(t),Bt=n(t,"P",{});var zc=i(Bt);La=a(zc,"The abstract from the paper is the following:"),zc.forEach(o),xs=m(t),Wt=n(t,"P",{});var Oc=i(Wt);Mo=n(Oc,"EM",{});var Lc=i(Mo);Aa=a(Lc,"Modern approaches typically formulate semantic segmentation as a per-pixel classification task, while instance-level segmentation is handled with an alternative mask classification. Our key insight: mask classification is sufficiently general to solve both semantic- and instance-level segmentation tasks in a unified manner using the exact same model, loss, and training procedure. Following this observation, we propose MaskFormer, a simple mask classification model which predicts a set of binary masks, each associated with a single global class label prediction. Overall, the proposed mask classification-based method simplifies the landscape of effective approaches to semantic and panoptic segmentation tasks and shows excellent empirical results. In particular, we observe that MaskFormer outperforms per-pixel classification baselines when the number of classes is large. Our mask classification-based method outperforms both current state-of-the-art semantic (55.6 mIoU on ADE20K) and panoptic segmentation (52.7 PQ on COCO) models."),Lc.forEach(o),Oc.forEach(o),ys=m(t),Vt=n(t,"P",{});var Ac=i(Vt);Ca=a(Ac,"Tips:"),Ac.forEach(o),Ms=m(t),R=n(t,"UL",{});var Ae=i(R);D=n(Ae,"LI",{});var Y=i(D);qa=a(Y,"MaskFormer\u2019s Transformer decoder is identical to the decoder of "),Gt=n(Y,"A",{href:!0});var Cc=i(Gt);Da=a(Cc,"DETR"),Cc.forEach(o),Sa=a(Y,". During training, the authors of DETR did find it helpful to use auxiliary losses in the decoder, especially to help the model output the correct number of objects of each class. If you set the parameter "),To=n(Y,"CODE",{});var qc=i(To);Na=a(qc,"use_auxilary_loss"),qc.forEach(o),Ra=a(Y," of "),Kt=n(Y,"A",{href:!0});var Dc=i(Kt);Ha=a(Dc,"MaskFormerConfig"),Dc.forEach(o),Ua=a(Y," to "),$o=n(Y,"CODE",{});var Sc=i($o);Ba=a(Sc,"True"),Sc.forEach(o),Wa=a(Y,", then prediction feedforward neural networks and Hungarian losses are added after each decoder layer (with the FFNs sharing parameters)."),Y.forEach(o),Va=m(Ae),S=n(Ae,"LI",{});var J=i(S);Ga=a(J,`If you want to train the model in a distributed environment across multiple nodes, then one should update the
`),Eo=n(J,"CODE",{});var Nc=i(Eo);Ka=a(Nc,"get_num_masks"),Nc.forEach(o),Qa=a(J," function inside in the "),Io=n(J,"CODE",{});var Rc=i(Io);Xa=a(Rc,"MaskFormerLoss"),Rc.forEach(o),Ya=a(J," class of "),Po=n(J,"CODE",{});var Hc=i(Po);Ja=a(Hc,"modeling_maskformer.py"),Hc.forEach(o),Za=a(J,`. When training on multiple nodes, this should be
set to the average number of target masks across all nodes, as can be seen in the original implementation `),Be=n(J,"A",{href:!0,rel:!0});var Uc=i(Be);er=a(Uc,"here"),Uc.forEach(o),tr=a(J,"."),J.forEach(o),or=m(Ae),We=n(Ae,"LI",{});var Ws=i(We);sr=a(Ws,"One can use "),Qt=n(Ws,"A",{href:!0});var Bc=i(Qt);ar=a(Bc,"MaskFormerFeatureExtractor"),Bc.forEach(o),rr=a(Ws," to prepare images for the model and optional targets for the model."),Ws.forEach(o),nr=m(Ae),N=n(Ae,"LI",{});var Z=i(N);ir=a(Z,"To get the final segmentation, depending on the task, you can call "),Xt=n(Z,"A",{href:!0});var Wc=i(Xt);cr=a(Wc,"post_process_semantic_segmentation()"),Wc.forEach(o),dr=a(Z," or "),Yt=n(Z,"A",{href:!0});var Vc=i(Yt);lr=a(Vc,"post_process_panoptic_segmentation()"),Vc.forEach(o),mr=a(Z,". Both tasks can be solved using "),Jt=n(Z,"A",{href:!0});var Gc=i(Jt);pr=a(Gc,"MaskFormerForInstanceSegmentation"),Gc.forEach(o),hr=a(Z," output, panoptic segmentation accepts an optional "),jo=n(Z,"CODE",{});var Kc=i(jo);fr=a(Kc,"label_ids_to_fuse"),Kc.forEach(o),gr=a(Z," argument to fuse instances of the target object/s (e.g. sky) together."),Z.forEach(o),Ae.forEach(o),Ts=m(t),ue=n(t,"P",{});var Vs=i(ue);ur=a(Vs,"The figure below illustrates the architecture of MaskFormer. Taken from the "),Ve=n(Vs,"A",{href:!0,rel:!0});var Qc=i(Ve);_r=a(Qc,"original paper"),Qc.forEach(o),kr=a(Vs,"."),Vs.forEach(o),$s=m(t),Ge=n(t,"IMG",{width:!0,src:!0}),Es=m(t),X=n(t,"P",{});var uo=i(X);br=a(uo,"This model was contributed by "),Ke=n(uo,"A",{href:!0,rel:!0});var Xc=i(Ke);Fr=a(Xc,"francesco"),Xc.forEach(o),vr=a(uo,". The original code can be found "),Qe=n(uo,"A",{href:!0,rel:!0});var Yc=i(Qe);wr=a(Yc,"here"),Yc.forEach(o),xr=a(uo,"."),uo.forEach(o),Is=m(t),te=n(t,"H2",{class:!0});var Gs=i(te);_e=n(Gs,"A",{id:!0,class:!0,href:!0});var Jc=i(_e);zo=n(Jc,"SPAN",{});var Zc=i(zo);v(Xe.$$.fragment,Zc),Zc.forEach(o),Jc.forEach(o),yr=m(Gs),Oo=n(Gs,"SPAN",{});var ed=i(Oo);Mr=a(ed,"Resources"),ed.forEach(o),Gs.forEach(o),Ps=m(t),v(Ye.$$.fragment,t),js=m(t),Zt=n(t,"UL",{});var td=i(Zt);Je=n(td,"LI",{});var Ks=i(Je);Tr=a(Ks,"All notebooks that illustrate inference as well as fine-tuning on custom data with MaskFormer can be found "),Ze=n(Ks,"A",{href:!0,rel:!0});var od=i(Ze);$r=a(od,"here"),od.forEach(o),Er=a(Ks,"."),Ks.forEach(o),td.forEach(o),zs=m(t),oe=n(t,"H2",{class:!0});var Qs=i(oe);ke=n(Qs,"A",{id:!0,class:!0,href:!0});var sd=i(ke);Lo=n(sd,"SPAN",{});var ad=i(Lo);v(et.$$.fragment,ad),ad.forEach(o),sd.forEach(o),Ir=m(Qs),Ao=n(Qs,"SPAN",{});var rd=i(Ao);Pr=a(rd,"MaskFormer specific outputs"),rd.forEach(o),Qs.forEach(o),Os=m(t),se=n(t,"DIV",{class:!0});var Xs=i(se);v(tt.$$.fragment,Xs),jr=m(Xs),ot=n(Xs,"P",{});var Ys=i(ot);zr=a(Ys,"Class for outputs of "),eo=n(Ys,"A",{href:!0});var nd=i(eo);Or=a(nd,"MaskFormerModel"),nd.forEach(o),Lr=a(Ys,". This class returns all the needed hidden states to compute the logits."),Ys.forEach(o),Xs.forEach(o),Ls=m(t),B=n(t,"DIV",{class:!0});var _o=i(B);v(st.$$.fragment,_o),Ar=m(_o),at=n(_o,"P",{});var Js=i(at);Cr=a(Js,"Class for outputs of "),to=n(Js,"A",{href:!0});var id=i(to);qr=a(id,"MaskFormerForInstanceSegmentation"),id.forEach(o),Dr=a(Js,"."),Js.forEach(o),Sr=m(_o),W=n(_o,"P",{});var Ce=i(W);Nr=a(Ce,"This output can be directly passed to "),oo=n(Ce,"A",{href:!0});var cd=i(oo);Rr=a(cd,"post_process_semantic_segmentation()"),cd.forEach(o),Hr=a(Ce,` or or
`),so=n(Ce,"A",{href:!0});var dd=i(so);Ur=a(dd,"post_process_instance_segmentation()"),dd.forEach(o),Br=a(Ce,` or
`),ao=n(Ce,"A",{href:!0});var ld=i(ao);Wr=a(ld,"post_process_panoptic_segmentation()"),ld.forEach(o),Vr=a(Ce," depending on the task. Please, see\n[`~MaskFormerFeatureExtractor] for details regarding usage."),Ce.forEach(o),_o.forEach(o),As=m(t),ae=n(t,"H2",{class:!0});var Zs=i(ae);be=n(Zs,"A",{id:!0,class:!0,href:!0});var md=i(be);Co=n(md,"SPAN",{});var pd=i(Co);v(rt.$$.fragment,pd),pd.forEach(o),md.forEach(o),Gr=m(Zs),qo=n(Zs,"SPAN",{});var hd=i(qo);Kr=a(hd,"MaskFormerConfig"),hd.forEach(o),Zs.forEach(o),Cs=m(t),I=n(t,"DIV",{class:!0});var q=i(I);v(nt.$$.fragment,q),Qr=m(q),V=n(q,"P",{});var qe=i(V);Xr=a(qe,"This is the configuration class to store the configuration of a "),ro=n(qe,"A",{href:!0});var fd=i(ro);Yr=a(fd,"MaskFormerModel"),fd.forEach(o),Jr=a(qe,`. It is used to instantiate a
MaskFormer model according to the specified arguments, defining the model architecture. Instantiating a
configuration with the defaults will yield a similar configuration to that of the MaskFormer
`),it=n(qe,"A",{href:!0,rel:!0});var gd=i(it);Zr=a(gd,"facebook/maskformer-swin-base-ade"),gd.forEach(o),en=a(qe,` architecture trained
on `),ct=n(qe,"A",{href:!0,rel:!0});var ud=i(ct);tn=a(ud,"ADE20k-150"),ud.forEach(o),on=a(qe,"."),qe.forEach(o),sn=m(q),re=n(q,"P",{});var ko=i(re);an=a(ko,"Configuration objects inherit from "),no=n(ko,"A",{href:!0});var _d=i(no);rn=a(_d,"PretrainedConfig"),_d.forEach(o),nn=a(ko,` and can be used to control the model outputs. Read the
documentation from `),io=n(ko,"A",{href:!0});var kd=i(io);cn=a(kd,"PretrainedConfig"),kd.forEach(o),dn=a(ko," for more information."),ko.forEach(o),ln=m(q),dt=n(q,"P",{});var ea=i(dt);mn=a(ea,"Currently, MaskFormer only supports the "),co=n(ea,"A",{href:!0});var bd=i(co);pn=a(bd,"Swin Transformer"),bd.forEach(o),hn=a(ea," as backbone."),ea.forEach(o),fn=m(q),v(Fe.$$.fragment,q),gn=m(q),ve=n(q,"DIV",{class:!0});var ta=i(ve);v(lt.$$.fragment,ta),un=m(ta),mt=n(ta,"P",{});var oa=i(mt);_n=a(oa,"Instantiate a "),lo=n(oa,"A",{href:!0});var Fd=i(lo);kn=a(Fd,"MaskFormerConfig"),Fd.forEach(o),bn=a(oa,` (or a derived class) from a pre-trained backbone model configuration and DETR model
configuration.`),oa.forEach(o),ta.forEach(o),Fn=m(q),we=n(q,"DIV",{class:!0});var sa=i(we);v(pt.$$.fragment,sa),vn=m(sa),ht=n(sa,"P",{});var aa=i(ht);wn=a(aa,"Serializes this instance to a Python dictionary. Override the default "),mo=n(aa,"A",{href:!0});var vd=i(mo);xn=a(vd,"to_dict()"),vd.forEach(o),yn=a(aa,"."),aa.forEach(o),sa.forEach(o),q.forEach(o),qs=m(t),ne=n(t,"H2",{class:!0});var ra=i(ne);xe=n(ra,"A",{id:!0,class:!0,href:!0});var wd=i(xe);Do=n(wd,"SPAN",{});var xd=i(Do);v(ft.$$.fragment,xd),xd.forEach(o),wd.forEach(o),Mn=m(ra),So=n(ra,"SPAN",{});var yd=i(So);Tn=a(yd,"MaskFormerFeatureExtractor"),yd.forEach(o),ra.forEach(o),Ds=m(t),$=n(t,"DIV",{class:!0});var O=i($);v(gt.$$.fragment,O),$n=m(O),No=n(O,"P",{});var Md=i(No);En=a(Md,`Constructs a MaskFormer feature extractor. The feature extractor can be used to prepare image(s) and optional
targets for the model.`),Md.forEach(o),In=m(O),ut=n(O,"P",{});var na=i(ut);Pn=a(na,"This feature extractor inherits from "),po=n(na,"A",{href:!0});var Td=i(po);jn=a(Td,"FeatureExtractionMixin"),Td.forEach(o),zn=a(na,` which contains most of the main methods. Users
should refer to this superclass for more information regarding those methods.`),na.forEach(o),On=m(O),E=n(O,"DIV",{class:!0});var L=i(E);v(_t.$$.fragment,L),Ln=m(L),Ro=n(L,"P",{});var $d=i(Ro);An=a($d,`Main method to prepare for the model one or several image(s) and optional annotations. Images are by default
padded up to the largest image in a batch, and a pixel mask is created that indicates which pixels are
real/which are padding.`),$d.forEach(o),Cn=m(L),kt=n(L,"P",{});var ia=i(kt);qn=a(ia,`Segmentation maps can be instance, semantic or panoptic segmentation maps. In case of instance and panoptic
segmentation, one needs to provide `),Ho=n(ia,"CODE",{});var Ed=i(Ho);Dn=a(Ed,"instance_id_to_semantic_id"),Ed.forEach(o),Sn=a(ia,`, which is a mapping from instance/segment ids
to semantic category ids.`),ia.forEach(o),Nn=m(L),Uo=n(L,"P",{});var Id=i(Uo);Rn=a(Id,`MaskFormer addresses all 3 forms of segmentation (instance, semantic and panoptic) in the same way, namely by
converting the segmentation maps to a set of binary masks with corresponding classes.`),Id.forEach(o),Hn=m(L),bt=n(L,"P",{});var ca=i(bt);Un=a(ca,`In case of instance segmentation, the segmentation maps contain the instance ids, and
`),Bo=n(ca,"CODE",{});var Pd=i(Bo);Bn=a(Pd,"instance_id_to_semantic_id"),Pd.forEach(o),Wn=a(ca," maps instance IDs to their corresponding semantic category."),ca.forEach(o),Vn=m(L),G=n(L,"P",{});var De=i(G);Gn=a(De,`In case of semantic segmentation, the segmentation maps contain the semantic category ids. Let\u2019s see an
example, assuming `),Wo=n(De,"CODE",{});var jd=i(Wo);Kn=a(jd,"segmentation_maps = [[2,6,7,9]]"),jd.forEach(o),Qn=a(De,", the output will contain "),Vo=n(De,"CODE",{});var zd=i(Vo);Xn=a(zd,"mask_labels = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]"),zd.forEach(o),Yn=a(De," (four binary masks) and "),Go=n(De,"CODE",{});var Od=i(Go);Jn=a(Od,"class_labels = [2,6,7,9]"),Od.forEach(o),Zn=a(De,`, the labels for
each mask.`),De.forEach(o),ei=m(L),Ft=n(L,"P",{});var da=i(Ft);ti=a(da,`In case of panoptic segmentation, the segmentation maps contain the segment ids, and
`),Ko=n(da,"CODE",{});var Ld=i(Ko);oi=a(Ld,"instance_id_to_semantic_id"),Ld.forEach(o),si=a(da," maps segment IDs to their corresponding semantic category."),da.forEach(o),ai=m(L),v(ye.$$.fragment,L),L.forEach(o),ri=m(O),T=n(O,"DIV",{class:!0});var j=i(T);v(vt.$$.fragment,j),ni=m(j),Qo=n(j,"P",{});var Ad=i(Qo);ii=a(Ad,"Encode a list of pixel values and an optional list of corresponding segmentation maps."),Ad.forEach(o),ci=m(j),ie=n(j,"P",{});var bo=i(ie);di=a(bo,`This method is useful if you have resized and normalized your images and segmentation maps yourself, using a
library like `),wt=n(bo,"A",{href:!0,rel:!0});var Cd=i(wt);li=a(Cd,"torchvision"),Cd.forEach(o),mi=a(bo,` or
`),xt=n(bo,"A",{href:!0,rel:!0});var qd=i(xt);pi=a(qd,"albumentations"),qd.forEach(o),hi=a(bo,"."),bo.forEach(o),fi=m(j),yt=n(j,"P",{});var la=i(yt);gi=a(la,"Images are padded up to the largest image in a batch, and a corresponding "),Xo=n(la,"CODE",{});var Dd=i(Xo);ui=a(Dd,"pixel_mask"),Dd.forEach(o),_i=a(la," is created."),la.forEach(o),ki=m(j),Mt=n(j,"P",{});var ma=i(Mt);bi=a(ma,`Segmentation maps can be instance, semantic or panoptic segmentation maps. In case of instance and panoptic
segmentation, one needs to provide `),Yo=n(ma,"CODE",{});var Sd=i(Yo);Fi=a(Sd,"instance_id_to_semantic_id"),Sd.forEach(o),vi=a(ma,`, which is a mapping from instance/segment ids
to semantic category ids.`),ma.forEach(o),wi=m(j),Jo=n(j,"P",{});var Nd=i(Jo);xi=a(Nd,`MaskFormer addresses all 3 forms of segmentation (instance, semantic and panoptic) in the same way, namely by
converting the segmentation maps to a set of binary masks with corresponding classes.`),Nd.forEach(o),yi=m(j),Tt=n(j,"P",{});var pa=i(Tt);Mi=a(pa,`In case of instance segmentation, the segmentation maps contain the instance ids, and
`),Zo=n(pa,"CODE",{});var Rd=i(Zo);Ti=a(Rd,"instance_id_to_semantic_id"),Rd.forEach(o),$i=a(pa," maps instance IDs to their corresponding semantic category."),pa.forEach(o),Ei=m(j),K=n(j,"P",{});var Se=i(K);Ii=a(Se,`In case of semantic segmentation, the segmentation maps contain the semantic category ids. Let\u2019s see an
example, assuming `),es=n(Se,"CODE",{});var Hd=i(es);Pi=a(Hd,"segmentation_maps = [[2,6,7,9]]"),Hd.forEach(o),ji=a(Se,", the output will contain "),ts=n(Se,"CODE",{});var Ud=i(ts);zi=a(Ud,"mask_labels = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]"),Ud.forEach(o),Oi=a(Se," (four binary masks) and "),os=n(Se,"CODE",{});var Bd=i(os);Li=a(Bd,"class_labels = [2,6,7,9]"),Bd.forEach(o),Ai=a(Se,`, the labels for
each mask.`),Se.forEach(o),Ci=m(j),$t=n(j,"P",{});var ha=i($t);qi=a(ha,`In case of panoptic segmentation, the segmentation maps contain the segment ids, and
`),ss=n(ha,"CODE",{});var Wd=i(ss);Di=a(Wd,"instance_id_to_semantic_id"),Wd.forEach(o),Si=a(ha," maps segment IDs to their corresponding semantic category."),ha.forEach(o),j.forEach(o),Ni=m(O),Me=n(O,"DIV",{class:!0});var fa=i(Me);v(Et.$$.fragment,fa),Ri=m(fa),It=n(fa,"P",{});var ga=i(It);Hi=a(ga,"Converts the output of "),ho=n(ga,"A",{href:!0});var Vd=i(ho);Ui=a(Vd,"MaskFormerForInstanceSegmentation"),Vd.forEach(o),Bi=a(ga,` into semantic segmentation maps. Only supports
PyTorch.`),ga.forEach(o),fa.forEach(o),Wi=m(O),Te=n(O,"DIV",{class:!0});var ua=i(Te);v(Pt.$$.fragment,ua),Vi=m(ua),jt=n(ua,"P",{});var _a=i(jt);Gi=a(_a,"Converts the output of "),as=n(_a,"CODE",{});var Gd=i(as);Ki=a(Gd,"MaskFormerForInstanceSegmentationOutput"),Gd.forEach(o),Qi=a(_a,` into instance segmentation predictions. Only
supports PyTorch.`),_a.forEach(o),ua.forEach(o),Xi=m(O),$e=n(O,"DIV",{class:!0});var ka=i($e);v(zt.$$.fragment,ka),Yi=m(ka),Ot=n(ka,"P",{});var ba=i(Ot);Ji=a(ba,"Converts the output of "),rs=n(ba,"CODE",{});var Kd=i(rs);Zi=a(Kd,"MaskFormerForInstanceSegmentationOutput"),Kd.forEach(o),ec=a(ba,` into image panoptic segmentation
predictions. Only supports PyTorch.`),ba.forEach(o),ka.forEach(o),O.forEach(o),Ss=m(t),ce=n(t,"H2",{class:!0});var Fa=i(ce);Ee=n(Fa,"A",{id:!0,class:!0,href:!0});var Qd=i(Ee);ns=n(Qd,"SPAN",{});var Xd=i(ns);v(Lt.$$.fragment,Xd),Xd.forEach(o),Qd.forEach(o),tc=m(Fa),is=n(Fa,"SPAN",{});var Yd=i(is);oc=a(Yd,"MaskFormerModel"),Yd.forEach(o),Fa.forEach(o),Ns=m(t),Q=n(t,"DIV",{class:!0});var Fo=i(Q);v(At.$$.fragment,Fo),sc=m(Fo),Ct=n(Fo,"P",{});var va=i(Ct);ac=a(va,`The bare MaskFormer Model outputting raw hidden-states without any specific head on top.
This model is a PyTorch `),qt=n(va,"A",{href:!0,rel:!0});var Jd=i(qt);rc=a(Jd,"torch.nn.Module"),Jd.forEach(o),nc=a(va,` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),va.forEach(o),ic=m(Fo),H=n(Fo,"DIV",{class:!0});var Ne=i(H);v(Dt.$$.fragment,Ne),cc=m(Ne),de=n(Ne,"P",{});var vo=i(de);dc=a(vo,"The "),fo=n(vo,"A",{href:!0});var Zd=i(fo);lc=a(Zd,"MaskFormerModel"),Zd.forEach(o),mc=a(vo," forward method, overrides the "),cs=n(vo,"CODE",{});var el=i(cs);pc=a(el,"__call__"),el.forEach(o),hc=a(vo," special method."),vo.forEach(o),fc=m(Ne),v(Ie.$$.fragment,Ne),gc=m(Ne),v(Pe.$$.fragment,Ne),Ne.forEach(o),Fo.forEach(o),Rs=m(t),le=n(t,"H2",{class:!0});var wa=i(le);je=n(wa,"A",{id:!0,class:!0,href:!0});var tl=i(je);ds=n(tl,"SPAN",{});var ol=i(ds);v(St.$$.fragment,ol),ol.forEach(o),tl.forEach(o),uc=m(wa),ls=n(wa,"SPAN",{});var sl=i(ls);_c=a(sl,"MaskFormerForInstanceSegmentation"),sl.forEach(o),wa.forEach(o),Hs=m(t),me=n(t,"DIV",{class:!0});var xa=i(me);v(Nt.$$.fragment,xa),kc=m(xa),z=n(xa,"DIV",{class:!0});var U=i(z);v(Rt.$$.fragment,U),bc=m(U),pe=n(U,"P",{});var wo=i(pe);Fc=a(wo,"The "),go=n(wo,"A",{href:!0});var al=i(go);vc=a(al,"MaskFormerForInstanceSegmentation"),al.forEach(o),wc=a(wo," forward method, overrides the "),ms=n(wo,"CODE",{});var rl=i(ms);xc=a(rl,"__call__"),rl.forEach(o),yc=a(wo," special method."),wo.forEach(o),Mc=m(U),v(ze.$$.fragment,U),Tc=m(U),ps=n(U,"P",{});var nl=i(ps);$c=a(nl,"Examples:"),nl.forEach(o),Ec=m(U),v(Oe.$$.fragment,U),Ic=m(U),v(Le.$$.fragment,U),U.forEach(o),xa.forEach(o),this.h()},h(){c(p,"name","hf:doc:metadata"),c(p,"content",JSON.stringify(xl)),c(g,"id","maskformer"),c(g,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(g,"href","#maskformer"),c(u,"class","relative group"),c(fe,"id","overview"),c(fe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(fe,"href","#overview"),c(ee,"class","relative group"),c(Ue,"href","https://arxiv.org/abs/2107.06278"),c(Ue,"rel","nofollow"),c(Gt,"href","detr"),c(Kt,"href","/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerConfig"),c(Be,"href","https://github.com/facebookresearch/MaskFormer/blob/da3e60d85fdeedcb31476b5edd7d328826ce56cc/mask_former/modeling/criterion.py#L169"),c(Be,"rel","nofollow"),c(Qt,"href","/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerFeatureExtractor"),c(Xt,"href","/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerFeatureExtractor.post_process_semantic_segmentation"),c(Yt,"href","/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerFeatureExtractor.post_process_panoptic_segmentation"),c(Jt,"href","/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerForInstanceSegmentation"),c(Ve,"href","https://arxiv.org/abs/2107.06278"),c(Ve,"rel","nofollow"),c(Ge,"width","600"),ml(Ge.src,Pc="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/maskformer_architecture.png")||c(Ge,"src",Pc),c(Ke,"href","https://huggingface.co/francesco"),c(Ke,"rel","nofollow"),c(Qe,"href","https://github.com/facebookresearch/MaskFormer"),c(Qe,"rel","nofollow"),c(_e,"id","resources"),c(_e,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(_e,"href","#resources"),c(te,"class","relative group"),c(Ze,"href","https://github.com/NielsRogge/Transformers-Tutorials/tree/master/MaskFormer"),c(Ze,"rel","nofollow"),c(ke,"id","transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput"),c(ke,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(ke,"href","#transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput"),c(oe,"class","relative group"),c(eo,"href","/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerModel"),c(se,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(to,"href","/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerForInstanceSegmentation"),c(oo,"href","/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerFeatureExtractor.post_process_semantic_segmentation"),c(so,"href","/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerFeatureExtractor.post_process_instance_segmentation"),c(ao,"href","/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerFeatureExtractor.post_process_panoptic_segmentation"),c(B,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(be,"id","transformers.MaskFormerConfig"),c(be,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(be,"href","#transformers.MaskFormerConfig"),c(ae,"class","relative group"),c(ro,"href","/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerModel"),c(it,"href","https://huggingface.co/facebook/maskformer-swin-base-ade"),c(it,"rel","nofollow"),c(ct,"href","https://huggingface.co/datasets/scene_parse_150"),c(ct,"rel","nofollow"),c(no,"href","/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig"),c(io,"href","/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig"),c(co,"href","swin"),c(lo,"href","/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerConfig"),c(ve,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(mo,"href","/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig.to_dict"),c(we,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(I,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(xe,"id","transformers.MaskFormerFeatureExtractor"),c(xe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(xe,"href","#transformers.MaskFormerFeatureExtractor"),c(ne,"class","relative group"),c(po,"href","/docs/transformers/main/en/main_classes/feature_extractor#transformers.FeatureExtractionMixin"),c(E,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(wt,"href","https://pytorch.org/vision/stable/transforms.html"),c(wt,"rel","nofollow"),c(xt,"href","https://albumentations.ai/"),c(xt,"rel","nofollow"),c(T,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(ho,"href","/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerForInstanceSegmentation"),c(Me,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Te,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c($e,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c($,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ee,"id","transformers.MaskFormerModel"),c(Ee,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Ee,"href","#transformers.MaskFormerModel"),c(ce,"class","relative group"),c(qt,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(qt,"rel","nofollow"),c(fo,"href","/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerModel"),c(H,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(je,"id","transformers.MaskFormerForInstanceSegmentation"),c(je,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(je,"href","#transformers.MaskFormerForInstanceSegmentation"),c(le,"class","relative group"),c(go,"href","/docs/transformers/main/en/model_doc/maskformer#transformers.MaskFormerForInstanceSegmentation"),c(z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(me,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,h){e(document.head,p),f(t,b,h),f(t,u,h),e(u,g),e(g,k),w(d,k,null),e(u,_),e(u,C),e(C,Ea),f(t,bs,h),w(he,t,h),f(t,Fs,h),f(t,ee,h),e(ee,fe),e(fe,xo),w(He,xo,null),e(ee,Ia),e(ee,yo),e(yo,Pa),f(t,vs,h),f(t,ge,h),e(ge,ja),e(ge,Ue),e(Ue,za),e(ge,Oa),f(t,ws,h),f(t,Bt,h),e(Bt,La),f(t,xs,h),f(t,Wt,h),e(Wt,Mo),e(Mo,Aa),f(t,ys,h),f(t,Vt,h),e(Vt,Ca),f(t,Ms,h),f(t,R,h),e(R,D),e(D,qa),e(D,Gt),e(Gt,Da),e(D,Sa),e(D,To),e(To,Na),e(D,Ra),e(D,Kt),e(Kt,Ha),e(D,Ua),e(D,$o),e($o,Ba),e(D,Wa),e(R,Va),e(R,S),e(S,Ga),e(S,Eo),e(Eo,Ka),e(S,Qa),e(S,Io),e(Io,Xa),e(S,Ya),e(S,Po),e(Po,Ja),e(S,Za),e(S,Be),e(Be,er),e(S,tr),e(R,or),e(R,We),e(We,sr),e(We,Qt),e(Qt,ar),e(We,rr),e(R,nr),e(R,N),e(N,ir),e(N,Xt),e(Xt,cr),e(N,dr),e(N,Yt),e(Yt,lr),e(N,mr),e(N,Jt),e(Jt,pr),e(N,hr),e(N,jo),e(jo,fr),e(N,gr),f(t,Ts,h),f(t,ue,h),e(ue,ur),e(ue,Ve),e(Ve,_r),e(ue,kr),f(t,$s,h),f(t,Ge,h),f(t,Es,h),f(t,X,h),e(X,br),e(X,Ke),e(Ke,Fr),e(X,vr),e(X,Qe),e(Qe,wr),e(X,xr),f(t,Is,h),f(t,te,h),e(te,_e),e(_e,zo),w(Xe,zo,null),e(te,yr),e(te,Oo),e(Oo,Mr),f(t,Ps,h),w(Ye,t,h),f(t,js,h),f(t,Zt,h),e(Zt,Je),e(Je,Tr),e(Je,Ze),e(Ze,$r),e(Je,Er),f(t,zs,h),f(t,oe,h),e(oe,ke),e(ke,Lo),w(et,Lo,null),e(oe,Ir),e(oe,Ao),e(Ao,Pr),f(t,Os,h),f(t,se,h),w(tt,se,null),e(se,jr),e(se,ot),e(ot,zr),e(ot,eo),e(eo,Or),e(ot,Lr),f(t,Ls,h),f(t,B,h),w(st,B,null),e(B,Ar),e(B,at),e(at,Cr),e(at,to),e(to,qr),e(at,Dr),e(B,Sr),e(B,W),e(W,Nr),e(W,oo),e(oo,Rr),e(W,Hr),e(W,so),e(so,Ur),e(W,Br),e(W,ao),e(ao,Wr),e(W,Vr),f(t,As,h),f(t,ae,h),e(ae,be),e(be,Co),w(rt,Co,null),e(ae,Gr),e(ae,qo),e(qo,Kr),f(t,Cs,h),f(t,I,h),w(nt,I,null),e(I,Qr),e(I,V),e(V,Xr),e(V,ro),e(ro,Yr),e(V,Jr),e(V,it),e(it,Zr),e(V,en),e(V,ct),e(ct,tn),e(V,on),e(I,sn),e(I,re),e(re,an),e(re,no),e(no,rn),e(re,nn),e(re,io),e(io,cn),e(re,dn),e(I,ln),e(I,dt),e(dt,mn),e(dt,co),e(co,pn),e(dt,hn),e(I,fn),w(Fe,I,null),e(I,gn),e(I,ve),w(lt,ve,null),e(ve,un),e(ve,mt),e(mt,_n),e(mt,lo),e(lo,kn),e(mt,bn),e(I,Fn),e(I,we),w(pt,we,null),e(we,vn),e(we,ht),e(ht,wn),e(ht,mo),e(mo,xn),e(ht,yn),f(t,qs,h),f(t,ne,h),e(ne,xe),e(xe,Do),w(ft,Do,null),e(ne,Mn),e(ne,So),e(So,Tn),f(t,Ds,h),f(t,$,h),w(gt,$,null),e($,$n),e($,No),e(No,En),e($,In),e($,ut),e(ut,Pn),e(ut,po),e(po,jn),e(ut,zn),e($,On),e($,E),w(_t,E,null),e(E,Ln),e(E,Ro),e(Ro,An),e(E,Cn),e(E,kt),e(kt,qn),e(kt,Ho),e(Ho,Dn),e(kt,Sn),e(E,Nn),e(E,Uo),e(Uo,Rn),e(E,Hn),e(E,bt),e(bt,Un),e(bt,Bo),e(Bo,Bn),e(bt,Wn),e(E,Vn),e(E,G),e(G,Gn),e(G,Wo),e(Wo,Kn),e(G,Qn),e(G,Vo),e(Vo,Xn),e(G,Yn),e(G,Go),e(Go,Jn),e(G,Zn),e(E,ei),e(E,Ft),e(Ft,ti),e(Ft,Ko),e(Ko,oi),e(Ft,si),e(E,ai),w(ye,E,null),e($,ri),e($,T),w(vt,T,null),e(T,ni),e(T,Qo),e(Qo,ii),e(T,ci),e(T,ie),e(ie,di),e(ie,wt),e(wt,li),e(ie,mi),e(ie,xt),e(xt,pi),e(ie,hi),e(T,fi),e(T,yt),e(yt,gi),e(yt,Xo),e(Xo,ui),e(yt,_i),e(T,ki),e(T,Mt),e(Mt,bi),e(Mt,Yo),e(Yo,Fi),e(Mt,vi),e(T,wi),e(T,Jo),e(Jo,xi),e(T,yi),e(T,Tt),e(Tt,Mi),e(Tt,Zo),e(Zo,Ti),e(Tt,$i),e(T,Ei),e(T,K),e(K,Ii),e(K,es),e(es,Pi),e(K,ji),e(K,ts),e(ts,zi),e(K,Oi),e(K,os),e(os,Li),e(K,Ai),e(T,Ci),e(T,$t),e($t,qi),e($t,ss),e(ss,Di),e($t,Si),e($,Ni),e($,Me),w(Et,Me,null),e(Me,Ri),e(Me,It),e(It,Hi),e(It,ho),e(ho,Ui),e(It,Bi),e($,Wi),e($,Te),w(Pt,Te,null),e(Te,Vi),e(Te,jt),e(jt,Gi),e(jt,as),e(as,Ki),e(jt,Qi),e($,Xi),e($,$e),w(zt,$e,null),e($e,Yi),e($e,Ot),e(Ot,Ji),e(Ot,rs),e(rs,Zi),e(Ot,ec),f(t,Ss,h),f(t,ce,h),e(ce,Ee),e(Ee,ns),w(Lt,ns,null),e(ce,tc),e(ce,is),e(is,oc),f(t,Ns,h),f(t,Q,h),w(At,Q,null),e(Q,sc),e(Q,Ct),e(Ct,ac),e(Ct,qt),e(qt,rc),e(Ct,nc),e(Q,ic),e(Q,H),w(Dt,H,null),e(H,cc),e(H,de),e(de,dc),e(de,fo),e(fo,lc),e(de,mc),e(de,cs),e(cs,pc),e(de,hc),e(H,fc),w(Ie,H,null),e(H,gc),w(Pe,H,null),f(t,Rs,h),f(t,le,h),e(le,je),e(je,ds),w(St,ds,null),e(le,uc),e(le,ls),e(ls,_c),f(t,Hs,h),f(t,me,h),w(Nt,me,null),e(me,kc),e(me,z),w(Rt,z,null),e(z,bc),e(z,pe),e(pe,Fc),e(pe,go),e(go,vc),e(pe,wc),e(pe,ms),e(ms,xc),e(pe,yc),e(z,Mc),w(ze,z,null),e(z,Tc),e(z,ps),e(ps,$c),e(z,Ec),w(Oe,z,null),e(z,Ic),w(Le,z,null),Us=!0},p(t,[h]){const Ht={};h&2&&(Ht.$$scope={dirty:h,ctx:t}),he.$set(Ht);const hs={};h&2&&(hs.$$scope={dirty:h,ctx:t}),Fe.$set(hs);const fs={};h&2&&(fs.$$scope={dirty:h,ctx:t}),ye.$set(fs);const gs={};h&2&&(gs.$$scope={dirty:h,ctx:t}),Ie.$set(gs);const Ut={};h&2&&(Ut.$$scope={dirty:h,ctx:t}),Pe.$set(Ut);const us={};h&2&&(us.$$scope={dirty:h,ctx:t}),ze.$set(us);const _s={};h&2&&(_s.$$scope={dirty:h,ctx:t}),Oe.$set(_s);const ks={};h&2&&(ks.$$scope={dirty:h,ctx:t}),Le.$set(ks)},i(t){Us||(x(d.$$.fragment,t),x(he.$$.fragment,t),x(He.$$.fragment,t),x(Xe.$$.fragment,t),x(Ye.$$.fragment,t),x(et.$$.fragment,t),x(tt.$$.fragment,t),x(st.$$.fragment,t),x(rt.$$.fragment,t),x(nt.$$.fragment,t),x(Fe.$$.fragment,t),x(lt.$$.fragment,t),x(pt.$$.fragment,t),x(ft.$$.fragment,t),x(gt.$$.fragment,t),x(_t.$$.fragment,t),x(ye.$$.fragment,t),x(vt.$$.fragment,t),x(Et.$$.fragment,t),x(Pt.$$.fragment,t),x(zt.$$.fragment,t),x(Lt.$$.fragment,t),x(At.$$.fragment,t),x(Dt.$$.fragment,t),x(Ie.$$.fragment,t),x(Pe.$$.fragment,t),x(St.$$.fragment,t),x(Nt.$$.fragment,t),x(Rt.$$.fragment,t),x(ze.$$.fragment,t),x(Oe.$$.fragment,t),x(Le.$$.fragment,t),Us=!0)},o(t){y(d.$$.fragment,t),y(he.$$.fragment,t),y(He.$$.fragment,t),y(Xe.$$.fragment,t),y(Ye.$$.fragment,t),y(et.$$.fragment,t),y(tt.$$.fragment,t),y(st.$$.fragment,t),y(rt.$$.fragment,t),y(nt.$$.fragment,t),y(Fe.$$.fragment,t),y(lt.$$.fragment,t),y(pt.$$.fragment,t),y(ft.$$.fragment,t),y(gt.$$.fragment,t),y(_t.$$.fragment,t),y(ye.$$.fragment,t),y(vt.$$.fragment,t),y(Et.$$.fragment,t),y(Pt.$$.fragment,t),y(zt.$$.fragment,t),y(Lt.$$.fragment,t),y(At.$$.fragment,t),y(Dt.$$.fragment,t),y(Ie.$$.fragment,t),y(Pe.$$.fragment,t),y(St.$$.fragment,t),y(Nt.$$.fragment,t),y(Rt.$$.fragment,t),y(ze.$$.fragment,t),y(Oe.$$.fragment,t),y(Le.$$.fragment,t),Us=!1},d(t){o(p),t&&o(b),t&&o(u),M(d),t&&o(bs),M(he,t),t&&o(Fs),t&&o(ee),M(He),t&&o(vs),t&&o(ge),t&&o(ws),t&&o(Bt),t&&o(xs),t&&o(Wt),t&&o(ys),t&&o(Vt),t&&o(Ms),t&&o(R),t&&o(Ts),t&&o(ue),t&&o($s),t&&o(Ge),t&&o(Es),t&&o(X),t&&o(Is),t&&o(te),M(Xe),t&&o(Ps),M(Ye,t),t&&o(js),t&&o(Zt),t&&o(zs),t&&o(oe),M(et),t&&o(Os),t&&o(se),M(tt),t&&o(Ls),t&&o(B),M(st),t&&o(As),t&&o(ae),M(rt),t&&o(Cs),t&&o(I),M(nt),M(Fe),M(lt),M(pt),t&&o(qs),t&&o(ne),M(ft),t&&o(Ds),t&&o($),M(gt),M(_t),M(ye),M(vt),M(Et),M(Pt),M(zt),t&&o(Ss),t&&o(ce),M(Lt),t&&o(Ns),t&&o(Q),M(At),M(Dt),M(Ie),M(Pe),t&&o(Rs),t&&o(le),M(St),t&&o(Hs),t&&o(me),M(Nt),M(Rt),M(ze),M(Oe),M(Le)}}}const xl={local:"maskformer",sections:[{local:"overview",title:"Overview"},{local:"resources",title:"Resources"},{local:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput",title:"MaskFormer specific outputs"},{local:"transformers.MaskFormerConfig",title:"MaskFormerConfig"},{local:"transformers.MaskFormerFeatureExtractor",title:"MaskFormerFeatureExtractor"},{local:"transformers.MaskFormerModel",title:"MaskFormerModel"},{local:"transformers.MaskFormerForInstanceSegmentation",title:"MaskFormerForInstanceSegmentation"}],title:"MaskFormer"};function yl(P){return pl(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class zl extends il{constructor(p){super();cl(this,p,yl,wl,dl,{})}}export{zl as default,xl as metadata};
