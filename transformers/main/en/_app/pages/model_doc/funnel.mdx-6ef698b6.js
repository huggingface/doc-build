import{S as B$,i as W$,s as Q$,e as r,k as l,w as F,t,M as U$,c as a,d as n,m as d,a as i,x as v,h as o,b as c,F as e,g as h,y,q as w,o as b,B as $,v as R$}from"../../chunks/vendor-6b77c823.js";import{T as qe}from"../../chunks/Tip-39098574.js";import{D as X}from"../../chunks/Docstring-abef54e3.js";import{C as ye}from"../../chunks/CodeBlock-3a8b25a8.js";import{I as je}from"../../chunks/IconCopyLink-7a11ce68.js";function H$(V){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function V$(V){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function Y$(V){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function K$(V){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function G$(V){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function Z$(V){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function X$(V){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function J$(V){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function e2(V){let u,z,g,_,k,T,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,C,oe,W,le,se,S,he,de,j,fe,B,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),C=r("li"),oe=t("a single Tensor with "),W=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),j=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),m=d(Z),M=a(Z,"LI",{});var we=i(M);ce=o(we,"having all inputs as a list, tuple or dict in the first positional arguments."),we.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var be=i(N);ue=o(be,"model(inputs)"),be.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var x=i(P);C=a(x,"LI",{});var R=i(C);oe=o(R,"a single Tensor with "),W=a(R,"CODE",{});var Ee=i(W);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(x),j=a(x,"LI",{});var H=i(j);fe=o(H,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=a(H,"CODE",{});var Me=i(B);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(H," or "),Q=a(H,"CODE",{});var ve=i(Q);me=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),H.forEach(n),I=d(x),O=a(x,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),x.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,C),e(C,oe),e(C,W),e(W,le),e(C,se),e(C,S),e(S,he),e(P,de),e(P,j),e(j,fe),e(j,B),e(B,ee),e(j,ae),e(j,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function n2(V){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function t2(V){let u,z,g,_,k,T,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,C,oe,W,le,se,S,he,de,j,fe,B,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),C=r("li"),oe=t("a single Tensor with "),W=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),j=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),m=d(Z),M=a(Z,"LI",{});var we=i(M);ce=o(we,"having all inputs as a list, tuple or dict in the first positional arguments."),we.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var be=i(N);ue=o(be,"model(inputs)"),be.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var x=i(P);C=a(x,"LI",{});var R=i(C);oe=o(R,"a single Tensor with "),W=a(R,"CODE",{});var Ee=i(W);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(x),j=a(x,"LI",{});var H=i(j);fe=o(H,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=a(H,"CODE",{});var Me=i(B);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(H," or "),Q=a(H,"CODE",{});var ve=i(Q);me=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),H.forEach(n),I=d(x),O=a(x,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),x.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,C),e(C,oe),e(C,W),e(W,le),e(C,se),e(C,S),e(S,he),e(P,de),e(P,j),e(j,fe),e(j,B),e(B,ee),e(j,ae),e(j,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function o2(V){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function s2(V){let u,z,g,_,k,T,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,C,oe,W,le,se,S,he,de,j,fe,B,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),C=r("li"),oe=t("a single Tensor with "),W=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),j=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),m=d(Z),M=a(Z,"LI",{});var we=i(M);ce=o(we,"having all inputs as a list, tuple or dict in the first positional arguments."),we.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var be=i(N);ue=o(be,"model(inputs)"),be.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var x=i(P);C=a(x,"LI",{});var R=i(C);oe=o(R,"a single Tensor with "),W=a(R,"CODE",{});var Ee=i(W);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(x),j=a(x,"LI",{});var H=i(j);fe=o(H,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=a(H,"CODE",{});var Me=i(B);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(H," or "),Q=a(H,"CODE",{});var ve=i(Q);me=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),H.forEach(n),I=d(x),O=a(x,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),x.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,C),e(C,oe),e(C,W),e(W,le),e(C,se),e(C,S),e(S,he),e(P,de),e(P,j),e(j,fe),e(j,B),e(B,ee),e(j,ae),e(j,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function r2(V){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function a2(V){let u,z,g,_,k,T,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,C,oe,W,le,se,S,he,de,j,fe,B,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),C=r("li"),oe=t("a single Tensor with "),W=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),j=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),m=d(Z),M=a(Z,"LI",{});var we=i(M);ce=o(we,"having all inputs as a list, tuple or dict in the first positional arguments."),we.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var be=i(N);ue=o(be,"model(inputs)"),be.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var x=i(P);C=a(x,"LI",{});var R=i(C);oe=o(R,"a single Tensor with "),W=a(R,"CODE",{});var Ee=i(W);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(x),j=a(x,"LI",{});var H=i(j);fe=o(H,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=a(H,"CODE",{});var Me=i(B);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(H," or "),Q=a(H,"CODE",{});var ve=i(Q);me=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),H.forEach(n),I=d(x),O=a(x,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),x.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,C),e(C,oe),e(C,W),e(W,le),e(C,se),e(C,S),e(S,he),e(P,de),e(P,j),e(j,fe),e(j,B),e(B,ee),e(j,ae),e(j,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function i2(V){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function l2(V){let u,z,g,_,k,T,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,C,oe,W,le,se,S,he,de,j,fe,B,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),C=r("li"),oe=t("a single Tensor with "),W=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),j=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),m=d(Z),M=a(Z,"LI",{});var we=i(M);ce=o(we,"having all inputs as a list, tuple or dict in the first positional arguments."),we.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var be=i(N);ue=o(be,"model(inputs)"),be.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var x=i(P);C=a(x,"LI",{});var R=i(C);oe=o(R,"a single Tensor with "),W=a(R,"CODE",{});var Ee=i(W);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(x),j=a(x,"LI",{});var H=i(j);fe=o(H,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=a(H,"CODE",{});var Me=i(B);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(H," or "),Q=a(H,"CODE",{});var ve=i(Q);me=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),H.forEach(n),I=d(x),O=a(x,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),x.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,C),e(C,oe),e(C,W),e(W,le),e(C,se),e(C,S),e(S,he),e(P,de),e(P,j),e(j,fe),e(j,B),e(B,ee),e(j,ae),e(j,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function d2(V){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function c2(V){let u,z,g,_,k,T,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,C,oe,W,le,se,S,he,de,j,fe,B,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),C=r("li"),oe=t("a single Tensor with "),W=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),j=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),m=d(Z),M=a(Z,"LI",{});var we=i(M);ce=o(we,"having all inputs as a list, tuple or dict in the first positional arguments."),we.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var be=i(N);ue=o(be,"model(inputs)"),be.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var x=i(P);C=a(x,"LI",{});var R=i(C);oe=o(R,"a single Tensor with "),W=a(R,"CODE",{});var Ee=i(W);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(x),j=a(x,"LI",{});var H=i(j);fe=o(H,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=a(H,"CODE",{});var Me=i(B);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(H," or "),Q=a(H,"CODE",{});var ve=i(Q);me=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),H.forEach(n),I=d(x),O=a(x,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),x.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,C),e(C,oe),e(C,W),e(W,le),e(C,se),e(C,S),e(S,he),e(P,de),e(P,j),e(j,fe),e(j,B),e(B,ee),e(j,ae),e(j,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function p2(V){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function u2(V){let u,z,g,_,k,T,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,C,oe,W,le,se,S,he,de,j,fe,B,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),C=r("li"),oe=t("a single Tensor with "),W=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),j=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),m=d(Z),M=a(Z,"LI",{});var we=i(M);ce=o(we,"having all inputs as a list, tuple or dict in the first positional arguments."),we.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var be=i(N);ue=o(be,"model(inputs)"),be.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var x=i(P);C=a(x,"LI",{});var R=i(C);oe=o(R,"a single Tensor with "),W=a(R,"CODE",{});var Ee=i(W);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(x),j=a(x,"LI",{});var H=i(j);fe=o(H,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=a(H,"CODE",{});var Me=i(B);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(H," or "),Q=a(H,"CODE",{});var ve=i(Q);me=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),H.forEach(n),I=d(x),O=a(x,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),x.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,C),e(C,oe),e(C,W),e(W,le),e(C,se),e(C,S),e(S,he),e(P,de),e(P,j),e(j,fe),e(j,B),e(B,ee),e(j,ae),e(j,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function h2(V){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function f2(V){let u,z,g,_,k,T,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,C,oe,W,le,se,S,he,de,j,fe,B,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),C=r("li"),oe=t("a single Tensor with "),W=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),j=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),m=d(Z),M=a(Z,"LI",{});var we=i(M);ce=o(we,"having all inputs as a list, tuple or dict in the first positional arguments."),we.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var be=i(N);ue=o(be,"model(inputs)"),be.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var x=i(P);C=a(x,"LI",{});var R=i(C);oe=o(R,"a single Tensor with "),W=a(R,"CODE",{});var Ee=i(W);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(x),j=a(x,"LI",{});var H=i(j);fe=o(H,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=a(H,"CODE",{});var Me=i(B);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(H," or "),Q=a(H,"CODE",{});var ve=i(Q);me=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),H.forEach(n),I=d(x),O=a(x,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),x.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,C),e(C,oe),e(C,W),e(W,le),e(C,se),e(C,S),e(S,he),e(P,de),e(P,j),e(j,fe),e(j,B),e(B,ee),e(j,ae),e(j,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function m2(V){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function g2(V){let u,z,g,_,k,T,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,C,oe,W,le,se,S,he,de,j,fe,B,ee,ae,Q,me,I,O,re,U,ge,p,E,Z,Te,we,D,ke,be,$e,x,R,Ee,Fe,H,Me,ve,_e,ze,oi,Yu,Ku,Oc,In,Gu,No,Zu,Xu,So,Ju,eh,Dc,Zn,Bt,Fl,Io,nh,vl,th,Ac,Nn,Bo,oh,Sn,sh,si,rh,ah,ri,ih,lh,Wo,dh,ch,ph,Xn,uh,ai,hh,fh,ii,mh,gh,Nc,Jn,Wt,yl,Qo,_h,wl,Th,Sc,Ce,Uo,kh,bl,Fh,vh,Qt,li,yh,wh,di,bh,$h,Eh,Ro,Mh,ci,zh,qh,Ph,Bn,Ho,jh,$l,Ch,xh,Vo,pi,Lh,El,Oh,Dh,ui,Ah,Ml,Nh,Sh,Ut,Yo,Ih,Ko,Bh,zl,Wh,Qh,Uh,yn,Go,Rh,ql,Hh,Vh,Zo,Yh,et,Kh,Pl,Gh,Zh,jl,Xh,Jh,ef,hi,Xo,Ic,nt,Rt,Cl,Jo,nf,xl,tf,Bc,sn,es,of,ns,sf,Ll,rf,af,lf,Ht,fi,df,cf,mi,pf,uf,hf,ts,ff,gi,mf,gf,_f,wn,os,Tf,Ol,kf,Ff,ss,vf,tt,yf,Dl,wf,bf,Al,$f,Ef,Wc,ot,Vt,Nl,rs,Mf,Sl,zf,Qc,st,as,qf,is,Pf,_i,jf,Cf,Uc,rt,ls,xf,ds,Lf,Ti,Of,Df,Rc,at,Yt,Il,cs,Af,Bl,Nf,Hc,Qe,ps,Sf,Wl,If,Bf,us,Wf,hs,Qf,Uf,Rf,fs,Hf,ki,Vf,Yf,Kf,ms,Gf,gs,Zf,Xf,Jf,rn,_s,em,it,nm,Fi,tm,om,Ql,sm,rm,am,Kt,im,Ul,lm,dm,Ts,Vc,lt,Gt,Rl,ks,cm,Hl,pm,Yc,Ue,Fs,um,Vl,hm,fm,vs,mm,ys,gm,_m,Tm,ws,km,vi,Fm,vm,ym,bs,wm,$s,bm,$m,Em,an,Es,Mm,dt,zm,yi,qm,Pm,Yl,jm,Cm,xm,Zt,Lm,Kl,Om,Dm,Ms,Kc,ct,Xt,Gl,zs,Am,Zl,Nm,Gc,pt,qs,Sm,ln,Ps,Im,ut,Bm,wi,Wm,Qm,Xl,Um,Rm,Hm,Jt,Vm,Jl,Ym,Km,js,Zc,ht,eo,ed,Cs,Gm,nd,Zm,Xc,Re,xs,Xm,Ls,Jm,td,eg,ng,tg,Os,og,Ds,sg,rg,ag,As,ig,bi,lg,dg,cg,Ns,pg,Ss,ug,hg,fg,Ge,Is,mg,ft,gg,$i,_g,Tg,od,kg,Fg,vg,no,yg,sd,wg,bg,Bs,$g,Ws,Jc,mt,to,rd,Qs,Eg,ad,Mg,ep,He,Us,zg,id,qg,Pg,Rs,jg,Hs,Cg,xg,Lg,Vs,Og,Ei,Dg,Ag,Ng,Ys,Sg,Ks,Ig,Bg,Wg,Pe,Gs,Qg,gt,Ug,Mi,Rg,Hg,ld,Vg,Yg,Kg,oo,Gg,dd,Zg,Xg,Zs,Jg,Xs,e_,cd,n_,t_,Js,o_,er,np,_t,so,pd,nr,s_,ud,r_,tp,Ve,tr,a_,hd,i_,l_,or,d_,sr,c_,p_,u_,rr,h_,zi,f_,m_,g_,ar,__,ir,T_,k_,F_,dn,lr,v_,Tt,y_,qi,w_,b_,fd,$_,E_,M_,ro,z_,md,q_,P_,dr,op,kt,ao,gd,cr,j_,_d,C_,sp,Ye,pr,x_,Td,L_,O_,ur,D_,hr,A_,N_,S_,fr,I_,Pi,B_,W_,Q_,mr,U_,gr,R_,H_,V_,Ze,_r,Y_,Ft,K_,ji,G_,Z_,kd,X_,J_,eT,io,nT,Fd,tT,oT,Tr,sT,kr,rp,vt,lo,vd,Fr,rT,yd,aT,ap,Ke,vr,iT,yt,lT,wd,dT,cT,bd,pT,uT,hT,yr,fT,wr,mT,gT,_T,br,TT,Ci,kT,FT,vT,$r,yT,Er,wT,bT,$T,Xe,Mr,ET,wt,MT,xi,zT,qT,$d,PT,jT,CT,co,xT,Ed,LT,OT,zr,DT,qr,ip,bt,po,Md,Pr,AT,zd,NT,lp,Le,jr,ST,qd,IT,BT,Cr,WT,xr,QT,UT,RT,Lr,HT,Li,VT,YT,KT,Or,GT,Dr,ZT,XT,JT,uo,ek,cn,Ar,nk,$t,tk,Oi,ok,sk,Pd,rk,ak,ik,ho,lk,jd,dk,ck,Nr,dp,Et,fo,Cd,Sr,pk,xd,uk,cp,Oe,Ir,hk,Ld,fk,mk,Br,gk,Wr,_k,Tk,kk,Qr,Fk,Di,vk,yk,wk,Ur,bk,Rr,$k,Ek,Mk,mo,zk,pn,Hr,qk,Mt,Pk,Ai,jk,Ck,Od,xk,Lk,Ok,go,Dk,Dd,Ak,Nk,Vr,pp,zt,_o,Ad,Yr,Sk,Nd,Ik,up,De,Kr,Bk,Sd,Wk,Qk,Gr,Uk,Zr,Rk,Hk,Vk,Xr,Yk,Ni,Kk,Gk,Zk,Jr,Xk,ea,Jk,eF,nF,To,tF,un,na,oF,qt,sF,Si,rF,aF,Id,iF,lF,dF,ko,cF,Bd,pF,uF,ta,hp,Pt,Fo,Wd,oa,hF,Qd,fF,fp,Ae,sa,mF,ra,gF,Ud,_F,TF,kF,aa,FF,ia,vF,yF,wF,la,bF,Ii,$F,EF,MF,da,zF,ca,qF,PF,jF,vo,CF,Je,pa,xF,jt,LF,Bi,OF,DF,Rd,AF,NF,SF,yo,IF,Hd,BF,WF,ua,QF,ha,mp,Ct,wo,Vd,fa,UF,Yd,RF,gp,Ne,ma,HF,Kd,VF,YF,ga,KF,_a,GF,ZF,XF,Ta,JF,Wi,ev,nv,tv,ka,ov,Fa,sv,rv,av,bo,iv,en,va,lv,xt,dv,Qi,cv,pv,Gd,uv,hv,fv,$o,mv,Zd,gv,_v,ya,Tv,wa,_p,Lt,Eo,Xd,ba,kv,Jd,Fv,Tp,Se,$a,vv,ec,yv,wv,Ea,bv,Ma,$v,Ev,Mv,za,zv,Ui,qv,Pv,jv,qa,Cv,Pa,xv,Lv,Ov,Mo,Dv,hn,ja,Av,Ot,Nv,Ri,Sv,Iv,nc,Bv,Wv,Qv,zo,Uv,tc,Rv,Hv,Ca,kp,Dt,qo,oc,xa,Vv,sc,Yv,Fp,Ie,La,Kv,rc,Gv,Zv,Oa,Xv,Da,Jv,ey,ny,Aa,ty,Hi,oy,sy,ry,Na,ay,Sa,iy,ly,dy,Po,cy,nn,Ia,py,At,uy,Vi,hy,fy,ac,my,gy,_y,jo,Ty,ic,ky,Fy,Ba,vy,Wa,vp,Nt,Co,lc,Qa,yy,dc,wy,yp,Be,Ua,by,St,$y,cc,Ey,My,pc,zy,qy,Py,Ra,jy,Ha,Cy,xy,Ly,Va,Oy,Yi,Dy,Ay,Ny,Ya,Sy,Ka,Iy,By,Wy,xo,Qy,tn,Ga,Uy,It,Ry,Ki,Hy,Vy,uc,Yy,Ky,Gy,Lo,Zy,hc,Xy,Jy,Za,ew,Xa,wp;return T=new je({}),ne=new je({}),Io=new je({}),Bo=new X({props:{name:"class transformers.FunnelConfig",anchor:"transformers.FunnelConfig",parameters:[{name:"vocab_size",val:" = 30522"},{name:"block_sizes",val:" = [4, 4, 4]"},{name:"block_repeats",val:" = None"},{name:"num_decoder_layers",val:" = 2"},{name:"d_model",val:" = 768"},{name:"n_head",val:" = 12"},{name:"d_head",val:" = 64"},{name:"d_inner",val:" = 3072"},{name:"hidden_act",val:" = 'gelu_new'"},{name:"hidden_dropout",val:" = 0.1"},{name:"attention_dropout",val:" = 0.1"},{name:"activation_dropout",val:" = 0.0"},{name:"max_position_embeddings",val:" = 512"},{name:"type_vocab_size",val:" = 3"},{name:"initializer_range",val:" = 0.1"},{name:"initializer_std",val:" = None"},{name:"layer_norm_eps",val:" = 1e-09"},{name:"pooling_type",val:" = 'mean'"},{name:"attention_type",val:" = 'relative_shift'"},{name:"separate_cls",val:" = True"},{name:"truncate_seq",val:" = True"},{name:"pool_q_only",val:" = True"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/configuration_funnel.py#L37",parametersDescription:[{anchor:"transformers.FunnelConfig.vocab_size",description:`<strong>vocab_size</strong> (<code>int</code>, <em>optional</em>, defaults to 30522) &#x2014;
Vocabulary size of the Funnel transformer. Defines the number of different tokens that can be represented
by the <code>inputs_ids</code> passed when calling <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelModel">FunnelModel</a> or <a href="/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelModel">TFFunnelModel</a>.`,name:"vocab_size"},{anchor:"transformers.FunnelConfig.block_sizes",description:`<strong>block_sizes</strong> (<code>List[int]</code>, <em>optional</em>, defaults to <code>[4, 4, 4]</code>) &#x2014;
The sizes of the blocks used in the model.`,name:"block_sizes"},{anchor:"transformers.FunnelConfig.block_repeats",description:`<strong>block_repeats</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
If passed along, each layer of each block is repeated the number of times indicated.`,name:"block_repeats"},{anchor:"transformers.FunnelConfig.num_decoder_layers",description:`<strong>num_decoder_layers</strong> (<code>int</code>, <em>optional</em>, defaults to 2) &#x2014;
The number of layers in the decoder (when not using the base model).`,name:"num_decoder_layers"},{anchor:"transformers.FunnelConfig.d_model",description:`<strong>d_model</strong> (<code>int</code>, <em>optional</em>, defaults to 768) &#x2014;
Dimensionality of the model&#x2019;s hidden states.`,name:"d_model"},{anchor:"transformers.FunnelConfig.n_head",description:`<strong>n_head</strong> (<code>int</code>, <em>optional</em>, defaults to 12) &#x2014;
Number of attention heads for each attention layer in the Transformer encoder.`,name:"n_head"},{anchor:"transformers.FunnelConfig.d_head",description:`<strong>d_head</strong> (<code>int</code>, <em>optional</em>, defaults to 64) &#x2014;
Dimensionality of the model&#x2019;s heads.`,name:"d_head"},{anchor:"transformers.FunnelConfig.d_inner",description:`<strong>d_inner</strong> (<code>int</code>, <em>optional</em>, defaults to 3072) &#x2014;
Inner dimension in the feed-forward blocks.`,name:"d_inner"},{anchor:"transformers.FunnelConfig.hidden_act",description:`<strong>hidden_act</strong> (<code>str</code> or <code>callable</code>, <em>optional</em>, defaults to <code>&quot;gelu_new&quot;</code>) &#x2014;
The non-linear activation function (function or string) in the encoder and pooler. If string, <code>&quot;gelu&quot;</code>,
<code>&quot;relu&quot;</code>, <code>&quot;silu&quot;</code> and <code>&quot;gelu_new&quot;</code> are supported.`,name:"hidden_act"},{anchor:"transformers.FunnelConfig.hidden_dropout",description:`<strong>hidden_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.`,name:"hidden_dropout"},{anchor:"transformers.FunnelConfig.attention_dropout",description:`<strong>attention_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The dropout probability for the attention probabilities.`,name:"attention_dropout"},{anchor:"transformers.FunnelConfig.activation_dropout",description:`<strong>activation_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
The dropout probability used between the two layers of the feed-forward blocks.`,name:"activation_dropout"},{anchor:"transformers.FunnelConfig.max_position_embeddings",description:`<strong>max_position_embeddings</strong> (<code>int</code>, <em>optional</em>, defaults to 512) &#x2014;
The maximum sequence length that this model might ever be used with. Typically set this to something large
just in case (e.g., 512 or 1024 or 2048).`,name:"max_position_embeddings"},{anchor:"transformers.FunnelConfig.type_vocab_size",description:`<strong>type_vocab_size</strong> (<code>int</code>, <em>optional</em>, defaults to 3) &#x2014;
The vocabulary size of the <code>token_type_ids</code> passed when calling <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelModel">FunnelModel</a> or <a href="/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelModel">TFFunnelModel</a>.`,name:"type_vocab_size"},{anchor:"transformers.FunnelConfig.initializer_range",description:`<strong>initializer_range</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The upper bound of the <em>uniform initializer</em> for initializing all weight matrices in attention layers.`,name:"initializer_range"},{anchor:"transformers.FunnelConfig.initializer_std",description:`<strong>initializer_std</strong> (<code>float</code>, <em>optional</em>) &#x2014;
The standard deviation of the <em>normal initializer</em> for initializing the embedding matrix and the weight of
linear layers. Will default to 1 for the embedding matrix and the value given by Xavier initialization for
linear layers.`,name:"initializer_std"},{anchor:"transformers.FunnelConfig.layer_norm_eps",description:`<strong>layer_norm_eps</strong> (<code>float</code>, <em>optional</em>, defaults to 1e-9) &#x2014;
The epsilon used by the layer normalization layers.`,name:"layer_norm_eps"},{anchor:"transformers.FunnelConfig.pooling_type",description:`<strong>pooling_type</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;mean&quot;</code>) &#x2014;
Possible values are <code>&quot;mean&quot;</code> or <code>&quot;max&quot;</code>. The way pooling is performed at the beginning of each block.`,name:"pooling_type"},{anchor:"transformers.FunnelConfig.attention_type",description:`<strong>attention_type</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;relative_shift&quot;</code>) &#x2014;
Possible values are <code>&quot;relative_shift&quot;</code> or <code>&quot;factorized&quot;</code>. The former is faster on CPU/GPU while the latter
is faster on TPU.`,name:"attention_type"},{anchor:"transformers.FunnelConfig.separate_cls",description:`<strong>separate_cls</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to separate the cls token when applying pooling.`,name:"separate_cls"},{anchor:"transformers.FunnelConfig.truncate_seq",description:`<strong>truncate_seq</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
When using <code>separate_cls</code>, whether or not to truncate the last token when pooling, to avoid getting a
sequence length that is not a multiple of 2.`,name:"truncate_seq"},{anchor:"transformers.FunnelConfig.pool_q_only",description:`<strong>pool_q_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to apply the pooling only to the query or to query, key and values for the attention layers.`,name:"pool_q_only"}]}}),Qo=new je({}),Uo=new X({props:{name:"class transformers.FunnelTokenizer",anchor:"transformers.FunnelTokenizer",parameters:[{name:"vocab_file",val:""},{name:"do_lower_case",val:" = True"},{name:"do_basic_tokenize",val:" = True"},{name:"never_split",val:" = None"},{name:"unk_token",val:" = '<unk>'"},{name:"sep_token",val:" = '<sep>'"},{name:"pad_token",val:" = '<pad>'"},{name:"cls_token",val:" = '<cls>'"},{name:"mask_token",val:" = '<mask>'"},{name:"bos_token",val:" = '<s>'"},{name:"eos_token",val:" = '</s>'"},{name:"tokenize_chinese_chars",val:" = True"},{name:"strip_accents",val:" = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/tokenization_funnel.py#L58"}}),Ho=new X({props:{name:"build_inputs_with_special_tokens",anchor:"transformers.BertTokenizer.build_inputs_with_special_tokens",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/bert/tokenization_bert.py#L248",parametersDescription:[{anchor:"transformers.BertTokenizer.build_inputs_with_special_tokens.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs to which the special tokens will be added.`,name:"token_ids_0"},{anchor:"transformers.BertTokenizer.build_inputs_with_special_tokens.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"}],returnDescription:`
<p>List of <a href="../glossary#input-ids">input IDs</a> with the appropriate special tokens.</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),Yo=new X({props:{name:"get_special_tokens_mask",anchor:"transformers.BertTokenizer.get_special_tokens_mask",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"},{name:"already_has_special_tokens",val:": bool = False"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/bert/tokenization_bert.py#L273",parametersDescription:[{anchor:"transformers.BertTokenizer.get_special_tokens_mask.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs.`,name:"token_ids_0"},{anchor:"transformers.BertTokenizer.get_special_tokens_mask.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"},{anchor:"transformers.BertTokenizer.get_special_tokens_mask.already_has_special_tokens",description:`<strong>already_has_special_tokens</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not the token list is already formatted with special tokens for the model.`,name:"already_has_special_tokens"}],returnDescription:`
<p>A list of integers in the range [0, 1]: 1 for a special token, 0 for a sequence token.</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),Go=new X({props:{name:"create_token_type_ids_from_sequences",anchor:"transformers.FunnelTokenizer.create_token_type_ids_from_sequences",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/tokenization_funnel.py#L108",parametersDescription:[{anchor:"transformers.FunnelTokenizer.create_token_type_ids_from_sequences.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs.`,name:"token_ids_0"},{anchor:"transformers.FunnelTokenizer.create_token_type_ids_from_sequences.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"}],returnDescription:`
<p>List of <a href="../glossary#token-type-ids">token type IDs</a> according to the given sequence(s).</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),Zo=new ye({props:{code:`2 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1
| first sequence    | second sequence |`,highlighted:`2<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1 1
| first sequence    | second sequence |`}}),Xo=new X({props:{name:"save_vocabulary",anchor:"transformers.BertTokenizer.save_vocabulary",parameters:[{name:"save_directory",val:": str"},{name:"filename_prefix",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/bert/tokenization_bert.py#L330"}}),Jo=new je({}),es=new X({props:{name:"class transformers.FunnelTokenizerFast",anchor:"transformers.FunnelTokenizerFast",parameters:[{name:"vocab_file",val:" = None"},{name:"tokenizer_file",val:" = None"},{name:"do_lower_case",val:" = True"},{name:"unk_token",val:" = '<unk>'"},{name:"sep_token",val:" = '<sep>'"},{name:"pad_token",val:" = '<pad>'"},{name:"cls_token",val:" = '<cls>'"},{name:"mask_token",val:" = '<mask>'"},{name:"bos_token",val:" = '<s>'"},{name:"eos_token",val:" = '</s>'"},{name:"clean_text",val:" = True"},{name:"tokenize_chinese_chars",val:" = True"},{name:"strip_accents",val:" = None"},{name:"wordpieces_prefix",val:" = '##'"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/tokenization_funnel_fast.py#L71"}}),os=new X({props:{name:"create_token_type_ids_from_sequences",anchor:"transformers.FunnelTokenizerFast.create_token_type_ids_from_sequences",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/tokenization_funnel_fast.py#L124",parametersDescription:[{anchor:"transformers.FunnelTokenizerFast.create_token_type_ids_from_sequences.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs.`,name:"token_ids_0"},{anchor:"transformers.FunnelTokenizerFast.create_token_type_ids_from_sequences.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"}],returnDescription:`
<p>List of <a href="../glossary#token-type-ids">token type IDs</a> according to the given sequence(s).</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),ss=new ye({props:{code:`2 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1
| first sequence    | second sequence |`,highlighted:`2<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1 1
| first sequence    | second sequence |`}}),rs=new je({}),as=new X({props:{name:"class transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput",anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput",parameters:[{name:"loss",val:": typing.Optional[torch.FloatTensor] = None"},{name:"logits",val:": FloatTensor = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"attentions",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L834",parametersDescription:[{anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput.loss",description:`<strong>loss</strong> (<em>optional</em>, returned when <code>labels</code> is provided, <code>torch.FloatTensor</code> of shape <code>(1,)</code>) &#x2014;
Total loss of the ELECTRA-style objective.`,name:"loss"},{anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput.logits",description:`<strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Prediction scores of the head (scores for each token before SoftMax).`,name:"logits"},{anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput.hidden_states",description:`<strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.`,name:"hidden_states"},{anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput.attentions",description:`<strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.`,name:"attentions"}]}}),ls=new X({props:{name:"class transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput",anchor:"transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput",parameters:[{name:"logits",val:": Tensor = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[tensorflow.python.framework.ops.Tensor]] = None"},{name:"attentions",val:": typing.Optional[typing.Tuple[tensorflow.python.framework.ops.Tensor]] = None"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L980",parametersDescription:[{anchor:"transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput.logits",description:`<strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Prediction scores of the head (scores for each token before SoftMax).`,name:"logits"},{anchor:"transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput.hidden_states",description:`<strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.`,name:"hidden_states"},{anchor:"transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput.attentions",description:`<strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) &#x2014;
Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.`,name:"attentions"}]}}),cs=new je({}),ps=new X({props:{name:"class transformers.FunnelBaseModel",anchor:"transformers.FunnelBaseModel",parameters:[{name:"config",val:": FunnelConfig"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L927",parametersDescription:[{anchor:"transformers.FunnelBaseModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),_s=new X({props:{name:"forward",anchor:"transformers.FunnelBaseModel.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"position_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"head_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L943",parametersDescription:[{anchor:"transformers.FunnelBaseModel.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelBaseModel.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelBaseModel.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelBaseModel.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelBaseModel.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelBaseModel.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelBaseModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Kt=new qe({props:{$$slots:{default:[H$]},$$scope:{ctx:V}}}),Ts=new ye({props:{code:`from transformers import FunnelTokenizer, FunnelBaseModel
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = FunnelBaseModel.from_pretrained("funnel-transformer/small-base")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
outputs = model(**inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelBaseModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelBaseModel.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),ks=new je({}),Fs=new X({props:{name:"class transformers.FunnelModel",anchor:"transformers.FunnelModel",parameters:[{name:"config",val:": FunnelConfig"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1004",parametersDescription:[{anchor:"transformers.FunnelModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Es=new X({props:{name:"forward",anchor:"transformers.FunnelModel.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1021",parametersDescription:[{anchor:"transformers.FunnelModel.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelModel.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelModel.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelModel.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelModel.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelModel.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Zt=new qe({props:{$$slots:{default:[V$]},$$scope:{ctx:V}}}),Ms=new ye({props:{code:`from transformers import FunnelTokenizer, FunnelModel
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelModel.from_pretrained("funnel-transformer/small")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
outputs = model(**inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelModel.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),zs=new je({}),qs=new X({props:{name:"class transformers.FunnelForPreTraining",anchor:"transformers.FunnelForPreTraining",parameters:[{name:"config",val:": FunnelConfig"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1112"}}),Ps=new X({props:{name:"forward",anchor:"transformers.FunnelForPreTraining.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1121",parametersDescription:[{anchor:"transformers.FunnelForPreTraining.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForPreTraining.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForPreTraining.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForPreTraining.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForPreTraining.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForPreTraining.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForPreTraining.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForPreTraining.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the ELECTRA-style loss. Input should be a sequence of tokens (see <code>input_ids</code>
docstring) Indices should be in <code>[0, 1]</code>:</p>
<ul>
<li>0 indicates the token is an original token,</li>
<li>1 indicates the token was replaced.</li>
</ul>`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput"
>transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<em>optional</em>, returned when <code>labels</code> is provided, <code>torch.FloatTensor</code> of shape <code>(1,)</code>) \u2014 Total loss of the ELECTRA-style objective.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Prediction scores of the head (scores for each token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput"
>transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Jt=new qe({props:{$$slots:{default:[Y$]},$$scope:{ctx:V}}}),js=new ye({props:{code:`from transformers import FunnelTokenizer, FunnelForPreTraining
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelForPreTraining.from_pretrained("funnel-transformer/small")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
logits = model(**inputs).logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForPreTraining
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForPreTraining.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(**inputs).logits`}}),Cs=new je({}),xs=new X({props:{name:"class transformers.FunnelForMaskedLM",anchor:"transformers.FunnelForMaskedLM",parameters:[{name:"config",val:": FunnelConfig"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1195",parametersDescription:[{anchor:"transformers.FunnelForMaskedLM.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Is=new X({props:{name:"forward",anchor:"transformers.FunnelForMaskedLM.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1211",parametersDescription:[{anchor:"transformers.FunnelForMaskedLM.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForMaskedLM.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForMaskedLM.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForMaskedLM.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForMaskedLM.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForMaskedLM.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForMaskedLM.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForMaskedLM.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the masked language modeling loss. Indices should be in <code>[-100, 0, ..., config.vocab_size]</code> (see <code>input_ids</code> docstring) Tokens with indices set to <code>-100</code> are ignored (masked), the
loss is only computed for the tokens with labels in <code>[0, ..., config.vocab_size]</code>`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.MaskedLMOutput"
>transformers.modeling_outputs.MaskedLMOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Masked language modeling (MLM) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, config.vocab_size)</code>) \u2014 Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.MaskedLMOutput"
>transformers.modeling_outputs.MaskedLMOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),no=new qe({props:{$$slots:{default:[K$]},$$scope:{ctx:V}}}),Bs=new ye({props:{code:`from transformers import FunnelTokenizer, FunnelForMaskedLM
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelForMaskedLM.from_pretrained("funnel-transformer/small")

inputs = tokenizer("The capital of France is <mask>.", return_tensors="pt")

with torch.no_grad():
    logits = model(**inputs).logits

# retrieve index of <mask>
mask_token_index = (inputs.input_ids == tokenizer.mask_token_id)[0].nonzero(as_tuple=True)[0]

predicted_token_id = logits[0, mask_token_index].argmax(axis=-1)
tokenizer.decode(predicted_token_id)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForMaskedLM
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForMaskedLM.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;The capital of France is &lt;mask&gt;.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># retrieve index of &lt;mask&gt;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>mask_token_index = (inputs.input_ids == tokenizer.mask_token_id)[<span class="hljs-number">0</span>].nonzero(as_tuple=<span class="hljs-literal">True</span>)[<span class="hljs-number">0</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_token_id = logits[<span class="hljs-number">0</span>, mask_token_index].argmax(axis=-<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.decode(predicted_token_id)
`}}),Ws=new ye({props:{code:`labels = tokenizer("The capital of France is Paris.", return_tensors="pt")["input_ids"]
# mask labels of non-<mask> tokens
labels = torch.where(inputs.input_ids == tokenizer.mask_token_id, labels, -100)

outputs = model(**inputs, labels=labels)
round(outputs.loss.item(), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>labels = tokenizer(<span class="hljs-string">&quot;The capital of France is Paris.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)[<span class="hljs-string">&quot;input_ids&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># mask labels of non-&lt;mask&gt; tokens</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.where(inputs.input_ids == tokenizer.mask_token_id, labels, -<span class="hljs-number">100</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, labels=labels)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(outputs.loss.item(), <span class="hljs-number">2</span>)
`}}),Qs=new je({}),Us=new X({props:{name:"class transformers.FunnelForSequenceClassification",anchor:"transformers.FunnelForSequenceClassification",parameters:[{name:"config",val:": FunnelConfig"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1275",parametersDescription:[{anchor:"transformers.FunnelForSequenceClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Gs=new X({props:{name:"forward",anchor:"transformers.FunnelForSequenceClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1286",parametersDescription:[{anchor:"transformers.FunnelForSequenceClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForSequenceClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForSequenceClassification.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForSequenceClassification.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForSequenceClassification.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForSequenceClassification.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForSequenceClassification.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForSequenceClassification.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the sequence classification/regression loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>. If <code>config.num_labels == 1</code> a regression loss is computed (Mean-Square loss), If
<code>config.num_labels &gt; 1</code> a classification loss is computed (Cross-Entropy).`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.SequenceClassifierOutput"
>transformers.modeling_outputs.SequenceClassifierOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification (or regression if config.num_labels==1) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.num_labels)</code>) \u2014 Classification (or regression if config.num_labels==1) scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.SequenceClassifierOutput"
>transformers.modeling_outputs.SequenceClassifierOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),oo=new qe({props:{$$slots:{default:[G$]},$$scope:{ctx:V}}}),Zs=new ye({props:{code:`import torch
from transformers import FunnelTokenizer, FunnelForSequenceClassification

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = FunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")

with torch.no_grad():
    logits = model(**inputs).logits

predicted_class_id = logits.argmax().item()
model.config.id2label[predicted_class_id]
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_class_id = logits.argmax().item()
<span class="hljs-meta">&gt;&gt;&gt; </span>model.config.id2label[predicted_class_id]
`}}),Xs=new ye({props:{code:`# To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`
num_labels = len(model.config.id2label)
model = FunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base", num_labels=num_labels)

labels = torch.tensor(1)
loss = model(**inputs, labels=labels).loss
round(loss.item(), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>num_labels = <span class="hljs-built_in">len</span>(model.config.id2label)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>, num_labels=num_labels)

<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.tensor(<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = model(**inputs, labels=labels).loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(loss.item(), <span class="hljs-number">2</span>)
`}}),Js=new ye({props:{code:`import torch
from transformers import FunnelTokenizer, FunnelForSequenceClassification

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = FunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base", problem_type="multi_label_classification")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")

with torch.no_grad():
    logits = model(**inputs).logits

predicted_class_id = logits.argmax().item()
model.config.id2label[predicted_class_id]
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>, problem_type=<span class="hljs-string">&quot;multi_label_classification&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_class_id = logits.argmax().item()
<span class="hljs-meta">&gt;&gt;&gt; </span>model.config.id2label[predicted_class_id]
`}}),er=new ye({props:{code:`# To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`
num_labels = len(model.config.id2label)
model = FunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base", num_labels=num_labels)

num_labels = len(model.config.id2label)
labels = torch.nn.functional.one_hot(torch.tensor([predicted_class_id]), num_classes=num_labels).to(
    torch.float
)
loss = model(**inputs, labels=labels).loss
loss.backward()`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>num_labels = <span class="hljs-built_in">len</span>(model.config.id2label)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>, num_labels=num_labels)

<span class="hljs-meta">&gt;&gt;&gt; </span>num_labels = <span class="hljs-built_in">len</span>(model.config.id2label)
<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.nn.functional.one_hot(torch.tensor([predicted_class_id]), num_classes=num_labels).to(
<span class="hljs-meta">... </span>    torch.<span class="hljs-built_in">float</span>
<span class="hljs-meta">... </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = model(**inputs, labels=labels).loss
<span class="hljs-meta">&gt;&gt;&gt; </span>loss.backward()`}}),nr=new je({}),tr=new X({props:{name:"class transformers.FunnelForMultipleChoice",anchor:"transformers.FunnelForMultipleChoice",parameters:[{name:"config",val:": FunnelConfig"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1368",parametersDescription:[{anchor:"transformers.FunnelForMultipleChoice.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),lr=new X({props:{name:"forward",anchor:"transformers.FunnelForMultipleChoice.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1377",parametersDescription:[{anchor:"transformers.FunnelForMultipleChoice.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForMultipleChoice.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForMultipleChoice.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForMultipleChoice.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForMultipleChoice.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForMultipleChoice.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForMultipleChoice.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForMultipleChoice.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the multiple choice classification loss. Indices should be in <code>[0, ..., num_choices-1]</code> where <code>num_choices</code> is the size of the second dimension of the input tensors. (See
<code>input_ids</code> above)`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.MultipleChoiceModelOutput"
>transformers.modeling_outputs.MultipleChoiceModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <em>(1,)</em>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices)</code>) \u2014 <em>num_choices</em> is the second dimension of the input tensors. (see <em>input_ids</em> above).</p>
<p>Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.MultipleChoiceModelOutput"
>transformers.modeling_outputs.MultipleChoiceModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),ro=new qe({props:{$$slots:{default:[Z$]},$$scope:{ctx:V}}}),dr=new ye({props:{code:`from transformers import FunnelTokenizer, FunnelForMultipleChoice
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = FunnelForMultipleChoice.from_pretrained("funnel-transformer/small-base")

prompt = "In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced."
choice0 = "It is eaten with a fork and a knife."
choice1 = "It is eaten while held in the hand."
labels = torch.tensor(0).unsqueeze(0)  # choice0 is correct (according to Wikipedia ;)), batch size 1

encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors="pt", padding=True)
outputs = model(**{k: v.unsqueeze(0) for k, v in encoding.items()}, labels=labels)  # batch size is 1

# the linear classifier still needs to be trained
loss = outputs.loss
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForMultipleChoice
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForMultipleChoice.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>prompt = <span class="hljs-string">&quot;In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice0 = <span class="hljs-string">&quot;It is eaten with a fork and a knife.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice1 = <span class="hljs-string">&quot;It is eaten while held in the hand.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.tensor(<span class="hljs-number">0</span>).unsqueeze(<span class="hljs-number">0</span>)  <span class="hljs-comment"># choice0 is correct (according to Wikipedia ;)), batch size 1</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors=<span class="hljs-string">&quot;pt&quot;</span>, padding=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**{k: v.unsqueeze(<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> encoding.items()}, labels=labels)  <span class="hljs-comment"># batch size is 1</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># the linear classifier still needs to be trained</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = outputs.loss
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),cr=new je({}),pr=new X({props:{name:"class transformers.FunnelForTokenClassification",anchor:"transformers.FunnelForTokenClassification",parameters:[{name:"config",val:": FunnelConfig"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1452",parametersDescription:[{anchor:"transformers.FunnelForTokenClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),_r=new X({props:{name:"forward",anchor:"transformers.FunnelForTokenClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1464",parametersDescription:[{anchor:"transformers.FunnelForTokenClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForTokenClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForTokenClassification.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForTokenClassification.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForTokenClassification.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForTokenClassification.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForTokenClassification.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForTokenClassification.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the token classification loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>.`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.TokenClassifierOutput"
>transformers.modeling_outputs.TokenClassifierOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided)  \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, config.num_labels)</code>) \u2014 Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.TokenClassifierOutput"
>transformers.modeling_outputs.TokenClassifierOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),io=new qe({props:{$$slots:{default:[X$]},$$scope:{ctx:V}}}),Tr=new ye({props:{code:`from transformers import FunnelTokenizer, FunnelForTokenClassification
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelForTokenClassification.from_pretrained("funnel-transformer/small")

inputs = tokenizer(
    "HuggingFace is a company based in Paris and New York", add_special_tokens=False, return_tensors="pt"
)

with torch.no_grad():
    logits = model(**inputs).logits

predicted_token_class_ids = logits.argmax(-1)

# Note that tokens are classified rather then input words which means that
# there might be more predicted token classes than words.
# Multiple token classes might account for the same word
predicted_tokens_classes = [model.config.id2label[t.item()] for t in predicted_token_class_ids[0]]
predicted_tokens_classes
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForTokenClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;HuggingFace is a company based in Paris and New York&quot;</span>, add_special_tokens=<span class="hljs-literal">False</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>
<span class="hljs-meta">... </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_token_class_ids = logits.argmax(-<span class="hljs-number">1</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Note that tokens are classified rather then input words which means that</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># there might be more predicted token classes than words.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Multiple token classes might account for the same word</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_tokens_classes = [model.config.id2label[t.item()] <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> predicted_token_class_ids[<span class="hljs-number">0</span>]]
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_tokens_classes
`}}),kr=new ye({props:{code:`labels = predicted_token_class_ids
loss = model(**inputs, labels=labels).loss
round(loss.item(), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>labels = predicted_token_class_ids
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = model(**inputs, labels=labels).loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(loss.item(), <span class="hljs-number">2</span>)
`}}),Fr=new je({}),vr=new X({props:{name:"class transformers.FunnelForQuestionAnswering",anchor:"transformers.FunnelForQuestionAnswering",parameters:[{name:"config",val:": FunnelConfig"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1526",parametersDescription:[{anchor:"transformers.FunnelForQuestionAnswering.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Mr=new X({props:{name:"forward",anchor:"transformers.FunnelForQuestionAnswering.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"start_positions",val:": typing.Optional[torch.Tensor] = None"},{name:"end_positions",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_funnel.py#L1537",parametersDescription:[{anchor:"transformers.FunnelForQuestionAnswering.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForQuestionAnswering.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForQuestionAnswering.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForQuestionAnswering.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForQuestionAnswering.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForQuestionAnswering.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForQuestionAnswering.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForQuestionAnswering.forward.start_positions",description:`<strong>start_positions</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the start of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"start_positions"},{anchor:"transformers.FunnelForQuestionAnswering.forward.end_positions",description:`<strong>end_positions</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the end of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"end_positions"}],returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.QuestionAnsweringModelOutput"
>transformers.modeling_outputs.QuestionAnsweringModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.</p>
</li>
<li>
<p><strong>start_logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-start scores (before SoftMax).</p>
</li>
<li>
<p><strong>end_logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-end scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.QuestionAnsweringModelOutput"
>transformers.modeling_outputs.QuestionAnsweringModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),co=new qe({props:{$$slots:{default:[J$]},$$scope:{ctx:V}}}),zr=new ye({props:{code:`from transformers import FunnelTokenizer, FunnelForQuestionAnswering
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelForQuestionAnswering.from_pretrained("funnel-transformer/small")

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"

inputs = tokenizer(question, text, return_tensors="pt")
with torch.no_grad():
    outputs = model(**inputs)

answer_start_index = outputs.start_logits.argmax()
answer_end_index = outputs.end_logits.argmax()

predict_answer_tokens = inputs.input_ids[0, answer_start_index : answer_end_index + 1]
tokenizer.decode(predict_answer_tokens)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForQuestionAnswering
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(question, text, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>answer_start_index = outputs.start_logits.argmax()
<span class="hljs-meta">&gt;&gt;&gt; </span>answer_end_index = outputs.end_logits.argmax()

<span class="hljs-meta">&gt;&gt;&gt; </span>predict_answer_tokens = inputs.input_ids[<span class="hljs-number">0</span>, answer_start_index : answer_end_index + <span class="hljs-number">1</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.decode(predict_answer_tokens)
`}}),qr=new ye({props:{code:`# target is "nice puppet"
target_start_index, target_end_index = torch.tensor([14]), torch.tensor([15])

outputs = model(**inputs, start_positions=target_start_index, end_positions=target_end_index)
loss = outputs.loss
round(loss.item(), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># target is &quot;nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>target_start_index, target_end_index = torch.tensor([<span class="hljs-number">14</span>]), torch.tensor([<span class="hljs-number">15</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, start_positions=target_start_index, end_positions=target_end_index)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = outputs.loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(loss.item(), <span class="hljs-number">2</span>)
`}}),Pr=new je({}),jr=new X({props:{name:"class transformers.TFFunnelBaseModel",anchor:"transformers.TFFunnelBaseModel",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1097",parametersDescription:[{anchor:"transformers.TFFunnelBaseModel.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),uo=new qe({props:{$$slots:{default:[e2]},$$scope:{ctx:V}}}),Ar=new X({props:{name:"call",anchor:"transformers.TFFunnelBaseModel.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"training",val:": bool = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1102",parametersDescription:[{anchor:"transformers.TFFunnelBaseModel.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelBaseModel.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelBaseModel.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelBaseModel.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelBaseModel.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelBaseModel.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelBaseModel.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used
in eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelBaseModel.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"}],returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFBaseModelOutput"
>transformers.modeling_tf_outputs.TFBaseModelOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFBaseModelOutput"
>transformers.modeling_tf_outputs.TFBaseModelOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),ho=new qe({props:{$$slots:{default:[n2]},$$scope:{ctx:V}}}),Nr=new ye({props:{code:`from transformers import FunnelTokenizer, TFFunnelBaseModel
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = TFFunnelBaseModel.from_pretrained("funnel-transformer/small-base")

inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")
outputs = model(inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelBaseModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelBaseModel.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),Sr=new je({}),Ir=new X({props:{name:"class transformers.TFFunnelModel",anchor:"transformers.TFFunnelModel",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1145",parametersDescription:[{anchor:"transformers.TFFunnelModel.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),mo=new qe({props:{$$slots:{default:[t2]},$$scope:{ctx:V}}}),Hr=new X({props:{name:"call",anchor:"transformers.TFFunnelModel.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"training",val:": bool = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1150",parametersDescription:[{anchor:"transformers.TFFunnelModel.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelModel.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelModel.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelModel.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelModel.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelModel.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelModel.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used
in eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelModel.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"}],returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFBaseModelOutput"
>transformers.modeling_tf_outputs.TFBaseModelOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFBaseModelOutput"
>transformers.modeling_tf_outputs.TFBaseModelOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),go=new qe({props:{$$slots:{default:[o2]},$$scope:{ctx:V}}}),Vr=new ye({props:{code:`from transformers import FunnelTokenizer, TFFunnelModel
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelModel.from_pretrained("funnel-transformer/small")

inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")
outputs = model(inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelModel.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),Yr=new je({}),Kr=new X({props:{name:"class transformers.TFFunnelForPreTraining",anchor:"transformers.TFFunnelForPreTraining",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1196",parametersDescription:[{anchor:"transformers.TFFunnelForPreTraining.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),To=new qe({props:{$$slots:{default:[s2]},$$scope:{ctx:V}}}),na=new X({props:{name:"call",anchor:"transformers.TFFunnelForPreTraining.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"training",val:": bool = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1203",parametersDescription:[{anchor:"transformers.TFFunnelForPreTraining.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForPreTraining.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForPreTraining.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForPreTraining.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForPreTraining.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForPreTraining.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForPreTraining.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used
in eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForPreTraining.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"}],returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput"
>transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Prediction scores of the head (scores for each token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput"
>transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),ko=new qe({props:{$$slots:{default:[r2]},$$scope:{ctx:V}}}),ta=new ye({props:{code:`from transformers import FunnelTokenizer, TFFunnelForPreTraining
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelForPreTraining.from_pretrained("funnel-transformer/small")

inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")
logits = model(inputs).logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForPreTraining
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForPreTraining.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(inputs).logits`}}),oa=new je({}),sa=new X({props:{name:"class transformers.TFFunnelForMaskedLM",anchor:"transformers.TFFunnelForMaskedLM",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1263",parametersDescription:[{anchor:"transformers.TFFunnelForMaskedLM.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),vo=new qe({props:{$$slots:{default:[a2]},$$scope:{ctx:V}}}),pa=new X({props:{name:"call",anchor:"transformers.TFFunnelForMaskedLM.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"labels",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1277",parametersDescription:[{anchor:"transformers.TFFunnelForMaskedLM.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForMaskedLM.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForMaskedLM.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForMaskedLM.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForMaskedLM.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForMaskedLM.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForMaskedLM.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used
in eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForMaskedLM.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForMaskedLM.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the masked language modeling loss. Indices should be in <code>[-100, 0, ..., config.vocab_size]</code> (see <code>input_ids</code> docstring) Tokens with indices set to <code>-100</code> are ignored (masked), the
loss is only computed for the tokens with labels in <code>[0, ..., config.vocab_size]</code>`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFMaskedLMOutput"
>transformers.modeling_tf_outputs.TFMaskedLMOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(n,)</code>, <em>optional</em>, where n is the number of non-masked labels, returned when <code>labels</code> is provided) \u2014 Masked language modeling (MLM) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, config.vocab_size)</code>) \u2014 Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFMaskedLMOutput"
>transformers.modeling_tf_outputs.TFMaskedLMOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),yo=new qe({props:{$$slots:{default:[i2]},$$scope:{ctx:V}}}),ua=new ye({props:{code:`from transformers import FunnelTokenizer, TFFunnelForMaskedLM
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelForMaskedLM.from_pretrained("funnel-transformer/small")

inputs = tokenizer("The capital of France is [MASK].", return_tensors="tf")
logits = model(**inputs).logits

# retrieve index of [MASK]
mask_token_index = tf.where(inputs.input_ids == tokenizer.mask_token_id)[0][1]

predicted_token_id = tf.math.argmax(logits[0, mask_token_index], axis=-1)
tokenizer.decode(predicted_token_id)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForMaskedLM
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForMaskedLM.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;The capital of France is [MASK].&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># retrieve index of [MASK]</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>mask_token_index = tf.where(inputs.input_ids == tokenizer.mask_token_id)[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_token_id = tf.math.argmax(logits[<span class="hljs-number">0</span>, mask_token_index], axis=-<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.decode(predicted_token_id)
`}}),ha=new ye({props:{code:`labels = tokenizer("The capital of France is Paris.", return_tensors="tf")["input_ids"]
# mask labels of non-[MASK] tokens
labels = tf.where(inputs.input_ids == tokenizer.mask_token_id, labels, -100)

outputs = model(**inputs, labels=labels)
round(float(outputs.loss), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>labels = tokenizer(<span class="hljs-string">&quot;The capital of France is Paris.&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)[<span class="hljs-string">&quot;input_ids&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># mask labels of non-[MASK] tokens</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>labels = tf.where(inputs.input_ids == tokenizer.mask_token_id, labels, -<span class="hljs-number">100</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, labels=labels)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(<span class="hljs-built_in">float</span>(outputs.loss), <span class="hljs-number">2</span>)
`}}),fa=new je({}),ma=new X({props:{name:"class transformers.TFFunnelForSequenceClassification",anchor:"transformers.TFFunnelForSequenceClassification",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1345",parametersDescription:[{anchor:"transformers.TFFunnelForSequenceClassification.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),bo=new qe({props:{$$slots:{default:[l2]},$$scope:{ctx:V}}}),va=new X({props:{name:"call",anchor:"transformers.TFFunnelForSequenceClassification.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"labels",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1353",parametersDescription:[{anchor:"transformers.TFFunnelForSequenceClassification.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForSequenceClassification.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForSequenceClassification.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForSequenceClassification.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForSequenceClassification.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForSequenceClassification.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForSequenceClassification.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used
in eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForSequenceClassification.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForSequenceClassification.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the sequence classification/regression loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>. If <code>config.num_labels == 1</code> a regression loss is computed (Mean-Square loss), If
<code>config.num_labels &gt; 1</code> a classification loss is computed (Cross-Entropy).`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFSequenceClassifierOutput"
>transformers.modeling_tf_outputs.TFSequenceClassifierOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, )</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification (or regression if config.num_labels==1) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, config.num_labels)</code>) \u2014 Classification (or regression if config.num_labels==1) scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFSequenceClassifierOutput"
>transformers.modeling_tf_outputs.TFSequenceClassifierOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),$o=new qe({props:{$$slots:{default:[d2]},$$scope:{ctx:V}}}),ya=new ye({props:{code:`from transformers import FunnelTokenizer, TFFunnelForSequenceClassification
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = TFFunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base")

inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")

logits = model(**inputs).logits

predicted_class_id = int(tf.math.argmax(logits, axis=-1)[0])
model.config.id2label[predicted_class_id]
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForSequenceClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_class_id = <span class="hljs-built_in">int</span>(tf.math.argmax(logits, axis=-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>model.config.id2label[predicted_class_id]
`}}),wa=new ye({props:{code:`# To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`
num_labels = len(model.config.id2label)
model = TFFunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base", num_labels=num_labels)

labels = tf.constant(1)
loss = model(**inputs, labels=labels).loss
round(float(loss), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>num_labels = <span class="hljs-built_in">len</span>(model.config.id2label)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>, num_labels=num_labels)

<span class="hljs-meta">&gt;&gt;&gt; </span>labels = tf.constant(<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = model(**inputs, labels=labels).loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(<span class="hljs-built_in">float</span>(loss), <span class="hljs-number">2</span>)
`}}),ba=new je({}),$a=new X({props:{name:"class transformers.TFFunnelForMultipleChoice",anchor:"transformers.TFFunnelForMultipleChoice",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1422",parametersDescription:[{anchor:"transformers.TFFunnelForMultipleChoice.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Mo=new qe({props:{$$slots:{default:[c2]},$$scope:{ctx:V}}}),ja=new X({props:{name:"call",anchor:"transformers.TFFunnelForMultipleChoice.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"labels",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1439",parametersDescription:[{anchor:"transformers.TFFunnelForMultipleChoice.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForMultipleChoice.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForMultipleChoice.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForMultipleChoice.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, num_choices, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForMultipleChoice.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForMultipleChoice.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForMultipleChoice.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used
in eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForMultipleChoice.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForMultipleChoice.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the multiple choice classification loss. Indices should be in <code>[0, ..., num_choices]</code>
where <code>num_choices</code> is the size of the second dimension of the input tensors. (See <code>input_ids</code> above)`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput"
>transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <em>(batch_size, )</em>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, num_choices)</code>) \u2014 <em>num_choices</em> is the second dimension of the input tensors. (see <em>input_ids</em> above).</p>
<p>Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput"
>transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),zo=new qe({props:{$$slots:{default:[p2]},$$scope:{ctx:V}}}),Ca=new ye({props:{code:`from transformers import FunnelTokenizer, TFFunnelForMultipleChoice
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = TFFunnelForMultipleChoice.from_pretrained("funnel-transformer/small-base")

prompt = "In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced."
choice0 = "It is eaten with a fork and a knife."
choice1 = "It is eaten while held in the hand."

encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors="tf", padding=True)
inputs = {k: tf.expand_dims(v, 0) for k, v in encoding.items()}
outputs = model(inputs)  # batch size is 1

# the linear classifier still needs to be trained
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForMultipleChoice
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForMultipleChoice.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>prompt = <span class="hljs-string">&quot;In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice0 = <span class="hljs-string">&quot;It is eaten with a fork and a knife.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice1 = <span class="hljs-string">&quot;It is eaten while held in the hand.&quot;</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors=<span class="hljs-string">&quot;tf&quot;</span>, padding=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = {k: tf.expand_dims(v, <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> encoding.items()}
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(inputs)  <span class="hljs-comment"># batch size is 1</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># the linear classifier still needs to be trained</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),xa=new je({}),La=new X({props:{name:"class transformers.TFFunnelForTokenClassification",anchor:"transformers.TFFunnelForTokenClassification",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1539",parametersDescription:[{anchor:"transformers.TFFunnelForTokenClassification.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Po=new qe({props:{$$slots:{default:[u2]},$$scope:{ctx:V}}}),Ia=new X({props:{name:"call",anchor:"transformers.TFFunnelForTokenClassification.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"labels",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1550",parametersDescription:[{anchor:"transformers.TFFunnelForTokenClassification.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForTokenClassification.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForTokenClassification.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForTokenClassification.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForTokenClassification.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForTokenClassification.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForTokenClassification.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used
in eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForTokenClassification.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForTokenClassification.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the token classification loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>.`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFTokenClassifierOutput"
>transformers.modeling_tf_outputs.TFTokenClassifierOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(n,)</code>, <em>optional</em>, where n is the number of unmasked labels, returned when <code>labels</code> is provided)  \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, config.num_labels)</code>) \u2014 Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFTokenClassifierOutput"
>transformers.modeling_tf_outputs.TFTokenClassifierOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),jo=new qe({props:{$$slots:{default:[h2]},$$scope:{ctx:V}}}),Ba=new ye({props:{code:`from transformers import FunnelTokenizer, TFFunnelForTokenClassification
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelForTokenClassification.from_pretrained("funnel-transformer/small")

inputs = tokenizer(
    "HuggingFace is a company based in Paris and New York", add_special_tokens=False, return_tensors="tf"
)

logits = model(**inputs).logits
predicted_token_class_ids = tf.math.argmax(logits, axis=-1)

# Note that tokens are classified rather then input words which means that
# there might be more predicted token classes than words.
# Multiple token classes might account for the same word
predicted_tokens_classes = [model.config.id2label[t] for t in predicted_token_class_ids[0].numpy().tolist()]
predicted_tokens_classes
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForTokenClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;HuggingFace is a company based in Paris and New York&quot;</span>, add_special_tokens=<span class="hljs-literal">False</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>
<span class="hljs-meta">... </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(**inputs).logits
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_token_class_ids = tf.math.argmax(logits, axis=-<span class="hljs-number">1</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Note that tokens are classified rather then input words which means that</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># there might be more predicted token classes than words.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Multiple token classes might account for the same word</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_tokens_classes = [model.config.id2label[t] <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> predicted_token_class_ids[<span class="hljs-number">0</span>].numpy().tolist()]
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_tokens_classes
`}}),Wa=new ye({props:{code:`labels = predicted_token_class_ids
loss = tf.math.reduce_mean(model(**inputs, labels=labels).loss)
round(float(loss), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>labels = predicted_token_class_ids
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = tf.math.reduce_mean(model(**inputs, labels=labels).loss)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(<span class="hljs-built_in">float</span>(loss), <span class="hljs-number">2</span>)
`}}),Qa=new je({}),Ua=new X({props:{name:"class transformers.TFFunnelForQuestionAnswering",anchor:"transformers.TFFunnelForQuestionAnswering",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1618",parametersDescription:[{anchor:"transformers.TFFunnelForQuestionAnswering.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),xo=new qe({props:{$$slots:{default:[f2]},$$scope:{ctx:V}}}),Ga=new X({props:{name:"call",anchor:"transformers.TFFunnelForQuestionAnswering.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"start_positions",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"end_positions",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/funnel/modeling_tf_funnel.py#L1628",parametersDescription:[{anchor:"transformers.TFFunnelForQuestionAnswering.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/main/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used
in eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.start_positions",description:`<strong>start_positions</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the start of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"start_positions"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.end_positions",description:`<strong>end_positions</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the end of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"end_positions"}],returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput"
>transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/main/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, )</code>, <em>optional</em>, returned when <code>start_positions</code> and <code>end_positions</code> are provided) \u2014 Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.</p>
</li>
<li>
<p><strong>start_logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-start scores (before SoftMax).</p>
</li>
<li>
<p><strong>end_logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-end scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput"
>transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),Lo=new qe({props:{$$slots:{default:[m2]},$$scope:{ctx:V}}}),Za=new ye({props:{code:`from transformers import FunnelTokenizer, TFFunnelForQuestionAnswering
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelForQuestionAnswering.from_pretrained("funnel-transformer/small")

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"

inputs = tokenizer(question, text, return_tensors="tf")
outputs = model(**inputs)

answer_start_index = int(tf.math.argmax(outputs.start_logits, axis=-1)[0])
answer_end_index = int(tf.math.argmax(outputs.end_logits, axis=-1)[0])

predict_answer_tokens = inputs.input_ids[0, answer_start_index : answer_end_index + 1]
tokenizer.decode(predict_answer_tokens)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForQuestionAnswering
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(question, text, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>answer_start_index = <span class="hljs-built_in">int</span>(tf.math.argmax(outputs.start_logits, axis=-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>answer_end_index = <span class="hljs-built_in">int</span>(tf.math.argmax(outputs.end_logits, axis=-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>predict_answer_tokens = inputs.input_ids[<span class="hljs-number">0</span>, answer_start_index : answer_end_index + <span class="hljs-number">1</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.decode(predict_answer_tokens)
`}}),Xa=new ye({props:{code:`# target is "nice puppet"
target_start_index, target_end_index = tf.constant([14]), tf.constant([15])

outputs = model(**inputs, start_positions=target_start_index, end_positions=target_end_index)
loss = tf.math.reduce_mean(outputs.loss)
round(float(loss), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># target is &quot;nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>target_start_index, target_end_index = tf.constant([<span class="hljs-number">14</span>]), tf.constant([<span class="hljs-number">15</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, start_positions=target_start_index, end_positions=target_end_index)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = tf.math.reduce_mean(outputs.loss)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(<span class="hljs-built_in">float</span>(loss), <span class="hljs-number">2</span>)
`}}),{c(){u=r("meta"),z=l(),g=r("h1"),_=r("a"),k=r("span"),F(T.$$.fragment),m=l(),M=r("span"),ce=t("Funnel Transformer"),K=l(),q=r("h2"),J=r("a"),A=r("span"),F(ne.$$.fragment),pe=l(),N=r("span"),ue=t("Overview"),ie=l(),Y=r("p"),L=t("The Funnel Transformer model was proposed in the paper "),te=r("a"),G=t(`Funnel-Transformer: Filtering out Sequential Redundancy for
Efficient Language Processing`),P=t(`. It is a bidirectional transformer model, like
BERT, but with a pooling operation after each block of layers, a bit like in traditional convolutional neural networks
(CNN) in computer vision.`),C=l(),oe=r("p"),W=t("The abstract from the paper is the following:"),le=l(),se=r("p"),S=r("em"),he=t(`With the success of language pretraining, it is highly desirable to develop more efficient architectures of good
scalability that can exploit the abundant unlabeled data at a lower cost. To improve the efficiency, we examine the
much-overlooked redundancy in maintaining a full-length token-level presentation, especially for tasks that only
require a single-vector presentation of the sequence. With this intuition, we propose Funnel-Transformer which
gradually compresses the sequence of hidden states to a shorter one and hence reduces the computation cost. More
importantly, by re-investing the saved FLOPs from length reduction in constructing a deeper or wider model, we further
improve the model capacity. In addition, to perform token-level predictions as required by common pretraining
objectives, Funnel-Transformer is able to recover a deep representation for each token from the reduced hidden sequence
via a decoder. Empirically, with comparable or fewer FLOPs, Funnel-Transformer outperforms the standard Transformer on
a wide variety of sequence-level prediction tasks, including text classification, language understanding, and reading
comprehension.`),de=l(),j=r("p"),fe=t("Tips:"),B=l(),ee=r("ul"),ae=r("li"),Q=t(`Since Funnel Transformer uses pooling, the sequence length of the hidden states changes after each block of layers.
The base model therefore has a final sequence length that is a quarter of the original one. This model can be used
directly for tasks that just require a sentence summary (like sequence classification or multiple choice). For other
tasks, the full model is used; this full model has a decoder that upsamples the final hidden states to the same
sequence length as the input.`),me=l(),I=r("li"),O=t(`The Funnel Transformer checkpoints are all available with a full version and a base version. The first ones should be
used for `),re=r("a"),U=t("FunnelModel"),ge=t(", "),p=r("a"),E=t("FunnelForPreTraining"),Z=t(`,
`),Te=r("a"),we=t("FunnelForMaskedLM"),D=t(", "),ke=r("a"),be=t("FunnelForTokenClassification"),$e=t(` and
class:`),x=r("em"),R=t("~transformers.FunnelForQuestionAnswering"),Ee=t(`. The second ones should be used for
`),Fe=r("a"),H=t("FunnelBaseModel"),Me=t(", "),ve=r("a"),_e=t("FunnelForSequenceClassification"),ze=t(` and
`),oi=r("a"),Yu=t("FunnelForMultipleChoice"),Ku=t("."),Oc=l(),In=r("p"),Gu=t("This model was contributed by "),No=r("a"),Zu=t("sgugger"),Xu=t(". The original code can be found "),So=r("a"),Ju=t("here"),eh=t("."),Dc=l(),Zn=r("h2"),Bt=r("a"),Fl=r("span"),F(Io.$$.fragment),nh=l(),vl=r("span"),th=t("FunnelConfig"),Ac=l(),Nn=r("div"),F(Bo.$$.fragment),oh=l(),Sn=r("p"),sh=t("This is the configuration class to store the configuration of a "),si=r("a"),rh=t("FunnelModel"),ah=t(" or a "),ri=r("a"),ih=t("TFBertModel"),lh=t(`. It is used to
instantiate a Funnel Transformer model according to the specified arguments, defining the model architecture.
Instantiating a configuration with the defaults will yield a similar configuration to that of the Funnel
Transformer `),Wo=r("a"),dh=t("funnel-transformer/small"),ch=t(" architecture."),ph=l(),Xn=r("p"),uh=t("Configuration objects inherit from "),ai=r("a"),hh=t("PretrainedConfig"),fh=t(` and can be used to control the model outputs. Read the
documentation from `),ii=r("a"),mh=t("PretrainedConfig"),gh=t(" for more information."),Nc=l(),Jn=r("h2"),Wt=r("a"),yl=r("span"),F(Qo.$$.fragment),_h=l(),wl=r("span"),Th=t("FunnelTokenizer"),Sc=l(),Ce=r("div"),F(Uo.$$.fragment),kh=l(),bl=r("p"),Fh=t("Construct a Funnel Transformer tokenizer."),vh=l(),Qt=r("p"),li=r("a"),yh=t("FunnelTokenizer"),wh=t(" is identical to "),di=r("a"),bh=t("BertTokenizer"),$h=t(` and runs end-to-end tokenization: punctuation splitting and
wordpiece.`),Eh=l(),Ro=r("p"),Mh=t("Refer to superclass "),ci=r("a"),zh=t("BertTokenizer"),qh=t(" for usage examples and documentation concerning parameters."),Ph=l(),Bn=r("div"),F(Ho.$$.fragment),jh=l(),$l=r("p"),Ch=t(`Build model inputs from a sequence or a pair of sequence for sequence classification tasks by concatenating and
adding special tokens. A BERT sequence has the following format:`),xh=l(),Vo=r("ul"),pi=r("li"),Lh=t("single sequence: "),El=r("code"),Oh=t("[CLS] X [SEP]"),Dh=l(),ui=r("li"),Ah=t("pair of sequences: "),Ml=r("code"),Nh=t("[CLS] A [SEP] B [SEP]"),Sh=l(),Ut=r("div"),F(Yo.$$.fragment),Ih=l(),Ko=r("p"),Bh=t(`Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding
special tokens using the tokenizer `),zl=r("code"),Wh=t("prepare_for_model"),Qh=t(" method."),Uh=l(),yn=r("div"),F(Go.$$.fragment),Rh=l(),ql=r("p"),Hh=t(`Create a mask from the two sequences passed to be used in a sequence-pair classification task. A Funnel
Transformer sequence pair mask has the following format:`),Vh=l(),F(Zo.$$.fragment),Yh=l(),et=r("p"),Kh=t("If "),Pl=r("code"),Gh=t("token_ids_1"),Zh=t(" is "),jl=r("code"),Xh=t("None"),Jh=t(", this method only returns the first portion of the mask (0s)."),ef=l(),hi=r("div"),F(Xo.$$.fragment),Ic=l(),nt=r("h2"),Rt=r("a"),Cl=r("span"),F(Jo.$$.fragment),nf=l(),xl=r("span"),tf=t("FunnelTokenizerFast"),Bc=l(),sn=r("div"),F(es.$$.fragment),of=l(),ns=r("p"),sf=t("Construct a \u201Cfast\u201D Funnel Transformer tokenizer (backed by HuggingFace\u2019s "),Ll=r("em"),rf=t("tokenizers"),af=t(" library)."),lf=l(),Ht=r("p"),fi=r("a"),df=t("FunnelTokenizerFast"),cf=t(" is identical to "),mi=r("a"),pf=t("BertTokenizerFast"),uf=t(` and runs end-to-end tokenization: punctuation
splitting and wordpiece.`),hf=l(),ts=r("p"),ff=t("Refer to superclass "),gi=r("a"),mf=t("BertTokenizerFast"),gf=t(" for usage examples and documentation concerning parameters."),_f=l(),wn=r("div"),F(os.$$.fragment),Tf=l(),Ol=r("p"),kf=t(`Create a mask from the two sequences passed to be used in a sequence-pair classification task. A Funnel
Transformer sequence pair mask has the following format:`),Ff=l(),F(ss.$$.fragment),vf=l(),tt=r("p"),yf=t("If "),Dl=r("code"),wf=t("token_ids_1"),bf=t(" is "),Al=r("code"),$f=t("None"),Ef=t(", this method only returns the first portion of the mask (0s)."),Wc=l(),ot=r("h2"),Vt=r("a"),Nl=r("span"),F(rs.$$.fragment),Mf=l(),Sl=r("span"),zf=t("Funnel specific outputs"),Qc=l(),st=r("div"),F(as.$$.fragment),qf=l(),is=r("p"),Pf=t("Output type of "),_i=r("a"),jf=t("FunnelForPreTraining"),Cf=t("."),Uc=l(),rt=r("div"),F(ls.$$.fragment),xf=l(),ds=r("p"),Lf=t("Output type of "),Ti=r("a"),Of=t("FunnelForPreTraining"),Df=t("."),Rc=l(),at=r("h2"),Yt=r("a"),Il=r("span"),F(cs.$$.fragment),Af=l(),Bl=r("span"),Nf=t("FunnelBaseModel"),Hc=l(),Qe=r("div"),F(ps.$$.fragment),Sf=l(),Wl=r("p"),If=t(`The base Funnel Transformer Model transformer outputting raw hidden-states without upsampling head (also called
decoder) or any task-specific head on top.`),Bf=l(),us=r("p"),Wf=t("The Funnel Transformer model was proposed in "),hs=r("a"),Qf=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Uf=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Rf=l(),fs=r("p"),Hf=t("This model inherits from "),ki=r("a"),Vf=t("PreTrainedModel"),Yf=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Kf=l(),ms=r("p"),Gf=t("This model is also a PyTorch "),gs=r("a"),Zf=t("torch.nn.Module"),Xf=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Jf=l(),rn=r("div"),F(_s.$$.fragment),em=l(),it=r("p"),nm=t("The "),Fi=r("a"),tm=t("FunnelBaseModel"),om=t(" forward method, overrides the "),Ql=r("code"),sm=t("__call__"),rm=t(" special method."),am=l(),F(Kt.$$.fragment),im=l(),Ul=r("p"),lm=t("Example:"),dm=l(),F(Ts.$$.fragment),Vc=l(),lt=r("h2"),Gt=r("a"),Rl=r("span"),F(ks.$$.fragment),cm=l(),Hl=r("span"),pm=t("FunnelModel"),Yc=l(),Ue=r("div"),F(Fs.$$.fragment),um=l(),Vl=r("p"),hm=t("The bare Funnel Transformer Model transformer outputting raw hidden-states without any specific head on top."),fm=l(),vs=r("p"),mm=t("The Funnel Transformer model was proposed in "),ys=r("a"),gm=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),_m=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Tm=l(),ws=r("p"),km=t("This model inherits from "),vi=r("a"),Fm=t("PreTrainedModel"),vm=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),ym=l(),bs=r("p"),wm=t("This model is also a PyTorch "),$s=r("a"),bm=t("torch.nn.Module"),$m=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Em=l(),an=r("div"),F(Es.$$.fragment),Mm=l(),dt=r("p"),zm=t("The "),yi=r("a"),qm=t("FunnelModel"),Pm=t(" forward method, overrides the "),Yl=r("code"),jm=t("__call__"),Cm=t(" special method."),xm=l(),F(Zt.$$.fragment),Lm=l(),Kl=r("p"),Om=t("Example:"),Dm=l(),F(Ms.$$.fragment),Kc=l(),ct=r("h2"),Xt=r("a"),Gl=r("span"),F(zs.$$.fragment),Am=l(),Zl=r("span"),Nm=t("FunnelModelForPreTraining"),Gc=l(),pt=r("div"),F(qs.$$.fragment),Sm=l(),ln=r("div"),F(Ps.$$.fragment),Im=l(),ut=r("p"),Bm=t("The "),wi=r("a"),Wm=t("FunnelForPreTraining"),Qm=t(" forward method, overrides the "),Xl=r("code"),Um=t("__call__"),Rm=t(" special method."),Hm=l(),F(Jt.$$.fragment),Vm=l(),Jl=r("p"),Ym=t("Examples:"),Km=l(),F(js.$$.fragment),Zc=l(),ht=r("h2"),eo=r("a"),ed=r("span"),F(Cs.$$.fragment),Gm=l(),nd=r("span"),Zm=t("FunnelForMaskedLM"),Xc=l(),Re=r("div"),F(xs.$$.fragment),Xm=l(),Ls=r("p"),Jm=t("Funnel Transformer Model with a "),td=r("code"),eg=t("language modeling"),ng=t(" head on top."),tg=l(),Os=r("p"),og=t("The Funnel Transformer model was proposed in "),Ds=r("a"),sg=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),rg=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),ag=l(),As=r("p"),ig=t("This model inherits from "),bi=r("a"),lg=t("PreTrainedModel"),dg=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),cg=l(),Ns=r("p"),pg=t("This model is also a PyTorch "),Ss=r("a"),ug=t("torch.nn.Module"),hg=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),fg=l(),Ge=r("div"),F(Is.$$.fragment),mg=l(),ft=r("p"),gg=t("The "),$i=r("a"),_g=t("FunnelForMaskedLM"),Tg=t(" forward method, overrides the "),od=r("code"),kg=t("__call__"),Fg=t(" special method."),vg=l(),F(no.$$.fragment),yg=l(),sd=r("p"),wg=t("Example:"),bg=l(),F(Bs.$$.fragment),$g=l(),F(Ws.$$.fragment),Jc=l(),mt=r("h2"),to=r("a"),rd=r("span"),F(Qs.$$.fragment),Eg=l(),ad=r("span"),Mg=t("FunnelForSequenceClassification"),ep=l(),He=r("div"),F(Us.$$.fragment),zg=l(),id=r("p"),qg=t(`Funnel Transformer Model with a sequence classification/regression head on top (two linear layer on top of the
first timestep of the last hidden state) e.g. for GLUE tasks.`),Pg=l(),Rs=r("p"),jg=t("The Funnel Transformer model was proposed in "),Hs=r("a"),Cg=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),xg=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Lg=l(),Vs=r("p"),Og=t("This model inherits from "),Ei=r("a"),Dg=t("PreTrainedModel"),Ag=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Ng=l(),Ys=r("p"),Sg=t("This model is also a PyTorch "),Ks=r("a"),Ig=t("torch.nn.Module"),Bg=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Wg=l(),Pe=r("div"),F(Gs.$$.fragment),Qg=l(),gt=r("p"),Ug=t("The "),Mi=r("a"),Rg=t("FunnelForSequenceClassification"),Hg=t(" forward method, overrides the "),ld=r("code"),Vg=t("__call__"),Yg=t(" special method."),Kg=l(),F(oo.$$.fragment),Gg=l(),dd=r("p"),Zg=t("Example of single-label classification:"),Xg=l(),F(Zs.$$.fragment),Jg=l(),F(Xs.$$.fragment),e_=l(),cd=r("p"),n_=t("Example of multi-label classification:"),t_=l(),F(Js.$$.fragment),o_=l(),F(er.$$.fragment),np=l(),_t=r("h2"),so=r("a"),pd=r("span"),F(nr.$$.fragment),s_=l(),ud=r("span"),r_=t("FunnelForMultipleChoice"),tp=l(),Ve=r("div"),F(tr.$$.fragment),a_=l(),hd=r("p"),i_=t(`Funnel Transformer Model with a multiple choice classification head on top (two linear layer on top of the first
timestep of the last hidden state, and a softmax) e.g. for RocStories/SWAG tasks.`),l_=l(),or=r("p"),d_=t("The Funnel Transformer model was proposed in "),sr=r("a"),c_=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),p_=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),u_=l(),rr=r("p"),h_=t("This model inherits from "),zi=r("a"),f_=t("PreTrainedModel"),m_=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),g_=l(),ar=r("p"),__=t("This model is also a PyTorch "),ir=r("a"),T_=t("torch.nn.Module"),k_=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),F_=l(),dn=r("div"),F(lr.$$.fragment),v_=l(),Tt=r("p"),y_=t("The "),qi=r("a"),w_=t("FunnelForMultipleChoice"),b_=t(" forward method, overrides the "),fd=r("code"),$_=t("__call__"),E_=t(" special method."),M_=l(),F(ro.$$.fragment),z_=l(),md=r("p"),q_=t("Example:"),P_=l(),F(dr.$$.fragment),op=l(),kt=r("h2"),ao=r("a"),gd=r("span"),F(cr.$$.fragment),j_=l(),_d=r("span"),C_=t("FunnelForTokenClassification"),sp=l(),Ye=r("div"),F(pr.$$.fragment),x_=l(),Td=r("p"),L_=t(`Funnel Transformer Model with a token classification head on top (a linear layer on top of the hidden-states
output) e.g. for Named-Entity-Recognition (NER) tasks.`),O_=l(),ur=r("p"),D_=t("The Funnel Transformer model was proposed in "),hr=r("a"),A_=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),N_=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),S_=l(),fr=r("p"),I_=t("This model inherits from "),Pi=r("a"),B_=t("PreTrainedModel"),W_=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Q_=l(),mr=r("p"),U_=t("This model is also a PyTorch "),gr=r("a"),R_=t("torch.nn.Module"),H_=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),V_=l(),Ze=r("div"),F(_r.$$.fragment),Y_=l(),Ft=r("p"),K_=t("The "),ji=r("a"),G_=t("FunnelForTokenClassification"),Z_=t(" forward method, overrides the "),kd=r("code"),X_=t("__call__"),J_=t(" special method."),eT=l(),F(io.$$.fragment),nT=l(),Fd=r("p"),tT=t("Example:"),oT=l(),F(Tr.$$.fragment),sT=l(),F(kr.$$.fragment),rp=l(),vt=r("h2"),lo=r("a"),vd=r("span"),F(Fr.$$.fragment),rT=l(),yd=r("span"),aT=t("FunnelForQuestionAnswering"),ap=l(),Ke=r("div"),F(vr.$$.fragment),iT=l(),yt=r("p"),lT=t(`Funnel Transformer Model with a span classification head on top for extractive question-answering tasks like SQuAD
(a linear layer on top of the hidden-states output to compute `),wd=r("code"),dT=t("span start logits"),cT=t(" and "),bd=r("code"),pT=t("span end logits"),uT=t(")."),hT=l(),yr=r("p"),fT=t("The Funnel Transformer model was proposed in "),wr=r("a"),mT=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),gT=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),_T=l(),br=r("p"),TT=t("This model inherits from "),Ci=r("a"),kT=t("PreTrainedModel"),FT=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),vT=l(),$r=r("p"),yT=t("This model is also a PyTorch "),Er=r("a"),wT=t("torch.nn.Module"),bT=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),$T=l(),Xe=r("div"),F(Mr.$$.fragment),ET=l(),wt=r("p"),MT=t("The "),xi=r("a"),zT=t("FunnelForQuestionAnswering"),qT=t(" forward method, overrides the "),$d=r("code"),PT=t("__call__"),jT=t(" special method."),CT=l(),F(co.$$.fragment),xT=l(),Ed=r("p"),LT=t("Example:"),OT=l(),F(zr.$$.fragment),DT=l(),F(qr.$$.fragment),ip=l(),bt=r("h2"),po=r("a"),Md=r("span"),F(Pr.$$.fragment),AT=l(),zd=r("span"),NT=t("TFFunnelBaseModel"),lp=l(),Le=r("div"),F(jr.$$.fragment),ST=l(),qd=r("p"),IT=t(`The base Funnel Transformer Model transformer outputting raw hidden-states without upsampling head (also called
decoder) or any task-specific head on top.`),BT=l(),Cr=r("p"),WT=t("The Funnel Transformer model was proposed in "),xr=r("a"),QT=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),UT=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),RT=l(),Lr=r("p"),HT=t("This model inherits from "),Li=r("a"),VT=t("TFPreTrainedModel"),YT=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),KT=l(),Or=r("p"),GT=t("This model is also a "),Dr=r("a"),ZT=t("tf.keras.Model"),XT=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),JT=l(),F(uo.$$.fragment),ek=l(),cn=r("div"),F(Ar.$$.fragment),nk=l(),$t=r("p"),tk=t("The "),Oi=r("a"),ok=t("TFFunnelBaseModel"),sk=t(" forward method, overrides the "),Pd=r("code"),rk=t("__call__"),ak=t(" special method."),ik=l(),F(ho.$$.fragment),lk=l(),jd=r("p"),dk=t("Example:"),ck=l(),F(Nr.$$.fragment),dp=l(),Et=r("h2"),fo=r("a"),Cd=r("span"),F(Sr.$$.fragment),pk=l(),xd=r("span"),uk=t("TFFunnelModel"),cp=l(),Oe=r("div"),F(Ir.$$.fragment),hk=l(),Ld=r("p"),fk=t("The bare Funnel Transformer Model transformer outputting raw hidden-states without any specific head on top."),mk=l(),Br=r("p"),gk=t("The Funnel Transformer model was proposed in "),Wr=r("a"),_k=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Tk=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),kk=l(),Qr=r("p"),Fk=t("This model inherits from "),Di=r("a"),vk=t("TFPreTrainedModel"),yk=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),wk=l(),Ur=r("p"),bk=t("This model is also a "),Rr=r("a"),$k=t("tf.keras.Model"),Ek=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Mk=l(),F(mo.$$.fragment),zk=l(),pn=r("div"),F(Hr.$$.fragment),qk=l(),Mt=r("p"),Pk=t("The "),Ai=r("a"),jk=t("TFFunnelModel"),Ck=t(" forward method, overrides the "),Od=r("code"),xk=t("__call__"),Lk=t(" special method."),Ok=l(),F(go.$$.fragment),Dk=l(),Dd=r("p"),Ak=t("Example:"),Nk=l(),F(Vr.$$.fragment),pp=l(),zt=r("h2"),_o=r("a"),Ad=r("span"),F(Yr.$$.fragment),Sk=l(),Nd=r("span"),Ik=t("TFFunnelModelForPreTraining"),up=l(),De=r("div"),F(Kr.$$.fragment),Bk=l(),Sd=r("p"),Wk=t("Funnel model with a binary classification head on top as used during pretraining for identifying generated tokens."),Qk=l(),Gr=r("p"),Uk=t("The Funnel Transformer model was proposed in "),Zr=r("a"),Rk=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Hk=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Vk=l(),Xr=r("p"),Yk=t("This model inherits from "),Ni=r("a"),Kk=t("TFPreTrainedModel"),Gk=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Zk=l(),Jr=r("p"),Xk=t("This model is also a "),ea=r("a"),Jk=t("tf.keras.Model"),eF=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),nF=l(),F(To.$$.fragment),tF=l(),un=r("div"),F(na.$$.fragment),oF=l(),qt=r("p"),sF=t("The "),Si=r("a"),rF=t("TFFunnelForPreTraining"),aF=t(" forward method, overrides the "),Id=r("code"),iF=t("__call__"),lF=t(" special method."),dF=l(),F(ko.$$.fragment),cF=l(),Bd=r("p"),pF=t("Examples:"),uF=l(),F(ta.$$.fragment),hp=l(),Pt=r("h2"),Fo=r("a"),Wd=r("span"),F(oa.$$.fragment),hF=l(),Qd=r("span"),fF=t("TFFunnelForMaskedLM"),fp=l(),Ae=r("div"),F(sa.$$.fragment),mF=l(),ra=r("p"),gF=t("Funnel Model with a "),Ud=r("code"),_F=t("language modeling"),TF=t(" head on top."),kF=l(),aa=r("p"),FF=t("The Funnel Transformer model was proposed in "),ia=r("a"),vF=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),yF=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),wF=l(),la=r("p"),bF=t("This model inherits from "),Ii=r("a"),$F=t("TFPreTrainedModel"),EF=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),MF=l(),da=r("p"),zF=t("This model is also a "),ca=r("a"),qF=t("tf.keras.Model"),PF=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),jF=l(),F(vo.$$.fragment),CF=l(),Je=r("div"),F(pa.$$.fragment),xF=l(),jt=r("p"),LF=t("The "),Bi=r("a"),OF=t("TFFunnelForMaskedLM"),DF=t(" forward method, overrides the "),Rd=r("code"),AF=t("__call__"),NF=t(" special method."),SF=l(),F(yo.$$.fragment),IF=l(),Hd=r("p"),BF=t("Example:"),WF=l(),F(ua.$$.fragment),QF=l(),F(ha.$$.fragment),mp=l(),Ct=r("h2"),wo=r("a"),Vd=r("span"),F(fa.$$.fragment),UF=l(),Yd=r("span"),RF=t("TFFunnelForSequenceClassification"),gp=l(),Ne=r("div"),F(ma.$$.fragment),HF=l(),Kd=r("p"),VF=t(`Funnel Model transformer with a sequence classification/regression head on top (a linear layer on top of the pooled
output) e.g. for GLUE tasks.`),YF=l(),ga=r("p"),KF=t("The Funnel Transformer model was proposed in "),_a=r("a"),GF=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),ZF=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),XF=l(),Ta=r("p"),JF=t("This model inherits from "),Wi=r("a"),ev=t("TFPreTrainedModel"),nv=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),tv=l(),ka=r("p"),ov=t("This model is also a "),Fa=r("a"),sv=t("tf.keras.Model"),rv=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),av=l(),F(bo.$$.fragment),iv=l(),en=r("div"),F(va.$$.fragment),lv=l(),xt=r("p"),dv=t("The "),Qi=r("a"),cv=t("TFFunnelForSequenceClassification"),pv=t(" forward method, overrides the "),Gd=r("code"),uv=t("__call__"),hv=t(" special method."),fv=l(),F($o.$$.fragment),mv=l(),Zd=r("p"),gv=t("Example:"),_v=l(),F(ya.$$.fragment),Tv=l(),F(wa.$$.fragment),_p=l(),Lt=r("h2"),Eo=r("a"),Xd=r("span"),F(ba.$$.fragment),kv=l(),Jd=r("span"),Fv=t("TFFunnelForMultipleChoice"),Tp=l(),Se=r("div"),F($a.$$.fragment),vv=l(),ec=r("p"),yv=t(`Funnel Model with a multiple choice classification head on top (a linear layer on top of the pooled output and a
softmax) e.g. for RocStories/SWAG tasks.`),wv=l(),Ea=r("p"),bv=t("The Funnel Transformer model was proposed in "),Ma=r("a"),$v=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Ev=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Mv=l(),za=r("p"),zv=t("This model inherits from "),Ui=r("a"),qv=t("TFPreTrainedModel"),Pv=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),jv=l(),qa=r("p"),Cv=t("This model is also a "),Pa=r("a"),xv=t("tf.keras.Model"),Lv=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Ov=l(),F(Mo.$$.fragment),Dv=l(),hn=r("div"),F(ja.$$.fragment),Av=l(),Ot=r("p"),Nv=t("The "),Ri=r("a"),Sv=t("TFFunnelForMultipleChoice"),Iv=t(" forward method, overrides the "),nc=r("code"),Bv=t("__call__"),Wv=t(" special method."),Qv=l(),F(zo.$$.fragment),Uv=l(),tc=r("p"),Rv=t("Example:"),Hv=l(),F(Ca.$$.fragment),kp=l(),Dt=r("h2"),qo=r("a"),oc=r("span"),F(xa.$$.fragment),Vv=l(),sc=r("span"),Yv=t("TFFunnelForTokenClassification"),Fp=l(),Ie=r("div"),F(La.$$.fragment),Kv=l(),rc=r("p"),Gv=t(`Funnel Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g. for
Named-Entity-Recognition (NER) tasks.`),Zv=l(),Oa=r("p"),Xv=t("The Funnel Transformer model was proposed in "),Da=r("a"),Jv=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),ey=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),ny=l(),Aa=r("p"),ty=t("This model inherits from "),Hi=r("a"),oy=t("TFPreTrainedModel"),sy=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),ry=l(),Na=r("p"),ay=t("This model is also a "),Sa=r("a"),iy=t("tf.keras.Model"),ly=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),dy=l(),F(Po.$$.fragment),cy=l(),nn=r("div"),F(Ia.$$.fragment),py=l(),At=r("p"),uy=t("The "),Vi=r("a"),hy=t("TFFunnelForTokenClassification"),fy=t(" forward method, overrides the "),ac=r("code"),my=t("__call__"),gy=t(" special method."),_y=l(),F(jo.$$.fragment),Ty=l(),ic=r("p"),ky=t("Example:"),Fy=l(),F(Ba.$$.fragment),vy=l(),F(Wa.$$.fragment),vp=l(),Nt=r("h2"),Co=r("a"),lc=r("span"),F(Qa.$$.fragment),yy=l(),dc=r("span"),wy=t("TFFunnelForQuestionAnswering"),yp=l(),Be=r("div"),F(Ua.$$.fragment),by=l(),St=r("p"),$y=t(`Funnel Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear
layers on top of the hidden-states output to compute `),cc=r("code"),Ey=t("span start logits"),My=t(" and "),pc=r("code"),zy=t("span end logits"),qy=t(")."),Py=l(),Ra=r("p"),jy=t("The Funnel Transformer model was proposed in "),Ha=r("a"),Cy=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),xy=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Ly=l(),Va=r("p"),Oy=t("This model inherits from "),Yi=r("a"),Dy=t("TFPreTrainedModel"),Ay=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Ny=l(),Ya=r("p"),Sy=t("This model is also a "),Ka=r("a"),Iy=t("tf.keras.Model"),By=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Wy=l(),F(xo.$$.fragment),Qy=l(),tn=r("div"),F(Ga.$$.fragment),Uy=l(),It=r("p"),Ry=t("The "),Ki=r("a"),Hy=t("TFFunnelForQuestionAnswering"),Vy=t(" forward method, overrides the "),uc=r("code"),Yy=t("__call__"),Ky=t(" special method."),Gy=l(),F(Lo.$$.fragment),Zy=l(),hc=r("p"),Xy=t("Example:"),Jy=l(),F(Za.$$.fragment),ew=l(),F(Xa.$$.fragment),this.h()},l(s){const f=U$('[data-svelte="svelte-1phssyn"]',document.head);u=a(f,"META",{name:!0,content:!0}),f.forEach(n),z=d(s),g=a(s,"H1",{class:!0});var Ja=i(g);_=a(Ja,"A",{id:!0,class:!0,href:!0});var fc=i(_);k=a(fc,"SPAN",{});var mc=i(k);v(T.$$.fragment,mc),mc.forEach(n),fc.forEach(n),m=d(Ja),M=a(Ja,"SPAN",{});var gc=i(M);ce=o(gc,"Funnel Transformer"),gc.forEach(n),Ja.forEach(n),K=d(s),q=a(s,"H2",{class:!0});var ei=i(q);J=a(ei,"A",{id:!0,class:!0,href:!0});var _c=i(J);A=a(_c,"SPAN",{});var Tc=i(A);v(ne.$$.fragment,Tc),Tc.forEach(n),_c.forEach(n),pe=d(ei),N=a(ei,"SPAN",{});var kc=i(N);ue=o(kc,"Overview"),kc.forEach(n),ei.forEach(n),ie=d(s),Y=a(s,"P",{});var ni=i(Y);L=o(ni,"The Funnel Transformer model was proposed in the paper "),te=a(ni,"A",{href:!0,rel:!0});var Fc=i(te);G=o(Fc,`Funnel-Transformer: Filtering out Sequential Redundancy for
Efficient Language Processing`),Fc.forEach(n),P=o(ni,`. It is a bidirectional transformer model, like
BERT, but with a pooling operation after each block of layers, a bit like in traditional convolutional neural networks
(CNN) in computer vision.`),ni.forEach(n),C=d(s),oe=a(s,"P",{});var vc=i(oe);W=o(vc,"The abstract from the paper is the following:"),vc.forEach(n),le=d(s),se=a(s,"P",{});var yc=i(se);S=a(yc,"EM",{});var wc=i(S);he=o(wc,`With the success of language pretraining, it is highly desirable to develop more efficient architectures of good
scalability that can exploit the abundant unlabeled data at a lower cost. To improve the efficiency, we examine the
much-overlooked redundancy in maintaining a full-length token-level presentation, especially for tasks that only
require a single-vector presentation of the sequence. With this intuition, we propose Funnel-Transformer which
gradually compresses the sequence of hidden states to a shorter one and hence reduces the computation cost. More
importantly, by re-investing the saved FLOPs from length reduction in constructing a deeper or wider model, we further
improve the model capacity. In addition, to perform token-level predictions as required by common pretraining
objectives, Funnel-Transformer is able to recover a deep representation for each token from the reduced hidden sequence
via a decoder. Empirically, with comparable or fewer FLOPs, Funnel-Transformer outperforms the standard Transformer on
a wide variety of sequence-level prediction tasks, including text classification, language understanding, and reading
comprehension.`),wc.forEach(n),yc.forEach(n),de=d(s),j=a(s,"P",{});var bc=i(j);fe=o(bc,"Tips:"),bc.forEach(n),B=d(s),ee=a(s,"UL",{});var ti=i(ee);ae=a(ti,"LI",{});var $c=i(ae);Q=o($c,`Since Funnel Transformer uses pooling, the sequence length of the hidden states changes after each block of layers.
The base model therefore has a final sequence length that is a quarter of the original one. This model can be used
directly for tasks that just require a sentence summary (like sequence classification or multiple choice). For other
tasks, the full model is used; this full model has a decoder that upsamples the final hidden states to the same
sequence length as the input.`),$c.forEach(n),me=d(ti),I=a(ti,"LI",{});var xe=i(I);O=o(xe,`The Funnel Transformer checkpoints are all available with a full version and a base version. The first ones should be
used for `),re=a(xe,"A",{href:!0});var Ec=i(re);U=o(Ec,"FunnelModel"),Ec.forEach(n),ge=o(xe,", "),p=a(xe,"A",{href:!0});var Mc=i(p);E=o(Mc,"FunnelForPreTraining"),Mc.forEach(n),Z=o(xe,`,
`),Te=a(xe,"A",{href:!0});var zc=i(Te);we=o(zc,"FunnelForMaskedLM"),zc.forEach(n),D=o(xe,", "),ke=a(xe,"A",{href:!0});var qc=i(ke);be=o(qc,"FunnelForTokenClassification"),qc.forEach(n),$e=o(xe,` and
class:`),x=a(xe,"EM",{});var Pc=i(x);R=o(Pc,"~transformers.FunnelForQuestionAnswering"),Pc.forEach(n),Ee=o(xe,`. The second ones should be used for
`),Fe=a(xe,"A",{href:!0});var jc=i(Fe);H=o(jc,"FunnelBaseModel"),jc.forEach(n),Me=o(xe,", "),ve=a(xe,"A",{href:!0});var Cc=i(ve);_e=o(Cc,"FunnelForSequenceClassification"),Cc.forEach(n),ze=o(xe,` and
`),oi=a(xe,"A",{href:!0});var ow=i(oi);Yu=o(ow,"FunnelForMultipleChoice"),ow.forEach(n),Ku=o(xe,"."),xe.forEach(n),ti.forEach(n),Oc=d(s),In=a(s,"P",{});var Gi=i(In);Gu=o(Gi,"This model was contributed by "),No=a(Gi,"A",{href:!0,rel:!0});var sw=i(No);Zu=o(sw,"sgugger"),sw.forEach(n),Xu=o(Gi,". The original code can be found "),So=a(Gi,"A",{href:!0,rel:!0});var rw=i(So);Ju=o(rw,"here"),rw.forEach(n),eh=o(Gi,"."),Gi.forEach(n),Dc=d(s),Zn=a(s,"H2",{class:!0});var bp=i(Zn);Bt=a(bp,"A",{id:!0,class:!0,href:!0});var aw=i(Bt);Fl=a(aw,"SPAN",{});var iw=i(Fl);v(Io.$$.fragment,iw),iw.forEach(n),aw.forEach(n),nh=d(bp),vl=a(bp,"SPAN",{});var lw=i(vl);th=o(lw,"FunnelConfig"),lw.forEach(n),bp.forEach(n),Ac=d(s),Nn=a(s,"DIV",{class:!0});var Zi=i(Nn);v(Bo.$$.fragment,Zi),oh=d(Zi),Sn=a(Zi,"P",{});var Oo=i(Sn);sh=o(Oo,"This is the configuration class to store the configuration of a "),si=a(Oo,"A",{href:!0});var dw=i(si);rh=o(dw,"FunnelModel"),dw.forEach(n),ah=o(Oo," or a "),ri=a(Oo,"A",{href:!0});var cw=i(ri);ih=o(cw,"TFBertModel"),cw.forEach(n),lh=o(Oo,`. It is used to
instantiate a Funnel Transformer model according to the specified arguments, defining the model architecture.
Instantiating a configuration with the defaults will yield a similar configuration to that of the Funnel
Transformer `),Wo=a(Oo,"A",{href:!0,rel:!0});var pw=i(Wo);dh=o(pw,"funnel-transformer/small"),pw.forEach(n),ch=o(Oo," architecture."),Oo.forEach(n),ph=d(Zi),Xn=a(Zi,"P",{});var Xi=i(Xn);uh=o(Xi,"Configuration objects inherit from "),ai=a(Xi,"A",{href:!0});var uw=i(ai);hh=o(uw,"PretrainedConfig"),uw.forEach(n),fh=o(Xi,` and can be used to control the model outputs. Read the
documentation from `),ii=a(Xi,"A",{href:!0});var hw=i(ii);mh=o(hw,"PretrainedConfig"),hw.forEach(n),gh=o(Xi," for more information."),Xi.forEach(n),Zi.forEach(n),Nc=d(s),Jn=a(s,"H2",{class:!0});var $p=i(Jn);Wt=a($p,"A",{id:!0,class:!0,href:!0});var fw=i(Wt);yl=a(fw,"SPAN",{});var mw=i(yl);v(Qo.$$.fragment,mw),mw.forEach(n),fw.forEach(n),_h=d($p),wl=a($p,"SPAN",{});var gw=i(wl);Th=o(gw,"FunnelTokenizer"),gw.forEach(n),$p.forEach(n),Sc=d(s),Ce=a(s,"DIV",{class:!0});var on=i(Ce);v(Uo.$$.fragment,on),kh=d(on),bl=a(on,"P",{});var _w=i(bl);Fh=o(_w,"Construct a Funnel Transformer tokenizer."),_w.forEach(n),vh=d(on),Qt=a(on,"P",{});var xc=i(Qt);li=a(xc,"A",{href:!0});var Tw=i(li);yh=o(Tw,"FunnelTokenizer"),Tw.forEach(n),wh=o(xc," is identical to "),di=a(xc,"A",{href:!0});var kw=i(di);bh=o(kw,"BertTokenizer"),kw.forEach(n),$h=o(xc,` and runs end-to-end tokenization: punctuation splitting and
wordpiece.`),xc.forEach(n),Eh=d(on),Ro=a(on,"P",{});var Ep=i(Ro);Mh=o(Ep,"Refer to superclass "),ci=a(Ep,"A",{href:!0});var Fw=i(ci);zh=o(Fw,"BertTokenizer"),Fw.forEach(n),qh=o(Ep," for usage examples and documentation concerning parameters."),Ep.forEach(n),Ph=d(on),Bn=a(on,"DIV",{class:!0});var Ji=i(Bn);v(Ho.$$.fragment,Ji),jh=d(Ji),$l=a(Ji,"P",{});var vw=i($l);Ch=o(vw,`Build model inputs from a sequence or a pair of sequence for sequence classification tasks by concatenating and
adding special tokens. A BERT sequence has the following format:`),vw.forEach(n),xh=d(Ji),Vo=a(Ji,"UL",{});var Mp=i(Vo);pi=a(Mp,"LI",{});var nw=i(pi);Lh=o(nw,"single sequence: "),El=a(nw,"CODE",{});var yw=i(El);Oh=o(yw,"[CLS] X [SEP]"),yw.forEach(n),nw.forEach(n),Dh=d(Mp),ui=a(Mp,"LI",{});var tw=i(ui);Ah=o(tw,"pair of sequences: "),Ml=a(tw,"CODE",{});var ww=i(Ml);Nh=o(ww,"[CLS] A [SEP] B [SEP]"),ww.forEach(n),tw.forEach(n),Mp.forEach(n),Ji.forEach(n),Sh=d(on),Ut=a(on,"DIV",{class:!0});var zp=i(Ut);v(Yo.$$.fragment,zp),Ih=d(zp),Ko=a(zp,"P",{});var qp=i(Ko);Bh=o(qp,`Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding
special tokens using the tokenizer `),zl=a(qp,"CODE",{});var bw=i(zl);Wh=o(bw,"prepare_for_model"),bw.forEach(n),Qh=o(qp," method."),qp.forEach(n),zp.forEach(n),Uh=d(on),yn=a(on,"DIV",{class:!0});var Do=i(yn);v(Go.$$.fragment,Do),Rh=d(Do),ql=a(Do,"P",{});var $w=i(ql);Hh=o($w,`Create a mask from the two sequences passed to be used in a sequence-pair classification task. A Funnel
Transformer sequence pair mask has the following format:`),$w.forEach(n),Vh=d(Do),v(Zo.$$.fragment,Do),Yh=d(Do),et=a(Do,"P",{});var el=i(et);Kh=o(el,"If "),Pl=a(el,"CODE",{});var Ew=i(Pl);Gh=o(Ew,"token_ids_1"),Ew.forEach(n),Zh=o(el," is "),jl=a(el,"CODE",{});var Mw=i(jl);Xh=o(Mw,"None"),Mw.forEach(n),Jh=o(el,", this method only returns the first portion of the mask (0s)."),el.forEach(n),Do.forEach(n),ef=d(on),hi=a(on,"DIV",{class:!0});var zw=i(hi);v(Xo.$$.fragment,zw),zw.forEach(n),on.forEach(n),Ic=d(s),nt=a(s,"H2",{class:!0});var Pp=i(nt);Rt=a(Pp,"A",{id:!0,class:!0,href:!0});var qw=i(Rt);Cl=a(qw,"SPAN",{});var Pw=i(Cl);v(Jo.$$.fragment,Pw),Pw.forEach(n),qw.forEach(n),nf=d(Pp),xl=a(Pp,"SPAN",{});var jw=i(xl);tf=o(jw,"FunnelTokenizerFast"),jw.forEach(n),Pp.forEach(n),Bc=d(s),sn=a(s,"DIV",{class:!0});var Wn=i(sn);v(es.$$.fragment,Wn),of=d(Wn),ns=a(Wn,"P",{});var jp=i(ns);sf=o(jp,"Construct a \u201Cfast\u201D Funnel Transformer tokenizer (backed by HuggingFace\u2019s "),Ll=a(jp,"EM",{});var Cw=i(Ll);rf=o(Cw,"tokenizers"),Cw.forEach(n),af=o(jp," library)."),jp.forEach(n),lf=d(Wn),Ht=a(Wn,"P",{});var Lc=i(Ht);fi=a(Lc,"A",{href:!0});var xw=i(fi);df=o(xw,"FunnelTokenizerFast"),xw.forEach(n),cf=o(Lc," is identical to "),mi=a(Lc,"A",{href:!0});var Lw=i(mi);pf=o(Lw,"BertTokenizerFast"),Lw.forEach(n),uf=o(Lc,` and runs end-to-end tokenization: punctuation
splitting and wordpiece.`),Lc.forEach(n),hf=d(Wn),ts=a(Wn,"P",{});var Cp=i(ts);ff=o(Cp,"Refer to superclass "),gi=a(Cp,"A",{href:!0});var Ow=i(gi);mf=o(Ow,"BertTokenizerFast"),Ow.forEach(n),gf=o(Cp," for usage examples and documentation concerning parameters."),Cp.forEach(n),_f=d(Wn),wn=a(Wn,"DIV",{class:!0});var Ao=i(wn);v(os.$$.fragment,Ao),Tf=d(Ao),Ol=a(Ao,"P",{});var Dw=i(Ol);kf=o(Dw,`Create a mask from the two sequences passed to be used in a sequence-pair classification task. A Funnel
Transformer sequence pair mask has the following format:`),Dw.forEach(n),Ff=d(Ao),v(ss.$$.fragment,Ao),vf=d(Ao),tt=a(Ao,"P",{});var nl=i(tt);yf=o(nl,"If "),Dl=a(nl,"CODE",{});var Aw=i(Dl);wf=o(Aw,"token_ids_1"),Aw.forEach(n),bf=o(nl," is "),Al=a(nl,"CODE",{});var Nw=i(Al);$f=o(Nw,"None"),Nw.forEach(n),Ef=o(nl,", this method only returns the first portion of the mask (0s)."),nl.forEach(n),Ao.forEach(n),Wn.forEach(n),Wc=d(s),ot=a(s,"H2",{class:!0});var xp=i(ot);Vt=a(xp,"A",{id:!0,class:!0,href:!0});var Sw=i(Vt);Nl=a(Sw,"SPAN",{});var Iw=i(Nl);v(rs.$$.fragment,Iw),Iw.forEach(n),Sw.forEach(n),Mf=d(xp),Sl=a(xp,"SPAN",{});var Bw=i(Sl);zf=o(Bw,"Funnel specific outputs"),Bw.forEach(n),xp.forEach(n),Qc=d(s),st=a(s,"DIV",{class:!0});var Lp=i(st);v(as.$$.fragment,Lp),qf=d(Lp),is=a(Lp,"P",{});var Op=i(is);Pf=o(Op,"Output type of "),_i=a(Op,"A",{href:!0});var Ww=i(_i);jf=o(Ww,"FunnelForPreTraining"),Ww.forEach(n),Cf=o(Op,"."),Op.forEach(n),Lp.forEach(n),Uc=d(s),rt=a(s,"DIV",{class:!0});var Dp=i(rt);v(ls.$$.fragment,Dp),xf=d(Dp),ds=a(Dp,"P",{});var Ap=i(ds);Lf=o(Ap,"Output type of "),Ti=a(Ap,"A",{href:!0});var Qw=i(Ti);Of=o(Qw,"FunnelForPreTraining"),Qw.forEach(n),Df=o(Ap,"."),Ap.forEach(n),Dp.forEach(n),Rc=d(s),at=a(s,"H2",{class:!0});var Np=i(at);Yt=a(Np,"A",{id:!0,class:!0,href:!0});var Uw=i(Yt);Il=a(Uw,"SPAN",{});var Rw=i(Il);v(cs.$$.fragment,Rw),Rw.forEach(n),Uw.forEach(n),Af=d(Np),Bl=a(Np,"SPAN",{});var Hw=i(Bl);Nf=o(Hw,"FunnelBaseModel"),Hw.forEach(n),Np.forEach(n),Hc=d(s),Qe=a(s,"DIV",{class:!0});var bn=i(Qe);v(ps.$$.fragment,bn),Sf=d(bn),Wl=a(bn,"P",{});var Vw=i(Wl);If=o(Vw,`The base Funnel Transformer Model transformer outputting raw hidden-states without upsampling head (also called
decoder) or any task-specific head on top.`),Vw.forEach(n),Bf=d(bn),us=a(bn,"P",{});var Sp=i(us);Wf=o(Sp,"The Funnel Transformer model was proposed in "),hs=a(Sp,"A",{href:!0,rel:!0});var Yw=i(hs);Qf=o(Yw,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Yw.forEach(n),Uf=o(Sp," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Sp.forEach(n),Rf=d(bn),fs=a(bn,"P",{});var Ip=i(fs);Hf=o(Ip,"This model inherits from "),ki=a(Ip,"A",{href:!0});var Kw=i(ki);Vf=o(Kw,"PreTrainedModel"),Kw.forEach(n),Yf=o(Ip,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Ip.forEach(n),Kf=d(bn),ms=a(bn,"P",{});var Bp=i(ms);Gf=o(Bp,"This model is also a PyTorch "),gs=a(Bp,"A",{href:!0,rel:!0});var Gw=i(gs);Zf=o(Gw,"torch.nn.Module"),Gw.forEach(n),Xf=o(Bp,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Bp.forEach(n),Jf=d(bn),rn=a(bn,"DIV",{class:!0});var Qn=i(rn);v(_s.$$.fragment,Qn),em=d(Qn),it=a(Qn,"P",{});var tl=i(it);nm=o(tl,"The "),Fi=a(tl,"A",{href:!0});var Zw=i(Fi);tm=o(Zw,"FunnelBaseModel"),Zw.forEach(n),om=o(tl," forward method, overrides the "),Ql=a(tl,"CODE",{});var Xw=i(Ql);sm=o(Xw,"__call__"),Xw.forEach(n),rm=o(tl," special method."),tl.forEach(n),am=d(Qn),v(Kt.$$.fragment,Qn),im=d(Qn),Ul=a(Qn,"P",{});var Jw=i(Ul);lm=o(Jw,"Example:"),Jw.forEach(n),dm=d(Qn),v(Ts.$$.fragment,Qn),Qn.forEach(n),bn.forEach(n),Vc=d(s),lt=a(s,"H2",{class:!0});var Wp=i(lt);Gt=a(Wp,"A",{id:!0,class:!0,href:!0});var eb=i(Gt);Rl=a(eb,"SPAN",{});var nb=i(Rl);v(ks.$$.fragment,nb),nb.forEach(n),eb.forEach(n),cm=d(Wp),Hl=a(Wp,"SPAN",{});var tb=i(Hl);pm=o(tb,"FunnelModel"),tb.forEach(n),Wp.forEach(n),Yc=d(s),Ue=a(s,"DIV",{class:!0});var $n=i(Ue);v(Fs.$$.fragment,$n),um=d($n),Vl=a($n,"P",{});var ob=i(Vl);hm=o(ob,"The bare Funnel Transformer Model transformer outputting raw hidden-states without any specific head on top."),ob.forEach(n),fm=d($n),vs=a($n,"P",{});var Qp=i(vs);mm=o(Qp,"The Funnel Transformer model was proposed in "),ys=a(Qp,"A",{href:!0,rel:!0});var sb=i(ys);gm=o(sb,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),sb.forEach(n),_m=o(Qp," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Qp.forEach(n),Tm=d($n),ws=a($n,"P",{});var Up=i(ws);km=o(Up,"This model inherits from "),vi=a(Up,"A",{href:!0});var rb=i(vi);Fm=o(rb,"PreTrainedModel"),rb.forEach(n),vm=o(Up,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Up.forEach(n),ym=d($n),bs=a($n,"P",{});var Rp=i(bs);wm=o(Rp,"This model is also a PyTorch "),$s=a(Rp,"A",{href:!0,rel:!0});var ab=i($s);bm=o(ab,"torch.nn.Module"),ab.forEach(n),$m=o(Rp,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Rp.forEach(n),Em=d($n),an=a($n,"DIV",{class:!0});var Un=i(an);v(Es.$$.fragment,Un),Mm=d(Un),dt=a(Un,"P",{});var ol=i(dt);zm=o(ol,"The "),yi=a(ol,"A",{href:!0});var ib=i(yi);qm=o(ib,"FunnelModel"),ib.forEach(n),Pm=o(ol," forward method, overrides the "),Yl=a(ol,"CODE",{});var lb=i(Yl);jm=o(lb,"__call__"),lb.forEach(n),Cm=o(ol," special method."),ol.forEach(n),xm=d(Un),v(Zt.$$.fragment,Un),Lm=d(Un),Kl=a(Un,"P",{});var db=i(Kl);Om=o(db,"Example:"),db.forEach(n),Dm=d(Un),v(Ms.$$.fragment,Un),Un.forEach(n),$n.forEach(n),Kc=d(s),ct=a(s,"H2",{class:!0});var Hp=i(ct);Xt=a(Hp,"A",{id:!0,class:!0,href:!0});var cb=i(Xt);Gl=a(cb,"SPAN",{});var pb=i(Gl);v(zs.$$.fragment,pb),pb.forEach(n),cb.forEach(n),Am=d(Hp),Zl=a(Hp,"SPAN",{});var ub=i(Zl);Nm=o(ub,"FunnelModelForPreTraining"),ub.forEach(n),Hp.forEach(n),Gc=d(s),pt=a(s,"DIV",{class:!0});var Vp=i(pt);v(qs.$$.fragment,Vp),Sm=d(Vp),ln=a(Vp,"DIV",{class:!0});var Rn=i(ln);v(Ps.$$.fragment,Rn),Im=d(Rn),ut=a(Rn,"P",{});var sl=i(ut);Bm=o(sl,"The "),wi=a(sl,"A",{href:!0});var hb=i(wi);Wm=o(hb,"FunnelForPreTraining"),hb.forEach(n),Qm=o(sl," forward method, overrides the "),Xl=a(sl,"CODE",{});var fb=i(Xl);Um=o(fb,"__call__"),fb.forEach(n),Rm=o(sl," special method."),sl.forEach(n),Hm=d(Rn),v(Jt.$$.fragment,Rn),Vm=d(Rn),Jl=a(Rn,"P",{});var mb=i(Jl);Ym=o(mb,"Examples:"),mb.forEach(n),Km=d(Rn),v(js.$$.fragment,Rn),Rn.forEach(n),Vp.forEach(n),Zc=d(s),ht=a(s,"H2",{class:!0});var Yp=i(ht);eo=a(Yp,"A",{id:!0,class:!0,href:!0});var gb=i(eo);ed=a(gb,"SPAN",{});var _b=i(ed);v(Cs.$$.fragment,_b),_b.forEach(n),gb.forEach(n),Gm=d(Yp),nd=a(Yp,"SPAN",{});var Tb=i(nd);Zm=o(Tb,"FunnelForMaskedLM"),Tb.forEach(n),Yp.forEach(n),Xc=d(s),Re=a(s,"DIV",{class:!0});var En=i(Re);v(xs.$$.fragment,En),Xm=d(En),Ls=a(En,"P",{});var Kp=i(Ls);Jm=o(Kp,"Funnel Transformer Model with a "),td=a(Kp,"CODE",{});var kb=i(td);eg=o(kb,"language modeling"),kb.forEach(n),ng=o(Kp," head on top."),Kp.forEach(n),tg=d(En),Os=a(En,"P",{});var Gp=i(Os);og=o(Gp,"The Funnel Transformer model was proposed in "),Ds=a(Gp,"A",{href:!0,rel:!0});var Fb=i(Ds);sg=o(Fb,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Fb.forEach(n),rg=o(Gp," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Gp.forEach(n),ag=d(En),As=a(En,"P",{});var Zp=i(As);ig=o(Zp,"This model inherits from "),bi=a(Zp,"A",{href:!0});var vb=i(bi);lg=o(vb,"PreTrainedModel"),vb.forEach(n),dg=o(Zp,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Zp.forEach(n),cg=d(En),Ns=a(En,"P",{});var Xp=i(Ns);pg=o(Xp,"This model is also a PyTorch "),Ss=a(Xp,"A",{href:!0,rel:!0});var yb=i(Ss);ug=o(yb,"torch.nn.Module"),yb.forEach(n),hg=o(Xp,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Xp.forEach(n),fg=d(En),Ge=a(En,"DIV",{class:!0});var Mn=i(Ge);v(Is.$$.fragment,Mn),mg=d(Mn),ft=a(Mn,"P",{});var rl=i(ft);gg=o(rl,"The "),$i=a(rl,"A",{href:!0});var wb=i($i);_g=o(wb,"FunnelForMaskedLM"),wb.forEach(n),Tg=o(rl," forward method, overrides the "),od=a(rl,"CODE",{});var bb=i(od);kg=o(bb,"__call__"),bb.forEach(n),Fg=o(rl," special method."),rl.forEach(n),vg=d(Mn),v(no.$$.fragment,Mn),yg=d(Mn),sd=a(Mn,"P",{});var $b=i(sd);wg=o($b,"Example:"),$b.forEach(n),bg=d(Mn),v(Bs.$$.fragment,Mn),$g=d(Mn),v(Ws.$$.fragment,Mn),Mn.forEach(n),En.forEach(n),Jc=d(s),mt=a(s,"H2",{class:!0});var Jp=i(mt);to=a(Jp,"A",{id:!0,class:!0,href:!0});var Eb=i(to);rd=a(Eb,"SPAN",{});var Mb=i(rd);v(Qs.$$.fragment,Mb),Mb.forEach(n),Eb.forEach(n),Eg=d(Jp),ad=a(Jp,"SPAN",{});var zb=i(ad);Mg=o(zb,"FunnelForSequenceClassification"),zb.forEach(n),Jp.forEach(n),ep=d(s),He=a(s,"DIV",{class:!0});var zn=i(He);v(Us.$$.fragment,zn),zg=d(zn),id=a(zn,"P",{});var qb=i(id);qg=o(qb,`Funnel Transformer Model with a sequence classification/regression head on top (two linear layer on top of the
first timestep of the last hidden state) e.g. for GLUE tasks.`),qb.forEach(n),Pg=d(zn),Rs=a(zn,"P",{});var eu=i(Rs);jg=o(eu,"The Funnel Transformer model was proposed in "),Hs=a(eu,"A",{href:!0,rel:!0});var Pb=i(Hs);Cg=o(Pb,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Pb.forEach(n),xg=o(eu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),eu.forEach(n),Lg=d(zn),Vs=a(zn,"P",{});var nu=i(Vs);Og=o(nu,"This model inherits from "),Ei=a(nu,"A",{href:!0});var jb=i(Ei);Dg=o(jb,"PreTrainedModel"),jb.forEach(n),Ag=o(nu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),nu.forEach(n),Ng=d(zn),Ys=a(zn,"P",{});var tu=i(Ys);Sg=o(tu,"This model is also a PyTorch "),Ks=a(tu,"A",{href:!0,rel:!0});var Cb=i(Ks);Ig=o(Cb,"torch.nn.Module"),Cb.forEach(n),Bg=o(tu,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),tu.forEach(n),Wg=d(zn),Pe=a(zn,"DIV",{class:!0});var We=i(Pe);v(Gs.$$.fragment,We),Qg=d(We),gt=a(We,"P",{});var al=i(gt);Ug=o(al,"The "),Mi=a(al,"A",{href:!0});var xb=i(Mi);Rg=o(xb,"FunnelForSequenceClassification"),xb.forEach(n),Hg=o(al," forward method, overrides the "),ld=a(al,"CODE",{});var Lb=i(ld);Vg=o(Lb,"__call__"),Lb.forEach(n),Yg=o(al," special method."),al.forEach(n),Kg=d(We),v(oo.$$.fragment,We),Gg=d(We),dd=a(We,"P",{});var Ob=i(dd);Zg=o(Ob,"Example of single-label classification:"),Ob.forEach(n),Xg=d(We),v(Zs.$$.fragment,We),Jg=d(We),v(Xs.$$.fragment,We),e_=d(We),cd=a(We,"P",{});var Db=i(cd);n_=o(Db,"Example of multi-label classification:"),Db.forEach(n),t_=d(We),v(Js.$$.fragment,We),o_=d(We),v(er.$$.fragment,We),We.forEach(n),zn.forEach(n),np=d(s),_t=a(s,"H2",{class:!0});var ou=i(_t);so=a(ou,"A",{id:!0,class:!0,href:!0});var Ab=i(so);pd=a(Ab,"SPAN",{});var Nb=i(pd);v(nr.$$.fragment,Nb),Nb.forEach(n),Ab.forEach(n),s_=d(ou),ud=a(ou,"SPAN",{});var Sb=i(ud);r_=o(Sb,"FunnelForMultipleChoice"),Sb.forEach(n),ou.forEach(n),tp=d(s),Ve=a(s,"DIV",{class:!0});var qn=i(Ve);v(tr.$$.fragment,qn),a_=d(qn),hd=a(qn,"P",{});var Ib=i(hd);i_=o(Ib,`Funnel Transformer Model with a multiple choice classification head on top (two linear layer on top of the first
timestep of the last hidden state, and a softmax) e.g. for RocStories/SWAG tasks.`),Ib.forEach(n),l_=d(qn),or=a(qn,"P",{});var su=i(or);d_=o(su,"The Funnel Transformer model was proposed in "),sr=a(su,"A",{href:!0,rel:!0});var Bb=i(sr);c_=o(Bb,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Bb.forEach(n),p_=o(su," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),su.forEach(n),u_=d(qn),rr=a(qn,"P",{});var ru=i(rr);h_=o(ru,"This model inherits from "),zi=a(ru,"A",{href:!0});var Wb=i(zi);f_=o(Wb,"PreTrainedModel"),Wb.forEach(n),m_=o(ru,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),ru.forEach(n),g_=d(qn),ar=a(qn,"P",{});var au=i(ar);__=o(au,"This model is also a PyTorch "),ir=a(au,"A",{href:!0,rel:!0});var Qb=i(ir);T_=o(Qb,"torch.nn.Module"),Qb.forEach(n),k_=o(au,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),au.forEach(n),F_=d(qn),dn=a(qn,"DIV",{class:!0});var Hn=i(dn);v(lr.$$.fragment,Hn),v_=d(Hn),Tt=a(Hn,"P",{});var il=i(Tt);y_=o(il,"The "),qi=a(il,"A",{href:!0});var Ub=i(qi);w_=o(Ub,"FunnelForMultipleChoice"),Ub.forEach(n),b_=o(il," forward method, overrides the "),fd=a(il,"CODE",{});var Rb=i(fd);$_=o(Rb,"__call__"),Rb.forEach(n),E_=o(il," special method."),il.forEach(n),M_=d(Hn),v(ro.$$.fragment,Hn),z_=d(Hn),md=a(Hn,"P",{});var Hb=i(md);q_=o(Hb,"Example:"),Hb.forEach(n),P_=d(Hn),v(dr.$$.fragment,Hn),Hn.forEach(n),qn.forEach(n),op=d(s),kt=a(s,"H2",{class:!0});var iu=i(kt);ao=a(iu,"A",{id:!0,class:!0,href:!0});var Vb=i(ao);gd=a(Vb,"SPAN",{});var Yb=i(gd);v(cr.$$.fragment,Yb),Yb.forEach(n),Vb.forEach(n),j_=d(iu),_d=a(iu,"SPAN",{});var Kb=i(_d);C_=o(Kb,"FunnelForTokenClassification"),Kb.forEach(n),iu.forEach(n),sp=d(s),Ye=a(s,"DIV",{class:!0});var Pn=i(Ye);v(pr.$$.fragment,Pn),x_=d(Pn),Td=a(Pn,"P",{});var Gb=i(Td);L_=o(Gb,`Funnel Transformer Model with a token classification head on top (a linear layer on top of the hidden-states
output) e.g. for Named-Entity-Recognition (NER) tasks.`),Gb.forEach(n),O_=d(Pn),ur=a(Pn,"P",{});var lu=i(ur);D_=o(lu,"The Funnel Transformer model was proposed in "),hr=a(lu,"A",{href:!0,rel:!0});var Zb=i(hr);A_=o(Zb,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Zb.forEach(n),N_=o(lu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),lu.forEach(n),S_=d(Pn),fr=a(Pn,"P",{});var du=i(fr);I_=o(du,"This model inherits from "),Pi=a(du,"A",{href:!0});var Xb=i(Pi);B_=o(Xb,"PreTrainedModel"),Xb.forEach(n),W_=o(du,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),du.forEach(n),Q_=d(Pn),mr=a(Pn,"P",{});var cu=i(mr);U_=o(cu,"This model is also a PyTorch "),gr=a(cu,"A",{href:!0,rel:!0});var Jb=i(gr);R_=o(Jb,"torch.nn.Module"),Jb.forEach(n),H_=o(cu,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),cu.forEach(n),V_=d(Pn),Ze=a(Pn,"DIV",{class:!0});var jn=i(Ze);v(_r.$$.fragment,jn),Y_=d(jn),Ft=a(jn,"P",{});var ll=i(Ft);K_=o(ll,"The "),ji=a(ll,"A",{href:!0});var e1=i(ji);G_=o(e1,"FunnelForTokenClassification"),e1.forEach(n),Z_=o(ll," forward method, overrides the "),kd=a(ll,"CODE",{});var n1=i(kd);X_=o(n1,"__call__"),n1.forEach(n),J_=o(ll," special method."),ll.forEach(n),eT=d(jn),v(io.$$.fragment,jn),nT=d(jn),Fd=a(jn,"P",{});var t1=i(Fd);tT=o(t1,"Example:"),t1.forEach(n),oT=d(jn),v(Tr.$$.fragment,jn),sT=d(jn),v(kr.$$.fragment,jn),jn.forEach(n),Pn.forEach(n),rp=d(s),vt=a(s,"H2",{class:!0});var pu=i(vt);lo=a(pu,"A",{id:!0,class:!0,href:!0});var o1=i(lo);vd=a(o1,"SPAN",{});var s1=i(vd);v(Fr.$$.fragment,s1),s1.forEach(n),o1.forEach(n),rT=d(pu),yd=a(pu,"SPAN",{});var r1=i(yd);aT=o(r1,"FunnelForQuestionAnswering"),r1.forEach(n),pu.forEach(n),ap=d(s),Ke=a(s,"DIV",{class:!0});var Cn=i(Ke);v(vr.$$.fragment,Cn),iT=d(Cn),yt=a(Cn,"P",{});var dl=i(yt);lT=o(dl,`Funnel Transformer Model with a span classification head on top for extractive question-answering tasks like SQuAD
(a linear layer on top of the hidden-states output to compute `),wd=a(dl,"CODE",{});var a1=i(wd);dT=o(a1,"span start logits"),a1.forEach(n),cT=o(dl," and "),bd=a(dl,"CODE",{});var i1=i(bd);pT=o(i1,"span end logits"),i1.forEach(n),uT=o(dl,")."),dl.forEach(n),hT=d(Cn),yr=a(Cn,"P",{});var uu=i(yr);fT=o(uu,"The Funnel Transformer model was proposed in "),wr=a(uu,"A",{href:!0,rel:!0});var l1=i(wr);mT=o(l1,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),l1.forEach(n),gT=o(uu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),uu.forEach(n),_T=d(Cn),br=a(Cn,"P",{});var hu=i(br);TT=o(hu,"This model inherits from "),Ci=a(hu,"A",{href:!0});var d1=i(Ci);kT=o(d1,"PreTrainedModel"),d1.forEach(n),FT=o(hu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),hu.forEach(n),vT=d(Cn),$r=a(Cn,"P",{});var fu=i($r);yT=o(fu,"This model is also a PyTorch "),Er=a(fu,"A",{href:!0,rel:!0});var c1=i(Er);wT=o(c1,"torch.nn.Module"),c1.forEach(n),bT=o(fu,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),fu.forEach(n),$T=d(Cn),Xe=a(Cn,"DIV",{class:!0});var xn=i(Xe);v(Mr.$$.fragment,xn),ET=d(xn),wt=a(xn,"P",{});var cl=i(wt);MT=o(cl,"The "),xi=a(cl,"A",{href:!0});var p1=i(xi);zT=o(p1,"FunnelForQuestionAnswering"),p1.forEach(n),qT=o(cl," forward method, overrides the "),$d=a(cl,"CODE",{});var u1=i($d);PT=o(u1,"__call__"),u1.forEach(n),jT=o(cl," special method."),cl.forEach(n),CT=d(xn),v(co.$$.fragment,xn),xT=d(xn),Ed=a(xn,"P",{});var h1=i(Ed);LT=o(h1,"Example:"),h1.forEach(n),OT=d(xn),v(zr.$$.fragment,xn),DT=d(xn),v(qr.$$.fragment,xn),xn.forEach(n),Cn.forEach(n),ip=d(s),bt=a(s,"H2",{class:!0});var mu=i(bt);po=a(mu,"A",{id:!0,class:!0,href:!0});var f1=i(po);Md=a(f1,"SPAN",{});var m1=i(Md);v(Pr.$$.fragment,m1),m1.forEach(n),f1.forEach(n),AT=d(mu),zd=a(mu,"SPAN",{});var g1=i(zd);NT=o(g1,"TFFunnelBaseModel"),g1.forEach(n),mu.forEach(n),lp=d(s),Le=a(s,"DIV",{class:!0});var fn=i(Le);v(jr.$$.fragment,fn),ST=d(fn),qd=a(fn,"P",{});var _1=i(qd);IT=o(_1,`The base Funnel Transformer Model transformer outputting raw hidden-states without upsampling head (also called
decoder) or any task-specific head on top.`),_1.forEach(n),BT=d(fn),Cr=a(fn,"P",{});var gu=i(Cr);WT=o(gu,"The Funnel Transformer model was proposed in "),xr=a(gu,"A",{href:!0,rel:!0});var T1=i(xr);QT=o(T1,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),T1.forEach(n),UT=o(gu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),gu.forEach(n),RT=d(fn),Lr=a(fn,"P",{});var _u=i(Lr);HT=o(_u,"This model inherits from "),Li=a(_u,"A",{href:!0});var k1=i(Li);VT=o(k1,"TFPreTrainedModel"),k1.forEach(n),YT=o(_u,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),_u.forEach(n),KT=d(fn),Or=a(fn,"P",{});var Tu=i(Or);GT=o(Tu,"This model is also a "),Dr=a(Tu,"A",{href:!0,rel:!0});var F1=i(Dr);ZT=o(F1,"tf.keras.Model"),F1.forEach(n),XT=o(Tu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Tu.forEach(n),JT=d(fn),v(uo.$$.fragment,fn),ek=d(fn),cn=a(fn,"DIV",{class:!0});var Vn=i(cn);v(Ar.$$.fragment,Vn),nk=d(Vn),$t=a(Vn,"P",{});var pl=i($t);tk=o(pl,"The "),Oi=a(pl,"A",{href:!0});var v1=i(Oi);ok=o(v1,"TFFunnelBaseModel"),v1.forEach(n),sk=o(pl," forward method, overrides the "),Pd=a(pl,"CODE",{});var y1=i(Pd);rk=o(y1,"__call__"),y1.forEach(n),ak=o(pl," special method."),pl.forEach(n),ik=d(Vn),v(ho.$$.fragment,Vn),lk=d(Vn),jd=a(Vn,"P",{});var w1=i(jd);dk=o(w1,"Example:"),w1.forEach(n),ck=d(Vn),v(Nr.$$.fragment,Vn),Vn.forEach(n),fn.forEach(n),dp=d(s),Et=a(s,"H2",{class:!0});var ku=i(Et);fo=a(ku,"A",{id:!0,class:!0,href:!0});var b1=i(fo);Cd=a(b1,"SPAN",{});var $1=i(Cd);v(Sr.$$.fragment,$1),$1.forEach(n),b1.forEach(n),pk=d(ku),xd=a(ku,"SPAN",{});var E1=i(xd);uk=o(E1,"TFFunnelModel"),E1.forEach(n),ku.forEach(n),cp=d(s),Oe=a(s,"DIV",{class:!0});var mn=i(Oe);v(Ir.$$.fragment,mn),hk=d(mn),Ld=a(mn,"P",{});var M1=i(Ld);fk=o(M1,"The bare Funnel Transformer Model transformer outputting raw hidden-states without any specific head on top."),M1.forEach(n),mk=d(mn),Br=a(mn,"P",{});var Fu=i(Br);gk=o(Fu,"The Funnel Transformer model was proposed in "),Wr=a(Fu,"A",{href:!0,rel:!0});var z1=i(Wr);_k=o(z1,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),z1.forEach(n),Tk=o(Fu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Fu.forEach(n),kk=d(mn),Qr=a(mn,"P",{});var vu=i(Qr);Fk=o(vu,"This model inherits from "),Di=a(vu,"A",{href:!0});var q1=i(Di);vk=o(q1,"TFPreTrainedModel"),q1.forEach(n),yk=o(vu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),vu.forEach(n),wk=d(mn),Ur=a(mn,"P",{});var yu=i(Ur);bk=o(yu,"This model is also a "),Rr=a(yu,"A",{href:!0,rel:!0});var P1=i(Rr);$k=o(P1,"tf.keras.Model"),P1.forEach(n),Ek=o(yu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),yu.forEach(n),Mk=d(mn),v(mo.$$.fragment,mn),zk=d(mn),pn=a(mn,"DIV",{class:!0});var Yn=i(pn);v(Hr.$$.fragment,Yn),qk=d(Yn),Mt=a(Yn,"P",{});var ul=i(Mt);Pk=o(ul,"The "),Ai=a(ul,"A",{href:!0});var j1=i(Ai);jk=o(j1,"TFFunnelModel"),j1.forEach(n),Ck=o(ul," forward method, overrides the "),Od=a(ul,"CODE",{});var C1=i(Od);xk=o(C1,"__call__"),C1.forEach(n),Lk=o(ul," special method."),ul.forEach(n),Ok=d(Yn),v(go.$$.fragment,Yn),Dk=d(Yn),Dd=a(Yn,"P",{});var x1=i(Dd);Ak=o(x1,"Example:"),x1.forEach(n),Nk=d(Yn),v(Vr.$$.fragment,Yn),Yn.forEach(n),mn.forEach(n),pp=d(s),zt=a(s,"H2",{class:!0});var wu=i(zt);_o=a(wu,"A",{id:!0,class:!0,href:!0});var L1=i(_o);Ad=a(L1,"SPAN",{});var O1=i(Ad);v(Yr.$$.fragment,O1),O1.forEach(n),L1.forEach(n),Sk=d(wu),Nd=a(wu,"SPAN",{});var D1=i(Nd);Ik=o(D1,"TFFunnelModelForPreTraining"),D1.forEach(n),wu.forEach(n),up=d(s),De=a(s,"DIV",{class:!0});var gn=i(De);v(Kr.$$.fragment,gn),Bk=d(gn),Sd=a(gn,"P",{});var A1=i(Sd);Wk=o(A1,"Funnel model with a binary classification head on top as used during pretraining for identifying generated tokens."),A1.forEach(n),Qk=d(gn),Gr=a(gn,"P",{});var bu=i(Gr);Uk=o(bu,"The Funnel Transformer model was proposed in "),Zr=a(bu,"A",{href:!0,rel:!0});var N1=i(Zr);Rk=o(N1,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),N1.forEach(n),Hk=o(bu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),bu.forEach(n),Vk=d(gn),Xr=a(gn,"P",{});var $u=i(Xr);Yk=o($u,"This model inherits from "),Ni=a($u,"A",{href:!0});var S1=i(Ni);Kk=o(S1,"TFPreTrainedModel"),S1.forEach(n),Gk=o($u,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),$u.forEach(n),Zk=d(gn),Jr=a(gn,"P",{});var Eu=i(Jr);Xk=o(Eu,"This model is also a "),ea=a(Eu,"A",{href:!0,rel:!0});var I1=i(ea);Jk=o(I1,"tf.keras.Model"),I1.forEach(n),eF=o(Eu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Eu.forEach(n),nF=d(gn),v(To.$$.fragment,gn),tF=d(gn),un=a(gn,"DIV",{class:!0});var Kn=i(un);v(na.$$.fragment,Kn),oF=d(Kn),qt=a(Kn,"P",{});var hl=i(qt);sF=o(hl,"The "),Si=a(hl,"A",{href:!0});var B1=i(Si);rF=o(B1,"TFFunnelForPreTraining"),B1.forEach(n),aF=o(hl," forward method, overrides the "),Id=a(hl,"CODE",{});var W1=i(Id);iF=o(W1,"__call__"),W1.forEach(n),lF=o(hl," special method."),hl.forEach(n),dF=d(Kn),v(ko.$$.fragment,Kn),cF=d(Kn),Bd=a(Kn,"P",{});var Q1=i(Bd);pF=o(Q1,"Examples:"),Q1.forEach(n),uF=d(Kn),v(ta.$$.fragment,Kn),Kn.forEach(n),gn.forEach(n),hp=d(s),Pt=a(s,"H2",{class:!0});var Mu=i(Pt);Fo=a(Mu,"A",{id:!0,class:!0,href:!0});var U1=i(Fo);Wd=a(U1,"SPAN",{});var R1=i(Wd);v(oa.$$.fragment,R1),R1.forEach(n),U1.forEach(n),hF=d(Mu),Qd=a(Mu,"SPAN",{});var H1=i(Qd);fF=o(H1,"TFFunnelForMaskedLM"),H1.forEach(n),Mu.forEach(n),fp=d(s),Ae=a(s,"DIV",{class:!0});var _n=i(Ae);v(sa.$$.fragment,_n),mF=d(_n),ra=a(_n,"P",{});var zu=i(ra);gF=o(zu,"Funnel Model with a "),Ud=a(zu,"CODE",{});var V1=i(Ud);_F=o(V1,"language modeling"),V1.forEach(n),TF=o(zu," head on top."),zu.forEach(n),kF=d(_n),aa=a(_n,"P",{});var qu=i(aa);FF=o(qu,"The Funnel Transformer model was proposed in "),ia=a(qu,"A",{href:!0,rel:!0});var Y1=i(ia);vF=o(Y1,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Y1.forEach(n),yF=o(qu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),qu.forEach(n),wF=d(_n),la=a(_n,"P",{});var Pu=i(la);bF=o(Pu,"This model inherits from "),Ii=a(Pu,"A",{href:!0});var K1=i(Ii);$F=o(K1,"TFPreTrainedModel"),K1.forEach(n),EF=o(Pu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Pu.forEach(n),MF=d(_n),da=a(_n,"P",{});var ju=i(da);zF=o(ju,"This model is also a "),ca=a(ju,"A",{href:!0,rel:!0});var G1=i(ca);qF=o(G1,"tf.keras.Model"),G1.forEach(n),PF=o(ju,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),ju.forEach(n),jF=d(_n),v(vo.$$.fragment,_n),CF=d(_n),Je=a(_n,"DIV",{class:!0});var Ln=i(Je);v(pa.$$.fragment,Ln),xF=d(Ln),jt=a(Ln,"P",{});var fl=i(jt);LF=o(fl,"The "),Bi=a(fl,"A",{href:!0});var Z1=i(Bi);OF=o(Z1,"TFFunnelForMaskedLM"),Z1.forEach(n),DF=o(fl," forward method, overrides the "),Rd=a(fl,"CODE",{});var X1=i(Rd);AF=o(X1,"__call__"),X1.forEach(n),NF=o(fl," special method."),fl.forEach(n),SF=d(Ln),v(yo.$$.fragment,Ln),IF=d(Ln),Hd=a(Ln,"P",{});var J1=i(Hd);BF=o(J1,"Example:"),J1.forEach(n),WF=d(Ln),v(ua.$$.fragment,Ln),QF=d(Ln),v(ha.$$.fragment,Ln),Ln.forEach(n),_n.forEach(n),mp=d(s),Ct=a(s,"H2",{class:!0});var Cu=i(Ct);wo=a(Cu,"A",{id:!0,class:!0,href:!0});var e$=i(wo);Vd=a(e$,"SPAN",{});var n$=i(Vd);v(fa.$$.fragment,n$),n$.forEach(n),e$.forEach(n),UF=d(Cu),Yd=a(Cu,"SPAN",{});var t$=i(Yd);RF=o(t$,"TFFunnelForSequenceClassification"),t$.forEach(n),Cu.forEach(n),gp=d(s),Ne=a(s,"DIV",{class:!0});var Tn=i(Ne);v(ma.$$.fragment,Tn),HF=d(Tn),Kd=a(Tn,"P",{});var o$=i(Kd);VF=o(o$,`Funnel Model transformer with a sequence classification/regression head on top (a linear layer on top of the pooled
output) e.g. for GLUE tasks.`),o$.forEach(n),YF=d(Tn),ga=a(Tn,"P",{});var xu=i(ga);KF=o(xu,"The Funnel Transformer model was proposed in "),_a=a(xu,"A",{href:!0,rel:!0});var s$=i(_a);GF=o(s$,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),s$.forEach(n),ZF=o(xu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),xu.forEach(n),XF=d(Tn),Ta=a(Tn,"P",{});var Lu=i(Ta);JF=o(Lu,"This model inherits from "),Wi=a(Lu,"A",{href:!0});var r$=i(Wi);ev=o(r$,"TFPreTrainedModel"),r$.forEach(n),nv=o(Lu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Lu.forEach(n),tv=d(Tn),ka=a(Tn,"P",{});var Ou=i(ka);ov=o(Ou,"This model is also a "),Fa=a(Ou,"A",{href:!0,rel:!0});var a$=i(Fa);sv=o(a$,"tf.keras.Model"),a$.forEach(n),rv=o(Ou,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Ou.forEach(n),av=d(Tn),v(bo.$$.fragment,Tn),iv=d(Tn),en=a(Tn,"DIV",{class:!0});var On=i(en);v(va.$$.fragment,On),lv=d(On),xt=a(On,"P",{});var ml=i(xt);dv=o(ml,"The "),Qi=a(ml,"A",{href:!0});var i$=i(Qi);cv=o(i$,"TFFunnelForSequenceClassification"),i$.forEach(n),pv=o(ml," forward method, overrides the "),Gd=a(ml,"CODE",{});var l$=i(Gd);uv=o(l$,"__call__"),l$.forEach(n),hv=o(ml," special method."),ml.forEach(n),fv=d(On),v($o.$$.fragment,On),mv=d(On),Zd=a(On,"P",{});var d$=i(Zd);gv=o(d$,"Example:"),d$.forEach(n),_v=d(On),v(ya.$$.fragment,On),Tv=d(On),v(wa.$$.fragment,On),On.forEach(n),Tn.forEach(n),_p=d(s),Lt=a(s,"H2",{class:!0});var Du=i(Lt);Eo=a(Du,"A",{id:!0,class:!0,href:!0});var c$=i(Eo);Xd=a(c$,"SPAN",{});var p$=i(Xd);v(ba.$$.fragment,p$),p$.forEach(n),c$.forEach(n),kv=d(Du),Jd=a(Du,"SPAN",{});var u$=i(Jd);Fv=o(u$,"TFFunnelForMultipleChoice"),u$.forEach(n),Du.forEach(n),Tp=d(s),Se=a(s,"DIV",{class:!0});var kn=i(Se);v($a.$$.fragment,kn),vv=d(kn),ec=a(kn,"P",{});var h$=i(ec);yv=o(h$,`Funnel Model with a multiple choice classification head on top (a linear layer on top of the pooled output and a
softmax) e.g. for RocStories/SWAG tasks.`),h$.forEach(n),wv=d(kn),Ea=a(kn,"P",{});var Au=i(Ea);bv=o(Au,"The Funnel Transformer model was proposed in "),Ma=a(Au,"A",{href:!0,rel:!0});var f$=i(Ma);$v=o(f$,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),f$.forEach(n),Ev=o(Au," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Au.forEach(n),Mv=d(kn),za=a(kn,"P",{});var Nu=i(za);zv=o(Nu,"This model inherits from "),Ui=a(Nu,"A",{href:!0});var m$=i(Ui);qv=o(m$,"TFPreTrainedModel"),m$.forEach(n),Pv=o(Nu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Nu.forEach(n),jv=d(kn),qa=a(kn,"P",{});var Su=i(qa);Cv=o(Su,"This model is also a "),Pa=a(Su,"A",{href:!0,rel:!0});var g$=i(Pa);xv=o(g$,"tf.keras.Model"),g$.forEach(n),Lv=o(Su,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Su.forEach(n),Ov=d(kn),v(Mo.$$.fragment,kn),Dv=d(kn),hn=a(kn,"DIV",{class:!0});var Gn=i(hn);v(ja.$$.fragment,Gn),Av=d(Gn),Ot=a(Gn,"P",{});var gl=i(Ot);Nv=o(gl,"The "),Ri=a(gl,"A",{href:!0});var _$=i(Ri);Sv=o(_$,"TFFunnelForMultipleChoice"),_$.forEach(n),Iv=o(gl," forward method, overrides the "),nc=a(gl,"CODE",{});var T$=i(nc);Bv=o(T$,"__call__"),T$.forEach(n),Wv=o(gl," special method."),gl.forEach(n),Qv=d(Gn),v(zo.$$.fragment,Gn),Uv=d(Gn),tc=a(Gn,"P",{});var k$=i(tc);Rv=o(k$,"Example:"),k$.forEach(n),Hv=d(Gn),v(Ca.$$.fragment,Gn),Gn.forEach(n),kn.forEach(n),kp=d(s),Dt=a(s,"H2",{class:!0});var Iu=i(Dt);qo=a(Iu,"A",{id:!0,class:!0,href:!0});var F$=i(qo);oc=a(F$,"SPAN",{});var v$=i(oc);v(xa.$$.fragment,v$),v$.forEach(n),F$.forEach(n),Vv=d(Iu),sc=a(Iu,"SPAN",{});var y$=i(sc);Yv=o(y$,"TFFunnelForTokenClassification"),y$.forEach(n),Iu.forEach(n),Fp=d(s),Ie=a(s,"DIV",{class:!0});var Fn=i(Ie);v(La.$$.fragment,Fn),Kv=d(Fn),rc=a(Fn,"P",{});var w$=i(rc);Gv=o(w$,`Funnel Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g. for
Named-Entity-Recognition (NER) tasks.`),w$.forEach(n),Zv=d(Fn),Oa=a(Fn,"P",{});var Bu=i(Oa);Xv=o(Bu,"The Funnel Transformer model was proposed in "),Da=a(Bu,"A",{href:!0,rel:!0});var b$=i(Da);Jv=o(b$,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),b$.forEach(n),ey=o(Bu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Bu.forEach(n),ny=d(Fn),Aa=a(Fn,"P",{});var Wu=i(Aa);ty=o(Wu,"This model inherits from "),Hi=a(Wu,"A",{href:!0});var $$=i(Hi);oy=o($$,"TFPreTrainedModel"),$$.forEach(n),sy=o(Wu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Wu.forEach(n),ry=d(Fn),Na=a(Fn,"P",{});var Qu=i(Na);ay=o(Qu,"This model is also a "),Sa=a(Qu,"A",{href:!0,rel:!0});var E$=i(Sa);iy=o(E$,"tf.keras.Model"),E$.forEach(n),ly=o(Qu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Qu.forEach(n),dy=d(Fn),v(Po.$$.fragment,Fn),cy=d(Fn),nn=a(Fn,"DIV",{class:!0});var Dn=i(nn);v(Ia.$$.fragment,Dn),py=d(Dn),At=a(Dn,"P",{});var _l=i(At);uy=o(_l,"The "),Vi=a(_l,"A",{href:!0});var M$=i(Vi);hy=o(M$,"TFFunnelForTokenClassification"),M$.forEach(n),fy=o(_l," forward method, overrides the "),ac=a(_l,"CODE",{});var z$=i(ac);my=o(z$,"__call__"),z$.forEach(n),gy=o(_l," special method."),_l.forEach(n),_y=d(Dn),v(jo.$$.fragment,Dn),Ty=d(Dn),ic=a(Dn,"P",{});var q$=i(ic);ky=o(q$,"Example:"),q$.forEach(n),Fy=d(Dn),v(Ba.$$.fragment,Dn),vy=d(Dn),v(Wa.$$.fragment,Dn),Dn.forEach(n),Fn.forEach(n),vp=d(s),Nt=a(s,"H2",{class:!0});var Uu=i(Nt);Co=a(Uu,"A",{id:!0,class:!0,href:!0});var P$=i(Co);lc=a(P$,"SPAN",{});var j$=i(lc);v(Qa.$$.fragment,j$),j$.forEach(n),P$.forEach(n),yy=d(Uu),dc=a(Uu,"SPAN",{});var C$=i(dc);wy=o(C$,"TFFunnelForQuestionAnswering"),C$.forEach(n),Uu.forEach(n),yp=d(s),Be=a(s,"DIV",{class:!0});var vn=i(Be);v(Ua.$$.fragment,vn),by=d(vn),St=a(vn,"P",{});var Tl=i(St);$y=o(Tl,`Funnel Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear
layers on top of the hidden-states output to compute `),cc=a(Tl,"CODE",{});var x$=i(cc);Ey=o(x$,"span start logits"),x$.forEach(n),My=o(Tl," and "),pc=a(Tl,"CODE",{});var L$=i(pc);zy=o(L$,"span end logits"),L$.forEach(n),qy=o(Tl,")."),Tl.forEach(n),Py=d(vn),Ra=a(vn,"P",{});var Ru=i(Ra);jy=o(Ru,"The Funnel Transformer model was proposed in "),Ha=a(Ru,"A",{href:!0,rel:!0});var O$=i(Ha);Cy=o(O$,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),O$.forEach(n),xy=o(Ru," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Ru.forEach(n),Ly=d(vn),Va=a(vn,"P",{});var Hu=i(Va);Oy=o(Hu,"This model inherits from "),Yi=a(Hu,"A",{href:!0});var D$=i(Yi);Dy=o(D$,"TFPreTrainedModel"),D$.forEach(n),Ay=o(Hu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Hu.forEach(n),Ny=d(vn),Ya=a(vn,"P",{});var Vu=i(Ya);Sy=o(Vu,"This model is also a "),Ka=a(Vu,"A",{href:!0,rel:!0});var A$=i(Ka);Iy=o(A$,"tf.keras.Model"),A$.forEach(n),By=o(Vu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Vu.forEach(n),Wy=d(vn),v(xo.$$.fragment,vn),Qy=d(vn),tn=a(vn,"DIV",{class:!0});var An=i(tn);v(Ga.$$.fragment,An),Uy=d(An),It=a(An,"P",{});var kl=i(It);Ry=o(kl,"The "),Ki=a(kl,"A",{href:!0});var N$=i(Ki);Hy=o(N$,"TFFunnelForQuestionAnswering"),N$.forEach(n),Vy=o(kl," forward method, overrides the "),uc=a(kl,"CODE",{});var S$=i(uc);Yy=o(S$,"__call__"),S$.forEach(n),Ky=o(kl," special method."),kl.forEach(n),Gy=d(An),v(Lo.$$.fragment,An),Zy=d(An),hc=a(An,"P",{});var I$=i(hc);Xy=o(I$,"Example:"),I$.forEach(n),Jy=d(An),v(Za.$$.fragment,An),ew=d(An),v(Xa.$$.fragment,An),An.forEach(n),vn.forEach(n),this.h()},h(){c(u,"name","hf:doc:metadata"),c(u,"content",JSON.stringify(_2)),c(_,"id","funnel-transformer"),c(_,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(_,"href","#funnel-transformer"),c(g,"class","relative group"),c(J,"id","overview"),c(J,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(J,"href","#overview"),c(q,"class","relative group"),c(te,"href","https://arxiv.org/abs/2006.03236"),c(te,"rel","nofollow"),c(re,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelModel"),c(p,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForPreTraining"),c(Te,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForMaskedLM"),c(ke,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForTokenClassification"),c(Fe,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelBaseModel"),c(ve,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForSequenceClassification"),c(oi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForMultipleChoice"),c(No,"href","https://huggingface.co/sgugger"),c(No,"rel","nofollow"),c(So,"href","https://github.com/laiguokun/Funnel-Transformer"),c(So,"rel","nofollow"),c(Bt,"id","transformers.FunnelConfig"),c(Bt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Bt,"href","#transformers.FunnelConfig"),c(Zn,"class","relative group"),c(si,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelModel"),c(ri,"href","/docs/transformers/main/en/model_doc/bert#transformers.TFBertModel"),c(Wo,"href","https://huggingface.co/funnel-transformer/small"),c(Wo,"rel","nofollow"),c(ai,"href","/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig"),c(ii,"href","/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig"),c(Nn,"class","docstring"),c(Wt,"id","transformers.FunnelTokenizer"),c(Wt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Wt,"href","#transformers.FunnelTokenizer"),c(Jn,"class","relative group"),c(li,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizer"),c(di,"href","/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer"),c(ci,"href","/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer"),c(Bn,"class","docstring"),c(Ut,"class","docstring"),c(yn,"class","docstring"),c(hi,"class","docstring"),c(Ce,"class","docstring"),c(Rt,"id","transformers.FunnelTokenizerFast"),c(Rt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Rt,"href","#transformers.FunnelTokenizerFast"),c(nt,"class","relative group"),c(fi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelTokenizerFast"),c(mi,"href","/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizerFast"),c(gi,"href","/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizerFast"),c(wn,"class","docstring"),c(sn,"class","docstring"),c(Vt,"id","transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput"),c(Vt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Vt,"href","#transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput"),c(ot,"class","relative group"),c(_i,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForPreTraining"),c(st,"class","docstring"),c(Ti,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForPreTraining"),c(rt,"class","docstring"),c(Yt,"id","transformers.FunnelBaseModel"),c(Yt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Yt,"href","#transformers.FunnelBaseModel"),c(at,"class","relative group"),c(hs,"href","https://arxiv.org/abs/2006.03236"),c(hs,"rel","nofollow"),c(ki,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),c(gs,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(gs,"rel","nofollow"),c(Fi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelBaseModel"),c(rn,"class","docstring"),c(Qe,"class","docstring"),c(Gt,"id","transformers.FunnelModel"),c(Gt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Gt,"href","#transformers.FunnelModel"),c(lt,"class","relative group"),c(ys,"href","https://arxiv.org/abs/2006.03236"),c(ys,"rel","nofollow"),c(vi,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),c($s,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c($s,"rel","nofollow"),c(yi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelModel"),c(an,"class","docstring"),c(Ue,"class","docstring"),c(Xt,"id","transformers.FunnelForPreTraining"),c(Xt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Xt,"href","#transformers.FunnelForPreTraining"),c(ct,"class","relative group"),c(wi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForPreTraining"),c(ln,"class","docstring"),c(pt,"class","docstring"),c(eo,"id","transformers.FunnelForMaskedLM"),c(eo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(eo,"href","#transformers.FunnelForMaskedLM"),c(ht,"class","relative group"),c(Ds,"href","https://arxiv.org/abs/2006.03236"),c(Ds,"rel","nofollow"),c(bi,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),c(Ss,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(Ss,"rel","nofollow"),c($i,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForMaskedLM"),c(Ge,"class","docstring"),c(Re,"class","docstring"),c(to,"id","transformers.FunnelForSequenceClassification"),c(to,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(to,"href","#transformers.FunnelForSequenceClassification"),c(mt,"class","relative group"),c(Hs,"href","https://arxiv.org/abs/2006.03236"),c(Hs,"rel","nofollow"),c(Ei,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),c(Ks,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(Ks,"rel","nofollow"),c(Mi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForSequenceClassification"),c(Pe,"class","docstring"),c(He,"class","docstring"),c(so,"id","transformers.FunnelForMultipleChoice"),c(so,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(so,"href","#transformers.FunnelForMultipleChoice"),c(_t,"class","relative group"),c(sr,"href","https://arxiv.org/abs/2006.03236"),c(sr,"rel","nofollow"),c(zi,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),c(ir,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(ir,"rel","nofollow"),c(qi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForMultipleChoice"),c(dn,"class","docstring"),c(Ve,"class","docstring"),c(ao,"id","transformers.FunnelForTokenClassification"),c(ao,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(ao,"href","#transformers.FunnelForTokenClassification"),c(kt,"class","relative group"),c(hr,"href","https://arxiv.org/abs/2006.03236"),c(hr,"rel","nofollow"),c(Pi,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),c(gr,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(gr,"rel","nofollow"),c(ji,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForTokenClassification"),c(Ze,"class","docstring"),c(Ye,"class","docstring"),c(lo,"id","transformers.FunnelForQuestionAnswering"),c(lo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(lo,"href","#transformers.FunnelForQuestionAnswering"),c(vt,"class","relative group"),c(wr,"href","https://arxiv.org/abs/2006.03236"),c(wr,"rel","nofollow"),c(Ci,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),c(Er,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(Er,"rel","nofollow"),c(xi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.FunnelForQuestionAnswering"),c(Xe,"class","docstring"),c(Ke,"class","docstring"),c(po,"id","transformers.TFFunnelBaseModel"),c(po,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(po,"href","#transformers.TFFunnelBaseModel"),c(bt,"class","relative group"),c(xr,"href","https://arxiv.org/abs/2006.03236"),c(xr,"rel","nofollow"),c(Li,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel"),c(Dr,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Dr,"rel","nofollow"),c(Oi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelBaseModel"),c(cn,"class","docstring"),c(Le,"class","docstring"),c(fo,"id","transformers.TFFunnelModel"),c(fo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(fo,"href","#transformers.TFFunnelModel"),c(Et,"class","relative group"),c(Wr,"href","https://arxiv.org/abs/2006.03236"),c(Wr,"rel","nofollow"),c(Di,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel"),c(Rr,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Rr,"rel","nofollow"),c(Ai,"href","/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelModel"),c(pn,"class","docstring"),c(Oe,"class","docstring"),c(_o,"id","transformers.TFFunnelForPreTraining"),c(_o,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(_o,"href","#transformers.TFFunnelForPreTraining"),c(zt,"class","relative group"),c(Zr,"href","https://arxiv.org/abs/2006.03236"),c(Zr,"rel","nofollow"),c(Ni,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel"),c(ea,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(ea,"rel","nofollow"),c(Si,"href","/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelForPreTraining"),c(un,"class","docstring"),c(De,"class","docstring"),c(Fo,"id","transformers.TFFunnelForMaskedLM"),c(Fo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Fo,"href","#transformers.TFFunnelForMaskedLM"),c(Pt,"class","relative group"),c(ia,"href","https://arxiv.org/abs/2006.03236"),c(ia,"rel","nofollow"),c(Ii,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel"),c(ca,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(ca,"rel","nofollow"),c(Bi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelForMaskedLM"),c(Je,"class","docstring"),c(Ae,"class","docstring"),c(wo,"id","transformers.TFFunnelForSequenceClassification"),c(wo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(wo,"href","#transformers.TFFunnelForSequenceClassification"),c(Ct,"class","relative group"),c(_a,"href","https://arxiv.org/abs/2006.03236"),c(_a,"rel","nofollow"),c(Wi,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel"),c(Fa,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Fa,"rel","nofollow"),c(Qi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelForSequenceClassification"),c(en,"class","docstring"),c(Ne,"class","docstring"),c(Eo,"id","transformers.TFFunnelForMultipleChoice"),c(Eo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Eo,"href","#transformers.TFFunnelForMultipleChoice"),c(Lt,"class","relative group"),c(Ma,"href","https://arxiv.org/abs/2006.03236"),c(Ma,"rel","nofollow"),c(Ui,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel"),c(Pa,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Pa,"rel","nofollow"),c(Ri,"href","/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelForMultipleChoice"),c(hn,"class","docstring"),c(Se,"class","docstring"),c(qo,"id","transformers.TFFunnelForTokenClassification"),c(qo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(qo,"href","#transformers.TFFunnelForTokenClassification"),c(Dt,"class","relative group"),c(Da,"href","https://arxiv.org/abs/2006.03236"),c(Da,"rel","nofollow"),c(Hi,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel"),c(Sa,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Sa,"rel","nofollow"),c(Vi,"href","/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelForTokenClassification"),c(nn,"class","docstring"),c(Ie,"class","docstring"),c(Co,"id","transformers.TFFunnelForQuestionAnswering"),c(Co,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Co,"href","#transformers.TFFunnelForQuestionAnswering"),c(Nt,"class","relative group"),c(Ha,"href","https://arxiv.org/abs/2006.03236"),c(Ha,"rel","nofollow"),c(Yi,"href","/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel"),c(Ka,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Ka,"rel","nofollow"),c(Ki,"href","/docs/transformers/main/en/model_doc/funnel#transformers.TFFunnelForQuestionAnswering"),c(tn,"class","docstring"),c(Be,"class","docstring")},m(s,f){e(document.head,u),h(s,z,f),h(s,g,f),e(g,_),e(_,k),y(T,k,null),e(g,m),e(g,M),e(M,ce),h(s,K,f),h(s,q,f),e(q,J),e(J,A),y(ne,A,null),e(q,pe),e(q,N),e(N,ue),h(s,ie,f),h(s,Y,f),e(Y,L),e(Y,te),e(te,G),e(Y,P),h(s,C,f),h(s,oe,f),e(oe,W),h(s,le,f),h(s,se,f),e(se,S),e(S,he),h(s,de,f),h(s,j,f),e(j,fe),h(s,B,f),h(s,ee,f),e(ee,ae),e(ae,Q),e(ee,me),e(ee,I),e(I,O),e(I,re),e(re,U),e(I,ge),e(I,p),e(p,E),e(I,Z),e(I,Te),e(Te,we),e(I,D),e(I,ke),e(ke,be),e(I,$e),e(I,x),e(x,R),e(I,Ee),e(I,Fe),e(Fe,H),e(I,Me),e(I,ve),e(ve,_e),e(I,ze),e(I,oi),e(oi,Yu),e(I,Ku),h(s,Oc,f),h(s,In,f),e(In,Gu),e(In,No),e(No,Zu),e(In,Xu),e(In,So),e(So,Ju),e(In,eh),h(s,Dc,f),h(s,Zn,f),e(Zn,Bt),e(Bt,Fl),y(Io,Fl,null),e(Zn,nh),e(Zn,vl),e(vl,th),h(s,Ac,f),h(s,Nn,f),y(Bo,Nn,null),e(Nn,oh),e(Nn,Sn),e(Sn,sh),e(Sn,si),e(si,rh),e(Sn,ah),e(Sn,ri),e(ri,ih),e(Sn,lh),e(Sn,Wo),e(Wo,dh),e(Sn,ch),e(Nn,ph),e(Nn,Xn),e(Xn,uh),e(Xn,ai),e(ai,hh),e(Xn,fh),e(Xn,ii),e(ii,mh),e(Xn,gh),h(s,Nc,f),h(s,Jn,f),e(Jn,Wt),e(Wt,yl),y(Qo,yl,null),e(Jn,_h),e(Jn,wl),e(wl,Th),h(s,Sc,f),h(s,Ce,f),y(Uo,Ce,null),e(Ce,kh),e(Ce,bl),e(bl,Fh),e(Ce,vh),e(Ce,Qt),e(Qt,li),e(li,yh),e(Qt,wh),e(Qt,di),e(di,bh),e(Qt,$h),e(Ce,Eh),e(Ce,Ro),e(Ro,Mh),e(Ro,ci),e(ci,zh),e(Ro,qh),e(Ce,Ph),e(Ce,Bn),y(Ho,Bn,null),e(Bn,jh),e(Bn,$l),e($l,Ch),e(Bn,xh),e(Bn,Vo),e(Vo,pi),e(pi,Lh),e(pi,El),e(El,Oh),e(Vo,Dh),e(Vo,ui),e(ui,Ah),e(ui,Ml),e(Ml,Nh),e(Ce,Sh),e(Ce,Ut),y(Yo,Ut,null),e(Ut,Ih),e(Ut,Ko),e(Ko,Bh),e(Ko,zl),e(zl,Wh),e(Ko,Qh),e(Ce,Uh),e(Ce,yn),y(Go,yn,null),e(yn,Rh),e(yn,ql),e(ql,Hh),e(yn,Vh),y(Zo,yn,null),e(yn,Yh),e(yn,et),e(et,Kh),e(et,Pl),e(Pl,Gh),e(et,Zh),e(et,jl),e(jl,Xh),e(et,Jh),e(Ce,ef),e(Ce,hi),y(Xo,hi,null),h(s,Ic,f),h(s,nt,f),e(nt,Rt),e(Rt,Cl),y(Jo,Cl,null),e(nt,nf),e(nt,xl),e(xl,tf),h(s,Bc,f),h(s,sn,f),y(es,sn,null),e(sn,of),e(sn,ns),e(ns,sf),e(ns,Ll),e(Ll,rf),e(ns,af),e(sn,lf),e(sn,Ht),e(Ht,fi),e(fi,df),e(Ht,cf),e(Ht,mi),e(mi,pf),e(Ht,uf),e(sn,hf),e(sn,ts),e(ts,ff),e(ts,gi),e(gi,mf),e(ts,gf),e(sn,_f),e(sn,wn),y(os,wn,null),e(wn,Tf),e(wn,Ol),e(Ol,kf),e(wn,Ff),y(ss,wn,null),e(wn,vf),e(wn,tt),e(tt,yf),e(tt,Dl),e(Dl,wf),e(tt,bf),e(tt,Al),e(Al,$f),e(tt,Ef),h(s,Wc,f),h(s,ot,f),e(ot,Vt),e(Vt,Nl),y(rs,Nl,null),e(ot,Mf),e(ot,Sl),e(Sl,zf),h(s,Qc,f),h(s,st,f),y(as,st,null),e(st,qf),e(st,is),e(is,Pf),e(is,_i),e(_i,jf),e(is,Cf),h(s,Uc,f),h(s,rt,f),y(ls,rt,null),e(rt,xf),e(rt,ds),e(ds,Lf),e(ds,Ti),e(Ti,Of),e(ds,Df),h(s,Rc,f),h(s,at,f),e(at,Yt),e(Yt,Il),y(cs,Il,null),e(at,Af),e(at,Bl),e(Bl,Nf),h(s,Hc,f),h(s,Qe,f),y(ps,Qe,null),e(Qe,Sf),e(Qe,Wl),e(Wl,If),e(Qe,Bf),e(Qe,us),e(us,Wf),e(us,hs),e(hs,Qf),e(us,Uf),e(Qe,Rf),e(Qe,fs),e(fs,Hf),e(fs,ki),e(ki,Vf),e(fs,Yf),e(Qe,Kf),e(Qe,ms),e(ms,Gf),e(ms,gs),e(gs,Zf),e(ms,Xf),e(Qe,Jf),e(Qe,rn),y(_s,rn,null),e(rn,em),e(rn,it),e(it,nm),e(it,Fi),e(Fi,tm),e(it,om),e(it,Ql),e(Ql,sm),e(it,rm),e(rn,am),y(Kt,rn,null),e(rn,im),e(rn,Ul),e(Ul,lm),e(rn,dm),y(Ts,rn,null),h(s,Vc,f),h(s,lt,f),e(lt,Gt),e(Gt,Rl),y(ks,Rl,null),e(lt,cm),e(lt,Hl),e(Hl,pm),h(s,Yc,f),h(s,Ue,f),y(Fs,Ue,null),e(Ue,um),e(Ue,Vl),e(Vl,hm),e(Ue,fm),e(Ue,vs),e(vs,mm),e(vs,ys),e(ys,gm),e(vs,_m),e(Ue,Tm),e(Ue,ws),e(ws,km),e(ws,vi),e(vi,Fm),e(ws,vm),e(Ue,ym),e(Ue,bs),e(bs,wm),e(bs,$s),e($s,bm),e(bs,$m),e(Ue,Em),e(Ue,an),y(Es,an,null),e(an,Mm),e(an,dt),e(dt,zm),e(dt,yi),e(yi,qm),e(dt,Pm),e(dt,Yl),e(Yl,jm),e(dt,Cm),e(an,xm),y(Zt,an,null),e(an,Lm),e(an,Kl),e(Kl,Om),e(an,Dm),y(Ms,an,null),h(s,Kc,f),h(s,ct,f),e(ct,Xt),e(Xt,Gl),y(zs,Gl,null),e(ct,Am),e(ct,Zl),e(Zl,Nm),h(s,Gc,f),h(s,pt,f),y(qs,pt,null),e(pt,Sm),e(pt,ln),y(Ps,ln,null),e(ln,Im),e(ln,ut),e(ut,Bm),e(ut,wi),e(wi,Wm),e(ut,Qm),e(ut,Xl),e(Xl,Um),e(ut,Rm),e(ln,Hm),y(Jt,ln,null),e(ln,Vm),e(ln,Jl),e(Jl,Ym),e(ln,Km),y(js,ln,null),h(s,Zc,f),h(s,ht,f),e(ht,eo),e(eo,ed),y(Cs,ed,null),e(ht,Gm),e(ht,nd),e(nd,Zm),h(s,Xc,f),h(s,Re,f),y(xs,Re,null),e(Re,Xm),e(Re,Ls),e(Ls,Jm),e(Ls,td),e(td,eg),e(Ls,ng),e(Re,tg),e(Re,Os),e(Os,og),e(Os,Ds),e(Ds,sg),e(Os,rg),e(Re,ag),e(Re,As),e(As,ig),e(As,bi),e(bi,lg),e(As,dg),e(Re,cg),e(Re,Ns),e(Ns,pg),e(Ns,Ss),e(Ss,ug),e(Ns,hg),e(Re,fg),e(Re,Ge),y(Is,Ge,null),e(Ge,mg),e(Ge,ft),e(ft,gg),e(ft,$i),e($i,_g),e(ft,Tg),e(ft,od),e(od,kg),e(ft,Fg),e(Ge,vg),y(no,Ge,null),e(Ge,yg),e(Ge,sd),e(sd,wg),e(Ge,bg),y(Bs,Ge,null),e(Ge,$g),y(Ws,Ge,null),h(s,Jc,f),h(s,mt,f),e(mt,to),e(to,rd),y(Qs,rd,null),e(mt,Eg),e(mt,ad),e(ad,Mg),h(s,ep,f),h(s,He,f),y(Us,He,null),e(He,zg),e(He,id),e(id,qg),e(He,Pg),e(He,Rs),e(Rs,jg),e(Rs,Hs),e(Hs,Cg),e(Rs,xg),e(He,Lg),e(He,Vs),e(Vs,Og),e(Vs,Ei),e(Ei,Dg),e(Vs,Ag),e(He,Ng),e(He,Ys),e(Ys,Sg),e(Ys,Ks),e(Ks,Ig),e(Ys,Bg),e(He,Wg),e(He,Pe),y(Gs,Pe,null),e(Pe,Qg),e(Pe,gt),e(gt,Ug),e(gt,Mi),e(Mi,Rg),e(gt,Hg),e(gt,ld),e(ld,Vg),e(gt,Yg),e(Pe,Kg),y(oo,Pe,null),e(Pe,Gg),e(Pe,dd),e(dd,Zg),e(Pe,Xg),y(Zs,Pe,null),e(Pe,Jg),y(Xs,Pe,null),e(Pe,e_),e(Pe,cd),e(cd,n_),e(Pe,t_),y(Js,Pe,null),e(Pe,o_),y(er,Pe,null),h(s,np,f),h(s,_t,f),e(_t,so),e(so,pd),y(nr,pd,null),e(_t,s_),e(_t,ud),e(ud,r_),h(s,tp,f),h(s,Ve,f),y(tr,Ve,null),e(Ve,a_),e(Ve,hd),e(hd,i_),e(Ve,l_),e(Ve,or),e(or,d_),e(or,sr),e(sr,c_),e(or,p_),e(Ve,u_),e(Ve,rr),e(rr,h_),e(rr,zi),e(zi,f_),e(rr,m_),e(Ve,g_),e(Ve,ar),e(ar,__),e(ar,ir),e(ir,T_),e(ar,k_),e(Ve,F_),e(Ve,dn),y(lr,dn,null),e(dn,v_),e(dn,Tt),e(Tt,y_),e(Tt,qi),e(qi,w_),e(Tt,b_),e(Tt,fd),e(fd,$_),e(Tt,E_),e(dn,M_),y(ro,dn,null),e(dn,z_),e(dn,md),e(md,q_),e(dn,P_),y(dr,dn,null),h(s,op,f),h(s,kt,f),e(kt,ao),e(ao,gd),y(cr,gd,null),e(kt,j_),e(kt,_d),e(_d,C_),h(s,sp,f),h(s,Ye,f),y(pr,Ye,null),e(Ye,x_),e(Ye,Td),e(Td,L_),e(Ye,O_),e(Ye,ur),e(ur,D_),e(ur,hr),e(hr,A_),e(ur,N_),e(Ye,S_),e(Ye,fr),e(fr,I_),e(fr,Pi),e(Pi,B_),e(fr,W_),e(Ye,Q_),e(Ye,mr),e(mr,U_),e(mr,gr),e(gr,R_),e(mr,H_),e(Ye,V_),e(Ye,Ze),y(_r,Ze,null),e(Ze,Y_),e(Ze,Ft),e(Ft,K_),e(Ft,ji),e(ji,G_),e(Ft,Z_),e(Ft,kd),e(kd,X_),e(Ft,J_),e(Ze,eT),y(io,Ze,null),e(Ze,nT),e(Ze,Fd),e(Fd,tT),e(Ze,oT),y(Tr,Ze,null),e(Ze,sT),y(kr,Ze,null),h(s,rp,f),h(s,vt,f),e(vt,lo),e(lo,vd),y(Fr,vd,null),e(vt,rT),e(vt,yd),e(yd,aT),h(s,ap,f),h(s,Ke,f),y(vr,Ke,null),e(Ke,iT),e(Ke,yt),e(yt,lT),e(yt,wd),e(wd,dT),e(yt,cT),e(yt,bd),e(bd,pT),e(yt,uT),e(Ke,hT),e(Ke,yr),e(yr,fT),e(yr,wr),e(wr,mT),e(yr,gT),e(Ke,_T),e(Ke,br),e(br,TT),e(br,Ci),e(Ci,kT),e(br,FT),e(Ke,vT),e(Ke,$r),e($r,yT),e($r,Er),e(Er,wT),e($r,bT),e(Ke,$T),e(Ke,Xe),y(Mr,Xe,null),e(Xe,ET),e(Xe,wt),e(wt,MT),e(wt,xi),e(xi,zT),e(wt,qT),e(wt,$d),e($d,PT),e(wt,jT),e(Xe,CT),y(co,Xe,null),e(Xe,xT),e(Xe,Ed),e(Ed,LT),e(Xe,OT),y(zr,Xe,null),e(Xe,DT),y(qr,Xe,null),h(s,ip,f),h(s,bt,f),e(bt,po),e(po,Md),y(Pr,Md,null),e(bt,AT),e(bt,zd),e(zd,NT),h(s,lp,f),h(s,Le,f),y(jr,Le,null),e(Le,ST),e(Le,qd),e(qd,IT),e(Le,BT),e(Le,Cr),e(Cr,WT),e(Cr,xr),e(xr,QT),e(Cr,UT),e(Le,RT),e(Le,Lr),e(Lr,HT),e(Lr,Li),e(Li,VT),e(Lr,YT),e(Le,KT),e(Le,Or),e(Or,GT),e(Or,Dr),e(Dr,ZT),e(Or,XT),e(Le,JT),y(uo,Le,null),e(Le,ek),e(Le,cn),y(Ar,cn,null),e(cn,nk),e(cn,$t),e($t,tk),e($t,Oi),e(Oi,ok),e($t,sk),e($t,Pd),e(Pd,rk),e($t,ak),e(cn,ik),y(ho,cn,null),e(cn,lk),e(cn,jd),e(jd,dk),e(cn,ck),y(Nr,cn,null),h(s,dp,f),h(s,Et,f),e(Et,fo),e(fo,Cd),y(Sr,Cd,null),e(Et,pk),e(Et,xd),e(xd,uk),h(s,cp,f),h(s,Oe,f),y(Ir,Oe,null),e(Oe,hk),e(Oe,Ld),e(Ld,fk),e(Oe,mk),e(Oe,Br),e(Br,gk),e(Br,Wr),e(Wr,_k),e(Br,Tk),e(Oe,kk),e(Oe,Qr),e(Qr,Fk),e(Qr,Di),e(Di,vk),e(Qr,yk),e(Oe,wk),e(Oe,Ur),e(Ur,bk),e(Ur,Rr),e(Rr,$k),e(Ur,Ek),e(Oe,Mk),y(mo,Oe,null),e(Oe,zk),e(Oe,pn),y(Hr,pn,null),e(pn,qk),e(pn,Mt),e(Mt,Pk),e(Mt,Ai),e(Ai,jk),e(Mt,Ck),e(Mt,Od),e(Od,xk),e(Mt,Lk),e(pn,Ok),y(go,pn,null),e(pn,Dk),e(pn,Dd),e(Dd,Ak),e(pn,Nk),y(Vr,pn,null),h(s,pp,f),h(s,zt,f),e(zt,_o),e(_o,Ad),y(Yr,Ad,null),e(zt,Sk),e(zt,Nd),e(Nd,Ik),h(s,up,f),h(s,De,f),y(Kr,De,null),e(De,Bk),e(De,Sd),e(Sd,Wk),e(De,Qk),e(De,Gr),e(Gr,Uk),e(Gr,Zr),e(Zr,Rk),e(Gr,Hk),e(De,Vk),e(De,Xr),e(Xr,Yk),e(Xr,Ni),e(Ni,Kk),e(Xr,Gk),e(De,Zk),e(De,Jr),e(Jr,Xk),e(Jr,ea),e(ea,Jk),e(Jr,eF),e(De,nF),y(To,De,null),e(De,tF),e(De,un),y(na,un,null),e(un,oF),e(un,qt),e(qt,sF),e(qt,Si),e(Si,rF),e(qt,aF),e(qt,Id),e(Id,iF),e(qt,lF),e(un,dF),y(ko,un,null),e(un,cF),e(un,Bd),e(Bd,pF),e(un,uF),y(ta,un,null),h(s,hp,f),h(s,Pt,f),e(Pt,Fo),e(Fo,Wd),y(oa,Wd,null),e(Pt,hF),e(Pt,Qd),e(Qd,fF),h(s,fp,f),h(s,Ae,f),y(sa,Ae,null),e(Ae,mF),e(Ae,ra),e(ra,gF),e(ra,Ud),e(Ud,_F),e(ra,TF),e(Ae,kF),e(Ae,aa),e(aa,FF),e(aa,ia),e(ia,vF),e(aa,yF),e(Ae,wF),e(Ae,la),e(la,bF),e(la,Ii),e(Ii,$F),e(la,EF),e(Ae,MF),e(Ae,da),e(da,zF),e(da,ca),e(ca,qF),e(da,PF),e(Ae,jF),y(vo,Ae,null),e(Ae,CF),e(Ae,Je),y(pa,Je,null),e(Je,xF),e(Je,jt),e(jt,LF),e(jt,Bi),e(Bi,OF),e(jt,DF),e(jt,Rd),e(Rd,AF),e(jt,NF),e(Je,SF),y(yo,Je,null),e(Je,IF),e(Je,Hd),e(Hd,BF),e(Je,WF),y(ua,Je,null),e(Je,QF),y(ha,Je,null),h(s,mp,f),h(s,Ct,f),e(Ct,wo),e(wo,Vd),y(fa,Vd,null),e(Ct,UF),e(Ct,Yd),e(Yd,RF),h(s,gp,f),h(s,Ne,f),y(ma,Ne,null),e(Ne,HF),e(Ne,Kd),e(Kd,VF),e(Ne,YF),e(Ne,ga),e(ga,KF),e(ga,_a),e(_a,GF),e(ga,ZF),e(Ne,XF),e(Ne,Ta),e(Ta,JF),e(Ta,Wi),e(Wi,ev),e(Ta,nv),e(Ne,tv),e(Ne,ka),e(ka,ov),e(ka,Fa),e(Fa,sv),e(ka,rv),e(Ne,av),y(bo,Ne,null),e(Ne,iv),e(Ne,en),y(va,en,null),e(en,lv),e(en,xt),e(xt,dv),e(xt,Qi),e(Qi,cv),e(xt,pv),e(xt,Gd),e(Gd,uv),e(xt,hv),e(en,fv),y($o,en,null),e(en,mv),e(en,Zd),e(Zd,gv),e(en,_v),y(ya,en,null),e(en,Tv),y(wa,en,null),h(s,_p,f),h(s,Lt,f),e(Lt,Eo),e(Eo,Xd),y(ba,Xd,null),e(Lt,kv),e(Lt,Jd),e(Jd,Fv),h(s,Tp,f),h(s,Se,f),y($a,Se,null),e(Se,vv),e(Se,ec),e(ec,yv),e(Se,wv),e(Se,Ea),e(Ea,bv),e(Ea,Ma),e(Ma,$v),e(Ea,Ev),e(Se,Mv),e(Se,za),e(za,zv),e(za,Ui),e(Ui,qv),e(za,Pv),e(Se,jv),e(Se,qa),e(qa,Cv),e(qa,Pa),e(Pa,xv),e(qa,Lv),e(Se,Ov),y(Mo,Se,null),e(Se,Dv),e(Se,hn),y(ja,hn,null),e(hn,Av),e(hn,Ot),e(Ot,Nv),e(Ot,Ri),e(Ri,Sv),e(Ot,Iv),e(Ot,nc),e(nc,Bv),e(Ot,Wv),e(hn,Qv),y(zo,hn,null),e(hn,Uv),e(hn,tc),e(tc,Rv),e(hn,Hv),y(Ca,hn,null),h(s,kp,f),h(s,Dt,f),e(Dt,qo),e(qo,oc),y(xa,oc,null),e(Dt,Vv),e(Dt,sc),e(sc,Yv),h(s,Fp,f),h(s,Ie,f),y(La,Ie,null),e(Ie,Kv),e(Ie,rc),e(rc,Gv),e(Ie,Zv),e(Ie,Oa),e(Oa,Xv),e(Oa,Da),e(Da,Jv),e(Oa,ey),e(Ie,ny),e(Ie,Aa),e(Aa,ty),e(Aa,Hi),e(Hi,oy),e(Aa,sy),e(Ie,ry),e(Ie,Na),e(Na,ay),e(Na,Sa),e(Sa,iy),e(Na,ly),e(Ie,dy),y(Po,Ie,null),e(Ie,cy),e(Ie,nn),y(Ia,nn,null),e(nn,py),e(nn,At),e(At,uy),e(At,Vi),e(Vi,hy),e(At,fy),e(At,ac),e(ac,my),e(At,gy),e(nn,_y),y(jo,nn,null),e(nn,Ty),e(nn,ic),e(ic,ky),e(nn,Fy),y(Ba,nn,null),e(nn,vy),y(Wa,nn,null),h(s,vp,f),h(s,Nt,f),e(Nt,Co),e(Co,lc),y(Qa,lc,null),e(Nt,yy),e(Nt,dc),e(dc,wy),h(s,yp,f),h(s,Be,f),y(Ua,Be,null),e(Be,by),e(Be,St),e(St,$y),e(St,cc),e(cc,Ey),e(St,My),e(St,pc),e(pc,zy),e(St,qy),e(Be,Py),e(Be,Ra),e(Ra,jy),e(Ra,Ha),e(Ha,Cy),e(Ra,xy),e(Be,Ly),e(Be,Va),e(Va,Oy),e(Va,Yi),e(Yi,Dy),e(Va,Ay),e(Be,Ny),e(Be,Ya),e(Ya,Sy),e(Ya,Ka),e(Ka,Iy),e(Ya,By),e(Be,Wy),y(xo,Be,null),e(Be,Qy),e(Be,tn),y(Ga,tn,null),e(tn,Uy),e(tn,It),e(It,Ry),e(It,Ki),e(Ki,Hy),e(It,Vy),e(It,uc),e(uc,Yy),e(It,Ky),e(tn,Gy),y(Lo,tn,null),e(tn,Zy),e(tn,hc),e(hc,Xy),e(tn,Jy),y(Za,tn,null),e(tn,ew),y(Xa,tn,null),wp=!0},p(s,[f]){const Ja={};f&2&&(Ja.$$scope={dirty:f,ctx:s}),Kt.$set(Ja);const fc={};f&2&&(fc.$$scope={dirty:f,ctx:s}),Zt.$set(fc);const mc={};f&2&&(mc.$$scope={dirty:f,ctx:s}),Jt.$set(mc);const gc={};f&2&&(gc.$$scope={dirty:f,ctx:s}),no.$set(gc);const ei={};f&2&&(ei.$$scope={dirty:f,ctx:s}),oo.$set(ei);const _c={};f&2&&(_c.$$scope={dirty:f,ctx:s}),ro.$set(_c);const Tc={};f&2&&(Tc.$$scope={dirty:f,ctx:s}),io.$set(Tc);const kc={};f&2&&(kc.$$scope={dirty:f,ctx:s}),co.$set(kc);const ni={};f&2&&(ni.$$scope={dirty:f,ctx:s}),uo.$set(ni);const Fc={};f&2&&(Fc.$$scope={dirty:f,ctx:s}),ho.$set(Fc);const vc={};f&2&&(vc.$$scope={dirty:f,ctx:s}),mo.$set(vc);const yc={};f&2&&(yc.$$scope={dirty:f,ctx:s}),go.$set(yc);const wc={};f&2&&(wc.$$scope={dirty:f,ctx:s}),To.$set(wc);const bc={};f&2&&(bc.$$scope={dirty:f,ctx:s}),ko.$set(bc);const ti={};f&2&&(ti.$$scope={dirty:f,ctx:s}),vo.$set(ti);const $c={};f&2&&($c.$$scope={dirty:f,ctx:s}),yo.$set($c);const xe={};f&2&&(xe.$$scope={dirty:f,ctx:s}),bo.$set(xe);const Ec={};f&2&&(Ec.$$scope={dirty:f,ctx:s}),$o.$set(Ec);const Mc={};f&2&&(Mc.$$scope={dirty:f,ctx:s}),Mo.$set(Mc);const zc={};f&2&&(zc.$$scope={dirty:f,ctx:s}),zo.$set(zc);const qc={};f&2&&(qc.$$scope={dirty:f,ctx:s}),Po.$set(qc);const Pc={};f&2&&(Pc.$$scope={dirty:f,ctx:s}),jo.$set(Pc);const jc={};f&2&&(jc.$$scope={dirty:f,ctx:s}),xo.$set(jc);const Cc={};f&2&&(Cc.$$scope={dirty:f,ctx:s}),Lo.$set(Cc)},i(s){wp||(w(T.$$.fragment,s),w(ne.$$.fragment,s),w(Io.$$.fragment,s),w(Bo.$$.fragment,s),w(Qo.$$.fragment,s),w(Uo.$$.fragment,s),w(Ho.$$.fragment,s),w(Yo.$$.fragment,s),w(Go.$$.fragment,s),w(Zo.$$.fragment,s),w(Xo.$$.fragment,s),w(Jo.$$.fragment,s),w(es.$$.fragment,s),w(os.$$.fragment,s),w(ss.$$.fragment,s),w(rs.$$.fragment,s),w(as.$$.fragment,s),w(ls.$$.fragment,s),w(cs.$$.fragment,s),w(ps.$$.fragment,s),w(_s.$$.fragment,s),w(Kt.$$.fragment,s),w(Ts.$$.fragment,s),w(ks.$$.fragment,s),w(Fs.$$.fragment,s),w(Es.$$.fragment,s),w(Zt.$$.fragment,s),w(Ms.$$.fragment,s),w(zs.$$.fragment,s),w(qs.$$.fragment,s),w(Ps.$$.fragment,s),w(Jt.$$.fragment,s),w(js.$$.fragment,s),w(Cs.$$.fragment,s),w(xs.$$.fragment,s),w(Is.$$.fragment,s),w(no.$$.fragment,s),w(Bs.$$.fragment,s),w(Ws.$$.fragment,s),w(Qs.$$.fragment,s),w(Us.$$.fragment,s),w(Gs.$$.fragment,s),w(oo.$$.fragment,s),w(Zs.$$.fragment,s),w(Xs.$$.fragment,s),w(Js.$$.fragment,s),w(er.$$.fragment,s),w(nr.$$.fragment,s),w(tr.$$.fragment,s),w(lr.$$.fragment,s),w(ro.$$.fragment,s),w(dr.$$.fragment,s),w(cr.$$.fragment,s),w(pr.$$.fragment,s),w(_r.$$.fragment,s),w(io.$$.fragment,s),w(Tr.$$.fragment,s),w(kr.$$.fragment,s),w(Fr.$$.fragment,s),w(vr.$$.fragment,s),w(Mr.$$.fragment,s),w(co.$$.fragment,s),w(zr.$$.fragment,s),w(qr.$$.fragment,s),w(Pr.$$.fragment,s),w(jr.$$.fragment,s),w(uo.$$.fragment,s),w(Ar.$$.fragment,s),w(ho.$$.fragment,s),w(Nr.$$.fragment,s),w(Sr.$$.fragment,s),w(Ir.$$.fragment,s),w(mo.$$.fragment,s),w(Hr.$$.fragment,s),w(go.$$.fragment,s),w(Vr.$$.fragment,s),w(Yr.$$.fragment,s),w(Kr.$$.fragment,s),w(To.$$.fragment,s),w(na.$$.fragment,s),w(ko.$$.fragment,s),w(ta.$$.fragment,s),w(oa.$$.fragment,s),w(sa.$$.fragment,s),w(vo.$$.fragment,s),w(pa.$$.fragment,s),w(yo.$$.fragment,s),w(ua.$$.fragment,s),w(ha.$$.fragment,s),w(fa.$$.fragment,s),w(ma.$$.fragment,s),w(bo.$$.fragment,s),w(va.$$.fragment,s),w($o.$$.fragment,s),w(ya.$$.fragment,s),w(wa.$$.fragment,s),w(ba.$$.fragment,s),w($a.$$.fragment,s),w(Mo.$$.fragment,s),w(ja.$$.fragment,s),w(zo.$$.fragment,s),w(Ca.$$.fragment,s),w(xa.$$.fragment,s),w(La.$$.fragment,s),w(Po.$$.fragment,s),w(Ia.$$.fragment,s),w(jo.$$.fragment,s),w(Ba.$$.fragment,s),w(Wa.$$.fragment,s),w(Qa.$$.fragment,s),w(Ua.$$.fragment,s),w(xo.$$.fragment,s),w(Ga.$$.fragment,s),w(Lo.$$.fragment,s),w(Za.$$.fragment,s),w(Xa.$$.fragment,s),wp=!0)},o(s){b(T.$$.fragment,s),b(ne.$$.fragment,s),b(Io.$$.fragment,s),b(Bo.$$.fragment,s),b(Qo.$$.fragment,s),b(Uo.$$.fragment,s),b(Ho.$$.fragment,s),b(Yo.$$.fragment,s),b(Go.$$.fragment,s),b(Zo.$$.fragment,s),b(Xo.$$.fragment,s),b(Jo.$$.fragment,s),b(es.$$.fragment,s),b(os.$$.fragment,s),b(ss.$$.fragment,s),b(rs.$$.fragment,s),b(as.$$.fragment,s),b(ls.$$.fragment,s),b(cs.$$.fragment,s),b(ps.$$.fragment,s),b(_s.$$.fragment,s),b(Kt.$$.fragment,s),b(Ts.$$.fragment,s),b(ks.$$.fragment,s),b(Fs.$$.fragment,s),b(Es.$$.fragment,s),b(Zt.$$.fragment,s),b(Ms.$$.fragment,s),b(zs.$$.fragment,s),b(qs.$$.fragment,s),b(Ps.$$.fragment,s),b(Jt.$$.fragment,s),b(js.$$.fragment,s),b(Cs.$$.fragment,s),b(xs.$$.fragment,s),b(Is.$$.fragment,s),b(no.$$.fragment,s),b(Bs.$$.fragment,s),b(Ws.$$.fragment,s),b(Qs.$$.fragment,s),b(Us.$$.fragment,s),b(Gs.$$.fragment,s),b(oo.$$.fragment,s),b(Zs.$$.fragment,s),b(Xs.$$.fragment,s),b(Js.$$.fragment,s),b(er.$$.fragment,s),b(nr.$$.fragment,s),b(tr.$$.fragment,s),b(lr.$$.fragment,s),b(ro.$$.fragment,s),b(dr.$$.fragment,s),b(cr.$$.fragment,s),b(pr.$$.fragment,s),b(_r.$$.fragment,s),b(io.$$.fragment,s),b(Tr.$$.fragment,s),b(kr.$$.fragment,s),b(Fr.$$.fragment,s),b(vr.$$.fragment,s),b(Mr.$$.fragment,s),b(co.$$.fragment,s),b(zr.$$.fragment,s),b(qr.$$.fragment,s),b(Pr.$$.fragment,s),b(jr.$$.fragment,s),b(uo.$$.fragment,s),b(Ar.$$.fragment,s),b(ho.$$.fragment,s),b(Nr.$$.fragment,s),b(Sr.$$.fragment,s),b(Ir.$$.fragment,s),b(mo.$$.fragment,s),b(Hr.$$.fragment,s),b(go.$$.fragment,s),b(Vr.$$.fragment,s),b(Yr.$$.fragment,s),b(Kr.$$.fragment,s),b(To.$$.fragment,s),b(na.$$.fragment,s),b(ko.$$.fragment,s),b(ta.$$.fragment,s),b(oa.$$.fragment,s),b(sa.$$.fragment,s),b(vo.$$.fragment,s),b(pa.$$.fragment,s),b(yo.$$.fragment,s),b(ua.$$.fragment,s),b(ha.$$.fragment,s),b(fa.$$.fragment,s),b(ma.$$.fragment,s),b(bo.$$.fragment,s),b(va.$$.fragment,s),b($o.$$.fragment,s),b(ya.$$.fragment,s),b(wa.$$.fragment,s),b(ba.$$.fragment,s),b($a.$$.fragment,s),b(Mo.$$.fragment,s),b(ja.$$.fragment,s),b(zo.$$.fragment,s),b(Ca.$$.fragment,s),b(xa.$$.fragment,s),b(La.$$.fragment,s),b(Po.$$.fragment,s),b(Ia.$$.fragment,s),b(jo.$$.fragment,s),b(Ba.$$.fragment,s),b(Wa.$$.fragment,s),b(Qa.$$.fragment,s),b(Ua.$$.fragment,s),b(xo.$$.fragment,s),b(Ga.$$.fragment,s),b(Lo.$$.fragment,s),b(Za.$$.fragment,s),b(Xa.$$.fragment,s),wp=!1},d(s){n(u),s&&n(z),s&&n(g),$(T),s&&n(K),s&&n(q),$(ne),s&&n(ie),s&&n(Y),s&&n(C),s&&n(oe),s&&n(le),s&&n(se),s&&n(de),s&&n(j),s&&n(B),s&&n(ee),s&&n(Oc),s&&n(In),s&&n(Dc),s&&n(Zn),$(Io),s&&n(Ac),s&&n(Nn),$(Bo),s&&n(Nc),s&&n(Jn),$(Qo),s&&n(Sc),s&&n(Ce),$(Uo),$(Ho),$(Yo),$(Go),$(Zo),$(Xo),s&&n(Ic),s&&n(nt),$(Jo),s&&n(Bc),s&&n(sn),$(es),$(os),$(ss),s&&n(Wc),s&&n(ot),$(rs),s&&n(Qc),s&&n(st),$(as),s&&n(Uc),s&&n(rt),$(ls),s&&n(Rc),s&&n(at),$(cs),s&&n(Hc),s&&n(Qe),$(ps),$(_s),$(Kt),$(Ts),s&&n(Vc),s&&n(lt),$(ks),s&&n(Yc),s&&n(Ue),$(Fs),$(Es),$(Zt),$(Ms),s&&n(Kc),s&&n(ct),$(zs),s&&n(Gc),s&&n(pt),$(qs),$(Ps),$(Jt),$(js),s&&n(Zc),s&&n(ht),$(Cs),s&&n(Xc),s&&n(Re),$(xs),$(Is),$(no),$(Bs),$(Ws),s&&n(Jc),s&&n(mt),$(Qs),s&&n(ep),s&&n(He),$(Us),$(Gs),$(oo),$(Zs),$(Xs),$(Js),$(er),s&&n(np),s&&n(_t),$(nr),s&&n(tp),s&&n(Ve),$(tr),$(lr),$(ro),$(dr),s&&n(op),s&&n(kt),$(cr),s&&n(sp),s&&n(Ye),$(pr),$(_r),$(io),$(Tr),$(kr),s&&n(rp),s&&n(vt),$(Fr),s&&n(ap),s&&n(Ke),$(vr),$(Mr),$(co),$(zr),$(qr),s&&n(ip),s&&n(bt),$(Pr),s&&n(lp),s&&n(Le),$(jr),$(uo),$(Ar),$(ho),$(Nr),s&&n(dp),s&&n(Et),$(Sr),s&&n(cp),s&&n(Oe),$(Ir),$(mo),$(Hr),$(go),$(Vr),s&&n(pp),s&&n(zt),$(Yr),s&&n(up),s&&n(De),$(Kr),$(To),$(na),$(ko),$(ta),s&&n(hp),s&&n(Pt),$(oa),s&&n(fp),s&&n(Ae),$(sa),$(vo),$(pa),$(yo),$(ua),$(ha),s&&n(mp),s&&n(Ct),$(fa),s&&n(gp),s&&n(Ne),$(ma),$(bo),$(va),$($o),$(ya),$(wa),s&&n(_p),s&&n(Lt),$(ba),s&&n(Tp),s&&n(Se),$($a),$(Mo),$(ja),$(zo),$(Ca),s&&n(kp),s&&n(Dt),$(xa),s&&n(Fp),s&&n(Ie),$(La),$(Po),$(Ia),$(jo),$(Ba),$(Wa),s&&n(vp),s&&n(Nt),$(Qa),s&&n(yp),s&&n(Be),$(Ua),$(xo),$(Ga),$(Lo),$(Za),$(Xa)}}}const _2={local:"funnel-transformer",sections:[{local:"overview",title:"Overview"},{local:"transformers.FunnelConfig",title:"FunnelConfig"},{local:"transformers.FunnelTokenizer",title:"FunnelTokenizer"},{local:"transformers.FunnelTokenizerFast",title:"FunnelTokenizerFast"},{local:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput",title:"Funnel specific outputs"},{local:"transformers.FunnelBaseModel",title:"FunnelBaseModel"},{local:"transformers.FunnelModel",title:"FunnelModel"},{local:"transformers.FunnelForPreTraining",title:"FunnelModelForPreTraining"},{local:"transformers.FunnelForMaskedLM",title:"FunnelForMaskedLM"},{local:"transformers.FunnelForSequenceClassification",title:"FunnelForSequenceClassification"},{local:"transformers.FunnelForMultipleChoice",title:"FunnelForMultipleChoice"},{local:"transformers.FunnelForTokenClassification",title:"FunnelForTokenClassification"},{local:"transformers.FunnelForQuestionAnswering",title:"FunnelForQuestionAnswering"},{local:"transformers.TFFunnelBaseModel",title:"TFFunnelBaseModel"},{local:"transformers.TFFunnelModel",title:"TFFunnelModel"},{local:"transformers.TFFunnelForPreTraining",title:"TFFunnelModelForPreTraining"},{local:"transformers.TFFunnelForMaskedLM",title:"TFFunnelForMaskedLM"},{local:"transformers.TFFunnelForSequenceClassification",title:"TFFunnelForSequenceClassification"},{local:"transformers.TFFunnelForMultipleChoice",title:"TFFunnelForMultipleChoice"},{local:"transformers.TFFunnelForTokenClassification",title:"TFFunnelForTokenClassification"},{local:"transformers.TFFunnelForQuestionAnswering",title:"TFFunnelForQuestionAnswering"}],title:"Funnel Transformer"};function T2(V){return R$(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class b2 extends B${constructor(u){super();W$(this,u,T2,g2,Q$,{})}}export{b2 as default,_2 as metadata};
