import{S as Si,i as Ti,s as Ui,e as n,k as c,w as _,t as r,M as ki,c as a,d as o,m as d,a as s,x as v,h as i,b as l,F as e,g as h,y as b,q as y,o as w,B as S,v as $i}from"../../chunks/vendor-6b77c823.js";import{T as yn}from"../../chunks/Tip-39098574.js";import{D as W}from"../../chunks/Docstring-17b815d9.js";import{C as Tt}from"../../chunks/CodeBlock-3a8b25a8.js";import{I as Te}from"../../chunks/IconCopyLink-7a11ce68.js";function Ci(L){let m,k,u,T,U;return{c(){m=n("p"),k=r("Although the recipe for forward pass needs to be defined within this function, one should call the "),u=n("code"),T=r("Module"),U=r(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(f){m=a(f,"P",{});var g=s(m);k=i(g,"Although the recipe for forward pass needs to be defined within this function, one should call the "),u=a(g,"CODE",{});var $=s(u);T=i($,"Module"),$.forEach(o),U=i(g,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),g.forEach(o)},m(f,g){h(f,m,g),e(m,k),e(m,u),e(u,T),e(m,U)},d(f){f&&o(m)}}}function xi(L){let m,k,u,T,U;return{c(){m=n("p"),k=r("Although the recipe for forward pass needs to be defined within this function, one should call the "),u=n("code"),T=r("Module"),U=r(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(f){m=a(f,"P",{});var g=s(m);k=i(g,"Although the recipe for forward pass needs to be defined within this function, one should call the "),u=a(g,"CODE",{});var $=s(u);T=i($,"Module"),$.forEach(o),U=i(g,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),g.forEach(o)},m(f,g){h(f,m,g),e(m,k),e(m,u),e(u,T),e(m,U)},d(f){f&&o(m)}}}function ji(L){let m,k,u,T,U;return{c(){m=n("p"),k=r("Although the recipe for forward pass needs to be defined within this function, one should call the "),u=n("code"),T=r("Module"),U=r(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(f){m=a(f,"P",{});var g=s(m);k=i(g,"Although the recipe for forward pass needs to be defined within this function, one should call the "),u=a(g,"CODE",{});var $=s(u);T=i($,"Module"),$.forEach(o),U=i(g,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),g.forEach(o)},m(f,g){h(f,m,g),e(m,k),e(m,u),e(u,T),e(m,U)},d(f){f&&o(m)}}}function Fi(L){let m,k,u,T,U;return{c(){m=n("p"),k=r("Although the recipe for forward pass needs to be defined within this function, one should call the "),u=n("code"),T=r("Module"),U=r(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(f){m=a(f,"P",{});var g=s(m);k=i(g,"Although the recipe for forward pass needs to be defined within this function, one should call the "),u=a(g,"CODE",{});var $=s(u);T=i($,"Module"),$.forEach(o),U=i(g,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),g.forEach(o)},m(f,g){h(f,m,g),e(m,k),e(m,u),e(u,T),e(m,U)},d(f){f&&o(m)}}}function qi(L){let m,k,u,T,U,f,g,$,wn,$o,R,de,Rt,Ue,Sn,Qt,Tn,Co,pe,Un,ke,kn,$n,xo,Ut,Cn,jo,kt,Xt,xn,Fo,$t,jn,qo,he,$e,Fn,Ct,qn,Pn,En,Ce,Mn,xt,zn,On,Po,N,Dn,xe,An,Wn,je,Ln,Nn,Eo,Q,me,Zt,Fe,Vn,Jt,In,Mo,F,qe,Bn,X,Hn,jt,Kn,Yn,Pe,Rn,Qn,Xn,Z,Zn,Ft,Jn,Gn,qt,ea,ta,oa,Gt,na,aa,Ee,zo,J,ue,eo,Me,sa,to,ra,Oo,G,ze,ia,Oe,la,oo,ca,da,Do,ee,De,pa,Ae,ha,no,ma,ua,Ao,te,fe,ao,We,fa,so,ga,Wo,q,Le,_a,Ne,va,Ve,ba,ya,wa,Ie,Sa,Pt,Ta,Ua,ka,Be,$a,He,Ca,xa,ja,M,Ke,Fa,oe,qa,Et,Pa,Ea,ro,Ma,za,Oa,ge,Da,io,Aa,Wa,Ye,Lo,ne,_e,lo,Re,La,co,Na,No,P,Qe,Va,ae,Ia,po,Ba,Ha,Xe,Ka,Ya,Ra,Ze,Qa,Mt,Xa,Za,Ja,Je,Ga,Ge,es,ts,os,x,et,ns,se,as,zt,ss,rs,ho,is,ls,cs,ve,ds,mo,ps,hs,tt,ms,ot,Vo,re,be,uo,nt,us,fo,fs,Io,C,at,gs,go,_s,vs,st,bs,rt,ys,ws,Ss,it,Ts,Ot,Us,ks,$s,lt,Cs,ct,xs,js,Fs,j,dt,qs,ie,Ps,Dt,Es,Ms,_o,zs,Os,Ds,ye,As,vo,Ws,Ls,pt,Ns,ht,Bo,le,we,bo,mt,Vs,yo,Is,Ho,E,ut,Bs,ft,Hs,gt,Ks,Ys,Rs,_t,Qs,At,Xs,Zs,Js,vt,Gs,bt,er,tr,or,z,yt,nr,ce,ar,Wt,sr,rr,wo,ir,lr,cr,Se,dr,So,pr,hr,wt,Ko;return f=new Te({}),Ue=new Te({}),Fe=new Te({}),qe=new W({props:{name:"class transformers.UniSpeechConfig",anchor:"transformers.UniSpeechConfig",parameters:[{name:"vocab_size",val:" = 32"},{name:"hidden_size",val:" = 768"},{name:"num_hidden_layers",val:" = 12"},{name:"num_attention_heads",val:" = 12"},{name:"intermediate_size",val:" = 3072"},{name:"hidden_act",val:" = 'gelu'"},{name:"hidden_dropout",val:" = 0.1"},{name:"activation_dropout",val:" = 0.1"},{name:"attention_dropout",val:" = 0.1"},{name:"feat_proj_dropout",val:" = 0.0"},{name:"feat_quantizer_dropout",val:" = 0.0"},{name:"final_dropout",val:" = 0.1"},{name:"layerdrop",val:" = 0.1"},{name:"initializer_range",val:" = 0.02"},{name:"layer_norm_eps",val:" = 1e-05"},{name:"feat_extract_norm",val:" = 'group'"},{name:"feat_extract_activation",val:" = 'gelu'"},{name:"conv_dim",val:" = (512, 512, 512, 512, 512, 512, 512)"},{name:"conv_stride",val:" = (5, 2, 2, 2, 2, 2, 2)"},{name:"conv_kernel",val:" = (10, 3, 3, 3, 3, 2, 2)"},{name:"conv_bias",val:" = False"},{name:"num_conv_pos_embeddings",val:" = 128"},{name:"num_conv_pos_embedding_groups",val:" = 16"},{name:"do_stable_layer_norm",val:" = False"},{name:"apply_spec_augment",val:" = True"},{name:"mask_time_prob",val:" = 0.05"},{name:"mask_time_length",val:" = 10"},{name:"mask_time_min_masks",val:" = 2"},{name:"mask_feature_prob",val:" = 0.0"},{name:"mask_feature_length",val:" = 10"},{name:"mask_feature_min_masks",val:" = 0"},{name:"num_codevectors_per_group",val:" = 320"},{name:"num_codevector_groups",val:" = 2"},{name:"contrastive_logits_temperature",val:" = 0.1"},{name:"num_negatives",val:" = 100"},{name:"codevector_dim",val:" = 256"},{name:"proj_codevector_dim",val:" = 256"},{name:"diversity_loss_weight",val:" = 0.1"},{name:"ctc_loss_reduction",val:" = 'mean'"},{name:"ctc_zero_infinity",val:" = False"},{name:"use_weighted_layer_sum",val:" = False"},{name:"classifier_proj_size",val:" = 256"},{name:"num_ctc_classes",val:" = 80"},{name:"pad_token_id",val:" = 0"},{name:"bos_token_id",val:" = 1"},{name:"eos_token_id",val:" = 2"},{name:"replace_prob",val:" = 0.5"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.UniSpeechConfig.vocab_size",description:`<strong>vocab_size</strong> (<code>int</code>, <em>optional</em>, defaults to 32) &#x2014;
Vocabulary size of the UniSpeech model. Defines the number of different tokens that can be represented by
the <code>inputs_ids</code> passed when calling <a href="/docs/transformers/main/en/model_doc/unispeech#transformers.UniSpeechModel">UniSpeechModel</a>. Vocabulary size of the model. Defines the
different tokens that can be represented by the <em>inputs_ids</em> passed to the forward method of
<a href="/docs/transformers/main/en/model_doc/unispeech#transformers.UniSpeechModel">UniSpeechModel</a>.`,name:"vocab_size"},{anchor:"transformers.UniSpeechConfig.hidden_size",description:`<strong>hidden_size</strong> (<code>int</code>, <em>optional</em>, defaults to 768) &#x2014;
Dimensionality of the encoder layers and the pooler layer.`,name:"hidden_size"},{anchor:"transformers.UniSpeechConfig.num_hidden_layers",description:`<strong>num_hidden_layers</strong> (<code>int</code>, <em>optional</em>, defaults to 12) &#x2014;
Number of hidden layers in the Transformer encoder.`,name:"num_hidden_layers"},{anchor:"transformers.UniSpeechConfig.num_attention_heads",description:`<strong>num_attention_heads</strong> (<code>int</code>, <em>optional</em>, defaults to 12) &#x2014;
Number of attention heads for each attention layer in the Transformer encoder.`,name:"num_attention_heads"},{anchor:"transformers.UniSpeechConfig.intermediate_size",description:`<strong>intermediate_size</strong> (<code>int</code>, <em>optional</em>, defaults to 3072) &#x2014;
Dimensionality of the &#x201C;intermediate&#x201D; (i.e., feed-forward) layer in the Transformer encoder.`,name:"intermediate_size"},{anchor:"transformers.UniSpeechConfig.hidden_act",description:`<strong>hidden_act</strong> (<code>str</code> or <code>function</code>, <em>optional</em>, defaults to <code>&quot;gelu&quot;</code>) &#x2014;
The non-linear activation function (function or string) in the encoder and pooler. If string, <code>&quot;gelu&quot;</code>,
<code>&quot;relu&quot;</code>, <code>&quot;selu&quot;</code> and <code>&quot;gelu_new&quot;</code> are supported.`,name:"hidden_act"},{anchor:"transformers.UniSpeechConfig.hidden_dropout",description:`<strong>hidden_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.`,name:"hidden_dropout"},{anchor:"transformers.UniSpeechConfig.attention_dropout",description:`<strong>attention_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The dropout ratio for the attention probabilities.`,name:"attention_dropout"},{anchor:"transformers.UniSpeechConfig.final_dropout",description:`<strong>final_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The dropout probability for the final projection layer of <a href="/docs/transformers/main/en/model_doc/unispeech#transformers.UniSpeechForCTC">UniSpeechForCTC</a>.`,name:"final_dropout"},{anchor:"transformers.UniSpeechConfig.initializer_range",description:`<strong>initializer_range</strong> (<code>float</code>, <em>optional</em>, defaults to 0.02) &#x2014;
The standard deviation of the truncated_normal_initializer for initializing all weight matrices.`,name:"initializer_range"},{anchor:"transformers.UniSpeechConfig.layer_norm_eps",description:`<strong>layer_norm_eps</strong> (<code>float</code>, <em>optional</em>, defaults to 1e-12) &#x2014;
The epsilon used by the layer normalization layers.`,name:"layer_norm_eps"},{anchor:"transformers.UniSpeechConfig.feat_extract_norm",description:`<strong>feat_extract_norm</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;group&quot;</code>) &#x2014;
The norm to be applied to 1D convolutional layers in feature encoder. One of <code>&quot;group&quot;</code> for group
normalization of only the first 1D convolutional layer or <code>&quot;layer&quot;</code> for layer normalization of all 1D
convolutional layers.`,name:"feat_extract_norm"},{anchor:"transformers.UniSpeechConfig.feat_proj_dropout",description:`<strong>feat_proj_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
The dropout probability for output of the feature encoder.`,name:"feat_proj_dropout"},{anchor:"transformers.UniSpeechConfig.feat_extract_activation",description:"<strong>feat_extract_activation</strong> (<code>str, </code>optional<code>, defaults to </code>&#x201C;gelu&#x201D;<code>) -- The non-linear activation function (function or string) in the 1D convolutional layers of the feature extractor. If string, </code>&#x201C;gelu&#x201D;<code>, </code>&#x201C;relu&#x201D;<code>, </code>&#x201C;selu&#x201D;<code>and</code>&#x201C;gelu_new&#x201D;` are supported.",name:"feat_extract_activation"},{anchor:"transformers.UniSpeechConfig.feat_quantizer_dropout",description:`<strong>feat_quantizer_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
The dropout probabilitiy for quantized feature encoder states.`,name:"feat_quantizer_dropout"},{anchor:"transformers.UniSpeechConfig.conv_dim",description:`<strong>conv_dim</strong> (<code>Tuple[int]</code>, <em>optional</em>, defaults to <code>(512, 512, 512, 512, 512, 512, 512)</code>) &#x2014;
A tuple of integers defining the number of input and output channels of each 1D convolutional layer in the
feature encoder. The length of <em>conv_dim</em> defines the number of 1D convolutional layers.`,name:"conv_dim"},{anchor:"transformers.UniSpeechConfig.conv_stride",description:`<strong>conv_stride</strong> (<code>Tuple[int]</code>, <em>optional</em>, defaults to <code>(5, 2, 2, 2, 2, 2, 2)</code>) &#x2014;
A tuple of integers defining the stride of each 1D convolutional layer in the feature encoder. The length
of <em>conv_stride</em> defines the number of convolutional layers and has to match the the length of <em>conv_dim</em>.`,name:"conv_stride"},{anchor:"transformers.UniSpeechConfig.conv_kernel",description:`<strong>conv_kernel</strong> (<code>Tuple[int]</code>, <em>optional</em>, defaults to <code>(10, 3, 3, 3, 3, 3, 3)</code>) &#x2014;
A tuple of integers defining the kernel size of each 1D convolutional layer in the feature encoder. The
length of <em>conv_kernel</em> defines the number of convolutional layers and has to match the the length of
<em>conv_dim</em>.`,name:"conv_kernel"},{anchor:"transformers.UniSpeechConfig.conv_bias",description:`<strong>conv_bias</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the 1D convolutional layers have a bias.`,name:"conv_bias"},{anchor:"transformers.UniSpeechConfig.num_conv_pos_embeddings",description:`<strong>num_conv_pos_embeddings</strong> (<code>int</code>, <em>optional</em>, defaults to 128) &#x2014;
Number of convolutional positional embeddings. Defines the kernel size of 1D convolutional positional
embeddings layer.`,name:"num_conv_pos_embeddings"},{anchor:"transformers.UniSpeechConfig.num_conv_pos_embedding_groups",description:`<strong>num_conv_pos_embedding_groups</strong> (<code>int</code>, <em>optional</em>, defaults to 16) &#x2014;
Number of groups of 1D convolutional positional embeddings layer.`,name:"num_conv_pos_embedding_groups"},{anchor:"transformers.UniSpeechConfig.do_stable_layer_norm",description:`<strong>do_stable_layer_norm</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to apply <em>stable</em> layer norm architecture of the Transformer encoder. <code>do_stable_layer_norm is True</code> corresponds to applying layer norm before the attention layer, whereas <code>do_stable_layer_norm is False</code> corresponds to applying layer norm after the attention layer.`,name:"do_stable_layer_norm"},{anchor:"transformers.UniSpeechConfig.apply_spec_augment",description:`<strong>apply_spec_augment</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to apply <em>SpecAugment</em> data augmentation to the outputs of the feature encoder. For reference see
<a href="https://arxiv.org/abs/1904.08779" rel="nofollow">SpecAugment: A Simple Data Augmentation Method for Automatic Speech
Recognition</a>.`,name:"apply_spec_augment"},{anchor:"transformers.UniSpeechConfig.mask_time_prob",description:`<strong>mask_time_prob</strong> (<code>float</code>, <em>optional</em>, defaults to 0.05) &#x2014;
Percentage (between 0 and 1) of all feature vectors along the time axis which will be masked. The masking
procecure generates &#x201D;mask_time_prob<em>len(time_axis)/mask_time_length&#x201D; independent masks over the axis. If
reasoning from the propability of each feature vector to be chosen as the start of the vector span to be
masked, </em>mask_time_prob<em> should be \`prob_vector_start</em>mask_time_length<code>. Note that overlap may decrease the actual percentage of masked vectors. This is only relevant if </code>apply_spec_augment is True\`.`,name:"mask_time_prob"},{anchor:"transformers.UniSpeechConfig.mask_time_length",description:`<strong>mask_time_length</strong> (<code>int</code>, <em>optional</em>, defaults to 10) &#x2014;
Length of vector span along the time axis.`,name:"mask_time_length"},{anchor:"transformers.UniSpeechConfig.mask_time_min_masks",description:`<strong>mask_time_min_masks</strong> (<code>int</code>, <em>optional</em>, defaults to 2), &#x2014;
The minimum number of masks of length <code>mask_feature_length</code> generated along the time axis, each time step,
irrespectively of <code>mask_feature_prob</code>. Only relevant if &#x201D;mask_time_prob*len(time_axis)/mask_time_length &lt;
mask_time_min_masks&#x201D;`,name:"mask_time_min_masks"},{anchor:"transformers.UniSpeechConfig.mask_feature_prob",description:`<strong>mask_feature_prob</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
Percentage (between 0 and 1) of all feature vectors along the feature axis which will be masked. The
masking procecure generates &#x201D;mask_feature_prob<em>len(feature_axis)/mask_time_length&#x201D; independent masks over
the axis. If reasoning from the propability of each feature vector to be chosen as the start of the vector
span to be masked, </em>mask_feature_prob<em> should be \`prob_vector_start</em>mask_feature_length<code>. Note that overlap may decrease the actual percentage of masked vectors. This is only relevant if </code>apply_spec_augment is
True\`.`,name:"mask_feature_prob"},{anchor:"transformers.UniSpeechConfig.mask_feature_length",description:`<strong>mask_feature_length</strong> (<code>int</code>, <em>optional</em>, defaults to 10) &#x2014;
Length of vector span along the feature axis.`,name:"mask_feature_length"},{anchor:"transformers.UniSpeechConfig.mask_feature_min_masks",description:`<strong>mask_feature_min_masks</strong> (<code>int</code>, <em>optional</em>, defaults to 0), &#x2014;
The minimum number of masks of length <code>mask_feature_length</code> generated along the feature axis, each time
step, irrespectively of <code>mask_feature_prob</code>. Only relevant if
&#x201D;mask_feature_prob*len(feature_axis)/mask_feature_length &lt; mask_feature_min_masks&#x201D;`,name:"mask_feature_min_masks"},{anchor:"transformers.UniSpeechConfig.num_codevectors_per_group",description:`<strong>num_codevectors_per_group</strong> (<code>int</code>, <em>optional</em>, defaults to 320) &#x2014;
Number of entries in each quantization codebook (group).`,name:"num_codevectors_per_group"},{anchor:"transformers.UniSpeechConfig.num_codevector_groups",description:`<strong>num_codevector_groups</strong> (<code>int</code>, <em>optional</em>, defaults to 2) &#x2014;
Number of codevector groups for product codevector quantization.`,name:"num_codevector_groups"},{anchor:"transformers.UniSpeechConfig.contrastive_logits_temperature",description:`<strong>contrastive_logits_temperature</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The temperature <em>kappa</em> in the contrastive loss.`,name:"contrastive_logits_temperature"},{anchor:"transformers.UniSpeechConfig.feat_quantizer_dropout",description:`<strong>feat_quantizer_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
The dropout probabilitiy for the output of the feature encoder that&#x2019;s used by the quantizer.`,name:"feat_quantizer_dropout"},{anchor:"transformers.UniSpeechConfig.num_negatives",description:`<strong>num_negatives</strong> (<code>int</code>, <em>optional</em>, defaults to 100) &#x2014;
Number of negative samples for the contrastive loss.`,name:"num_negatives"},{anchor:"transformers.UniSpeechConfig.codevector_dim",description:`<strong>codevector_dim</strong> (<code>int</code>, <em>optional</em>, defaults to 256) &#x2014;
Dimensionality of the quantized feature vectors.`,name:"codevector_dim"},{anchor:"transformers.UniSpeechConfig.proj_codevector_dim",description:`<strong>proj_codevector_dim</strong> (<code>int</code>, <em>optional</em>, defaults to 256) &#x2014;
Dimensionality of the final projection of both the quantized and the transformer features.`,name:"proj_codevector_dim"},{anchor:"transformers.UniSpeechConfig.diversity_loss_weight",description:`<strong>diversity_loss_weight</strong> (<code>int</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The weight of the codebook diversity loss component.`,name:"diversity_loss_weight"},{anchor:"transformers.UniSpeechConfig.ctc_loss_reduction",description:`<strong>ctc_loss_reduction</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;mean&quot;</code>) &#x2014;
Specifies the reduction to apply to the output of <code>torch.nn.CTCLoss</code>. Only relevant when training an
instance of <a href="/docs/transformers/main/en/model_doc/unispeech#transformers.UniSpeechForCTC">UniSpeechForCTC</a>.`,name:"ctc_loss_reduction"},{anchor:"transformers.UniSpeechConfig.ctc_zero_infinity",description:`<strong>ctc_zero_infinity</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to zero infinite losses and the associated gradients of <code>torch.nn.CTCLoss</code>. Infinite losses mainly
occur when the inputs are too short to be aligned to the targets. Only relevant when training an instance
of <a href="/docs/transformers/main/en/model_doc/unispeech#transformers.UniSpeechForCTC">UniSpeechForCTC</a>.`,name:"ctc_zero_infinity"},{anchor:"transformers.UniSpeechConfig.use_weighted_layer_sum",description:`<strong>use_weighted_layer_sum</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to use a weighted average of layer outputs with learned weights. Only relevant when using an
instance of <a href="/docs/transformers/main/en/model_doc/unispeech#transformers.UniSpeechForSequenceClassification">UniSpeechForSequenceClassification</a>.`,name:"use_weighted_layer_sum"},{anchor:"transformers.UniSpeechConfig.classifier_proj_size",description:`<strong>classifier_proj_size</strong> (<code>int</code>, <em>optional</em>, defaults to 256) &#x2014;
Dimensionality of the projection before token mean-pooling for classification.`,name:"classifier_proj_size"},{anchor:"transformers.UniSpeechConfig.replace_prob",description:`<strong>replace_prob</strong> (<code>float</code>, <em>optional</em>, defaults to 0.5) &#x2014;
Propability that transformer feature is replaced by quantized feature for pretraining.`,name:"replace_prob"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/unispeech/configuration_unispeech.py#L32"}}),Ee=new Tt({props:{code:`from transformers import UniSpeechModel, UniSpeechConfig

# Initializing a UniSpeech facebook/unispeech-base-960h style configuration
configuration = UniSpeechConfig()

# Initializing a model from the facebook/unispeech-base-960h style configuration
model = UniSpeechModel(configuration)

# Accessing the model configuration
configuration = model.config`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> UniSpeechModel, UniSpeechConfig

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a UniSpeech facebook/unispeech-base-960h style configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = UniSpeechConfig()

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a model from the facebook/unispeech-base-960h style configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = UniSpeechModel(configuration)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Accessing the model configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = model.config`}}),Me=new Te({}),ze=new W({props:{name:"class transformers.models.unispeech.modeling_unispeech.UniSpeechBaseModelOutput",anchor:"transformers.models.unispeech.modeling_unispeech.UniSpeechBaseModelOutput",parameters:[{name:"last_hidden_state",val:": FloatTensor = None"},{name:"extract_features",val:": FloatTensor = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"attentions",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"}],parametersDescription:[{anchor:"transformers.models.unispeech.modeling_unispeech.UniSpeechBaseModelOutput.last_hidden_state",description:`<strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) &#x2014;
Sequence of hidden-states at the output of the last layer of the model.`,name:"last_hidden_state"},{anchor:"transformers.models.unispeech.modeling_unispeech.UniSpeechBaseModelOutput.extract_features",description:`<strong>extract_features</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, conv_dim[-1])</code>) &#x2014;
Sequence of extracted feature vectors of the last convolutional layer of the model.`,name:"extract_features"},{anchor:"transformers.models.unispeech.modeling_unispeech.UniSpeechBaseModelOutput.hidden_states",description:`<strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.`,name:"hidden_states"},{anchor:"transformers.models.unispeech.modeling_unispeech.UniSpeechBaseModelOutput.attentions",description:`<strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.`,name:"attentions"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/unispeech/modeling_unispeech.py#L75"}}),De=new W({props:{name:"class transformers.models.unispeech.modeling_unispeech.UniSpeechForPreTrainingOutput",anchor:"transformers.models.unispeech.modeling_unispeech.UniSpeechForPreTrainingOutput",parameters:[{name:"loss",val:": typing.Optional[torch.FloatTensor] = None"},{name:"projected_states",val:": FloatTensor = None"},{name:"projected_quantized_states",val:": FloatTensor = None"},{name:"codevector_perplexity",val:": FloatTensor = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"attentions",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"}],parametersDescription:[{anchor:"transformers.models.unispeech.modeling_unispeech.UniSpeechForPreTrainingOutput.loss",description:`<strong>loss</strong> (<em>optional</em>, returned when model is in train mode, <code>torch.FloatTensor</code> of shape <code>(1,)</code>) &#x2014;
Total loss as the sum of the contrastive loss (L_m) and the diversity loss (L_d) as stated in the <a href="https://arxiv.org/pdf/2006.11477.pdf" rel="nofollow">official
paper</a> . (classification) loss.`,name:"loss"},{anchor:"transformers.models.unispeech.modeling_unispeech.UniSpeechForPreTrainingOutput.projected_states",description:`<strong>projected_states</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, config.proj_codevector_dim)</code>) &#x2014;
Hidden-states of the model projected to <em>config.proj_codevector_dim</em> that can be used to predict the masked
projected quantized states.`,name:"projected_states"},{anchor:"transformers.models.unispeech.modeling_unispeech.UniSpeechForPreTrainingOutput.projected_quantized_states",description:`<strong>projected_quantized_states</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, config.proj_codevector_dim)</code>) &#x2014;
Quantized extracted feature vectors projected to <em>config.proj_codevector_dim</em> representing the positive
target vectors for contrastive loss.`,name:"projected_quantized_states"},{anchor:"transformers.models.unispeech.modeling_unispeech.UniSpeechForPreTrainingOutput.hidden_states",description:`<strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.`,name:"hidden_states"},{anchor:"transformers.models.unispeech.modeling_unispeech.UniSpeechForPreTrainingOutput.attentions",description:`<strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.`,name:"attentions"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/unispeech/modeling_unispeech.py#L104"}}),We=new Te({}),Le=new W({props:{name:"class transformers.UniSpeechModel",anchor:"transformers.UniSpeechModel",parameters:[{name:"config",val:": UniSpeechConfig"}],parametersDescription:[{anchor:"transformers.UniSpeechModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/unispeech#transformers.UniSpeechConfig">UniSpeechConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/unispeech/modeling_unispeech.py#L1088"}}),Ke=new W({props:{name:"forward",anchor:"transformers.UniSpeechModel.forward",parameters:[{name:"input_values",val:": typing.Optional[torch.Tensor]"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"mask_time_indices",val:": typing.Optional[torch.FloatTensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.UniSpeechModel.forward.input_values",description:`<strong>input_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Float values of input raw speech waveform. Values can be obtained by loading a <em>.flac</em> or <em>.wav</em> audio file
into an array of type <em>List[float]</em> or a <em>numpy.ndarray</em>, <em>e.g.</em> via the soundfile library (<em>pip install
soundfile</em>). To prepare the array into <em>input_values</em>, the <code>UniSpeechProcessor</code> should be used for
padding and conversion into a tensor of type <em>torch.FloatTensor</em>. See <code>UniSpeechProcessor.__call__</code> for
details.`,name:"input_values"},{anchor:"transformers.UniSpeechModel.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing convolution and attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a></p>
<div class="course-tip course-tip-orange bg-gradient-to-br dark:bg-gradient-to-r before:border-orange-500 dark:before:border-orange-800 from-orange-50 dark:from-gray-900 to-white dark:to-gray-950 border border-orange-50 text-orange-700 dark:text-gray-400">
						
<p><code>attention_mask</code> should only be passed if the corresponding processor has <code>config.return_attention_mask == True</code>. For all models whose processor has <code>config.return_attention_mask == False</code>, <code>attention_mask</code> should
<strong>not</strong> be passed to avoid degraded performance when doing batched inference. For such models
<code>input_values</code> should simply be padded with 0 and passed without <code>attention_mask</code>. Be aware that these
models also yield slightly different results depending on whether <code>input_values</code> is padded or not.</p>

					</div>`,name:"attention_mask"},{anchor:"transformers.UniSpeechModel.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.UniSpeechModel.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.UniSpeechModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/unispeech/modeling_unispeech.py#L1153",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/model_doc/unispeech#transformers.models.unispeech.modeling_unispeech.UniSpeechBaseModelOutput"
>transformers.models.unispeech.modeling_unispeech.UniSpeechBaseModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/unispeech#transformers.UniSpeechConfig"
>UniSpeechConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>extract_features</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, conv_dim[-1])</code>) \u2014 Sequence of extracted feature vectors of the last convolutional layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/model_doc/unispeech#transformers.models.unispeech.modeling_unispeech.UniSpeechBaseModelOutput"
>transformers.models.unispeech.modeling_unispeech.UniSpeechBaseModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),ge=new yn({props:{$$slots:{default:[Ci]},$$scope:{ctx:L}}}),Ye=new Tt({props:{code:`from transformers import Wav2Vec2Processor, UniSpeechModel
import torch
from datasets import load_dataset

dataset = load_dataset("hf-internal-testing/librispeech_asr_demo", "clean", split="validation")
dataset = dataset.sort("id")
sampling_rate = dataset.features["audio"].sampling_rate

processor = Wav2Vec2Processor.from_pretrained("patrickvonplaten/unispeech-large-1500h-cv-timit")
model = UniSpeechModel.from_pretrained("patrickvonplaten/unispeech-large-1500h-cv-timit")

# audio file is decoded on the fly
inputs = processor(dataset[0]["audio"]["array"], sampling_rate=sampling_rate, return_tensors="pt")
with torch.no_grad():
    outputs = model(**inputs)

last_hidden_states = outputs.last_hidden_state
list(last_hidden_states.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Wav2Vec2Processor, UniSpeechModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&quot;hf-internal-testing/librispeech_asr_demo&quot;</span>, <span class="hljs-string">&quot;clean&quot;</span>, split=<span class="hljs-string">&quot;validation&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = dataset.sort(<span class="hljs-string">&quot;id&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>sampling_rate = dataset.features[<span class="hljs-string">&quot;audio&quot;</span>].sampling_rate

<span class="hljs-meta">&gt;&gt;&gt; </span>processor = Wav2Vec2Processor.from_pretrained(<span class="hljs-string">&quot;patrickvonplaten/unispeech-large-1500h-cv-timit&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = UniSpeechModel.from_pretrained(<span class="hljs-string">&quot;patrickvonplaten/unispeech-large-1500h-cv-timit&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># audio file is decoded on the fly</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = processor(dataset[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;audio&quot;</span>][<span class="hljs-string">&quot;array&quot;</span>], sampling_rate=sampling_rate, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(last_hidden_states.shape)
[<span class="hljs-number">1</span>, <span class="hljs-number">292</span>, <span class="hljs-number">1024</span>]`}}),Re=new Te({}),Qe=new W({props:{name:"class transformers.UniSpeechForCTC",anchor:"transformers.UniSpeechForCTC",parameters:[{name:"config",val:""}],parametersDescription:[{anchor:"transformers.UniSpeechForCTC.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/unispeech#transformers.UniSpeechConfig">UniSpeechConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/unispeech/modeling_unispeech.py#L1364"}}),et=new W({props:{name:"forward",anchor:"transformers.UniSpeechForCTC.forward",parameters:[{name:"input_values",val:": typing.Optional[torch.Tensor]"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"}],parametersDescription:[{anchor:"transformers.UniSpeechForCTC.forward.input_values",description:`<strong>input_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Float values of input raw speech waveform. Values can be obtained by loading a <em>.flac</em> or <em>.wav</em> audio file
into an array of type <em>List[float]</em> or a <em>numpy.ndarray</em>, <em>e.g.</em> via the soundfile library (<em>pip install
soundfile</em>). To prepare the array into <em>input_values</em>, the <code>UniSpeechProcessor</code> should be used for
padding and conversion into a tensor of type <em>torch.FloatTensor</em>. See <code>UniSpeechProcessor.__call__</code> for
details.`,name:"input_values"},{anchor:"transformers.UniSpeechForCTC.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing convolution and attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a></p>
<div class="course-tip course-tip-orange bg-gradient-to-br dark:bg-gradient-to-r before:border-orange-500 dark:before:border-orange-800 from-orange-50 dark:from-gray-900 to-white dark:to-gray-950 border border-orange-50 text-orange-700 dark:text-gray-400">
						
<p><code>attention_mask</code> should only be passed if the corresponding processor has <code>config.return_attention_mask == True</code>. For all models whose processor has <code>config.return_attention_mask == False</code>, <code>attention_mask</code> should
<strong>not</strong> be passed to avoid degraded performance when doing batched inference. For such models
<code>input_values</code> should simply be padded with 0 and passed without <code>attention_mask</code>. Be aware that these
models also yield slightly different results depending on whether <code>input_values</code> is padded or not.</p>

					</div>`,name:"attention_mask"},{anchor:"transformers.UniSpeechForCTC.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.UniSpeechForCTC.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.UniSpeechForCTC.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.UniSpeechForCTC.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, target_length)</code>, <em>optional</em>) &#x2014;
Labels for connectionist temporal classification. Note that <code>target_length</code> has to be smaller or equal to
the sequence length of the output logits. Indices are selected in <code>[-100, 0, ..., config.vocab_size - 1]</code>.
All labels set to <code>-100</code> are ignored (masked), the loss is only computed for labels in <code>[0, ..., config.vocab_size - 1]</code>.`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/unispeech/modeling_unispeech.py#L1405",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.CausalLMOutput"
>transformers.modeling_outputs.CausalLMOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/unispeech#transformers.UniSpeechConfig"
>UniSpeechConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Language modeling loss (for next-token prediction).</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, config.vocab_size)</code>) \u2014 Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.CausalLMOutput"
>transformers.modeling_outputs.CausalLMOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),ve=new yn({props:{$$slots:{default:[xi]},$$scope:{ctx:L}}}),tt=new Tt({props:{code:`from transformers import Wav2Vec2Processor, UniSpeechForCTC
from datasets import load_dataset
import torch

dataset = load_dataset("hf-internal-testing/librispeech_asr_demo", "clean", split="validation")
dataset = dataset.sort("id")
sampling_rate = dataset.features["audio"].sampling_rate

processor = Wav2Vec2Processor.from_pretrained("patrickvonplaten/unispeech-large-1500h-cv-timit")
model = UniSpeechForCTC.from_pretrained("patrickvonplaten/unispeech-large-1500h-cv-timit")

# audio file is decoded on the fly
inputs = processor(dataset[0]["audio"]["array"], sampling_rate=sampling_rate, return_tensors="pt")
with torch.no_grad():
    logits = model(**inputs).logits
predicted_ids = torch.argmax(logits, dim=-1)

# transcribe speech
transcription = processor.batch_decode(predicted_ids)
transcription[0]`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Wav2Vec2Processor, UniSpeechForCTC
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&quot;hf-internal-testing/librispeech_asr_demo&quot;</span>, <span class="hljs-string">&quot;clean&quot;</span>, split=<span class="hljs-string">&quot;validation&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = dataset.sort(<span class="hljs-string">&quot;id&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>sampling_rate = dataset.features[<span class="hljs-string">&quot;audio&quot;</span>].sampling_rate

<span class="hljs-meta">&gt;&gt;&gt; </span>processor = Wav2Vec2Processor.from_pretrained(<span class="hljs-string">&quot;patrickvonplaten/unispeech-large-1500h-cv-timit&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = UniSpeechForCTC.from_pretrained(<span class="hljs-string">&quot;patrickvonplaten/unispeech-large-1500h-cv-timit&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># audio file is decoded on the fly</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = processor(dataset[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;audio&quot;</span>][<span class="hljs-string">&quot;array&quot;</span>], sampling_rate=sampling_rate, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_ids = torch.argmax(logits, dim=-<span class="hljs-number">1</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># transcribe speech</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>transcription = processor.batch_decode(predicted_ids)
<span class="hljs-meta">&gt;&gt;&gt; </span>transcription[<span class="hljs-number">0</span>]
<span class="hljs-string">&#x27;mister quilter is the apposl of the midle classes and weare glad to welcom his gosepl&#x27;</span>`}}),ot=new Tt({props:{code:`with processor.as_target_processor():
    inputs["labels"] = processor(dataset[0]["text"], return_tensors="pt").input_ids

# compute loss
loss = model(**inputs).loss
round(loss.item(), 2)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> processor.as_target_processor():
<span class="hljs-meta">... </span>    inputs[<span class="hljs-string">&quot;labels&quot;</span>] = processor(dataset[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;text&quot;</span>], return_tensors=<span class="hljs-string">&quot;pt&quot;</span>).input_ids

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># compute loss</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = model(**inputs).loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(loss.item(), <span class="hljs-number">2</span>)
<span class="hljs-number">17.17</span>`}}),nt=new Te({}),at=new W({props:{name:"class transformers.UniSpeechForSequenceClassification",anchor:"transformers.UniSpeechForSequenceClassification",parameters:[{name:"config",val:""}],parametersDescription:[{anchor:"transformers.UniSpeechForSequenceClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/unispeech#transformers.UniSpeechConfig">UniSpeechConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/unispeech/modeling_unispeech.py#L1495"}}),dt=new W({props:{name:"forward",anchor:"transformers.UniSpeechForSequenceClassification.forward",parameters:[{name:"input_values",val:": typing.Optional[torch.Tensor]"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"}],parametersDescription:[{anchor:"transformers.UniSpeechForSequenceClassification.forward.input_values",description:`<strong>input_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Float values of input raw speech waveform. Values can be obtained by loading a <em>.flac</em> or <em>.wav</em> audio file
into an array of type <em>List[float]</em> or a <em>numpy.ndarray</em>, <em>e.g.</em> via the soundfile library (<em>pip install
soundfile</em>). To prepare the array into <em>input_values</em>, the <code>UniSpeechProcessor</code> should be used for
padding and conversion into a tensor of type <em>torch.FloatTensor</em>. See <code>UniSpeechProcessor.__call__</code> for
details.`,name:"input_values"},{anchor:"transformers.UniSpeechForSequenceClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing convolution and attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a></p>
<div class="course-tip course-tip-orange bg-gradient-to-br dark:bg-gradient-to-r before:border-orange-500 dark:before:border-orange-800 from-orange-50 dark:from-gray-900 to-white dark:to-gray-950 border border-orange-50 text-orange-700 dark:text-gray-400">
						
<p><code>attention_mask</code> should only be passed if the corresponding processor has <code>config.return_attention_mask == True</code>. For all models whose processor has <code>config.return_attention_mask == False</code>, <code>attention_mask</code> should
<strong>not</strong> be passed to avoid degraded performance when doing batched inference. For such models
<code>input_values</code> should simply be padded with 0 and passed without <code>attention_mask</code>. Be aware that these
models also yield slightly different results depending on whether <code>input_values</code> is padded or not.</p>

					</div>`,name:"attention_mask"},{anchor:"transformers.UniSpeechForSequenceClassification.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.UniSpeechForSequenceClassification.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.UniSpeechForSequenceClassification.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.UniSpeechForSequenceClassification.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the sequence classification/regression loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>. If <code>config.num_labels == 1</code> a regression loss is computed (Mean-Square loss), If
<code>config.num_labels &gt; 1</code> a classification loss is computed (Cross-Entropy).`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/unispeech/modeling_unispeech.py#L1540",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.SequenceClassifierOutput"
>transformers.modeling_outputs.SequenceClassifierOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/unispeech#transformers.UniSpeechConfig"
>UniSpeechConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification (or regression if config.num_labels==1) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.num_labels)</code>) \u2014 Classification (or regression if config.num_labels==1) scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.SequenceClassifierOutput"
>transformers.modeling_outputs.SequenceClassifierOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),ye=new yn({props:{$$slots:{default:[ji]},$$scope:{ctx:L}}}),pt=new Tt({props:{code:`from transformers import Wav2Vec2FeatureExtractor, UniSpeechForSequenceClassification
from datasets import load_dataset
import torch

dataset = load_dataset("hf-internal-testing/librispeech_asr_demo", "clean", split="validation")
dataset = dataset.sort("id")
sampling_rate = dataset.features["audio"].sampling_rate

feature_extractor = Wav2Vec2FeatureExtractor.from_pretrained("hf-internal-testing/tiny-random-unispeech")
model = UniSpeechForSequenceClassification.from_pretrained("hf-internal-testing/tiny-random-unispeech")

# audio file is decoded on the fly
inputs = feature_extractor(dataset[0]["audio"]["array"], sampling_rate=sampling_rate, return_tensors="pt")

with torch.no_grad():
    logits = model(**inputs).logits

predicted_class_ids = torch.argmax(logits, dim=-1).item()
predicted_label = model.config.id2label[predicted_class_ids]
predicted_label`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Wav2Vec2FeatureExtractor, UniSpeechForSequenceClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&quot;hf-internal-testing/librispeech_asr_demo&quot;</span>, <span class="hljs-string">&quot;clean&quot;</span>, split=<span class="hljs-string">&quot;validation&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = dataset.sort(<span class="hljs-string">&quot;id&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>sampling_rate = dataset.features[<span class="hljs-string">&quot;audio&quot;</span>].sampling_rate

<span class="hljs-meta">&gt;&gt;&gt; </span>feature_extractor = Wav2Vec2FeatureExtractor.from_pretrained(<span class="hljs-string">&quot;hf-internal-testing/tiny-random-unispeech&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = UniSpeechForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;hf-internal-testing/tiny-random-unispeech&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># audio file is decoded on the fly</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = feature_extractor(dataset[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;audio&quot;</span>][<span class="hljs-string">&quot;array&quot;</span>], sampling_rate=sampling_rate, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_class_ids = torch.argmax(logits, dim=-<span class="hljs-number">1</span>).item()
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_label = model.config.id2label[predicted_class_ids]
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_label
<span class="hljs-string">&#x27;LABEL_0&#x27;</span>`}}),ht=new Tt({props:{code:`# compute loss - target_label is e.g. "down"
target_label = model.config.id2label[0]
inputs["labels"] = torch.tensor([model.config.label2id[target_label]])
loss = model(**inputs).loss
round(loss.item(), 2)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># compute loss - target_label is e.g. &quot;down&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>target_label = model.config.id2label[<span class="hljs-number">0</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs[<span class="hljs-string">&quot;labels&quot;</span>] = torch.tensor([model.config.label2id[target_label]])
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = model(**inputs).loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(loss.item(), <span class="hljs-number">2</span>)
<span class="hljs-number">0.66</span>`}}),mt=new Te({}),ut=new W({props:{name:"class transformers.UniSpeechForPreTraining",anchor:"transformers.UniSpeechForPreTraining",parameters:[{name:"config",val:": UniSpeechConfig"}],parametersDescription:[{anchor:"transformers.UniSpeechForPreTraining.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/unispeech#transformers.UniSpeechConfig">UniSpeechConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/unispeech/modeling_unispeech.py#L1213"}}),yt=new W({props:{name:"forward",anchor:"transformers.UniSpeechForPreTraining.forward",parameters:[{name:"input_values",val:": typing.Optional[torch.Tensor]"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.UniSpeechForPreTraining.forward.input_values",description:`<strong>input_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Float values of input raw speech waveform. Values can be obtained by loading a <em>.flac</em> or <em>.wav</em> audio file
into an array of type <em>List[float]</em> or a <em>numpy.ndarray</em>, <em>e.g.</em> via the soundfile library (<em>pip install
soundfile</em>). To prepare the array into <em>input_values</em>, the <code>UniSpeechProcessor</code> should be used for
padding and conversion into a tensor of type <em>torch.FloatTensor</em>. See <code>UniSpeechProcessor.__call__</code> for
details.`,name:"input_values"},{anchor:"transformers.UniSpeechForPreTraining.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing convolution and attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a></p>
<div class="course-tip course-tip-orange bg-gradient-to-br dark:bg-gradient-to-r before:border-orange-500 dark:before:border-orange-800 from-orange-50 dark:from-gray-900 to-white dark:to-gray-950 border border-orange-50 text-orange-700 dark:text-gray-400">
						
<p><code>attention_mask</code> should only be passed if the corresponding processor has <code>config.return_attention_mask == True</code>. For all models whose processor has <code>config.return_attention_mask == False</code>, <code>attention_mask</code> should
<strong>not</strong> be passed to avoid degraded performance when doing batched inference. For such models
<code>input_values</code> should simply be padded with 0 and passed without <code>attention_mask</code>. Be aware that these
models also yield slightly different results depending on whether <code>input_values</code> is padded or not.</p>

					</div>`,name:"attention_mask"},{anchor:"transformers.UniSpeechForPreTraining.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.UniSpeechForPreTraining.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.UniSpeechForPreTraining.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.UniSpeechForPreTraining.forward.mask_time_indices",description:`<strong>mask_time_indices</strong> (<code>torch.BoolTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Indices to mask extracted features for contrastive loss. When in training mode, model learns to predict
masked extracted features in <em>config.proj_codevector_dim</em> space.`,name:"mask_time_indices"},{anchor:"transformers.UniSpeechForPreTraining.forward.sampled_negative_indices",description:`<strong>sampled_negative_indices</strong> (<code>torch.BoolTensor</code> of shape <code>(batch_size, sequence_length, num_negatives)</code>, <em>optional</em>) &#x2014;
Indices indicating which quantized target vectors are used as negative sampled vectors in contrastive loss.
Required input for pre-training.`,name:"sampled_negative_indices"}],source:"https://github.com/huggingface/transformers/blob/main/src/transformers/models/unispeech/modeling_unispeech.py#L1274",returnDescription:`
<p>A <a
  href="/docs/transformers/main/en/model_doc/unispeech#transformers.models.unispeech.modeling_unispeech.UniSpeechForPreTrainingOutput"
>transformers.models.unispeech.modeling_unispeech.UniSpeechForPreTrainingOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/unispeech#transformers.UniSpeechConfig"
>UniSpeechConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<em>optional</em>, returned when model is in train mode, <code>torch.FloatTensor</code> of shape <code>(1,)</code>) \u2014 Total loss as the sum of the contrastive loss (L_m) and the diversity loss (L_d) as stated in the <a
  href="https://arxiv.org/pdf/2006.11477.pdf"
  rel="nofollow"
>official
paper</a> . (classification) loss.</p>
</li>
<li>
<p><strong>projected_states</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, config.proj_codevector_dim)</code>) \u2014 Hidden-states of the model projected to <em>config.proj_codevector_dim</em> that can be used to predict the masked
projected quantized states.</p>
</li>
<li>
<p><strong>projected_quantized_states</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, config.proj_codevector_dim)</code>) \u2014 Quantized extracted feature vectors projected to <em>config.proj_codevector_dim</em> representing the positive
target vectors for contrastive loss.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/main/en/model_doc/unispeech#transformers.models.unispeech.modeling_unispeech.UniSpeechForPreTrainingOutput"
>transformers.models.unispeech.modeling_unispeech.UniSpeechForPreTrainingOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Se=new yn({props:{$$slots:{default:[Fi]},$$scope:{ctx:L}}}),wt=new Tt({props:{code:`import torch
from transformers import Wav2Vec2FeatureExtractor, UniSpeechForPreTraining
from transformers.models.unispeech.modeling_unispeech import _compute_mask_indices

feature_extractor = Wav2Vec2FeatureExtractor.from_pretrained(
    "hf-internal-testing/tiny-random-unispeech-sat"
)
model = UniSpeechForPreTraining.from_pretrained("microsoft/unispeech-large-1500h-cv")
# TODO: Add full pretraining example`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Wav2Vec2FeatureExtractor, UniSpeechForPreTraining
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.models.unispeech.modeling_unispeech <span class="hljs-keyword">import</span> _compute_mask_indices

<span class="hljs-meta">&gt;&gt;&gt; </span>feature_extractor = Wav2Vec2FeatureExtractor.from_pretrained(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;hf-internal-testing/tiny-random-unispeech-sat&quot;</span>
<span class="hljs-meta">... </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = UniSpeechForPreTraining.from_pretrained(<span class="hljs-string">&quot;microsoft/unispeech-large-1500h-cv&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> Add full pretraining example</span>`}}),{c(){m=n("meta"),k=c(),u=n("h1"),T=n("a"),U=n("span"),_(f.$$.fragment),g=c(),$=n("span"),wn=r("UniSpeech"),$o=c(),R=n("h2"),de=n("a"),Rt=n("span"),_(Ue.$$.fragment),Sn=c(),Qt=n("span"),Tn=r("Overview"),Co=c(),pe=n("p"),Un=r("The UniSpeech model was proposed in "),ke=n("a"),kn=r("UniSpeech: Unified Speech Representation Learning with Labeled and Unlabeled Data"),$n=r(` by Chengyi Wang, Yu Wu, Yao Qian, Kenichi Kumatani, Shujie Liu, Furu Wei, Michael
Zeng, Xuedong Huang .`),xo=c(),Ut=n("p"),Cn=r("The abstract from the paper is the following:"),jo=c(),kt=n("p"),Xt=n("em"),xn=r(`In this paper, we propose a unified pre-training approach called UniSpeech to learn speech representations with both
unlabeled and labeled data, in which supervised phonetic CTC learning and phonetically-aware contrastive
self-supervised learning are conducted in a multi-task learning manner. The resultant representations can capture
information more correlated with phonetic structures and improve the generalization across languages and domains. We
evaluate the effectiveness of UniSpeech for cross-lingual representation learning on public CommonVoice corpus. The
results show that UniSpeech outperforms self-supervised pretraining and supervised transfer learning for speech
recognition by a maximum of 13.4% and 17.8% relative phone error rate reductions respectively (averaged over all
testing languages). The transferability of UniSpeech is also demonstrated on a domain-shift speech recognition task,
i.e., a relative word error rate reduction of 6% against the previous approach.`),Fo=c(),$t=n("p"),jn=r("Tips:"),qo=c(),he=n("ul"),$e=n("li"),Fn=r(`UniSpeech is a speech model that accepts a float array corresponding to the raw waveform of the speech signal. Please
use `),Ct=n("a"),qn=r("Wav2Vec2Processor"),Pn=r(" for the feature extraction."),En=c(),Ce=n("li"),Mn=r(`UniSpeech model can be fine-tuned using connectionist temporal classification (CTC) so the model output has to be
decoded using `),xt=n("a"),zn=r("Wav2Vec2CTCTokenizer"),On=r("."),Po=c(),N=n("p"),Dn=r("This model was contributed by "),xe=n("a"),An=r("patrickvonplaten"),Wn=r(`. The Authors\u2019 code can be
found `),je=n("a"),Ln=r("here"),Nn=r("."),Eo=c(),Q=n("h2"),me=n("a"),Zt=n("span"),_(Fe.$$.fragment),Vn=c(),Jt=n("span"),In=r("UniSpeechConfig"),Mo=c(),F=n("div"),_(qe.$$.fragment),Bn=c(),X=n("p"),Hn=r("This is the configuration class to store the configuration of a "),jt=n("a"),Kn=r("UniSpeechModel"),Yn=r(`. It is used to instantiate an
UniSpeech model according to the specified arguments, defining the model architecture. Instantiating a
configuration with the defaults will yield a similar configuration to that of the UniSpeech
`),Pe=n("a"),Rn=r("facebook/unispeech-base-960h"),Qn=r(" architecture."),Xn=c(),Z=n("p"),Zn=r("Configuration objects inherit from "),Ft=n("a"),Jn=r("PretrainedConfig"),Gn=r(` and can be used to control the model outputs. Read the
documentation from `),qt=n("a"),ea=r("PretrainedConfig"),ta=r(" for more information."),oa=c(),Gt=n("p"),na=r("Example:"),aa=c(),_(Ee.$$.fragment),zo=c(),J=n("h2"),ue=n("a"),eo=n("span"),_(Me.$$.fragment),sa=c(),to=n("span"),ra=r("UniSpeech specific outputs"),Oo=c(),G=n("div"),_(ze.$$.fragment),ia=c(),Oe=n("p"),la=r("Output type of "),oo=n("code"),ca=r("UniSpeechBaseModelOutput"),da=r(", with potential hidden states and attentions."),Do=c(),ee=n("div"),_(De.$$.fragment),pa=c(),Ae=n("p"),ha=r("Output type of "),no=n("code"),ma=r("UniSpeechForPreTrainingOutput"),ua=r(", with potential hidden states and attentions."),Ao=c(),te=n("h2"),fe=n("a"),ao=n("span"),_(We.$$.fragment),fa=c(),so=n("span"),ga=r("UniSpeechModel"),Wo=c(),q=n("div"),_(Le.$$.fragment),_a=c(),Ne=n("p"),va=r(`The bare UniSpeech Model transformer outputting raw hidden-states without any specific head on top.
UniSpeech was proposed in `),Ve=n("a"),ba=r(`UniSpeech: Unified Speech Representation Learning with Labeled and Unlabeled
Data`),ya=r(` by Chengyi Wang, Yu Wu, Yao Qian, Kenichi Kumatani, Shujie Liu, Furu Wei,
Michael Zeng, Xuedong Huang.`),wa=c(),Ie=n("p"),Sa=r("This model inherits from "),Pt=n("a"),Ta=r("PreTrainedModel"),Ua=r(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving etc.).`),ka=c(),Be=n("p"),$a=r("This model is a PyTorch "),He=n("a"),Ca=r("torch.nn.Module"),xa=r(` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),ja=c(),M=n("div"),_(Ke.$$.fragment),Fa=c(),oe=n("p"),qa=r("The "),Et=n("a"),Pa=r("UniSpeechModel"),Ea=r(" forward method, overrides the "),ro=n("code"),Ma=r("__call__"),za=r(" special method."),Oa=c(),_(ge.$$.fragment),Da=c(),io=n("p"),Aa=r("Example:"),Wa=c(),_(Ye.$$.fragment),Lo=c(),ne=n("h2"),_e=n("a"),lo=n("span"),_(Re.$$.fragment),La=c(),co=n("span"),Na=r("UniSpeechForCTC"),No=c(),P=n("div"),_(Qe.$$.fragment),Va=c(),ae=n("p"),Ia=r("UniSpeech Model with a "),po=n("code"),Ba=r("language modeling"),Ha=r(` head on top for Connectionist Temporal Classification (CTC).
UniSpeech was proposed in `),Xe=n("a"),Ka=r(`UniSpeech: Unified Speech Representation Learning with Labeled and Unlabeled
Data`),Ya=r(` by Chengyi Wang, Yu Wu, Yao Qian, Kenichi Kumatani, Shujie Liu, Furu Wei,
Michael Zeng, Xuedong Huang.`),Ra=c(),Ze=n("p"),Qa=r("This model inherits from "),Mt=n("a"),Xa=r("PreTrainedModel"),Za=r(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving etc.).`),Ja=c(),Je=n("p"),Ga=r("This model is a PyTorch "),Ge=n("a"),es=r("torch.nn.Module"),ts=r(` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),os=c(),x=n("div"),_(et.$$.fragment),ns=c(),se=n("p"),as=r("The "),zt=n("a"),ss=r("UniSpeechForCTC"),rs=r(" forward method, overrides the "),ho=n("code"),is=r("__call__"),ls=r(" special method."),cs=c(),_(ve.$$.fragment),ds=c(),mo=n("p"),ps=r("Example:"),hs=c(),_(tt.$$.fragment),ms=c(),_(ot.$$.fragment),Vo=c(),re=n("h2"),be=n("a"),uo=n("span"),_(nt.$$.fragment),us=c(),fo=n("span"),fs=r("UniSpeechForSequenceClassification"),Io=c(),C=n("div"),_(at.$$.fragment),gs=c(),go=n("p"),_s=r(`UniSpeech Model with a sequence classification head on top (a linear layer over the pooled output) for tasks like
SUPERB Keyword Spotting.`),vs=c(),st=n("p"),bs=r("UniSpeech was proposed in "),rt=n("a"),ys=r(`UniSpeech: Unified Speech Representation Learning with Labeled and Unlabeled
Data`),ws=r(` by Chengyi Wang, Yu Wu, Yao Qian, Kenichi Kumatani, Shujie Liu, Furu Wei,
Michael Zeng, Xuedong Huang.`),Ss=c(),it=n("p"),Ts=r("This model inherits from "),Ot=n("a"),Us=r("PreTrainedModel"),ks=r(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving etc.).`),$s=c(),lt=n("p"),Cs=r("This model is a PyTorch "),ct=n("a"),xs=r("torch.nn.Module"),js=r(` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),Fs=c(),j=n("div"),_(dt.$$.fragment),qs=c(),ie=n("p"),Ps=r("The "),Dt=n("a"),Es=r("UniSpeechForSequenceClassification"),Ms=r(" forward method, overrides the "),_o=n("code"),zs=r("__call__"),Os=r(" special method."),Ds=c(),_(ye.$$.fragment),As=c(),vo=n("p"),Ws=r("Example:"),Ls=c(),_(pt.$$.fragment),Ns=c(),_(ht.$$.fragment),Bo=c(),le=n("h2"),we=n("a"),bo=n("span"),_(mt.$$.fragment),Vs=c(),yo=n("span"),Is=r("UniSpeechForPreTraining"),Ho=c(),E=n("div"),_(ut.$$.fragment),Bs=c(),ft=n("p"),Hs=r(`UniSpeech Model with a vector-quantization module and ctc loss for pre-training.
UniSpeech was proposed in `),gt=n("a"),Ks=r(`UniSpeech: Unified Speech Representation Learning with Labeled and Unlabeled
Data`),Ys=r(` by Chengyi Wang, Yu Wu, Yao Qian, Kenichi Kumatani, Shujie Liu, Furu Wei,
Michael Zeng, Xuedong Huang.`),Rs=c(),_t=n("p"),Qs=r("This model inherits from "),At=n("a"),Xs=r("PreTrainedModel"),Zs=r(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving etc.).`),Js=c(),vt=n("p"),Gs=r("This model is a PyTorch "),bt=n("a"),er=r("torch.nn.Module"),tr=r(` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),or=c(),z=n("div"),_(yt.$$.fragment),nr=c(),ce=n("p"),ar=r("The "),Wt=n("a"),sr=r("UniSpeechForPreTraining"),rr=r(" forward method, overrides the "),wo=n("code"),ir=r("__call__"),lr=r(" special method."),cr=c(),_(Se.$$.fragment),dr=c(),So=n("p"),pr=r("Example:"),hr=c(),_(wt.$$.fragment),this.h()},l(t){const p=ki('[data-svelte="svelte-1phssyn"]',document.head);m=a(p,"META",{name:!0,content:!0}),p.forEach(o),k=d(t),u=a(t,"H1",{class:!0});var St=s(u);T=a(St,"A",{id:!0,class:!0,href:!0});var To=s(T);U=a(To,"SPAN",{});var Uo=s(U);v(f.$$.fragment,Uo),Uo.forEach(o),To.forEach(o),g=d(St),$=a(St,"SPAN",{});var ko=s($);wn=i(ko,"UniSpeech"),ko.forEach(o),St.forEach(o),$o=d(t),R=a(t,"H2",{class:!0});var Yo=s(R);de=a(Yo,"A",{id:!0,class:!0,href:!0});var mr=s(de);Rt=a(mr,"SPAN",{});var ur=s(Rt);v(Ue.$$.fragment,ur),ur.forEach(o),mr.forEach(o),Sn=d(Yo),Qt=a(Yo,"SPAN",{});var fr=s(Qt);Tn=i(fr,"Overview"),fr.forEach(o),Yo.forEach(o),Co=d(t),pe=a(t,"P",{});var Ro=s(pe);Un=i(Ro,"The UniSpeech model was proposed in "),ke=a(Ro,"A",{href:!0,rel:!0});var gr=s(ke);kn=i(gr,"UniSpeech: Unified Speech Representation Learning with Labeled and Unlabeled Data"),gr.forEach(o),$n=i(Ro,` by Chengyi Wang, Yu Wu, Yao Qian, Kenichi Kumatani, Shujie Liu, Furu Wei, Michael
Zeng, Xuedong Huang .`),Ro.forEach(o),xo=d(t),Ut=a(t,"P",{});var _r=s(Ut);Cn=i(_r,"The abstract from the paper is the following:"),_r.forEach(o),jo=d(t),kt=a(t,"P",{});var vr=s(kt);Xt=a(vr,"EM",{});var br=s(Xt);xn=i(br,`In this paper, we propose a unified pre-training approach called UniSpeech to learn speech representations with both
unlabeled and labeled data, in which supervised phonetic CTC learning and phonetically-aware contrastive
self-supervised learning are conducted in a multi-task learning manner. The resultant representations can capture
information more correlated with phonetic structures and improve the generalization across languages and domains. We
evaluate the effectiveness of UniSpeech for cross-lingual representation learning on public CommonVoice corpus. The
results show that UniSpeech outperforms self-supervised pretraining and supervised transfer learning for speech
recognition by a maximum of 13.4% and 17.8% relative phone error rate reductions respectively (averaged over all
testing languages). The transferability of UniSpeech is also demonstrated on a domain-shift speech recognition task,
i.e., a relative word error rate reduction of 6% against the previous approach.`),br.forEach(o),vr.forEach(o),Fo=d(t),$t=a(t,"P",{});var yr=s($t);jn=i(yr,"Tips:"),yr.forEach(o),qo=d(t),he=a(t,"UL",{});var Qo=s(he);$e=a(Qo,"LI",{});var Xo=s($e);Fn=i(Xo,`UniSpeech is a speech model that accepts a float array corresponding to the raw waveform of the speech signal. Please
use `),Ct=a(Xo,"A",{href:!0});var wr=s(Ct);qn=i(wr,"Wav2Vec2Processor"),wr.forEach(o),Pn=i(Xo," for the feature extraction."),Xo.forEach(o),En=d(Qo),Ce=a(Qo,"LI",{});var Zo=s(Ce);Mn=i(Zo,`UniSpeech model can be fine-tuned using connectionist temporal classification (CTC) so the model output has to be
decoded using `),xt=a(Zo,"A",{href:!0});var Sr=s(xt);zn=i(Sr,"Wav2Vec2CTCTokenizer"),Sr.forEach(o),On=i(Zo,"."),Zo.forEach(o),Qo.forEach(o),Po=d(t),N=a(t,"P",{});var Lt=s(N);Dn=i(Lt,"This model was contributed by "),xe=a(Lt,"A",{href:!0,rel:!0});var Tr=s(xe);An=i(Tr,"patrickvonplaten"),Tr.forEach(o),Wn=i(Lt,`. The Authors\u2019 code can be
found `),je=a(Lt,"A",{href:!0,rel:!0});var Ur=s(je);Ln=i(Ur,"here"),Ur.forEach(o),Nn=i(Lt,"."),Lt.forEach(o),Eo=d(t),Q=a(t,"H2",{class:!0});var Jo=s(Q);me=a(Jo,"A",{id:!0,class:!0,href:!0});var kr=s(me);Zt=a(kr,"SPAN",{});var $r=s(Zt);v(Fe.$$.fragment,$r),$r.forEach(o),kr.forEach(o),Vn=d(Jo),Jt=a(Jo,"SPAN",{});var Cr=s(Jt);In=i(Cr,"UniSpeechConfig"),Cr.forEach(o),Jo.forEach(o),Mo=d(t),F=a(t,"DIV",{class:!0});var V=s(F);v(qe.$$.fragment,V),Bn=d(V),X=a(V,"P",{});var Nt=s(X);Hn=i(Nt,"This is the configuration class to store the configuration of a "),jt=a(Nt,"A",{href:!0});var xr=s(jt);Kn=i(xr,"UniSpeechModel"),xr.forEach(o),Yn=i(Nt,`. It is used to instantiate an
UniSpeech model according to the specified arguments, defining the model architecture. Instantiating a
configuration with the defaults will yield a similar configuration to that of the UniSpeech
`),Pe=a(Nt,"A",{href:!0,rel:!0});var jr=s(Pe);Rn=i(jr,"facebook/unispeech-base-960h"),jr.forEach(o),Qn=i(Nt," architecture."),Nt.forEach(o),Xn=d(V),Z=a(V,"P",{});var Vt=s(Z);Zn=i(Vt,"Configuration objects inherit from "),Ft=a(Vt,"A",{href:!0});var Fr=s(Ft);Jn=i(Fr,"PretrainedConfig"),Fr.forEach(o),Gn=i(Vt,` and can be used to control the model outputs. Read the
documentation from `),qt=a(Vt,"A",{href:!0});var qr=s(qt);ea=i(qr,"PretrainedConfig"),qr.forEach(o),ta=i(Vt," for more information."),Vt.forEach(o),oa=d(V),Gt=a(V,"P",{});var Pr=s(Gt);na=i(Pr,"Example:"),Pr.forEach(o),aa=d(V),v(Ee.$$.fragment,V),V.forEach(o),zo=d(t),J=a(t,"H2",{class:!0});var Go=s(J);ue=a(Go,"A",{id:!0,class:!0,href:!0});var Er=s(ue);eo=a(Er,"SPAN",{});var Mr=s(eo);v(Me.$$.fragment,Mr),Mr.forEach(o),Er.forEach(o),sa=d(Go),to=a(Go,"SPAN",{});var zr=s(to);ra=i(zr,"UniSpeech specific outputs"),zr.forEach(o),Go.forEach(o),Oo=d(t),G=a(t,"DIV",{class:!0});var en=s(G);v(ze.$$.fragment,en),ia=d(en),Oe=a(en,"P",{});var tn=s(Oe);la=i(tn,"Output type of "),oo=a(tn,"CODE",{});var Or=s(oo);ca=i(Or,"UniSpeechBaseModelOutput"),Or.forEach(o),da=i(tn,", with potential hidden states and attentions."),tn.forEach(o),en.forEach(o),Do=d(t),ee=a(t,"DIV",{class:!0});var on=s(ee);v(De.$$.fragment,on),pa=d(on),Ae=a(on,"P",{});var nn=s(Ae);ha=i(nn,"Output type of "),no=a(nn,"CODE",{});var Dr=s(no);ma=i(Dr,"UniSpeechForPreTrainingOutput"),Dr.forEach(o),ua=i(nn,", with potential hidden states and attentions."),nn.forEach(o),on.forEach(o),Ao=d(t),te=a(t,"H2",{class:!0});var an=s(te);fe=a(an,"A",{id:!0,class:!0,href:!0});var Ar=s(fe);ao=a(Ar,"SPAN",{});var Wr=s(ao);v(We.$$.fragment,Wr),Wr.forEach(o),Ar.forEach(o),fa=d(an),so=a(an,"SPAN",{});var Lr=s(so);ga=i(Lr,"UniSpeechModel"),Lr.forEach(o),an.forEach(o),Wo=d(t),q=a(t,"DIV",{class:!0});var I=s(q);v(Le.$$.fragment,I),_a=d(I),Ne=a(I,"P",{});var sn=s(Ne);va=i(sn,`The bare UniSpeech Model transformer outputting raw hidden-states without any specific head on top.
UniSpeech was proposed in `),Ve=a(sn,"A",{href:!0,rel:!0});var Nr=s(Ve);ba=i(Nr,`UniSpeech: Unified Speech Representation Learning with Labeled and Unlabeled
Data`),Nr.forEach(o),ya=i(sn,` by Chengyi Wang, Yu Wu, Yao Qian, Kenichi Kumatani, Shujie Liu, Furu Wei,
Michael Zeng, Xuedong Huang.`),sn.forEach(o),wa=d(I),Ie=a(I,"P",{});var rn=s(Ie);Sa=i(rn,"This model inherits from "),Pt=a(rn,"A",{href:!0});var Vr=s(Pt);Ta=i(Vr,"PreTrainedModel"),Vr.forEach(o),Ua=i(rn,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving etc.).`),rn.forEach(o),ka=d(I),Be=a(I,"P",{});var ln=s(Be);$a=i(ln,"This model is a PyTorch "),He=a(ln,"A",{href:!0,rel:!0});var Ir=s(He);Ca=i(Ir,"torch.nn.Module"),Ir.forEach(o),xa=i(ln,` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),ln.forEach(o),ja=d(I),M=a(I,"DIV",{class:!0});var B=s(M);v(Ke.$$.fragment,B),Fa=d(B),oe=a(B,"P",{});var It=s(oe);qa=i(It,"The "),Et=a(It,"A",{href:!0});var Br=s(Et);Pa=i(Br,"UniSpeechModel"),Br.forEach(o),Ea=i(It," forward method, overrides the "),ro=a(It,"CODE",{});var Hr=s(ro);Ma=i(Hr,"__call__"),Hr.forEach(o),za=i(It," special method."),It.forEach(o),Oa=d(B),v(ge.$$.fragment,B),Da=d(B),io=a(B,"P",{});var Kr=s(io);Aa=i(Kr,"Example:"),Kr.forEach(o),Wa=d(B),v(Ye.$$.fragment,B),B.forEach(o),I.forEach(o),Lo=d(t),ne=a(t,"H2",{class:!0});var cn=s(ne);_e=a(cn,"A",{id:!0,class:!0,href:!0});var Yr=s(_e);lo=a(Yr,"SPAN",{});var Rr=s(lo);v(Re.$$.fragment,Rr),Rr.forEach(o),Yr.forEach(o),La=d(cn),co=a(cn,"SPAN",{});var Qr=s(co);Na=i(Qr,"UniSpeechForCTC"),Qr.forEach(o),cn.forEach(o),No=d(t),P=a(t,"DIV",{class:!0});var H=s(P);v(Qe.$$.fragment,H),Va=d(H),ae=a(H,"P",{});var Bt=s(ae);Ia=i(Bt,"UniSpeech Model with a "),po=a(Bt,"CODE",{});var Xr=s(po);Ba=i(Xr,"language modeling"),Xr.forEach(o),Ha=i(Bt,` head on top for Connectionist Temporal Classification (CTC).
UniSpeech was proposed in `),Xe=a(Bt,"A",{href:!0,rel:!0});var Zr=s(Xe);Ka=i(Zr,`UniSpeech: Unified Speech Representation Learning with Labeled and Unlabeled
Data`),Zr.forEach(o),Ya=i(Bt,` by Chengyi Wang, Yu Wu, Yao Qian, Kenichi Kumatani, Shujie Liu, Furu Wei,
Michael Zeng, Xuedong Huang.`),Bt.forEach(o),Ra=d(H),Ze=a(H,"P",{});var dn=s(Ze);Qa=i(dn,"This model inherits from "),Mt=a(dn,"A",{href:!0});var Jr=s(Mt);Xa=i(Jr,"PreTrainedModel"),Jr.forEach(o),Za=i(dn,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving etc.).`),dn.forEach(o),Ja=d(H),Je=a(H,"P",{});var pn=s(Je);Ga=i(pn,"This model is a PyTorch "),Ge=a(pn,"A",{href:!0,rel:!0});var Gr=s(Ge);es=i(Gr,"torch.nn.Module"),Gr.forEach(o),ts=i(pn,` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),pn.forEach(o),os=d(H),x=a(H,"DIV",{class:!0});var O=s(x);v(et.$$.fragment,O),ns=d(O),se=a(O,"P",{});var Ht=s(se);as=i(Ht,"The "),zt=a(Ht,"A",{href:!0});var ei=s(zt);ss=i(ei,"UniSpeechForCTC"),ei.forEach(o),rs=i(Ht," forward method, overrides the "),ho=a(Ht,"CODE",{});var ti=s(ho);is=i(ti,"__call__"),ti.forEach(o),ls=i(Ht," special method."),Ht.forEach(o),cs=d(O),v(ve.$$.fragment,O),ds=d(O),mo=a(O,"P",{});var oi=s(mo);ps=i(oi,"Example:"),oi.forEach(o),hs=d(O),v(tt.$$.fragment,O),ms=d(O),v(ot.$$.fragment,O),O.forEach(o),H.forEach(o),Vo=d(t),re=a(t,"H2",{class:!0});var hn=s(re);be=a(hn,"A",{id:!0,class:!0,href:!0});var ni=s(be);uo=a(ni,"SPAN",{});var ai=s(uo);v(nt.$$.fragment,ai),ai.forEach(o),ni.forEach(o),us=d(hn),fo=a(hn,"SPAN",{});var si=s(fo);fs=i(si,"UniSpeechForSequenceClassification"),si.forEach(o),hn.forEach(o),Io=d(t),C=a(t,"DIV",{class:!0});var D=s(C);v(at.$$.fragment,D),gs=d(D),go=a(D,"P",{});var ri=s(go);_s=i(ri,`UniSpeech Model with a sequence classification head on top (a linear layer over the pooled output) for tasks like
SUPERB Keyword Spotting.`),ri.forEach(o),vs=d(D),st=a(D,"P",{});var mn=s(st);bs=i(mn,"UniSpeech was proposed in "),rt=a(mn,"A",{href:!0,rel:!0});var ii=s(rt);ys=i(ii,`UniSpeech: Unified Speech Representation Learning with Labeled and Unlabeled
Data`),ii.forEach(o),ws=i(mn,` by Chengyi Wang, Yu Wu, Yao Qian, Kenichi Kumatani, Shujie Liu, Furu Wei,
Michael Zeng, Xuedong Huang.`),mn.forEach(o),Ss=d(D),it=a(D,"P",{});var un=s(it);Ts=i(un,"This model inherits from "),Ot=a(un,"A",{href:!0});var li=s(Ot);Us=i(li,"PreTrainedModel"),li.forEach(o),ks=i(un,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving etc.).`),un.forEach(o),$s=d(D),lt=a(D,"P",{});var fn=s(lt);Cs=i(fn,"This model is a PyTorch "),ct=a(fn,"A",{href:!0,rel:!0});var ci=s(ct);xs=i(ci,"torch.nn.Module"),ci.forEach(o),js=i(fn,` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),fn.forEach(o),Fs=d(D),j=a(D,"DIV",{class:!0});var A=s(j);v(dt.$$.fragment,A),qs=d(A),ie=a(A,"P",{});var Kt=s(ie);Ps=i(Kt,"The "),Dt=a(Kt,"A",{href:!0});var di=s(Dt);Es=i(di,"UniSpeechForSequenceClassification"),di.forEach(o),Ms=i(Kt," forward method, overrides the "),_o=a(Kt,"CODE",{});var pi=s(_o);zs=i(pi,"__call__"),pi.forEach(o),Os=i(Kt," special method."),Kt.forEach(o),Ds=d(A),v(ye.$$.fragment,A),As=d(A),vo=a(A,"P",{});var hi=s(vo);Ws=i(hi,"Example:"),hi.forEach(o),Ls=d(A),v(pt.$$.fragment,A),Ns=d(A),v(ht.$$.fragment,A),A.forEach(o),D.forEach(o),Bo=d(t),le=a(t,"H2",{class:!0});var gn=s(le);we=a(gn,"A",{id:!0,class:!0,href:!0});var mi=s(we);bo=a(mi,"SPAN",{});var ui=s(bo);v(mt.$$.fragment,ui),ui.forEach(o),mi.forEach(o),Vs=d(gn),yo=a(gn,"SPAN",{});var fi=s(yo);Is=i(fi,"UniSpeechForPreTraining"),fi.forEach(o),gn.forEach(o),Ho=d(t),E=a(t,"DIV",{class:!0});var K=s(E);v(ut.$$.fragment,K),Bs=d(K),ft=a(K,"P",{});var _n=s(ft);Hs=i(_n,`UniSpeech Model with a vector-quantization module and ctc loss for pre-training.
UniSpeech was proposed in `),gt=a(_n,"A",{href:!0,rel:!0});var gi=s(gt);Ks=i(gi,`UniSpeech: Unified Speech Representation Learning with Labeled and Unlabeled
Data`),gi.forEach(o),Ys=i(_n,` by Chengyi Wang, Yu Wu, Yao Qian, Kenichi Kumatani, Shujie Liu, Furu Wei,
Michael Zeng, Xuedong Huang.`),_n.forEach(o),Rs=d(K),_t=a(K,"P",{});var vn=s(_t);Qs=i(vn,"This model inherits from "),At=a(vn,"A",{href:!0});var _i=s(At);Xs=i(_i,"PreTrainedModel"),_i.forEach(o),Zs=i(vn,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving etc.).`),vn.forEach(o),Js=d(K),vt=a(K,"P",{});var bn=s(vt);Gs=i(bn,"This model is a PyTorch "),bt=a(bn,"A",{href:!0,rel:!0});var vi=s(bt);er=i(vi,"torch.nn.Module"),vi.forEach(o),tr=i(bn,` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),bn.forEach(o),or=d(K),z=a(K,"DIV",{class:!0});var Y=s(z);v(yt.$$.fragment,Y),nr=d(Y),ce=a(Y,"P",{});var Yt=s(ce);ar=i(Yt,"The "),Wt=a(Yt,"A",{href:!0});var bi=s(Wt);sr=i(bi,"UniSpeechForPreTraining"),bi.forEach(o),rr=i(Yt," forward method, overrides the "),wo=a(Yt,"CODE",{});var yi=s(wo);ir=i(yi,"__call__"),yi.forEach(o),lr=i(Yt," special method."),Yt.forEach(o),cr=d(Y),v(Se.$$.fragment,Y),dr=d(Y),So=a(Y,"P",{});var wi=s(So);pr=i(wi,"Example:"),wi.forEach(o),hr=d(Y),v(wt.$$.fragment,Y),Y.forEach(o),K.forEach(o),this.h()},h(){l(m,"name","hf:doc:metadata"),l(m,"content",JSON.stringify(Pi)),l(T,"id","unispeech"),l(T,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(T,"href","#unispeech"),l(u,"class","relative group"),l(de,"id","overview"),l(de,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(de,"href","#overview"),l(R,"class","relative group"),l(ke,"href","https://arxiv.org/abs/2101.07597"),l(ke,"rel","nofollow"),l(Ct,"href","/docs/transformers/main/en/model_doc/wav2vec2#transformers.Wav2Vec2Processor"),l(xt,"href","/docs/transformers/main/en/model_doc/wav2vec2#transformers.Wav2Vec2CTCTokenizer"),l(xe,"href","https://huggingface.co/patrickvonplaten"),l(xe,"rel","nofollow"),l(je,"href","https://github.com/microsoft/UniSpeech/tree/main/UniSpeech"),l(je,"rel","nofollow"),l(me,"id","transformers.UniSpeechConfig"),l(me,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(me,"href","#transformers.UniSpeechConfig"),l(Q,"class","relative group"),l(jt,"href","/docs/transformers/main/en/model_doc/unispeech#transformers.UniSpeechModel"),l(Pe,"href","https://huggingface.co/facebook/unispeech-base-960h"),l(Pe,"rel","nofollow"),l(Ft,"href","/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig"),l(qt,"href","/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig"),l(F,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(ue,"id","transformers.models.unispeech.modeling_unispeech.UniSpeechBaseModelOutput"),l(ue,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(ue,"href","#transformers.models.unispeech.modeling_unispeech.UniSpeechBaseModelOutput"),l(J,"class","relative group"),l(G,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(fe,"id","transformers.UniSpeechModel"),l(fe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(fe,"href","#transformers.UniSpeechModel"),l(te,"class","relative group"),l(Ve,"href","https://arxiv.org/abs/2101.07597"),l(Ve,"rel","nofollow"),l(Pt,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),l(He,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),l(He,"rel","nofollow"),l(Et,"href","/docs/transformers/main/en/model_doc/unispeech#transformers.UniSpeechModel"),l(M,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(_e,"id","transformers.UniSpeechForCTC"),l(_e,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(_e,"href","#transformers.UniSpeechForCTC"),l(ne,"class","relative group"),l(Xe,"href","https://arxiv.org/abs/2101.07597"),l(Xe,"rel","nofollow"),l(Mt,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),l(Ge,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),l(Ge,"rel","nofollow"),l(zt,"href","/docs/transformers/main/en/model_doc/unispeech#transformers.UniSpeechForCTC"),l(x,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(P,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(be,"id","transformers.UniSpeechForSequenceClassification"),l(be,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(be,"href","#transformers.UniSpeechForSequenceClassification"),l(re,"class","relative group"),l(rt,"href","https://arxiv.org/abs/2101.07597"),l(rt,"rel","nofollow"),l(Ot,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),l(ct,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),l(ct,"rel","nofollow"),l(Dt,"href","/docs/transformers/main/en/model_doc/unispeech#transformers.UniSpeechForSequenceClassification"),l(j,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(C,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(we,"id","transformers.UniSpeechForPreTraining"),l(we,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(we,"href","#transformers.UniSpeechForPreTraining"),l(le,"class","relative group"),l(gt,"href","https://arxiv.org/abs/2101.07597"),l(gt,"rel","nofollow"),l(At,"href","/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel"),l(bt,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),l(bt,"rel","nofollow"),l(Wt,"href","/docs/transformers/main/en/model_doc/unispeech#transformers.UniSpeechForPreTraining"),l(z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(E,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,p){e(document.head,m),h(t,k,p),h(t,u,p),e(u,T),e(T,U),b(f,U,null),e(u,g),e(u,$),e($,wn),h(t,$o,p),h(t,R,p),e(R,de),e(de,Rt),b(Ue,Rt,null),e(R,Sn),e(R,Qt),e(Qt,Tn),h(t,Co,p),h(t,pe,p),e(pe,Un),e(pe,ke),e(ke,kn),e(pe,$n),h(t,xo,p),h(t,Ut,p),e(Ut,Cn),h(t,jo,p),h(t,kt,p),e(kt,Xt),e(Xt,xn),h(t,Fo,p),h(t,$t,p),e($t,jn),h(t,qo,p),h(t,he,p),e(he,$e),e($e,Fn),e($e,Ct),e(Ct,qn),e($e,Pn),e(he,En),e(he,Ce),e(Ce,Mn),e(Ce,xt),e(xt,zn),e(Ce,On),h(t,Po,p),h(t,N,p),e(N,Dn),e(N,xe),e(xe,An),e(N,Wn),e(N,je),e(je,Ln),e(N,Nn),h(t,Eo,p),h(t,Q,p),e(Q,me),e(me,Zt),b(Fe,Zt,null),e(Q,Vn),e(Q,Jt),e(Jt,In),h(t,Mo,p),h(t,F,p),b(qe,F,null),e(F,Bn),e(F,X),e(X,Hn),e(X,jt),e(jt,Kn),e(X,Yn),e(X,Pe),e(Pe,Rn),e(X,Qn),e(F,Xn),e(F,Z),e(Z,Zn),e(Z,Ft),e(Ft,Jn),e(Z,Gn),e(Z,qt),e(qt,ea),e(Z,ta),e(F,oa),e(F,Gt),e(Gt,na),e(F,aa),b(Ee,F,null),h(t,zo,p),h(t,J,p),e(J,ue),e(ue,eo),b(Me,eo,null),e(J,sa),e(J,to),e(to,ra),h(t,Oo,p),h(t,G,p),b(ze,G,null),e(G,ia),e(G,Oe),e(Oe,la),e(Oe,oo),e(oo,ca),e(Oe,da),h(t,Do,p),h(t,ee,p),b(De,ee,null),e(ee,pa),e(ee,Ae),e(Ae,ha),e(Ae,no),e(no,ma),e(Ae,ua),h(t,Ao,p),h(t,te,p),e(te,fe),e(fe,ao),b(We,ao,null),e(te,fa),e(te,so),e(so,ga),h(t,Wo,p),h(t,q,p),b(Le,q,null),e(q,_a),e(q,Ne),e(Ne,va),e(Ne,Ve),e(Ve,ba),e(Ne,ya),e(q,wa),e(q,Ie),e(Ie,Sa),e(Ie,Pt),e(Pt,Ta),e(Ie,Ua),e(q,ka),e(q,Be),e(Be,$a),e(Be,He),e(He,Ca),e(Be,xa),e(q,ja),e(q,M),b(Ke,M,null),e(M,Fa),e(M,oe),e(oe,qa),e(oe,Et),e(Et,Pa),e(oe,Ea),e(oe,ro),e(ro,Ma),e(oe,za),e(M,Oa),b(ge,M,null),e(M,Da),e(M,io),e(io,Aa),e(M,Wa),b(Ye,M,null),h(t,Lo,p),h(t,ne,p),e(ne,_e),e(_e,lo),b(Re,lo,null),e(ne,La),e(ne,co),e(co,Na),h(t,No,p),h(t,P,p),b(Qe,P,null),e(P,Va),e(P,ae),e(ae,Ia),e(ae,po),e(po,Ba),e(ae,Ha),e(ae,Xe),e(Xe,Ka),e(ae,Ya),e(P,Ra),e(P,Ze),e(Ze,Qa),e(Ze,Mt),e(Mt,Xa),e(Ze,Za),e(P,Ja),e(P,Je),e(Je,Ga),e(Je,Ge),e(Ge,es),e(Je,ts),e(P,os),e(P,x),b(et,x,null),e(x,ns),e(x,se),e(se,as),e(se,zt),e(zt,ss),e(se,rs),e(se,ho),e(ho,is),e(se,ls),e(x,cs),b(ve,x,null),e(x,ds),e(x,mo),e(mo,ps),e(x,hs),b(tt,x,null),e(x,ms),b(ot,x,null),h(t,Vo,p),h(t,re,p),e(re,be),e(be,uo),b(nt,uo,null),e(re,us),e(re,fo),e(fo,fs),h(t,Io,p),h(t,C,p),b(at,C,null),e(C,gs),e(C,go),e(go,_s),e(C,vs),e(C,st),e(st,bs),e(st,rt),e(rt,ys),e(st,ws),e(C,Ss),e(C,it),e(it,Ts),e(it,Ot),e(Ot,Us),e(it,ks),e(C,$s),e(C,lt),e(lt,Cs),e(lt,ct),e(ct,xs),e(lt,js),e(C,Fs),e(C,j),b(dt,j,null),e(j,qs),e(j,ie),e(ie,Ps),e(ie,Dt),e(Dt,Es),e(ie,Ms),e(ie,_o),e(_o,zs),e(ie,Os),e(j,Ds),b(ye,j,null),e(j,As),e(j,vo),e(vo,Ws),e(j,Ls),b(pt,j,null),e(j,Ns),b(ht,j,null),h(t,Bo,p),h(t,le,p),e(le,we),e(we,bo),b(mt,bo,null),e(le,Vs),e(le,yo),e(yo,Is),h(t,Ho,p),h(t,E,p),b(ut,E,null),e(E,Bs),e(E,ft),e(ft,Hs),e(ft,gt),e(gt,Ks),e(ft,Ys),e(E,Rs),e(E,_t),e(_t,Qs),e(_t,At),e(At,Xs),e(_t,Zs),e(E,Js),e(E,vt),e(vt,Gs),e(vt,bt),e(bt,er),e(vt,tr),e(E,or),e(E,z),b(yt,z,null),e(z,nr),e(z,ce),e(ce,ar),e(ce,Wt),e(Wt,sr),e(ce,rr),e(ce,wo),e(wo,ir),e(ce,lr),e(z,cr),b(Se,z,null),e(z,dr),e(z,So),e(So,pr),e(z,hr),b(wt,z,null),Ko=!0},p(t,[p]){const St={};p&2&&(St.$$scope={dirty:p,ctx:t}),ge.$set(St);const To={};p&2&&(To.$$scope={dirty:p,ctx:t}),ve.$set(To);const Uo={};p&2&&(Uo.$$scope={dirty:p,ctx:t}),ye.$set(Uo);const ko={};p&2&&(ko.$$scope={dirty:p,ctx:t}),Se.$set(ko)},i(t){Ko||(y(f.$$.fragment,t),y(Ue.$$.fragment,t),y(Fe.$$.fragment,t),y(qe.$$.fragment,t),y(Ee.$$.fragment,t),y(Me.$$.fragment,t),y(ze.$$.fragment,t),y(De.$$.fragment,t),y(We.$$.fragment,t),y(Le.$$.fragment,t),y(Ke.$$.fragment,t),y(ge.$$.fragment,t),y(Ye.$$.fragment,t),y(Re.$$.fragment,t),y(Qe.$$.fragment,t),y(et.$$.fragment,t),y(ve.$$.fragment,t),y(tt.$$.fragment,t),y(ot.$$.fragment,t),y(nt.$$.fragment,t),y(at.$$.fragment,t),y(dt.$$.fragment,t),y(ye.$$.fragment,t),y(pt.$$.fragment,t),y(ht.$$.fragment,t),y(mt.$$.fragment,t),y(ut.$$.fragment,t),y(yt.$$.fragment,t),y(Se.$$.fragment,t),y(wt.$$.fragment,t),Ko=!0)},o(t){w(f.$$.fragment,t),w(Ue.$$.fragment,t),w(Fe.$$.fragment,t),w(qe.$$.fragment,t),w(Ee.$$.fragment,t),w(Me.$$.fragment,t),w(ze.$$.fragment,t),w(De.$$.fragment,t),w(We.$$.fragment,t),w(Le.$$.fragment,t),w(Ke.$$.fragment,t),w(ge.$$.fragment,t),w(Ye.$$.fragment,t),w(Re.$$.fragment,t),w(Qe.$$.fragment,t),w(et.$$.fragment,t),w(ve.$$.fragment,t),w(tt.$$.fragment,t),w(ot.$$.fragment,t),w(nt.$$.fragment,t),w(at.$$.fragment,t),w(dt.$$.fragment,t),w(ye.$$.fragment,t),w(pt.$$.fragment,t),w(ht.$$.fragment,t),w(mt.$$.fragment,t),w(ut.$$.fragment,t),w(yt.$$.fragment,t),w(Se.$$.fragment,t),w(wt.$$.fragment,t),Ko=!1},d(t){o(m),t&&o(k),t&&o(u),S(f),t&&o($o),t&&o(R),S(Ue),t&&o(Co),t&&o(pe),t&&o(xo),t&&o(Ut),t&&o(jo),t&&o(kt),t&&o(Fo),t&&o($t),t&&o(qo),t&&o(he),t&&o(Po),t&&o(N),t&&o(Eo),t&&o(Q),S(Fe),t&&o(Mo),t&&o(F),S(qe),S(Ee),t&&o(zo),t&&o(J),S(Me),t&&o(Oo),t&&o(G),S(ze),t&&o(Do),t&&o(ee),S(De),t&&o(Ao),t&&o(te),S(We),t&&o(Wo),t&&o(q),S(Le),S(Ke),S(ge),S(Ye),t&&o(Lo),t&&o(ne),S(Re),t&&o(No),t&&o(P),S(Qe),S(et),S(ve),S(tt),S(ot),t&&o(Vo),t&&o(re),S(nt),t&&o(Io),t&&o(C),S(at),S(dt),S(ye),S(pt),S(ht),t&&o(Bo),t&&o(le),S(mt),t&&o(Ho),t&&o(E),S(ut),S(yt),S(Se),S(wt)}}}const Pi={local:"unispeech",sections:[{local:"overview",title:"Overview"},{local:"transformers.UniSpeechConfig",title:"UniSpeechConfig"},{local:"transformers.models.unispeech.modeling_unispeech.UniSpeechBaseModelOutput",title:"UniSpeech specific outputs"},{local:"transformers.UniSpeechModel",title:"UniSpeechModel"},{local:"transformers.UniSpeechForCTC",title:"UniSpeechForCTC"},{local:"transformers.UniSpeechForSequenceClassification",title:"UniSpeechForSequenceClassification"},{local:"transformers.UniSpeechForPreTraining",title:"UniSpeechForPreTraining"}],title:"UniSpeech"};function Ei(L){return $i(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Wi extends Si{constructor(m){super();Ti(this,m,Ei,qi,Ui,{})}}export{Wi as default,Pi as metadata};
