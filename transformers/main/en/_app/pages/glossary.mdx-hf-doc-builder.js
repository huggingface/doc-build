import{S as j_,i as P_,s as T_,e as a,k as f,w as c,t as l,M as x_,c as n,d as t,m as d,a as r,x as u,h as i,b as p,G as s,g as h,y as m,q as v,o as g,B as w,v as S_}from"../chunks/vendor-hf-doc-builder.js";import{T as N_}from"../chunks/Tip-hf-doc-builder.js";import{Y as Rv}from"../chunks/Youtube-hf-doc-builder.js";import{I as b}from"../chunks/IconCopyLink-hf-doc-builder.js";import{C as y}from"../chunks/CodeBlock-hf-doc-builder.js";function z_(bl){let E,Re;return{c(){E=a("p"),Re=l(`Each model\u2019s labels may be different, so be sure to always check the documentation of each model for more information
about their specific labels!`)},l(A){E=n(A,"P",{});var T=r(E);Re=i(T,`Each model\u2019s labels may be different, so be sure to always check the documentation of each model for more information
about their specific labels!`),T.forEach(t)},m(A,T){h(A,E,T),s(E,Re)},d(A){A&&t(E)}}}function C_(bl){let E,Re,A,T,Rn,Kt,Yp,Vn,Qp,_l,wa,Jp,$l,U,Ve,Ln,Zt,Kp,Gn,Zp,kl,X,Le,Wn,es,ef,Un,tf,El,ba,sf,yl,ts,Al,_a,af,ql,$a,nf,jl,ss,Pl,ka,rf,Tl,as,xl,Ea,of,Sl,ya,lf,Nl,ns,zl,Aa,hf,Cl,rs,Dl,S,pf,qa,ff,df,Xn,cf,uf,Yn,mf,vf,Il,os,Bl,Y,Ge,Qn,ls,gf,Jn,wf,Hl,is,bf,ja,_f,Fl,Q,We,Kn,hs,$f,Zn,kf,Ml,ps,Ef,Pa,yf,Ol,J,Ue,er,fs,Af,tr,qf,Rl,K,Xe,sr,ds,jf,ar,Pf,Vl,q,Tf,Ta,xf,Sf,xa,Nf,zf,nr,Cf,Df,Sa,If,Bf,Ll,Z,Ye,rr,cs,Hf,or,Ff,Gl,ee,Qe,lr,us,Mf,ir,Of,Wl,$,Rf,hr,Vf,Lf,pr,Gf,Wf,fr,Uf,Xf,dr,Yf,Qf,cr,Jf,Kf,ur,Zf,ed,Ul,te,Je,mr,ms,td,vr,sd,Xl,Na,ad,Yl,se,Ke,gr,vs,nd,wr,rd,Ql,za,od,Jl,ae,Ze,br,gs,ld,_r,id,Kl,Ca,hd,Zl,ne,et,$r,ws,pd,kr,fd,ei,re,tt,Er,bs,dd,yr,cd,ti,Da,ud,si,N,md,Ar,vd,gd,qr,wd,bd,jr,_d,$d,ai,Ia,kd,ni,oe,st,Pr,_s,Ed,Tr,yd,ri,Ba,Ad,oi,le,at,xr,$s,qd,Sr,jd,li,ie,nt,Nr,ks,Pd,zr,Td,ii,rt,xd,Cr,Sd,Nd,hi,_,zd,Dr,Cd,Dd,Ir,Id,Bd,Es,Hd,Fd,Br,Md,Od,Hr,Rd,Vd,Fr,Ld,Gd,Mr,Wd,Ud,Or,Xd,Yd,pi,z,Qd,Ha,Jd,Kd,Rr,Zd,ec,Vr,tc,sc,fi,he,ot,Lr,ys,ac,Gr,nc,di,pe,lt,Wr,As,rc,Ur,oc,ci,Fa,lc,ui,D,it,Ma,ic,hc,Oa,pc,fc,dc,I,Ra,cc,uc,Xr,mc,vc,Va,gc,wc,bc,B,La,_c,$c,Ga,kc,Ec,Wa,yc,Ac,mi,fe,ht,Yr,qs,qc,Qr,jc,vi,de,pt,Jr,js,Pc,Kr,Tc,gi,ft,xc,Zr,Sc,Nc,wi,ce,dt,eo,Ps,zc,to,Cc,bi,Ua,Dc,_i,Ts,$i,ct,Ic,xs,Bc,Hc,ki,Ss,Ei,Xa,Fc,yi,Ns,Ai,Ya,Mc,qi,zs,ji,ut,Oc,Cs,Rc,Vc,Pi,Ds,Ti,mt,Lc,so,Gc,Wc,xi,Is,Si,Qa,Uc,Ni,Ja,Xc,zi,Bs,Ci,Ka,Yc,Di,Hs,Ii,vt,Qc,Za,Jc,Kc,Bi,ue,gt,ao,Fs,Zc,no,eu,Hi,me,wt,ro,Ms,tu,oo,su,Fi,en,au,Mi,tn,nu,Oi,C,ve,ru,sn,ou,lu,lo,iu,hu,pu,ge,fu,an,du,cu,io,uu,mu,vu,we,gu,nn,wu,bu,ho,_u,$u,ku,x,Eu,rn,yu,Au,on,qu,ju,po,Pu,Tu,fo,xu,Su,Ri,bt,Vi,_t,Nu,ln,zu,Cu,Li,be,$t,co,Os,Du,uo,Iu,Gi,_e,kt,mo,Rs,Bu,vo,Hu,Wi,hn,Fu,Ui,$e,Et,go,Vs,Mu,wo,Ou,Xi,pn,Ru,Yi,ke,yt,bo,Ls,Vu,_o,Lu,Qi,Ee,At,$o,Gs,Gu,ko,Wu,Ji,fn,Uu,Ki,ye,qt,Eo,Ws,Xu,yo,Yu,Zi,dn,Qu,eh,Ae,jt,Ao,Us,Ju,qo,Ku,th,cn,Zu,sh,qe,Pt,jo,Xs,em,Po,tm,ah,je,Tt,To,Ys,sm,xo,am,nh,j,nm,So,rm,om,No,lm,im,zo,hm,pm,Co,fm,dm,rh,Pe,xt,Do,Qs,cm,Io,um,oh,un,mm,lh,Te,St,Bo,Js,vm,Ho,gm,ih,Nt,wm,Fo,bm,_m,hh,zt,$m,Mo,km,Em,ph,Ct,ym,Oo,Am,qm,fh,xe,Dt,Ro,Ks,jm,Vo,Pm,dh,H,Tm,mn,xm,Sm,vn,Nm,zm,ch,gn,Cm,uh,Se,It,Lo,Zs,Dm,Go,Im,mh,Ne,Bt,Wo,ea,Bm,Uo,Hm,vh,wn,Fm,gh,ze,Ht,Xo,ta,Mm,Yo,Om,wh,Ce,Ft,Qo,sa,Rm,Jo,Vm,bh,bn,Lm,_h,De,Mt,Ko,aa,Gm,Zo,Wm,$h,_n,Um,kh,Ie,Ot,el,na,Xm,tl,Ym,Eh,F,Qm,$n,Jm,Km,kn,Zm,ev,yh,Be,Rt,sl,ra,tv,al,sv,Ah,M,av,En,nv,rv,yn,ov,lv,qh,He,Vt,nl,oa,iv,rl,hv,jh,Fe,Lt,ol,la,pv,ll,fv,Ph,An,dv,Th,Me,Gt,il,ia,cv,hl,uv,xh,qn,mv,Sh,ha,Nh,O,vv,pl,gv,wv,fl,bv,_v,zh,pa,Ch,Wt,$v,dl,kv,Ev,Dh,fa,Ih,jn,yv,Bh,da,Hh,Pn,Av,Fh,Tn,qv,Mh,ca,Oh,R,jv,cl,Pv,Tv,ul,xv,Sv,Rh,V,Nv,xn,zv,Cv,ml,Dv,Iv,Vh,Oe,Ut,vl,ua,Bv,gl,Hv,Lh,Sn,Fv,Gh;return Kt=new b({}),Zt=new b({}),es=new b({}),ts=new Rv({props:{id:"M6adb1j2jPI"}}),ss=new y({props:{code:`from transformers import BertTokenizer

tokenizer = BertTokenizer.from_pretrained("bert-base-cased")

sequence_a = "This is a short sequence."
sequence_b = "This is a rather long sequence. It is at least longer than the sequence A."

encoded_sequence_a = tokenizer(sequence_a)["input_ids"]
encoded_sequence_b = tokenizer(sequence_b)["input_ids"]`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertTokenizer

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = BertTokenizer.from_pretrained(<span class="hljs-string">&quot;bert-base-cased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>sequence_a = <span class="hljs-string">&quot;This is a short sequence.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>sequence_b = <span class="hljs-string">&quot;This is a rather long sequence. It is at least longer than the sequence A.&quot;</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>encoded_sequence_a = tokenizer(sequence_a)[<span class="hljs-string">&quot;input_ids&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>encoded_sequence_b = tokenizer(sequence_b)[<span class="hljs-string">&quot;input_ids&quot;</span>]`}}),as=new y({props:{code:"len(encoded_sequence_a), len(encoded_sequence_b)",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(encoded_sequence_a), <span class="hljs-built_in">len</span>(encoded_sequence_b)
(<span class="hljs-number">8</span>, <span class="hljs-number">19</span>)`}}),ns=new y({props:{code:"padded_sequences = tokenizer([sequence_a, sequence_b], padding=True)",highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>padded_sequences = tokenizer([sequence_a, sequence_b], padding=<span class="hljs-literal">True</span>)'}}),rs=new y({props:{code:'padded_sequences["input_ids"]',highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>padded_sequences[<span class="hljs-string">&quot;input_ids&quot;</span>]
[[<span class="hljs-number">101</span>, <span class="hljs-number">1188</span>, <span class="hljs-number">1110</span>, <span class="hljs-number">170</span>, <span class="hljs-number">1603</span>, <span class="hljs-number">4954</span>, <span class="hljs-number">119</span>, <span class="hljs-number">102</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">101</span>, <span class="hljs-number">1188</span>, <span class="hljs-number">1110</span>, <span class="hljs-number">170</span>, <span class="hljs-number">1897</span>, <span class="hljs-number">1263</span>, <span class="hljs-number">4954</span>, <span class="hljs-number">119</span>, <span class="hljs-number">1135</span>, <span class="hljs-number">1110</span>, <span class="hljs-number">1120</span>, <span class="hljs-number">1655</span>, <span class="hljs-number">2039</span>, <span class="hljs-number">1190</span>, <span class="hljs-number">1103</span>, <span class="hljs-number">4954</span>, <span class="hljs-number">138</span>, <span class="hljs-number">119</span>, <span class="hljs-number">102</span>]]`}}),os=new y({props:{code:'padded_sequences["attention_mask"]',highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>padded_sequences[<span class="hljs-string">&quot;attention_mask&quot;</span>]
[[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]]`}}),ls=new b({}),hs=new b({}),fs=new b({}),ds=new b({}),cs=new b({}),us=new b({}),ms=new b({}),vs=new b({}),gs=new b({}),ws=new b({}),bs=new b({}),_s=new b({}),$s=new b({}),ks=new b({}),ys=new b({}),As=new b({}),qs=new b({}),js=new b({}),Ps=new b({}),Ts=new Rv({props:{id:"VFp38yj8h3A"}}),Ss=new y({props:{code:`from transformers import BertTokenizer

tokenizer = BertTokenizer.from_pretrained("bert-base-cased")

sequence = "A Titan RTX has 24GB of VRAM"`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertTokenizer

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = BertTokenizer.from_pretrained(<span class="hljs-string">&quot;bert-base-cased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>sequence = <span class="hljs-string">&quot;A Titan RTX has 24GB of VRAM&quot;</span>`}}),Ns=new y({props:{code:"tokenized_sequence = tokenizer.tokenize(sequence)",highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>tokenized_sequence = tokenizer.tokenize(sequence)'}}),zs=new y({props:{code:"print(tokenized_sequence)",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(tokenized_sequence)
[<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;Titan&#x27;</span>, <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;##T&#x27;</span>, <span class="hljs-string">&#x27;##X&#x27;</span>, <span class="hljs-string">&#x27;has&#x27;</span>, <span class="hljs-string">&#x27;24&#x27;</span>, <span class="hljs-string">&#x27;##GB&#x27;</span>, <span class="hljs-string">&#x27;of&#x27;</span>, <span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-string">&#x27;##RA&#x27;</span>, <span class="hljs-string">&#x27;##M&#x27;</span>]`}}),Ds=new y({props:{code:"inputs = tokenizer(sequence)",highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(sequence)'}}),Is=new y({props:{code:`encoded_sequence = inputs["input_ids"]
print(encoded_sequence)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>encoded_sequence = inputs[<span class="hljs-string">&quot;input_ids&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(encoded_sequence)
[<span class="hljs-number">101</span>, <span class="hljs-number">138</span>, <span class="hljs-number">18696</span>, <span class="hljs-number">155</span>, <span class="hljs-number">1942</span>, <span class="hljs-number">3190</span>, <span class="hljs-number">1144</span>, <span class="hljs-number">1572</span>, <span class="hljs-number">13745</span>, <span class="hljs-number">1104</span>, <span class="hljs-number">159</span>, <span class="hljs-number">9664</span>, <span class="hljs-number">2107</span>, <span class="hljs-number">102</span>]`}}),Bs=new y({props:{code:"decoded_sequence = tokenizer.decode(encoded_sequence)",highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>decoded_sequence = tokenizer.decode(encoded_sequence)'}}),Hs=new y({props:{code:"print(decoded_sequence)",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(decoded_sequence)
[CLS] A Titan RTX has 24GB of VRAM [SEP]`}}),Fs=new b({}),Ms=new b({}),bt=new N_({props:{$$slots:{default:[z_]},$$scope:{ctx:bl}}}),Os=new b({}),Rs=new b({}),Vs=new b({}),Ls=new b({}),Gs=new b({}),Ws=new b({}),Us=new b({}),Xs=new b({}),Ys=new b({}),Qs=new b({}),Js=new b({}),Ks=new b({}),Zs=new b({}),ea=new b({}),ta=new b({}),sa=new b({}),aa=new b({}),na=new b({}),ra=new b({}),oa=new b({}),la=new b({}),ia=new b({}),ha=new Rv({props:{id:"0u3ioSwev3s"}}),pa=new y({props:{code:"# [CLS] SEQUENCE_A [SEP] SEQUENCE_B [SEP]",highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># [CLS] SEQUENCE_A [SEP] SEQUENCE_B [SEP]</span>'}}),fa=new y({props:{code:`from transformers import BertTokenizer

tokenizer = BertTokenizer.from_pretrained("bert-base-cased")
sequence_a = "HuggingFace is based in NYC"
sequence_b = "Where is HuggingFace based?"

encoded_dict = tokenizer(sequence_a, sequence_b)
decoded = tokenizer.decode(encoded_dict["input_ids"])`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertTokenizer

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = BertTokenizer.from_pretrained(<span class="hljs-string">&quot;bert-base-cased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>sequence_a = <span class="hljs-string">&quot;HuggingFace is based in NYC&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>sequence_b = <span class="hljs-string">&quot;Where is HuggingFace based?&quot;</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>encoded_dict = tokenizer(sequence_a, sequence_b)
<span class="hljs-meta">&gt;&gt;&gt; </span>decoded = tokenizer.decode(encoded_dict[<span class="hljs-string">&quot;input_ids&quot;</span>])`}}),da=new y({props:{code:"print(decoded)",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(decoded)
[CLS] HuggingFace <span class="hljs-keyword">is</span> based <span class="hljs-keyword">in</span> NYC [SEP] Where <span class="hljs-keyword">is</span> HuggingFace based? [SEP]`}}),ca=new y({props:{code:'encoded_dict["token_type_ids"]',highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>encoded_dict[<span class="hljs-string">&quot;token_type_ids&quot;</span>]
[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]`}}),ua=new b({}),{c(){E=a("meta"),Re=f(),A=a("h1"),T=a("a"),Rn=a("span"),c(Kt.$$.fragment),Yp=f(),Vn=a("span"),Qp=l("Glossary"),_l=f(),wa=a("p"),Jp=l(`This glossary defines general machine learning and \u{1F917} Transformers terms to help you better understand the
documentation.`),$l=f(),U=a("h2"),Ve=a("a"),Ln=a("span"),c(Zt.$$.fragment),Kp=f(),Gn=a("span"),Zp=l("A"),kl=f(),X=a("h3"),Le=a("a"),Wn=a("span"),c(es.$$.fragment),ef=f(),Un=a("span"),tf=l("attention mask"),El=f(),ba=a("p"),sf=l("The attention mask is an optional argument used when batching sequences together."),yl=f(),c(ts.$$.fragment),Al=f(),_a=a("p"),af=l("This argument indicates to the model which tokens should be attended to, and which should not."),ql=f(),$a=a("p"),nf=l("For example, consider these two sequences:"),jl=f(),c(ss.$$.fragment),Pl=f(),ka=a("p"),rf=l("The encoded versions have different lengths:"),Tl=f(),c(as.$$.fragment),xl=f(),Ea=a("p"),of=l(`Therefore, we can\u2019t put them together in the same tensor as-is. The first sequence needs to be padded up to the length
of the second one, or the second one needs to be truncated down to the length of the first one.`),Sl=f(),ya=a("p"),lf=l(`In the first case, the list of IDs will be extended by the padding indices. We can pass a list to the tokenizer and ask
it to pad like this:`),Nl=f(),c(ns.$$.fragment),zl=f(),Aa=a("p"),hf=l("We can see that 0s have been added on the right of the first sentence to make it the same length as the second one:"),Cl=f(),c(rs.$$.fragment),Dl=f(),S=a("p"),pf=l(`This can then be converted into a tensor in PyTorch or TensorFlow. The attention mask is a binary tensor indicating the
position of the padded indices so that the model does not attend to them. For the `),qa=a("a"),ff=l("BertTokenizer"),df=l(", "),Xn=a("code"),cf=l("1"),uf=l(` indicates a
value that should be attended to, while `),Yn=a("code"),mf=l("0"),vf=l(` indicates a padded value. This attention mask is in the dictionary returned
by the tokenizer under the key \u201Cattention_mask\u201D:`),Il=f(),c(os.$$.fragment),Bl=f(),Y=a("h3"),Ge=a("a"),Qn=a("span"),c(ls.$$.fragment),gf=f(),Jn=a("span"),wf=l("autoencoding models"),Hl=f(),is=a("p"),bf=l("see "),ja=a("a"),_f=l("masked language modeling"),Fl=f(),Q=a("h3"),We=a("a"),Kn=a("span"),c(hs.$$.fragment),$f=f(),Zn=a("span"),kf=l("autoregressive models"),Ml=f(),ps=a("p"),Ef=l("see "),Pa=a("a"),yf=l("causal language modeling"),Ol=f(),J=a("h2"),Ue=a("a"),er=a("span"),c(fs.$$.fragment),Af=f(),tr=a("span"),qf=l("B"),Rl=f(),K=a("h3"),Xe=a("a"),sr=a("span"),c(ds.$$.fragment),jf=f(),ar=a("span"),Pf=l("backbone"),Vl=f(),q=a("p"),Tf=l("The backbone is the network (embeddings and layers) that outputs the raw hidden states or features. It is usually connected to a "),Ta=a("a"),xf=l("head"),Sf=l(" which accepts the features as its input to make a prediction. For example, "),xa=a("a"),Nf=l("ViTModel"),zf=l(" is a backbone without a specific head on top. Other models can also use "),nr=a("code"),Cf=l("VitModel"),Df=l(" as a backbone such as "),Sa=a("a"),If=l("DPT"),Bf=l("."),Ll=f(),Z=a("h2"),Ye=a("a"),rr=a("span"),c(cs.$$.fragment),Hf=f(),or=a("span"),Ff=l("C"),Gl=f(),ee=a("h3"),Qe=a("a"),lr=a("span"),c(us.$$.fragment),Mf=f(),ir=a("span"),Of=l("channel"),Wl=f(),$=a("p"),Rf=l("Color images are made up of some combination of values in three channels - red, green, and blue (RGB) - and grayscale images only have one channel. In \u{1F917} Transformers, the channel can be the first or last dimension of an image\u2019s tensor: ["),hr=a("code"),Vf=l("n_channels"),Lf=l(", "),pr=a("code"),Gf=l("height"),Wf=l(", "),fr=a("code"),Uf=l("width"),Xf=l("] or ["),dr=a("code"),Yf=l("height"),Qf=l(", "),cr=a("code"),Jf=l("width"),Kf=l(", "),ur=a("code"),Zf=l("n_channels"),ed=l("]."),Ul=f(),te=a("h3"),Je=a("a"),mr=a("span"),c(ms.$$.fragment),td=f(),vr=a("span"),sd=l("causal language modeling"),Xl=f(),Na=a("p"),ad=l(`A pretraining task where the model reads the texts in order and has to predict the next word. It\u2019s usually done by
reading the whole sentence but using a mask inside the model to hide the future tokens at a certain timestep.`),Yl=f(),se=a("h3"),Ke=a("a"),gr=a("span"),c(vs.$$.fragment),nd=f(),wr=a("span"),rd=l("connectionist temporal classification (CTC)"),Ql=f(),za=a("p"),od=l("An algorithm which allows a model to learn without knowing exactly how the input and output are aligned; CTC calculates the distribution of all possible outputs for a given input and chooses the most likely output from it. CTC is commonly used in speech recognition tasks because speech doesn\u2019t always cleanly align with the transcript for a variety of reasons such as a speaker\u2019s different speech rates."),Jl=f(),ae=a("h3"),Ze=a("a"),br=a("span"),c(gs.$$.fragment),ld=f(),_r=a("span"),id=l("convolution"),Kl=f(),Ca=a("p"),hd=l("A type of layer in a neural network where the input matrix is multiplied element-wise by a smaller matrix (kernel or filter) and the values are summed up in a new matrix. This is known as a convolutional operation which is repeated over the entire input matrix. Each operation is applied to a different segment of the input matrix. Convolutional neural networks (CNNs) are commonly used in computer vision."),Zl=f(),ne=a("h2"),et=a("a"),$r=a("span"),c(ws.$$.fragment),pd=f(),kr=a("span"),fd=l("D"),ei=f(),re=a("h3"),tt=a("a"),Er=a("span"),c(bs.$$.fragment),dd=f(),yr=a("span"),cd=l("decoder input IDs"),ti=f(),Da=a("p"),ud=l(`This input is specific to encoder-decoder models, and contains the input IDs that will be fed to the decoder. These
inputs should be used for sequence to sequence tasks, such as translation or summarization, and are usually built in a
way specific to each model.`),si=f(),N=a("p"),md=l("Most encoder-decoder models (BART, T5) create their "),Ar=a("code"),vd=l("decoder_input_ids"),gd=l(" on their own from the "),qr=a("code"),wd=l("labels"),bd=l(`. In such models,
passing the `),jr=a("code"),_d=l("labels"),$d=l(" is the preferred way to handle training."),ai=f(),Ia=a("p"),kd=l("Please check each model\u2019s docs to see how they handle these input IDs for sequence to sequence training."),ni=f(),oe=a("h3"),st=a("a"),Pr=a("span"),c(_s.$$.fragment),Ed=f(),Tr=a("span"),yd=l("deep learning"),ri=f(),Ba=a("p"),Ad=l("Machine learning algorithms which uses neural networks with several layers."),oi=f(),le=a("h2"),at=a("a"),xr=a("span"),c($s.$$.fragment),qd=f(),Sr=a("span"),jd=l("F"),li=f(),ie=a("h3"),nt=a("a"),Nr=a("span"),c(ks.$$.fragment),Pd=f(),zr=a("span"),Td=l("feed forward chunking"),ii=f(),rt=a("p"),xd=l(`In each residual attention block in transformers the self-attention layer is usually followed by 2 feed forward layers.
The intermediate embedding size of the feed forward layers is often bigger than the hidden size of the model (e.g., for
`),Cr=a("code"),Sd=l("bert-base-uncased"),Nd=l(")."),hi=f(),_=a("p"),zd=l("For an input of size "),Dr=a("code"),Cd=l("[batch_size, sequence_length]"),Dd=l(`, the memory required to store the intermediate feed forward
embeddings `),Ir=a("code"),Id=l("[batch_size, sequence_length, config.intermediate_size]"),Bd=l(` can account for a large fraction of the memory
use. The authors of `),Es=a("a"),Hd=l("Reformer: The Efficient Transformer"),Fd=l(` noticed that since the
computation is independent of the `),Br=a("code"),Md=l("sequence_length"),Od=l(` dimension, it is mathematically equivalent to compute the output
embeddings of both feed forward layers `),Hr=a("code"),Rd=l("[batch_size, config.hidden_size]_0, ..., [batch_size, config.hidden_size]_n"),Vd=l(`
individually and concat them afterward to `),Fr=a("code"),Ld=l("[batch_size, sequence_length, config.hidden_size]"),Gd=l(" with "),Mr=a("code"),Wd=l("n = sequence_length"),Ud=l(`, which trades increased computation time against reduced memory use, but yields a mathematically
`),Or=a("strong"),Xd=l("equivalent"),Yd=l(" result."),pi=f(),z=a("p"),Qd=l("For models employing the function "),Ha=a("a"),Jd=l("apply_chunking_to_forward()"),Kd=l(", the "),Rr=a("code"),Zd=l("chunk_size"),ec=l(` defines the number of output
embeddings that are computed in parallel and thus defines the trade-off between memory and time complexity. If
`),Vr=a("code"),tc=l("chunk_size"),sc=l(" is set to 0, no feed forward chunking is done."),fi=f(),he=a("h2"),ot=a("a"),Lr=a("span"),c(ys.$$.fragment),ac=f(),Gr=a("span"),nc=l("H"),di=f(),pe=a("h3"),lt=a("a"),Wr=a("span"),c(As.$$.fragment),rc=f(),Ur=a("span"),oc=l("head"),ci=f(),Fa=a("p"),lc=l("The model head refers to the last layer of a neural network that accepts the raw hidden states and projects them onto a different dimension. There is a different model head for each task. For example:"),ui=f(),D=a("ul"),it=a("li"),Ma=a("a"),ic=l("GPT2ForSequenceClassification"),hc=l(" is a sequence classification head - a linear layer - on top of the base "),Oa=a("a"),pc=l("GPT2Model"),fc=l("."),dc=f(),I=a("li"),Ra=a("a"),cc=l("ViTForImageClassification"),uc=l(" is an image classification head - a linear layer on top of the final hidden state of the "),Xr=a("code"),mc=l("CLS"),vc=l(" token - on top of the base "),Va=a("a"),gc=l("ViTModel"),wc=l("."),bc=f(),B=a("li"),La=a("a"),_c=l("Wav2Vec2ForCTC"),$c=l(" ia a language modeling head with "),Ga=a("a"),kc=l("CTC"),Ec=l(" on top of the base "),Wa=a("a"),yc=l("Wav2Vec2Model"),Ac=l("."),mi=f(),fe=a("h2"),ht=a("a"),Yr=a("span"),c(qs.$$.fragment),qc=f(),Qr=a("span"),jc=l("I"),vi=f(),de=a("h3"),pt=a("a"),Jr=a("span"),c(js.$$.fragment),Pc=f(),Kr=a("span"),Tc=l("image patch"),gi=f(),ft=a("p"),xc=l("Vision-based Transformers models split an image into smaller patches which are linearly embedded, and then passed as a sequence to the model. You can find the "),Zr=a("code"),Sc=l("patch_size"),Nc=l(" - or resolution - of the model in it\u2019s configuration."),wi=f(),ce=a("h3"),dt=a("a"),eo=a("span"),c(Ps.$$.fragment),zc=f(),to=a("span"),Cc=l("input IDs"),bi=f(),Ua=a("p"),Dc=l(`The input ids are often the only required parameters to be passed to the model as input. They are token indices,
numerical representations of tokens building the sequences that will be used as input by the model.`),_i=f(),c(Ts.$$.fragment),$i=f(),ct=a("p"),Ic=l(`Each tokenizer works differently but the underlying mechanism remains the same. Here\u2019s an example using the BERT
tokenizer, which is a `),xs=a("a"),Bc=l("WordPiece"),Hc=l(" tokenizer:"),ki=f(),c(Ss.$$.fragment),Ei=f(),Xa=a("p"),Fc=l("The tokenizer takes care of splitting the sequence into tokens available in the tokenizer vocabulary."),yi=f(),c(Ns.$$.fragment),Ai=f(),Ya=a("p"),Mc=l(`The tokens are either words or subwords. Here for instance, \u201CVRAM\u201D wasn\u2019t in the model vocabulary, so it\u2019s been split
in \u201CV\u201D, \u201CRA\u201D and \u201CM\u201D. To indicate those tokens are not separate words but parts of the same word, a double-hash prefix
is added for \u201CRA\u201D and \u201CM\u201D:`),qi=f(),c(zs.$$.fragment),ji=f(),ut=a("p"),Oc=l(`These tokens can then be converted into IDs which are understandable by the model. This can be done by directly feeding
the sentence to the tokenizer, which leverages the Rust implementation of `),Cs=a("a"),Rc=l(`\u{1F917}
Tokenizers`),Vc=l(" for peak performance."),Pi=f(),c(Ds.$$.fragment),Ti=f(),mt=a("p"),Lc=l(`The tokenizer returns a dictionary with all the arguments necessary for its corresponding model to work properly. The
token indices are under the key `),so=a("code"),Gc=l("input_ids"),Wc=l(":"),xi=f(),c(Is.$$.fragment),Si=f(),Qa=a("p"),Uc=l(`Note that the tokenizer automatically adds \u201Cspecial tokens\u201D (if the associated model relies on them) which are special
IDs the model sometimes uses.`),Ni=f(),Ja=a("p"),Xc=l("If we decode the previous sequence of ids,"),zi=f(),c(Bs.$$.fragment),Ci=f(),Ka=a("p"),Yc=l("we will see"),Di=f(),c(Hs.$$.fragment),Ii=f(),vt=a("p"),Qc=l("because this is the way a "),Za=a("a"),Jc=l("BertModel"),Kc=l(" is going to expect its inputs."),Bi=f(),ue=a("h2"),gt=a("a"),ao=a("span"),c(Fs.$$.fragment),Zc=f(),no=a("span"),eu=l("L"),Hi=f(),me=a("h3"),wt=a("a"),ro=a("span"),c(Ms.$$.fragment),tu=f(),oo=a("span"),su=l("labels"),Fi=f(),en=a("p"),au=l(`The labels are an optional argument which can be passed in order for the model to compute the loss itself. These labels
should be the expected prediction of the model: it will use the standard loss in order to compute the loss between its
predictions and the expected value (the label).`),Mi=f(),tn=a("p"),nu=l("These labels are different according to the model head, for example:"),Oi=f(),C=a("ul"),ve=a("li"),ru=l("For sequence classification models ("),sn=a("a"),ou=l("BertForSequenceClassification"),lu=l(`), the model expects a tensor of dimension
`),lo=a("code"),iu=l("(batch_size)"),hu=l(" with each value of the batch corresponding to the expected label of the entire sequence."),pu=f(),ge=a("li"),fu=l("For token classification models ("),an=a("a"),du=l("BertForTokenClassification"),cu=l(`), the model expects a tensor of dimension
`),io=a("code"),uu=l("(batch_size, seq_length)"),mu=l(" with each value corresponding to the expected label of each individual token."),vu=f(),we=a("li"),gu=l("For masked language modeling ("),nn=a("a"),wu=l("BertForMaskedLM"),bu=l("), the model expects a tensor of dimension "),ho=a("code"),_u=l("(batch_size, seq_length)"),$u=l(` with each value corresponding to the expected label of each individual token: the labels being the token
ID for the masked token, and values to be ignored for the rest (usually -100).`),ku=f(),x=a("li"),Eu=l("For sequence to sequence tasks,("),rn=a("a"),yu=l("BartForConditionalGeneration"),Au=l(", "),on=a("a"),qu=l("MBartForConditionalGeneration"),ju=l(`), the model
expects a tensor of dimension `),po=a("code"),Pu=l("(batch_size, tgt_seq_length)"),Tu=l(` with each value corresponding to the target sequences
associated with each input sequence. During training, both BART and T5 will make the appropriate
`),fo=a("code"),xu=l("decoder_input_ids"),Su=l(` and decoder attention masks internally. They usually do not need to be supplied. This does not
apply to models leveraging the Encoder-Decoder framework.`),Ri=f(),c(bt.$$.fragment),Vi=f(),_t=a("p"),Nu=l("The base models ("),ln=a("a"),zu=l("BertModel"),Cu=l(`) do not accept labels, as these are the base transformer models, simply outputting
features.`),Li=f(),be=a("h2"),$t=a("a"),co=a("span"),c(Os.$$.fragment),Du=f(),uo=a("span"),Iu=l("M"),Gi=f(),_e=a("h3"),kt=a("a"),mo=a("span"),c(Rs.$$.fragment),Bu=f(),vo=a("span"),Hu=l("masked language modeling"),Wi=f(),hn=a("p"),Fu=l(`A pretraining task where the model sees a corrupted version of the texts, usually done by
masking some tokens randomly, and has to predict the original text.`),Ui=f(),$e=a("h3"),Et=a("a"),go=a("span"),c(Vs.$$.fragment),Mu=f(),wo=a("span"),Ou=l("multimodal"),Xi=f(),pn=a("p"),Ru=l("A task that combines texts with another kind of inputs (for instance images)."),Yi=f(),ke=a("h2"),yt=a("a"),bo=a("span"),c(Ls.$$.fragment),Vu=f(),_o=a("span"),Lu=l("N"),Qi=f(),Ee=a("h3"),At=a("a"),$o=a("span"),c(Gs.$$.fragment),Gu=f(),ko=a("span"),Wu=l("Natural language generation"),Ji=f(),fn=a("p"),Uu=l("All tasks related to generating text (for instance talk with transformers, translation)."),Ki=f(),ye=a("h3"),qt=a("a"),Eo=a("span"),c(Ws.$$.fragment),Xu=f(),yo=a("span"),Yu=l("Natural language processing"),Zi=f(),dn=a("p"),Qu=l("A generic way to say \u201Cdeal with texts\u201D."),eh=f(),Ae=a("h3"),jt=a("a"),Ao=a("span"),c(Us.$$.fragment),Ju=f(),qo=a("span"),Ku=l("Natural language understanding"),th=f(),cn=a("p"),Zu=l(`All tasks related to understanding what is in a text (for instance classifying the
whole text, individual words).`),sh=f(),qe=a("h2"),Pt=a("a"),jo=a("span"),c(Xs.$$.fragment),em=f(),Po=a("span"),tm=l("P"),ah=f(),je=a("h3"),Tt=a("a"),To=a("span"),c(Ys.$$.fragment),sm=f(),xo=a("span"),am=l("pixel values"),nh=f(),j=a("p"),nm=l("A tensor of the numerical representations of an image that is passed to a model. The pixel values have a shape of ["),So=a("code"),rm=l("batch_size"),om=l(", "),No=a("code"),lm=l("num_channels"),im=l(", "),zo=a("code"),hm=l("height"),pm=l(", "),Co=a("code"),fm=l("width"),dm=l("], and are generated from a feature extractor."),rh=f(),Pe=a("h3"),xt=a("a"),Do=a("span"),c(Qs.$$.fragment),cm=f(),Io=a("span"),um=l("pooling"),oh=f(),un=a("p"),mm=l("An operation that reduces a matrix into a smaller matrix, either by taking the maximum or average of the pooled dimension(s). Pooling layers are commonly found between convolutional layers to downsample the feature representation."),lh=f(),Te=a("h3"),St=a("a"),Bo=a("span"),c(Js.$$.fragment),vm=f(),Ho=a("span"),gm=l("position IDs"),ih=f(),Nt=a("p"),wm=l(`Contrary to RNNs that have the position of each token embedded within them, transformers are unaware of the position of
each token. Therefore, the position IDs (`),Fo=a("code"),bm=l("position_ids"),_m=l(`) are used by the model to identify each token\u2019s position in the
list of tokens.`),hh=f(),zt=a("p"),$m=l("They are an optional parameter. If no "),Mo=a("code"),km=l("position_ids"),Em=l(` are passed to the model, the IDs are automatically created as
absolute positional embeddings.`),ph=f(),Ct=a("p"),ym=l("Absolute positional embeddings are selected in the range "),Oo=a("code"),Am=l("[0, config.max_position_embeddings - 1]"),qm=l(`. Some models use
other types of positional embeddings, such as sinusoidal position embeddings or relative position embeddings.`),fh=f(),xe=a("h3"),Dt=a("a"),Ro=a("span"),c(Ks.$$.fragment),jm=f(),Vo=a("span"),Pm=l("pretrained model"),dh=f(),H=a("p"),Tm=l(`A model that has been pretrained on some data (for instance all of Wikipedia). Pretraining methods involve a
self-supervised objective, which can be reading the text and trying to predict the next word (see `),mn=a("a"),xm=l(`causal language
modeling`),Sm=l(") or masking some words and trying to predict them (see "),vn=a("a"),Nm=l(`masked language
modeling`),zm=l(")."),ch=f(),gn=a("p"),Cm=l("Speech and vision models have their own pretraining objectives. For example, Wav2Vec2 is a speech model pretrained on a contrastive task which requires the model to identify the \u201Ctrue\u201D speech representation from a set of \u201Cfalse\u201D speech representations. On the other hand, BEiT is a vision model pretrained on a masked image modeling task which masks some of the image patches and requires the model to predict the masked patches (similar to the masked language modeling objective)."),uh=f(),Se=a("h2"),It=a("a"),Lo=a("span"),c(Zs.$$.fragment),Dm=f(),Go=a("span"),Im=l("R"),mh=f(),Ne=a("h3"),Bt=a("a"),Wo=a("span"),c(ea.$$.fragment),Bm=f(),Uo=a("span"),Hm=l("recurrent neural network"),vh=f(),wn=a("p"),Fm=l("A type of model that uses a loop over a layer to process texts."),gh=f(),ze=a("h2"),Ht=a("a"),Xo=a("span"),c(ta.$$.fragment),Mm=f(),Yo=a("span"),Om=l("S"),wh=f(),Ce=a("h3"),Ft=a("a"),Qo=a("span"),c(sa.$$.fragment),Rm=f(),Jo=a("span"),Vm=l("sampling rate"),bh=f(),bn=a("p"),Lm=l("A measurement in hertz of the number of samples (the audio signal) taken per second. The sampling rate is a result of discretizing a continuous signal such as speech."),_h=f(),De=a("h3"),Mt=a("a"),Ko=a("span"),c(aa.$$.fragment),Gm=f(),Zo=a("span"),Wm=l("self-attention"),$h=f(),_n=a("p"),Um=l("Each element of the input finds out which other elements of the input they should attend to."),kh=f(),Ie=a("h3"),Ot=a("a"),el=a("span"),c(na.$$.fragment),Xm=f(),tl=a("span"),Ym=l("sequence-to-sequence (seq2seq)"),Eh=f(),F=a("p"),Qm=l(`Models that generate a new sequence from an input, like translation models, or summarization models (such as
`),$n=a("a"),Jm=l("Bart"),Km=l(" or "),kn=a("a"),Zm=l("T5"),ev=l(")."),yh=f(),Be=a("h3"),Rt=a("a"),sl=a("span"),c(ra.$$.fragment),tv=f(),al=a("span"),sv=l("stride"),Ah=f(),M=a("p"),av=l("In "),En=a("a"),nv=l("convolution"),rv=l(" or "),yn=a("a"),ov=l("pooling"),lv=l(", the stride refers to the distance the kernel is moved over a matrix. A stride of 1 means the kernel is moved one pixel over at a time, and a stride of 2 means the kernel is moved two pixels over at a time."),qh=f(),He=a("h2"),Vt=a("a"),nl=a("span"),c(oa.$$.fragment),iv=f(),rl=a("span"),hv=l("T"),jh=f(),Fe=a("h3"),Lt=a("a"),ol=a("span"),c(la.$$.fragment),pv=f(),ll=a("span"),fv=l("token"),Ph=f(),An=a("p"),dv=l(`A part of a sentence, usually a word, but can also be a subword (non-common words are often split in subwords) or a
punctuation symbol.`),Th=f(),Me=a("h3"),Gt=a("a"),il=a("span"),c(ia.$$.fragment),cv=f(),hl=a("span"),uv=l("token Type IDs"),xh=f(),qn=a("p"),mv=l("Some models\u2019 purpose is to do classification on pairs of sentences or question answering."),Sh=f(),c(ha.$$.fragment),Nh=f(),O=a("p"),vv=l(`These require two different sequences to be joined in a single \u201Cinput_ids\u201D entry, which usually is performed with the
help of special tokens, such as the classifier (`),pl=a("code"),gv=l("[CLS]"),wv=l(") and separator ("),fl=a("code"),bv=l("[SEP]"),_v=l(`) tokens. For example, the BERT model
builds its two sequence input as such:`),zh=f(),c(pa.$$.fragment),Ch=f(),Wt=a("p"),$v=l("We can use our tokenizer to automatically generate such a sentence by passing the two sequences to "),dl=a("code"),kv=l("tokenizer"),Ev=l(` as two
arguments (and not a list, like before) like this:`),Dh=f(),c(fa.$$.fragment),Ih=f(),jn=a("p"),yv=l("which will return:"),Bh=f(),c(da.$$.fragment),Hh=f(),Pn=a("p"),Av=l(`This is enough for some models to understand where one sequence ends and where another begins. However, other models,
such as BERT, also deploy token type IDs (also called segment IDs). They are represented as a binary mask identifying
the two types of sequence in the model.`),Fh=f(),Tn=a("p"),qv=l("The tokenizer returns this mask as the \u201Ctoken_type_ids\u201D entry:"),Mh=f(),c(ca.$$.fragment),Oh=f(),R=a("p"),jv=l("The first sequence, the \u201Ccontext\u201D used for the question, has all its tokens represented by a "),cl=a("code"),Pv=l("0"),Tv=l(`, whereas the second
sequence, corresponding to the \u201Cquestion\u201D, has all its tokens represented by a `),ul=a("code"),xv=l("1"),Sv=l("."),Rh=f(),V=a("p"),Nv=l("Some models, like "),xn=a("a"),zv=l("XLNetModel"),Cv=l(" use an additional token represented by a "),ml=a("code"),Dv=l("2"),Iv=l("."),Vh=f(),Oe=a("h3"),Ut=a("a"),vl=a("span"),c(ua.$$.fragment),Bv=f(),gl=a("span"),Hv=l("transformer"),Lh=f(),Sn=a("p"),Fv=l("Self-attention based deep learning model architecture."),this.h()},l(e){const o=x_('[data-svelte="svelte-1phssyn"]',document.head);E=n(o,"META",{name:!0,content:!0}),o.forEach(t),Re=d(e),A=n(e,"H1",{class:!0});var ma=r(A);T=n(ma,"A",{id:!0,class:!0,href:!0});var Vv=r(T);Rn=n(Vv,"SPAN",{});var Lv=r(Rn);u(Kt.$$.fragment,Lv),Lv.forEach(t),Vv.forEach(t),Yp=d(ma),Vn=n(ma,"SPAN",{});var Gv=r(Vn);Qp=i(Gv,"Glossary"),Gv.forEach(t),ma.forEach(t),_l=d(e),wa=n(e,"P",{});var Wv=r(wa);Jp=i(Wv,`This glossary defines general machine learning and \u{1F917} Transformers terms to help you better understand the
documentation.`),Wv.forEach(t),$l=d(e),U=n(e,"H2",{class:!0});var Wh=r(U);Ve=n(Wh,"A",{id:!0,class:!0,href:!0});var Uv=r(Ve);Ln=n(Uv,"SPAN",{});var Xv=r(Ln);u(Zt.$$.fragment,Xv),Xv.forEach(t),Uv.forEach(t),Kp=d(Wh),Gn=n(Wh,"SPAN",{});var Yv=r(Gn);Zp=i(Yv,"A"),Yv.forEach(t),Wh.forEach(t),kl=d(e),X=n(e,"H3",{class:!0});var Uh=r(X);Le=n(Uh,"A",{id:!0,class:!0,href:!0});var Qv=r(Le);Wn=n(Qv,"SPAN",{});var Jv=r(Wn);u(es.$$.fragment,Jv),Jv.forEach(t),Qv.forEach(t),ef=d(Uh),Un=n(Uh,"SPAN",{});var Kv=r(Un);tf=i(Kv,"attention mask"),Kv.forEach(t),Uh.forEach(t),El=d(e),ba=n(e,"P",{});var Zv=r(ba);sf=i(Zv,"The attention mask is an optional argument used when batching sequences together."),Zv.forEach(t),yl=d(e),u(ts.$$.fragment,e),Al=d(e),_a=n(e,"P",{});var e1=r(_a);af=i(e1,"This argument indicates to the model which tokens should be attended to, and which should not."),e1.forEach(t),ql=d(e),$a=n(e,"P",{});var t1=r($a);nf=i(t1,"For example, consider these two sequences:"),t1.forEach(t),jl=d(e),u(ss.$$.fragment,e),Pl=d(e),ka=n(e,"P",{});var s1=r(ka);rf=i(s1,"The encoded versions have different lengths:"),s1.forEach(t),Tl=d(e),u(as.$$.fragment,e),xl=d(e),Ea=n(e,"P",{});var a1=r(Ea);of=i(a1,`Therefore, we can\u2019t put them together in the same tensor as-is. The first sequence needs to be padded up to the length
of the second one, or the second one needs to be truncated down to the length of the first one.`),a1.forEach(t),Sl=d(e),ya=n(e,"P",{});var n1=r(ya);lf=i(n1,`In the first case, the list of IDs will be extended by the padding indices. We can pass a list to the tokenizer and ask
it to pad like this:`),n1.forEach(t),Nl=d(e),u(ns.$$.fragment,e),zl=d(e),Aa=n(e,"P",{});var r1=r(Aa);hf=i(r1,"We can see that 0s have been added on the right of the first sentence to make it the same length as the second one:"),r1.forEach(t),Cl=d(e),u(rs.$$.fragment,e),Dl=d(e),S=n(e,"P",{});var Xt=r(S);pf=i(Xt,`This can then be converted into a tensor in PyTorch or TensorFlow. The attention mask is a binary tensor indicating the
position of the padded indices so that the model does not attend to them. For the `),qa=n(Xt,"A",{href:!0});var o1=r(qa);ff=i(o1,"BertTokenizer"),o1.forEach(t),df=i(Xt,", "),Xn=n(Xt,"CODE",{});var l1=r(Xn);cf=i(l1,"1"),l1.forEach(t),uf=i(Xt,` indicates a
value that should be attended to, while `),Yn=n(Xt,"CODE",{});var i1=r(Yn);mf=i(i1,"0"),i1.forEach(t),vf=i(Xt,` indicates a padded value. This attention mask is in the dictionary returned
by the tokenizer under the key \u201Cattention_mask\u201D:`),Xt.forEach(t),Il=d(e),u(os.$$.fragment,e),Bl=d(e),Y=n(e,"H3",{class:!0});var Xh=r(Y);Ge=n(Xh,"A",{id:!0,class:!0,href:!0});var h1=r(Ge);Qn=n(h1,"SPAN",{});var p1=r(Qn);u(ls.$$.fragment,p1),p1.forEach(t),h1.forEach(t),gf=d(Xh),Jn=n(Xh,"SPAN",{});var f1=r(Jn);wf=i(f1,"autoencoding models"),f1.forEach(t),Xh.forEach(t),Hl=d(e),is=n(e,"P",{});var Mv=r(is);bf=i(Mv,"see "),ja=n(Mv,"A",{href:!0});var d1=r(ja);_f=i(d1,"masked language modeling"),d1.forEach(t),Mv.forEach(t),Fl=d(e),Q=n(e,"H3",{class:!0});var Yh=r(Q);We=n(Yh,"A",{id:!0,class:!0,href:!0});var c1=r(We);Kn=n(c1,"SPAN",{});var u1=r(Kn);u(hs.$$.fragment,u1),u1.forEach(t),c1.forEach(t),$f=d(Yh),Zn=n(Yh,"SPAN",{});var m1=r(Zn);kf=i(m1,"autoregressive models"),m1.forEach(t),Yh.forEach(t),Ml=d(e),ps=n(e,"P",{});var Ov=r(ps);Ef=i(Ov,"see "),Pa=n(Ov,"A",{href:!0});var v1=r(Pa);yf=i(v1,"causal language modeling"),v1.forEach(t),Ov.forEach(t),Ol=d(e),J=n(e,"H2",{class:!0});var Qh=r(J);Ue=n(Qh,"A",{id:!0,class:!0,href:!0});var g1=r(Ue);er=n(g1,"SPAN",{});var w1=r(er);u(fs.$$.fragment,w1),w1.forEach(t),g1.forEach(t),Af=d(Qh),tr=n(Qh,"SPAN",{});var b1=r(tr);qf=i(b1,"B"),b1.forEach(t),Qh.forEach(t),Rl=d(e),K=n(e,"H3",{class:!0});var Jh=r(K);Xe=n(Jh,"A",{id:!0,class:!0,href:!0});var _1=r(Xe);sr=n(_1,"SPAN",{});var $1=r(sr);u(ds.$$.fragment,$1),$1.forEach(t),_1.forEach(t),jf=d(Jh),ar=n(Jh,"SPAN",{});var k1=r(ar);Pf=i(k1,"backbone"),k1.forEach(t),Jh.forEach(t),Vl=d(e),q=n(e,"P",{});var L=r(q);Tf=i(L,"The backbone is the network (embeddings and layers) that outputs the raw hidden states or features. It is usually connected to a "),Ta=n(L,"A",{href:!0});var E1=r(Ta);xf=i(E1,"head"),E1.forEach(t),Sf=i(L," which accepts the features as its input to make a prediction. For example, "),xa=n(L,"A",{href:!0});var y1=r(xa);Nf=i(y1,"ViTModel"),y1.forEach(t),zf=i(L," is a backbone without a specific head on top. Other models can also use "),nr=n(L,"CODE",{});var A1=r(nr);Cf=i(A1,"VitModel"),A1.forEach(t),Df=i(L," as a backbone such as "),Sa=n(L,"A",{href:!0});var q1=r(Sa);If=i(q1,"DPT"),q1.forEach(t),Bf=i(L,"."),L.forEach(t),Ll=d(e),Z=n(e,"H2",{class:!0});var Kh=r(Z);Ye=n(Kh,"A",{id:!0,class:!0,href:!0});var j1=r(Ye);rr=n(j1,"SPAN",{});var P1=r(rr);u(cs.$$.fragment,P1),P1.forEach(t),j1.forEach(t),Hf=d(Kh),or=n(Kh,"SPAN",{});var T1=r(or);Ff=i(T1,"C"),T1.forEach(t),Kh.forEach(t),Gl=d(e),ee=n(e,"H3",{class:!0});var Zh=r(ee);Qe=n(Zh,"A",{id:!0,class:!0,href:!0});var x1=r(Qe);lr=n(x1,"SPAN",{});var S1=r(lr);u(us.$$.fragment,S1),S1.forEach(t),x1.forEach(t),Mf=d(Zh),ir=n(Zh,"SPAN",{});var N1=r(ir);Of=i(N1,"channel"),N1.forEach(t),Zh.forEach(t),Wl=d(e),$=n(e,"P",{});var P=r($);Rf=i(P,"Color images are made up of some combination of values in three channels - red, green, and blue (RGB) - and grayscale images only have one channel. In \u{1F917} Transformers, the channel can be the first or last dimension of an image\u2019s tensor: ["),hr=n(P,"CODE",{});var z1=r(hr);Vf=i(z1,"n_channels"),z1.forEach(t),Lf=i(P,", "),pr=n(P,"CODE",{});var C1=r(pr);Gf=i(C1,"height"),C1.forEach(t),Wf=i(P,", "),fr=n(P,"CODE",{});var D1=r(fr);Uf=i(D1,"width"),D1.forEach(t),Xf=i(P,"] or ["),dr=n(P,"CODE",{});var I1=r(dr);Yf=i(I1,"height"),I1.forEach(t),Qf=i(P,", "),cr=n(P,"CODE",{});var B1=r(cr);Jf=i(B1,"width"),B1.forEach(t),Kf=i(P,", "),ur=n(P,"CODE",{});var H1=r(ur);Zf=i(H1,"n_channels"),H1.forEach(t),ed=i(P,"]."),P.forEach(t),Ul=d(e),te=n(e,"H3",{class:!0});var ep=r(te);Je=n(ep,"A",{id:!0,class:!0,href:!0});var F1=r(Je);mr=n(F1,"SPAN",{});var M1=r(mr);u(ms.$$.fragment,M1),M1.forEach(t),F1.forEach(t),td=d(ep),vr=n(ep,"SPAN",{});var O1=r(vr);sd=i(O1,"causal language modeling"),O1.forEach(t),ep.forEach(t),Xl=d(e),Na=n(e,"P",{});var R1=r(Na);ad=i(R1,`A pretraining task where the model reads the texts in order and has to predict the next word. It\u2019s usually done by
reading the whole sentence but using a mask inside the model to hide the future tokens at a certain timestep.`),R1.forEach(t),Yl=d(e),se=n(e,"H3",{class:!0});var tp=r(se);Ke=n(tp,"A",{id:!0,class:!0,href:!0});var V1=r(Ke);gr=n(V1,"SPAN",{});var L1=r(gr);u(vs.$$.fragment,L1),L1.forEach(t),V1.forEach(t),nd=d(tp),wr=n(tp,"SPAN",{});var G1=r(wr);rd=i(G1,"connectionist temporal classification (CTC)"),G1.forEach(t),tp.forEach(t),Ql=d(e),za=n(e,"P",{});var W1=r(za);od=i(W1,"An algorithm which allows a model to learn without knowing exactly how the input and output are aligned; CTC calculates the distribution of all possible outputs for a given input and chooses the most likely output from it. CTC is commonly used in speech recognition tasks because speech doesn\u2019t always cleanly align with the transcript for a variety of reasons such as a speaker\u2019s different speech rates."),W1.forEach(t),Jl=d(e),ae=n(e,"H3",{class:!0});var sp=r(ae);Ze=n(sp,"A",{id:!0,class:!0,href:!0});var U1=r(Ze);br=n(U1,"SPAN",{});var X1=r(br);u(gs.$$.fragment,X1),X1.forEach(t),U1.forEach(t),ld=d(sp),_r=n(sp,"SPAN",{});var Y1=r(_r);id=i(Y1,"convolution"),Y1.forEach(t),sp.forEach(t),Kl=d(e),Ca=n(e,"P",{});var Q1=r(Ca);hd=i(Q1,"A type of layer in a neural network where the input matrix is multiplied element-wise by a smaller matrix (kernel or filter) and the values are summed up in a new matrix. This is known as a convolutional operation which is repeated over the entire input matrix. Each operation is applied to a different segment of the input matrix. Convolutional neural networks (CNNs) are commonly used in computer vision."),Q1.forEach(t),Zl=d(e),ne=n(e,"H2",{class:!0});var ap=r(ne);et=n(ap,"A",{id:!0,class:!0,href:!0});var J1=r(et);$r=n(J1,"SPAN",{});var K1=r($r);u(ws.$$.fragment,K1),K1.forEach(t),J1.forEach(t),pd=d(ap),kr=n(ap,"SPAN",{});var Z1=r(kr);fd=i(Z1,"D"),Z1.forEach(t),ap.forEach(t),ei=d(e),re=n(e,"H3",{class:!0});var np=r(re);tt=n(np,"A",{id:!0,class:!0,href:!0});var eg=r(tt);Er=n(eg,"SPAN",{});var tg=r(Er);u(bs.$$.fragment,tg),tg.forEach(t),eg.forEach(t),dd=d(np),yr=n(np,"SPAN",{});var sg=r(yr);cd=i(sg,"decoder input IDs"),sg.forEach(t),np.forEach(t),ti=d(e),Da=n(e,"P",{});var ag=r(Da);ud=i(ag,`This input is specific to encoder-decoder models, and contains the input IDs that will be fed to the decoder. These
inputs should be used for sequence to sequence tasks, such as translation or summarization, and are usually built in a
way specific to each model.`),ag.forEach(t),si=d(e),N=n(e,"P",{});var Yt=r(N);md=i(Yt,"Most encoder-decoder models (BART, T5) create their "),Ar=n(Yt,"CODE",{});var ng=r(Ar);vd=i(ng,"decoder_input_ids"),ng.forEach(t),gd=i(Yt," on their own from the "),qr=n(Yt,"CODE",{});var rg=r(qr);wd=i(rg,"labels"),rg.forEach(t),bd=i(Yt,`. In such models,
passing the `),jr=n(Yt,"CODE",{});var og=r(jr);_d=i(og,"labels"),og.forEach(t),$d=i(Yt," is the preferred way to handle training."),Yt.forEach(t),ai=d(e),Ia=n(e,"P",{});var lg=r(Ia);kd=i(lg,"Please check each model\u2019s docs to see how they handle these input IDs for sequence to sequence training."),lg.forEach(t),ni=d(e),oe=n(e,"H3",{class:!0});var rp=r(oe);st=n(rp,"A",{id:!0,class:!0,href:!0});var ig=r(st);Pr=n(ig,"SPAN",{});var hg=r(Pr);u(_s.$$.fragment,hg),hg.forEach(t),ig.forEach(t),Ed=d(rp),Tr=n(rp,"SPAN",{});var pg=r(Tr);yd=i(pg,"deep learning"),pg.forEach(t),rp.forEach(t),ri=d(e),Ba=n(e,"P",{});var fg=r(Ba);Ad=i(fg,"Machine learning algorithms which uses neural networks with several layers."),fg.forEach(t),oi=d(e),le=n(e,"H2",{class:!0});var op=r(le);at=n(op,"A",{id:!0,class:!0,href:!0});var dg=r(at);xr=n(dg,"SPAN",{});var cg=r(xr);u($s.$$.fragment,cg),cg.forEach(t),dg.forEach(t),qd=d(op),Sr=n(op,"SPAN",{});var ug=r(Sr);jd=i(ug,"F"),ug.forEach(t),op.forEach(t),li=d(e),ie=n(e,"H3",{class:!0});var lp=r(ie);nt=n(lp,"A",{id:!0,class:!0,href:!0});var mg=r(nt);Nr=n(mg,"SPAN",{});var vg=r(Nr);u(ks.$$.fragment,vg),vg.forEach(t),mg.forEach(t),Pd=d(lp),zr=n(lp,"SPAN",{});var gg=r(zr);Td=i(gg,"feed forward chunking"),gg.forEach(t),lp.forEach(t),ii=d(e),rt=n(e,"P",{});var ip=r(rt);xd=i(ip,`In each residual attention block in transformers the self-attention layer is usually followed by 2 feed forward layers.
The intermediate embedding size of the feed forward layers is often bigger than the hidden size of the model (e.g., for
`),Cr=n(ip,"CODE",{});var wg=r(Cr);Sd=i(wg,"bert-base-uncased"),wg.forEach(t),Nd=i(ip,")."),ip.forEach(t),hi=d(e),_=n(e,"P",{});var k=r(_);zd=i(k,"For an input of size "),Dr=n(k,"CODE",{});var bg=r(Dr);Cd=i(bg,"[batch_size, sequence_length]"),bg.forEach(t),Dd=i(k,`, the memory required to store the intermediate feed forward
embeddings `),Ir=n(k,"CODE",{});var _g=r(Ir);Id=i(_g,"[batch_size, sequence_length, config.intermediate_size]"),_g.forEach(t),Bd=i(k,` can account for a large fraction of the memory
use. The authors of `),Es=n(k,"A",{href:!0,rel:!0});var $g=r(Es);Hd=i($g,"Reformer: The Efficient Transformer"),$g.forEach(t),Fd=i(k,` noticed that since the
computation is independent of the `),Br=n(k,"CODE",{});var kg=r(Br);Md=i(kg,"sequence_length"),kg.forEach(t),Od=i(k,` dimension, it is mathematically equivalent to compute the output
embeddings of both feed forward layers `),Hr=n(k,"CODE",{});var Eg=r(Hr);Rd=i(Eg,"[batch_size, config.hidden_size]_0, ..., [batch_size, config.hidden_size]_n"),Eg.forEach(t),Vd=i(k,`
individually and concat them afterward to `),Fr=n(k,"CODE",{});var yg=r(Fr);Ld=i(yg,"[batch_size, sequence_length, config.hidden_size]"),yg.forEach(t),Gd=i(k," with "),Mr=n(k,"CODE",{});var Ag=r(Mr);Wd=i(Ag,"n = sequence_length"),Ag.forEach(t),Ud=i(k,`, which trades increased computation time against reduced memory use, but yields a mathematically
`),Or=n(k,"STRONG",{});var qg=r(Or);Xd=i(qg,"equivalent"),qg.forEach(t),Yd=i(k," result."),k.forEach(t),pi=d(e),z=n(e,"P",{});var Qt=r(z);Qd=i(Qt,"For models employing the function "),Ha=n(Qt,"A",{href:!0});var jg=r(Ha);Jd=i(jg,"apply_chunking_to_forward()"),jg.forEach(t),Kd=i(Qt,", the "),Rr=n(Qt,"CODE",{});var Pg=r(Rr);Zd=i(Pg,"chunk_size"),Pg.forEach(t),ec=i(Qt,` defines the number of output
embeddings that are computed in parallel and thus defines the trade-off between memory and time complexity. If
`),Vr=n(Qt,"CODE",{});var Tg=r(Vr);tc=i(Tg,"chunk_size"),Tg.forEach(t),sc=i(Qt," is set to 0, no feed forward chunking is done."),Qt.forEach(t),fi=d(e),he=n(e,"H2",{class:!0});var hp=r(he);ot=n(hp,"A",{id:!0,class:!0,href:!0});var xg=r(ot);Lr=n(xg,"SPAN",{});var Sg=r(Lr);u(ys.$$.fragment,Sg),Sg.forEach(t),xg.forEach(t),ac=d(hp),Gr=n(hp,"SPAN",{});var Ng=r(Gr);nc=i(Ng,"H"),Ng.forEach(t),hp.forEach(t),di=d(e),pe=n(e,"H3",{class:!0});var pp=r(pe);lt=n(pp,"A",{id:!0,class:!0,href:!0});var zg=r(lt);Wr=n(zg,"SPAN",{});var Cg=r(Wr);u(As.$$.fragment,Cg),Cg.forEach(t),zg.forEach(t),rc=d(pp),Ur=n(pp,"SPAN",{});var Dg=r(Ur);oc=i(Dg,"head"),Dg.forEach(t),pp.forEach(t),ci=d(e),Fa=n(e,"P",{});var Ig=r(Fa);lc=i(Ig,"The model head refers to the last layer of a neural network that accepts the raw hidden states and projects them onto a different dimension. There is a different model head for each task. For example:"),Ig.forEach(t),ui=d(e),D=n(e,"UL",{});var Nn=r(D);it=n(Nn,"LI",{});var wl=r(it);Ma=n(wl,"A",{href:!0});var Bg=r(Ma);ic=i(Bg,"GPT2ForSequenceClassification"),Bg.forEach(t),hc=i(wl," is a sequence classification head - a linear layer - on top of the base "),Oa=n(wl,"A",{href:!0});var Hg=r(Oa);pc=i(Hg,"GPT2Model"),Hg.forEach(t),fc=i(wl,"."),wl.forEach(t),dc=d(Nn),I=n(Nn,"LI",{});var va=r(I);Ra=n(va,"A",{href:!0});var Fg=r(Ra);cc=i(Fg,"ViTForImageClassification"),Fg.forEach(t),uc=i(va," is an image classification head - a linear layer on top of the final hidden state of the "),Xr=n(va,"CODE",{});var Mg=r(Xr);mc=i(Mg,"CLS"),Mg.forEach(t),vc=i(va," token - on top of the base "),Va=n(va,"A",{href:!0});var Og=r(Va);gc=i(Og,"ViTModel"),Og.forEach(t),wc=i(va,"."),va.forEach(t),bc=d(Nn),B=n(Nn,"LI",{});var ga=r(B);La=n(ga,"A",{href:!0});var Rg=r(La);_c=i(Rg,"Wav2Vec2ForCTC"),Rg.forEach(t),$c=i(ga," ia a language modeling head with "),Ga=n(ga,"A",{href:!0});var Vg=r(Ga);kc=i(Vg,"CTC"),Vg.forEach(t),Ec=i(ga," on top of the base "),Wa=n(ga,"A",{href:!0});var Lg=r(Wa);yc=i(Lg,"Wav2Vec2Model"),Lg.forEach(t),Ac=i(ga,"."),ga.forEach(t),Nn.forEach(t),mi=d(e),fe=n(e,"H2",{class:!0});var fp=r(fe);ht=n(fp,"A",{id:!0,class:!0,href:!0});var Gg=r(ht);Yr=n(Gg,"SPAN",{});var Wg=r(Yr);u(qs.$$.fragment,Wg),Wg.forEach(t),Gg.forEach(t),qc=d(fp),Qr=n(fp,"SPAN",{});var Ug=r(Qr);jc=i(Ug,"I"),Ug.forEach(t),fp.forEach(t),vi=d(e),de=n(e,"H3",{class:!0});var dp=r(de);pt=n(dp,"A",{id:!0,class:!0,href:!0});var Xg=r(pt);Jr=n(Xg,"SPAN",{});var Yg=r(Jr);u(js.$$.fragment,Yg),Yg.forEach(t),Xg.forEach(t),Pc=d(dp),Kr=n(dp,"SPAN",{});var Qg=r(Kr);Tc=i(Qg,"image patch"),Qg.forEach(t),dp.forEach(t),gi=d(e),ft=n(e,"P",{});var cp=r(ft);xc=i(cp,"Vision-based Transformers models split an image into smaller patches which are linearly embedded, and then passed as a sequence to the model. You can find the "),Zr=n(cp,"CODE",{});var Jg=r(Zr);Sc=i(Jg,"patch_size"),Jg.forEach(t),Nc=i(cp," - or resolution - of the model in it\u2019s configuration."),cp.forEach(t),wi=d(e),ce=n(e,"H3",{class:!0});var up=r(ce);dt=n(up,"A",{id:!0,class:!0,href:!0});var Kg=r(dt);eo=n(Kg,"SPAN",{});var Zg=r(eo);u(Ps.$$.fragment,Zg),Zg.forEach(t),Kg.forEach(t),zc=d(up),to=n(up,"SPAN",{});var ew=r(to);Cc=i(ew,"input IDs"),ew.forEach(t),up.forEach(t),bi=d(e),Ua=n(e,"P",{});var tw=r(Ua);Dc=i(tw,`The input ids are often the only required parameters to be passed to the model as input. They are token indices,
numerical representations of tokens building the sequences that will be used as input by the model.`),tw.forEach(t),_i=d(e),u(Ts.$$.fragment,e),$i=d(e),ct=n(e,"P",{});var mp=r(ct);Ic=i(mp,`Each tokenizer works differently but the underlying mechanism remains the same. Here\u2019s an example using the BERT
tokenizer, which is a `),xs=n(mp,"A",{href:!0,rel:!0});var sw=r(xs);Bc=i(sw,"WordPiece"),sw.forEach(t),Hc=i(mp," tokenizer:"),mp.forEach(t),ki=d(e),u(Ss.$$.fragment,e),Ei=d(e),Xa=n(e,"P",{});var aw=r(Xa);Fc=i(aw,"The tokenizer takes care of splitting the sequence into tokens available in the tokenizer vocabulary."),aw.forEach(t),yi=d(e),u(Ns.$$.fragment,e),Ai=d(e),Ya=n(e,"P",{});var nw=r(Ya);Mc=i(nw,`The tokens are either words or subwords. Here for instance, \u201CVRAM\u201D wasn\u2019t in the model vocabulary, so it\u2019s been split
in \u201CV\u201D, \u201CRA\u201D and \u201CM\u201D. To indicate those tokens are not separate words but parts of the same word, a double-hash prefix
is added for \u201CRA\u201D and \u201CM\u201D:`),nw.forEach(t),qi=d(e),u(zs.$$.fragment,e),ji=d(e),ut=n(e,"P",{});var vp=r(ut);Oc=i(vp,`These tokens can then be converted into IDs which are understandable by the model. This can be done by directly feeding
the sentence to the tokenizer, which leverages the Rust implementation of `),Cs=n(vp,"A",{href:!0,rel:!0});var rw=r(Cs);Rc=i(rw,`\u{1F917}
Tokenizers`),rw.forEach(t),Vc=i(vp," for peak performance."),vp.forEach(t),Pi=d(e),u(Ds.$$.fragment,e),Ti=d(e),mt=n(e,"P",{});var gp=r(mt);Lc=i(gp,`The tokenizer returns a dictionary with all the arguments necessary for its corresponding model to work properly. The
token indices are under the key `),so=n(gp,"CODE",{});var ow=r(so);Gc=i(ow,"input_ids"),ow.forEach(t),Wc=i(gp,":"),gp.forEach(t),xi=d(e),u(Is.$$.fragment,e),Si=d(e),Qa=n(e,"P",{});var lw=r(Qa);Uc=i(lw,`Note that the tokenizer automatically adds \u201Cspecial tokens\u201D (if the associated model relies on them) which are special
IDs the model sometimes uses.`),lw.forEach(t),Ni=d(e),Ja=n(e,"P",{});var iw=r(Ja);Xc=i(iw,"If we decode the previous sequence of ids,"),iw.forEach(t),zi=d(e),u(Bs.$$.fragment,e),Ci=d(e),Ka=n(e,"P",{});var hw=r(Ka);Yc=i(hw,"we will see"),hw.forEach(t),Di=d(e),u(Hs.$$.fragment,e),Ii=d(e),vt=n(e,"P",{});var wp=r(vt);Qc=i(wp,"because this is the way a "),Za=n(wp,"A",{href:!0});var pw=r(Za);Jc=i(pw,"BertModel"),pw.forEach(t),Kc=i(wp," is going to expect its inputs."),wp.forEach(t),Bi=d(e),ue=n(e,"H2",{class:!0});var bp=r(ue);gt=n(bp,"A",{id:!0,class:!0,href:!0});var fw=r(gt);ao=n(fw,"SPAN",{});var dw=r(ao);u(Fs.$$.fragment,dw),dw.forEach(t),fw.forEach(t),Zc=d(bp),no=n(bp,"SPAN",{});var cw=r(no);eu=i(cw,"L"),cw.forEach(t),bp.forEach(t),Hi=d(e),me=n(e,"H3",{class:!0});var _p=r(me);wt=n(_p,"A",{id:!0,class:!0,href:!0});var uw=r(wt);ro=n(uw,"SPAN",{});var mw=r(ro);u(Ms.$$.fragment,mw),mw.forEach(t),uw.forEach(t),tu=d(_p),oo=n(_p,"SPAN",{});var vw=r(oo);su=i(vw,"labels"),vw.forEach(t),_p.forEach(t),Fi=d(e),en=n(e,"P",{});var gw=r(en);au=i(gw,`The labels are an optional argument which can be passed in order for the model to compute the loss itself. These labels
should be the expected prediction of the model: it will use the standard loss in order to compute the loss between its
predictions and the expected value (the label).`),gw.forEach(t),Mi=d(e),tn=n(e,"P",{});var ww=r(tn);nu=i(ww,"These labels are different according to the model head, for example:"),ww.forEach(t),Oi=d(e),C=n(e,"UL",{});var Jt=r(C);ve=n(Jt,"LI",{});var zn=r(ve);ru=i(zn,"For sequence classification models ("),sn=n(zn,"A",{href:!0});var bw=r(sn);ou=i(bw,"BertForSequenceClassification"),bw.forEach(t),lu=i(zn,`), the model expects a tensor of dimension
`),lo=n(zn,"CODE",{});var _w=r(lo);iu=i(_w,"(batch_size)"),_w.forEach(t),hu=i(zn," with each value of the batch corresponding to the expected label of the entire sequence."),zn.forEach(t),pu=d(Jt),ge=n(Jt,"LI",{});var Cn=r(ge);fu=i(Cn,"For token classification models ("),an=n(Cn,"A",{href:!0});var $w=r(an);du=i($w,"BertForTokenClassification"),$w.forEach(t),cu=i(Cn,`), the model expects a tensor of dimension
`),io=n(Cn,"CODE",{});var kw=r(io);uu=i(kw,"(batch_size, seq_length)"),kw.forEach(t),mu=i(Cn," with each value corresponding to the expected label of each individual token."),Cn.forEach(t),vu=d(Jt),we=n(Jt,"LI",{});var Dn=r(we);gu=i(Dn,"For masked language modeling ("),nn=n(Dn,"A",{href:!0});var Ew=r(nn);wu=i(Ew,"BertForMaskedLM"),Ew.forEach(t),bu=i(Dn,"), the model expects a tensor of dimension "),ho=n(Dn,"CODE",{});var yw=r(ho);_u=i(yw,"(batch_size, seq_length)"),yw.forEach(t),$u=i(Dn,` with each value corresponding to the expected label of each individual token: the labels being the token
ID for the masked token, and values to be ignored for the rest (usually -100).`),Dn.forEach(t),ku=d(Jt),x=n(Jt,"LI",{});var G=r(x);Eu=i(G,"For sequence to sequence tasks,("),rn=n(G,"A",{href:!0});var Aw=r(rn);yu=i(Aw,"BartForConditionalGeneration"),Aw.forEach(t),Au=i(G,", "),on=n(G,"A",{href:!0});var qw=r(on);qu=i(qw,"MBartForConditionalGeneration"),qw.forEach(t),ju=i(G,`), the model
expects a tensor of dimension `),po=n(G,"CODE",{});var jw=r(po);Pu=i(jw,"(batch_size, tgt_seq_length)"),jw.forEach(t),Tu=i(G,` with each value corresponding to the target sequences
associated with each input sequence. During training, both BART and T5 will make the appropriate
`),fo=n(G,"CODE",{});var Pw=r(fo);xu=i(Pw,"decoder_input_ids"),Pw.forEach(t),Su=i(G,` and decoder attention masks internally. They usually do not need to be supplied. This does not
apply to models leveraging the Encoder-Decoder framework.`),G.forEach(t),Jt.forEach(t),Ri=d(e),u(bt.$$.fragment,e),Vi=d(e),_t=n(e,"P",{});var $p=r(_t);Nu=i($p,"The base models ("),ln=n($p,"A",{href:!0});var Tw=r(ln);zu=i(Tw,"BertModel"),Tw.forEach(t),Cu=i($p,`) do not accept labels, as these are the base transformer models, simply outputting
features.`),$p.forEach(t),Li=d(e),be=n(e,"H2",{class:!0});var kp=r(be);$t=n(kp,"A",{id:!0,class:!0,href:!0});var xw=r($t);co=n(xw,"SPAN",{});var Sw=r(co);u(Os.$$.fragment,Sw),Sw.forEach(t),xw.forEach(t),Du=d(kp),uo=n(kp,"SPAN",{});var Nw=r(uo);Iu=i(Nw,"M"),Nw.forEach(t),kp.forEach(t),Gi=d(e),_e=n(e,"H3",{class:!0});var Ep=r(_e);kt=n(Ep,"A",{id:!0,class:!0,href:!0});var zw=r(kt);mo=n(zw,"SPAN",{});var Cw=r(mo);u(Rs.$$.fragment,Cw),Cw.forEach(t),zw.forEach(t),Bu=d(Ep),vo=n(Ep,"SPAN",{});var Dw=r(vo);Hu=i(Dw,"masked language modeling"),Dw.forEach(t),Ep.forEach(t),Wi=d(e),hn=n(e,"P",{});var Iw=r(hn);Fu=i(Iw,`A pretraining task where the model sees a corrupted version of the texts, usually done by
masking some tokens randomly, and has to predict the original text.`),Iw.forEach(t),Ui=d(e),$e=n(e,"H3",{class:!0});var yp=r($e);Et=n(yp,"A",{id:!0,class:!0,href:!0});var Bw=r(Et);go=n(Bw,"SPAN",{});var Hw=r(go);u(Vs.$$.fragment,Hw),Hw.forEach(t),Bw.forEach(t),Mu=d(yp),wo=n(yp,"SPAN",{});var Fw=r(wo);Ou=i(Fw,"multimodal"),Fw.forEach(t),yp.forEach(t),Xi=d(e),pn=n(e,"P",{});var Mw=r(pn);Ru=i(Mw,"A task that combines texts with another kind of inputs (for instance images)."),Mw.forEach(t),Yi=d(e),ke=n(e,"H2",{class:!0});var Ap=r(ke);yt=n(Ap,"A",{id:!0,class:!0,href:!0});var Ow=r(yt);bo=n(Ow,"SPAN",{});var Rw=r(bo);u(Ls.$$.fragment,Rw),Rw.forEach(t),Ow.forEach(t),Vu=d(Ap),_o=n(Ap,"SPAN",{});var Vw=r(_o);Lu=i(Vw,"N"),Vw.forEach(t),Ap.forEach(t),Qi=d(e),Ee=n(e,"H3",{class:!0});var qp=r(Ee);At=n(qp,"A",{id:!0,class:!0,href:!0});var Lw=r(At);$o=n(Lw,"SPAN",{});var Gw=r($o);u(Gs.$$.fragment,Gw),Gw.forEach(t),Lw.forEach(t),Gu=d(qp),ko=n(qp,"SPAN",{});var Ww=r(ko);Wu=i(Ww,"Natural language generation"),Ww.forEach(t),qp.forEach(t),Ji=d(e),fn=n(e,"P",{});var Uw=r(fn);Uu=i(Uw,"All tasks related to generating text (for instance talk with transformers, translation)."),Uw.forEach(t),Ki=d(e),ye=n(e,"H3",{class:!0});var jp=r(ye);qt=n(jp,"A",{id:!0,class:!0,href:!0});var Xw=r(qt);Eo=n(Xw,"SPAN",{});var Yw=r(Eo);u(Ws.$$.fragment,Yw),Yw.forEach(t),Xw.forEach(t),Xu=d(jp),yo=n(jp,"SPAN",{});var Qw=r(yo);Yu=i(Qw,"Natural language processing"),Qw.forEach(t),jp.forEach(t),Zi=d(e),dn=n(e,"P",{});var Jw=r(dn);Qu=i(Jw,"A generic way to say \u201Cdeal with texts\u201D."),Jw.forEach(t),eh=d(e),Ae=n(e,"H3",{class:!0});var Pp=r(Ae);jt=n(Pp,"A",{id:!0,class:!0,href:!0});var Kw=r(jt);Ao=n(Kw,"SPAN",{});var Zw=r(Ao);u(Us.$$.fragment,Zw),Zw.forEach(t),Kw.forEach(t),Ju=d(Pp),qo=n(Pp,"SPAN",{});var eb=r(qo);Ku=i(eb,"Natural language understanding"),eb.forEach(t),Pp.forEach(t),th=d(e),cn=n(e,"P",{});var tb=r(cn);Zu=i(tb,`All tasks related to understanding what is in a text (for instance classifying the
whole text, individual words).`),tb.forEach(t),sh=d(e),qe=n(e,"H2",{class:!0});var Tp=r(qe);Pt=n(Tp,"A",{id:!0,class:!0,href:!0});var sb=r(Pt);jo=n(sb,"SPAN",{});var ab=r(jo);u(Xs.$$.fragment,ab),ab.forEach(t),sb.forEach(t),em=d(Tp),Po=n(Tp,"SPAN",{});var nb=r(Po);tm=i(nb,"P"),nb.forEach(t),Tp.forEach(t),ah=d(e),je=n(e,"H3",{class:!0});var xp=r(je);Tt=n(xp,"A",{id:!0,class:!0,href:!0});var rb=r(Tt);To=n(rb,"SPAN",{});var ob=r(To);u(Ys.$$.fragment,ob),ob.forEach(t),rb.forEach(t),sm=d(xp),xo=n(xp,"SPAN",{});var lb=r(xo);am=i(lb,"pixel values"),lb.forEach(t),xp.forEach(t),nh=d(e),j=n(e,"P",{});var W=r(j);nm=i(W,"A tensor of the numerical representations of an image that is passed to a model. The pixel values have a shape of ["),So=n(W,"CODE",{});var ib=r(So);rm=i(ib,"batch_size"),ib.forEach(t),om=i(W,", "),No=n(W,"CODE",{});var hb=r(No);lm=i(hb,"num_channels"),hb.forEach(t),im=i(W,", "),zo=n(W,"CODE",{});var pb=r(zo);hm=i(pb,"height"),pb.forEach(t),pm=i(W,", "),Co=n(W,"CODE",{});var fb=r(Co);fm=i(fb,"width"),fb.forEach(t),dm=i(W,"], and are generated from a feature extractor."),W.forEach(t),rh=d(e),Pe=n(e,"H3",{class:!0});var Sp=r(Pe);xt=n(Sp,"A",{id:!0,class:!0,href:!0});var db=r(xt);Do=n(db,"SPAN",{});var cb=r(Do);u(Qs.$$.fragment,cb),cb.forEach(t),db.forEach(t),cm=d(Sp),Io=n(Sp,"SPAN",{});var ub=r(Io);um=i(ub,"pooling"),ub.forEach(t),Sp.forEach(t),oh=d(e),un=n(e,"P",{});var mb=r(un);mm=i(mb,"An operation that reduces a matrix into a smaller matrix, either by taking the maximum or average of the pooled dimension(s). Pooling layers are commonly found between convolutional layers to downsample the feature representation."),mb.forEach(t),lh=d(e),Te=n(e,"H3",{class:!0});var Np=r(Te);St=n(Np,"A",{id:!0,class:!0,href:!0});var vb=r(St);Bo=n(vb,"SPAN",{});var gb=r(Bo);u(Js.$$.fragment,gb),gb.forEach(t),vb.forEach(t),vm=d(Np),Ho=n(Np,"SPAN",{});var wb=r(Ho);gm=i(wb,"position IDs"),wb.forEach(t),Np.forEach(t),ih=d(e),Nt=n(e,"P",{});var zp=r(Nt);wm=i(zp,`Contrary to RNNs that have the position of each token embedded within them, transformers are unaware of the position of
each token. Therefore, the position IDs (`),Fo=n(zp,"CODE",{});var bb=r(Fo);bm=i(bb,"position_ids"),bb.forEach(t),_m=i(zp,`) are used by the model to identify each token\u2019s position in the
list of tokens.`),zp.forEach(t),hh=d(e),zt=n(e,"P",{});var Cp=r(zt);$m=i(Cp,"They are an optional parameter. If no "),Mo=n(Cp,"CODE",{});var _b=r(Mo);km=i(_b,"position_ids"),_b.forEach(t),Em=i(Cp,` are passed to the model, the IDs are automatically created as
absolute positional embeddings.`),Cp.forEach(t),ph=d(e),Ct=n(e,"P",{});var Dp=r(Ct);ym=i(Dp,"Absolute positional embeddings are selected in the range "),Oo=n(Dp,"CODE",{});var $b=r(Oo);Am=i($b,"[0, config.max_position_embeddings - 1]"),$b.forEach(t),qm=i(Dp,`. Some models use
other types of positional embeddings, such as sinusoidal position embeddings or relative position embeddings.`),Dp.forEach(t),fh=d(e),xe=n(e,"H3",{class:!0});var Ip=r(xe);Dt=n(Ip,"A",{id:!0,class:!0,href:!0});var kb=r(Dt);Ro=n(kb,"SPAN",{});var Eb=r(Ro);u(Ks.$$.fragment,Eb),Eb.forEach(t),kb.forEach(t),jm=d(Ip),Vo=n(Ip,"SPAN",{});var yb=r(Vo);Pm=i(yb,"pretrained model"),yb.forEach(t),Ip.forEach(t),dh=d(e),H=n(e,"P",{});var In=r(H);Tm=i(In,`A model that has been pretrained on some data (for instance all of Wikipedia). Pretraining methods involve a
self-supervised objective, which can be reading the text and trying to predict the next word (see `),mn=n(In,"A",{href:!0});var Ab=r(mn);xm=i(Ab,`causal language
modeling`),Ab.forEach(t),Sm=i(In,") or masking some words and trying to predict them (see "),vn=n(In,"A",{href:!0});var qb=r(vn);Nm=i(qb,`masked language
modeling`),qb.forEach(t),zm=i(In,")."),In.forEach(t),ch=d(e),gn=n(e,"P",{});var jb=r(gn);Cm=i(jb,"Speech and vision models have their own pretraining objectives. For example, Wav2Vec2 is a speech model pretrained on a contrastive task which requires the model to identify the \u201Ctrue\u201D speech representation from a set of \u201Cfalse\u201D speech representations. On the other hand, BEiT is a vision model pretrained on a masked image modeling task which masks some of the image patches and requires the model to predict the masked patches (similar to the masked language modeling objective)."),jb.forEach(t),uh=d(e),Se=n(e,"H2",{class:!0});var Bp=r(Se);It=n(Bp,"A",{id:!0,class:!0,href:!0});var Pb=r(It);Lo=n(Pb,"SPAN",{});var Tb=r(Lo);u(Zs.$$.fragment,Tb),Tb.forEach(t),Pb.forEach(t),Dm=d(Bp),Go=n(Bp,"SPAN",{});var xb=r(Go);Im=i(xb,"R"),xb.forEach(t),Bp.forEach(t),mh=d(e),Ne=n(e,"H3",{class:!0});var Hp=r(Ne);Bt=n(Hp,"A",{id:!0,class:!0,href:!0});var Sb=r(Bt);Wo=n(Sb,"SPAN",{});var Nb=r(Wo);u(ea.$$.fragment,Nb),Nb.forEach(t),Sb.forEach(t),Bm=d(Hp),Uo=n(Hp,"SPAN",{});var zb=r(Uo);Hm=i(zb,"recurrent neural network"),zb.forEach(t),Hp.forEach(t),vh=d(e),wn=n(e,"P",{});var Cb=r(wn);Fm=i(Cb,"A type of model that uses a loop over a layer to process texts."),Cb.forEach(t),gh=d(e),ze=n(e,"H2",{class:!0});var Fp=r(ze);Ht=n(Fp,"A",{id:!0,class:!0,href:!0});var Db=r(Ht);Xo=n(Db,"SPAN",{});var Ib=r(Xo);u(ta.$$.fragment,Ib),Ib.forEach(t),Db.forEach(t),Mm=d(Fp),Yo=n(Fp,"SPAN",{});var Bb=r(Yo);Om=i(Bb,"S"),Bb.forEach(t),Fp.forEach(t),wh=d(e),Ce=n(e,"H3",{class:!0});var Mp=r(Ce);Ft=n(Mp,"A",{id:!0,class:!0,href:!0});var Hb=r(Ft);Qo=n(Hb,"SPAN",{});var Fb=r(Qo);u(sa.$$.fragment,Fb),Fb.forEach(t),Hb.forEach(t),Rm=d(Mp),Jo=n(Mp,"SPAN",{});var Mb=r(Jo);Vm=i(Mb,"sampling rate"),Mb.forEach(t),Mp.forEach(t),bh=d(e),bn=n(e,"P",{});var Ob=r(bn);Lm=i(Ob,"A measurement in hertz of the number of samples (the audio signal) taken per second. The sampling rate is a result of discretizing a continuous signal such as speech."),Ob.forEach(t),_h=d(e),De=n(e,"H3",{class:!0});var Op=r(De);Mt=n(Op,"A",{id:!0,class:!0,href:!0});var Rb=r(Mt);Ko=n(Rb,"SPAN",{});var Vb=r(Ko);u(aa.$$.fragment,Vb),Vb.forEach(t),Rb.forEach(t),Gm=d(Op),Zo=n(Op,"SPAN",{});var Lb=r(Zo);Wm=i(Lb,"self-attention"),Lb.forEach(t),Op.forEach(t),$h=d(e),_n=n(e,"P",{});var Gb=r(_n);Um=i(Gb,"Each element of the input finds out which other elements of the input they should attend to."),Gb.forEach(t),kh=d(e),Ie=n(e,"H3",{class:!0});var Rp=r(Ie);Ot=n(Rp,"A",{id:!0,class:!0,href:!0});var Wb=r(Ot);el=n(Wb,"SPAN",{});var Ub=r(el);u(na.$$.fragment,Ub),Ub.forEach(t),Wb.forEach(t),Xm=d(Rp),tl=n(Rp,"SPAN",{});var Xb=r(tl);Ym=i(Xb,"sequence-to-sequence (seq2seq)"),Xb.forEach(t),Rp.forEach(t),Eh=d(e),F=n(e,"P",{});var Bn=r(F);Qm=i(Bn,`Models that generate a new sequence from an input, like translation models, or summarization models (such as
`),$n=n(Bn,"A",{href:!0});var Yb=r($n);Jm=i(Yb,"Bart"),Yb.forEach(t),Km=i(Bn," or "),kn=n(Bn,"A",{href:!0});var Qb=r(kn);Zm=i(Qb,"T5"),Qb.forEach(t),ev=i(Bn,")."),Bn.forEach(t),yh=d(e),Be=n(e,"H3",{class:!0});var Vp=r(Be);Rt=n(Vp,"A",{id:!0,class:!0,href:!0});var Jb=r(Rt);sl=n(Jb,"SPAN",{});var Kb=r(sl);u(ra.$$.fragment,Kb),Kb.forEach(t),Jb.forEach(t),tv=d(Vp),al=n(Vp,"SPAN",{});var Zb=r(al);sv=i(Zb,"stride"),Zb.forEach(t),Vp.forEach(t),Ah=d(e),M=n(e,"P",{});var Hn=r(M);av=i(Hn,"In "),En=n(Hn,"A",{href:!0});var e_=r(En);nv=i(e_,"convolution"),e_.forEach(t),rv=i(Hn," or "),yn=n(Hn,"A",{href:!0});var t_=r(yn);ov=i(t_,"pooling"),t_.forEach(t),lv=i(Hn,", the stride refers to the distance the kernel is moved over a matrix. A stride of 1 means the kernel is moved one pixel over at a time, and a stride of 2 means the kernel is moved two pixels over at a time."),Hn.forEach(t),qh=d(e),He=n(e,"H2",{class:!0});var Lp=r(He);Vt=n(Lp,"A",{id:!0,class:!0,href:!0});var s_=r(Vt);nl=n(s_,"SPAN",{});var a_=r(nl);u(oa.$$.fragment,a_),a_.forEach(t),s_.forEach(t),iv=d(Lp),rl=n(Lp,"SPAN",{});var n_=r(rl);hv=i(n_,"T"),n_.forEach(t),Lp.forEach(t),jh=d(e),Fe=n(e,"H3",{class:!0});var Gp=r(Fe);Lt=n(Gp,"A",{id:!0,class:!0,href:!0});var r_=r(Lt);ol=n(r_,"SPAN",{});var o_=r(ol);u(la.$$.fragment,o_),o_.forEach(t),r_.forEach(t),pv=d(Gp),ll=n(Gp,"SPAN",{});var l_=r(ll);fv=i(l_,"token"),l_.forEach(t),Gp.forEach(t),Ph=d(e),An=n(e,"P",{});var i_=r(An);dv=i(i_,`A part of a sentence, usually a word, but can also be a subword (non-common words are often split in subwords) or a
punctuation symbol.`),i_.forEach(t),Th=d(e),Me=n(e,"H3",{class:!0});var Wp=r(Me);Gt=n(Wp,"A",{id:!0,class:!0,href:!0});var h_=r(Gt);il=n(h_,"SPAN",{});var p_=r(il);u(ia.$$.fragment,p_),p_.forEach(t),h_.forEach(t),cv=d(Wp),hl=n(Wp,"SPAN",{});var f_=r(hl);uv=i(f_,"token Type IDs"),f_.forEach(t),Wp.forEach(t),xh=d(e),qn=n(e,"P",{});var d_=r(qn);mv=i(d_,"Some models\u2019 purpose is to do classification on pairs of sentences or question answering."),d_.forEach(t),Sh=d(e),u(ha.$$.fragment,e),Nh=d(e),O=n(e,"P",{});var Fn=r(O);vv=i(Fn,`These require two different sequences to be joined in a single \u201Cinput_ids\u201D entry, which usually is performed with the
help of special tokens, such as the classifier (`),pl=n(Fn,"CODE",{});var c_=r(pl);gv=i(c_,"[CLS]"),c_.forEach(t),wv=i(Fn,") and separator ("),fl=n(Fn,"CODE",{});var u_=r(fl);bv=i(u_,"[SEP]"),u_.forEach(t),_v=i(Fn,`) tokens. For example, the BERT model
builds its two sequence input as such:`),Fn.forEach(t),zh=d(e),u(pa.$$.fragment,e),Ch=d(e),Wt=n(e,"P",{});var Up=r(Wt);$v=i(Up,"We can use our tokenizer to automatically generate such a sentence by passing the two sequences to "),dl=n(Up,"CODE",{});var m_=r(dl);kv=i(m_,"tokenizer"),m_.forEach(t),Ev=i(Up,` as two
arguments (and not a list, like before) like this:`),Up.forEach(t),Dh=d(e),u(fa.$$.fragment,e),Ih=d(e),jn=n(e,"P",{});var v_=r(jn);yv=i(v_,"which will return:"),v_.forEach(t),Bh=d(e),u(da.$$.fragment,e),Hh=d(e),Pn=n(e,"P",{});var g_=r(Pn);Av=i(g_,`This is enough for some models to understand where one sequence ends and where another begins. However, other models,
such as BERT, also deploy token type IDs (also called segment IDs). They are represented as a binary mask identifying
the two types of sequence in the model.`),g_.forEach(t),Fh=d(e),Tn=n(e,"P",{});var w_=r(Tn);qv=i(w_,"The tokenizer returns this mask as the \u201Ctoken_type_ids\u201D entry:"),w_.forEach(t),Mh=d(e),u(ca.$$.fragment,e),Oh=d(e),R=n(e,"P",{});var Mn=r(R);jv=i(Mn,"The first sequence, the \u201Ccontext\u201D used for the question, has all its tokens represented by a "),cl=n(Mn,"CODE",{});var b_=r(cl);Pv=i(b_,"0"),b_.forEach(t),Tv=i(Mn,`, whereas the second
sequence, corresponding to the \u201Cquestion\u201D, has all its tokens represented by a `),ul=n(Mn,"CODE",{});var __=r(ul);xv=i(__,"1"),__.forEach(t),Sv=i(Mn,"."),Mn.forEach(t),Rh=d(e),V=n(e,"P",{});var On=r(V);Nv=i(On,"Some models, like "),xn=n(On,"A",{href:!0});var $_=r(xn);zv=i($_,"XLNetModel"),$_.forEach(t),Cv=i(On," use an additional token represented by a "),ml=n(On,"CODE",{});var k_=r(ml);Dv=i(k_,"2"),k_.forEach(t),Iv=i(On,"."),On.forEach(t),Vh=d(e),Oe=n(e,"H3",{class:!0});var Xp=r(Oe);Ut=n(Xp,"A",{id:!0,class:!0,href:!0});var E_=r(Ut);vl=n(E_,"SPAN",{});var y_=r(vl);u(ua.$$.fragment,y_),y_.forEach(t),E_.forEach(t),Bv=d(Xp),gl=n(Xp,"SPAN",{});var A_=r(gl);Hv=i(A_,"transformer"),A_.forEach(t),Xp.forEach(t),Lh=d(e),Sn=n(e,"P",{});var q_=r(Sn);Fv=i(q_,"Self-attention based deep learning model architecture."),q_.forEach(t),this.h()},h(){p(E,"name","hf:doc:metadata"),p(E,"content",JSON.stringify(D_)),p(T,"id","glossary"),p(T,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(T,"href","#glossary"),p(A,"class","relative group"),p(Ve,"id","a"),p(Ve,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Ve,"href","#a"),p(U,"class","relative group"),p(Le,"id","attention-mask"),p(Le,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Le,"href","#attention-mask"),p(X,"class","relative group"),p(qa,"href","/docs/transformers/main/en/model_doc/bert#transformers.BertTokenizer"),p(Ge,"id","autoencoding-models"),p(Ge,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Ge,"href","#autoencoding-models"),p(Y,"class","relative group"),p(ja,"href","#masked-language-modeling"),p(We,"id","autoregressive-models"),p(We,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(We,"href","#autoregressive-models"),p(Q,"class","relative group"),p(Pa,"href","#causal-language-modeling"),p(Ue,"id","b"),p(Ue,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Ue,"href","#b"),p(J,"class","relative group"),p(Xe,"id","backbone"),p(Xe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Xe,"href","#backbone"),p(K,"class","relative group"),p(Ta,"href","#head"),p(xa,"href","/docs/transformers/main/en/model_doc/vit#transformers.ViTModel"),p(Sa,"href","model_doc/dpt"),p(Ye,"id","c"),p(Ye,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Ye,"href","#c"),p(Z,"class","relative group"),p(Qe,"id","channel"),p(Qe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Qe,"href","#channel"),p(ee,"class","relative group"),p(Je,"id","causal-language-modeling"),p(Je,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Je,"href","#causal-language-modeling"),p(te,"class","relative group"),p(Ke,"id","connectionist-temporal-classification-ctc"),p(Ke,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Ke,"href","#connectionist-temporal-classification-ctc"),p(se,"class","relative group"),p(Ze,"id","convolution"),p(Ze,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Ze,"href","#convolution"),p(ae,"class","relative group"),p(et,"id","d"),p(et,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(et,"href","#d"),p(ne,"class","relative group"),p(tt,"id","decoder-input-ids"),p(tt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(tt,"href","#decoder-input-ids"),p(re,"class","relative group"),p(st,"id","deep-learning"),p(st,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(st,"href","#deep-learning"),p(oe,"class","relative group"),p(at,"id","f"),p(at,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(at,"href","#f"),p(le,"class","relative group"),p(nt,"id","feed-forward-chunking"),p(nt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(nt,"href","#feed-forward-chunking"),p(ie,"class","relative group"),p(Es,"href","https://arxiv.org/abs/2001.04451"),p(Es,"rel","nofollow"),p(Ha,"href","/docs/transformers/main/en/internal/modeling_utils#transformers.apply_chunking_to_forward"),p(ot,"id","h"),p(ot,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(ot,"href","#h"),p(he,"class","relative group"),p(lt,"id","head"),p(lt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(lt,"href","#head"),p(pe,"class","relative group"),p(Ma,"href","/docs/transformers/main/en/model_doc/gpt2#transformers.GPT2ForSequenceClassification"),p(Oa,"href","/docs/transformers/main/en/model_doc/gpt2#transformers.GPT2Model"),p(Ra,"href","/docs/transformers/main/en/model_doc/vit#transformers.ViTForImageClassification"),p(Va,"href","/docs/transformers/main/en/model_doc/vit#transformers.ViTModel"),p(La,"href","/docs/transformers/main/en/model_doc/wav2vec2#transformers.Wav2Vec2ForCTC"),p(Ga,"href","#connectionist-temporal-classification-(CTC)"),p(Wa,"href","/docs/transformers/main/en/model_doc/wav2vec2#transformers.Wav2Vec2Model"),p(ht,"id","i"),p(ht,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(ht,"href","#i"),p(fe,"class","relative group"),p(pt,"id","image-patch"),p(pt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(pt,"href","#image-patch"),p(de,"class","relative group"),p(dt,"id","input-ids"),p(dt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(dt,"href","#input-ids"),p(ce,"class","relative group"),p(xs,"href","https://arxiv.org/pdf/1609.08144.pdf"),p(xs,"rel","nofollow"),p(Cs,"href","https://github.com/huggingface/tokenizers"),p(Cs,"rel","nofollow"),p(Za,"href","/docs/transformers/main/en/model_doc/bert#transformers.BertModel"),p(gt,"id","l"),p(gt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(gt,"href","#l"),p(ue,"class","relative group"),p(wt,"id","labels"),p(wt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(wt,"href","#labels"),p(me,"class","relative group"),p(sn,"href","/docs/transformers/main/en/model_doc/bert#transformers.BertForSequenceClassification"),p(an,"href","/docs/transformers/main/en/model_doc/bert#transformers.BertForTokenClassification"),p(nn,"href","/docs/transformers/main/en/model_doc/bert#transformers.BertForMaskedLM"),p(rn,"href","/docs/transformers/main/en/model_doc/bart#transformers.BartForConditionalGeneration"),p(on,"href","/docs/transformers/main/en/model_doc/mbart#transformers.MBartForConditionalGeneration"),p(ln,"href","/docs/transformers/main/en/model_doc/bert#transformers.BertModel"),p($t,"id","m"),p($t,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p($t,"href","#m"),p(be,"class","relative group"),p(kt,"id","masked-language-modeling"),p(kt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(kt,"href","#masked-language-modeling"),p(_e,"class","relative group"),p(Et,"id","multimodal"),p(Et,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Et,"href","#multimodal"),p($e,"class","relative group"),p(yt,"id","n"),p(yt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(yt,"href","#n"),p(ke,"class","relative group"),p(At,"id","natural-language-generation"),p(At,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(At,"href","#natural-language-generation"),p(Ee,"class","relative group"),p(qt,"id","natural-language-processing"),p(qt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(qt,"href","#natural-language-processing"),p(ye,"class","relative group"),p(jt,"id","natural-language-understanding"),p(jt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(jt,"href","#natural-language-understanding"),p(Ae,"class","relative group"),p(Pt,"id","p"),p(Pt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Pt,"href","#p"),p(qe,"class","relative group"),p(Tt,"id","pixel-values"),p(Tt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Tt,"href","#pixel-values"),p(je,"class","relative group"),p(xt,"id","pooling"),p(xt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(xt,"href","#pooling"),p(Pe,"class","relative group"),p(St,"id","position-ids"),p(St,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(St,"href","#position-ids"),p(Te,"class","relative group"),p(Dt,"id","pretrained-model"),p(Dt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Dt,"href","#pretrained-model"),p(xe,"class","relative group"),p(mn,"href","#causal-language-modeling"),p(vn,"href","#masked-language-modeling"),p(It,"id","r"),p(It,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(It,"href","#r"),p(Se,"class","relative group"),p(Bt,"id","recurrent-neural-network"),p(Bt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Bt,"href","#recurrent-neural-network"),p(Ne,"class","relative group"),p(Ht,"id","s"),p(Ht,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Ht,"href","#s"),p(ze,"class","relative group"),p(Ft,"id","sampling-rate"),p(Ft,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Ft,"href","#sampling-rate"),p(Ce,"class","relative group"),p(Mt,"id","selfattention"),p(Mt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Mt,"href","#selfattention"),p(De,"class","relative group"),p(Ot,"id","sequencetosequence-seq2seq"),p(Ot,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Ot,"href","#sequencetosequence-seq2seq"),p(Ie,"class","relative group"),p($n,"href","model_doc/bart"),p(kn,"href","model_doc/t5"),p(Rt,"id","stride"),p(Rt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Rt,"href","#stride"),p(Be,"class","relative group"),p(En,"href","#convolution"),p(yn,"href","#pooling"),p(Vt,"id","t"),p(Vt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Vt,"href","#t"),p(He,"class","relative group"),p(Lt,"id","token"),p(Lt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Lt,"href","#token"),p(Fe,"class","relative group"),p(Gt,"id","token-type-ids"),p(Gt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Gt,"href","#token-type-ids"),p(Me,"class","relative group"),p(xn,"href","/docs/transformers/main/en/model_doc/xlnet#transformers.XLNetModel"),p(Ut,"id","transformer"),p(Ut,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Ut,"href","#transformer"),p(Oe,"class","relative group")},m(e,o){s(document.head,E),h(e,Re,o),h(e,A,o),s(A,T),s(T,Rn),m(Kt,Rn,null),s(A,Yp),s(A,Vn),s(Vn,Qp),h(e,_l,o),h(e,wa,o),s(wa,Jp),h(e,$l,o),h(e,U,o),s(U,Ve),s(Ve,Ln),m(Zt,Ln,null),s(U,Kp),s(U,Gn),s(Gn,Zp),h(e,kl,o),h(e,X,o),s(X,Le),s(Le,Wn),m(es,Wn,null),s(X,ef),s(X,Un),s(Un,tf),h(e,El,o),h(e,ba,o),s(ba,sf),h(e,yl,o),m(ts,e,o),h(e,Al,o),h(e,_a,o),s(_a,af),h(e,ql,o),h(e,$a,o),s($a,nf),h(e,jl,o),m(ss,e,o),h(e,Pl,o),h(e,ka,o),s(ka,rf),h(e,Tl,o),m(as,e,o),h(e,xl,o),h(e,Ea,o),s(Ea,of),h(e,Sl,o),h(e,ya,o),s(ya,lf),h(e,Nl,o),m(ns,e,o),h(e,zl,o),h(e,Aa,o),s(Aa,hf),h(e,Cl,o),m(rs,e,o),h(e,Dl,o),h(e,S,o),s(S,pf),s(S,qa),s(qa,ff),s(S,df),s(S,Xn),s(Xn,cf),s(S,uf),s(S,Yn),s(Yn,mf),s(S,vf),h(e,Il,o),m(os,e,o),h(e,Bl,o),h(e,Y,o),s(Y,Ge),s(Ge,Qn),m(ls,Qn,null),s(Y,gf),s(Y,Jn),s(Jn,wf),h(e,Hl,o),h(e,is,o),s(is,bf),s(is,ja),s(ja,_f),h(e,Fl,o),h(e,Q,o),s(Q,We),s(We,Kn),m(hs,Kn,null),s(Q,$f),s(Q,Zn),s(Zn,kf),h(e,Ml,o),h(e,ps,o),s(ps,Ef),s(ps,Pa),s(Pa,yf),h(e,Ol,o),h(e,J,o),s(J,Ue),s(Ue,er),m(fs,er,null),s(J,Af),s(J,tr),s(tr,qf),h(e,Rl,o),h(e,K,o),s(K,Xe),s(Xe,sr),m(ds,sr,null),s(K,jf),s(K,ar),s(ar,Pf),h(e,Vl,o),h(e,q,o),s(q,Tf),s(q,Ta),s(Ta,xf),s(q,Sf),s(q,xa),s(xa,Nf),s(q,zf),s(q,nr),s(nr,Cf),s(q,Df),s(q,Sa),s(Sa,If),s(q,Bf),h(e,Ll,o),h(e,Z,o),s(Z,Ye),s(Ye,rr),m(cs,rr,null),s(Z,Hf),s(Z,or),s(or,Ff),h(e,Gl,o),h(e,ee,o),s(ee,Qe),s(Qe,lr),m(us,lr,null),s(ee,Mf),s(ee,ir),s(ir,Of),h(e,Wl,o),h(e,$,o),s($,Rf),s($,hr),s(hr,Vf),s($,Lf),s($,pr),s(pr,Gf),s($,Wf),s($,fr),s(fr,Uf),s($,Xf),s($,dr),s(dr,Yf),s($,Qf),s($,cr),s(cr,Jf),s($,Kf),s($,ur),s(ur,Zf),s($,ed),h(e,Ul,o),h(e,te,o),s(te,Je),s(Je,mr),m(ms,mr,null),s(te,td),s(te,vr),s(vr,sd),h(e,Xl,o),h(e,Na,o),s(Na,ad),h(e,Yl,o),h(e,se,o),s(se,Ke),s(Ke,gr),m(vs,gr,null),s(se,nd),s(se,wr),s(wr,rd),h(e,Ql,o),h(e,za,o),s(za,od),h(e,Jl,o),h(e,ae,o),s(ae,Ze),s(Ze,br),m(gs,br,null),s(ae,ld),s(ae,_r),s(_r,id),h(e,Kl,o),h(e,Ca,o),s(Ca,hd),h(e,Zl,o),h(e,ne,o),s(ne,et),s(et,$r),m(ws,$r,null),s(ne,pd),s(ne,kr),s(kr,fd),h(e,ei,o),h(e,re,o),s(re,tt),s(tt,Er),m(bs,Er,null),s(re,dd),s(re,yr),s(yr,cd),h(e,ti,o),h(e,Da,o),s(Da,ud),h(e,si,o),h(e,N,o),s(N,md),s(N,Ar),s(Ar,vd),s(N,gd),s(N,qr),s(qr,wd),s(N,bd),s(N,jr),s(jr,_d),s(N,$d),h(e,ai,o),h(e,Ia,o),s(Ia,kd),h(e,ni,o),h(e,oe,o),s(oe,st),s(st,Pr),m(_s,Pr,null),s(oe,Ed),s(oe,Tr),s(Tr,yd),h(e,ri,o),h(e,Ba,o),s(Ba,Ad),h(e,oi,o),h(e,le,o),s(le,at),s(at,xr),m($s,xr,null),s(le,qd),s(le,Sr),s(Sr,jd),h(e,li,o),h(e,ie,o),s(ie,nt),s(nt,Nr),m(ks,Nr,null),s(ie,Pd),s(ie,zr),s(zr,Td),h(e,ii,o),h(e,rt,o),s(rt,xd),s(rt,Cr),s(Cr,Sd),s(rt,Nd),h(e,hi,o),h(e,_,o),s(_,zd),s(_,Dr),s(Dr,Cd),s(_,Dd),s(_,Ir),s(Ir,Id),s(_,Bd),s(_,Es),s(Es,Hd),s(_,Fd),s(_,Br),s(Br,Md),s(_,Od),s(_,Hr),s(Hr,Rd),s(_,Vd),s(_,Fr),s(Fr,Ld),s(_,Gd),s(_,Mr),s(Mr,Wd),s(_,Ud),s(_,Or),s(Or,Xd),s(_,Yd),h(e,pi,o),h(e,z,o),s(z,Qd),s(z,Ha),s(Ha,Jd),s(z,Kd),s(z,Rr),s(Rr,Zd),s(z,ec),s(z,Vr),s(Vr,tc),s(z,sc),h(e,fi,o),h(e,he,o),s(he,ot),s(ot,Lr),m(ys,Lr,null),s(he,ac),s(he,Gr),s(Gr,nc),h(e,di,o),h(e,pe,o),s(pe,lt),s(lt,Wr),m(As,Wr,null),s(pe,rc),s(pe,Ur),s(Ur,oc),h(e,ci,o),h(e,Fa,o),s(Fa,lc),h(e,ui,o),h(e,D,o),s(D,it),s(it,Ma),s(Ma,ic),s(it,hc),s(it,Oa),s(Oa,pc),s(it,fc),s(D,dc),s(D,I),s(I,Ra),s(Ra,cc),s(I,uc),s(I,Xr),s(Xr,mc),s(I,vc),s(I,Va),s(Va,gc),s(I,wc),s(D,bc),s(D,B),s(B,La),s(La,_c),s(B,$c),s(B,Ga),s(Ga,kc),s(B,Ec),s(B,Wa),s(Wa,yc),s(B,Ac),h(e,mi,o),h(e,fe,o),s(fe,ht),s(ht,Yr),m(qs,Yr,null),s(fe,qc),s(fe,Qr),s(Qr,jc),h(e,vi,o),h(e,de,o),s(de,pt),s(pt,Jr),m(js,Jr,null),s(de,Pc),s(de,Kr),s(Kr,Tc),h(e,gi,o),h(e,ft,o),s(ft,xc),s(ft,Zr),s(Zr,Sc),s(ft,Nc),h(e,wi,o),h(e,ce,o),s(ce,dt),s(dt,eo),m(Ps,eo,null),s(ce,zc),s(ce,to),s(to,Cc),h(e,bi,o),h(e,Ua,o),s(Ua,Dc),h(e,_i,o),m(Ts,e,o),h(e,$i,o),h(e,ct,o),s(ct,Ic),s(ct,xs),s(xs,Bc),s(ct,Hc),h(e,ki,o),m(Ss,e,o),h(e,Ei,o),h(e,Xa,o),s(Xa,Fc),h(e,yi,o),m(Ns,e,o),h(e,Ai,o),h(e,Ya,o),s(Ya,Mc),h(e,qi,o),m(zs,e,o),h(e,ji,o),h(e,ut,o),s(ut,Oc),s(ut,Cs),s(Cs,Rc),s(ut,Vc),h(e,Pi,o),m(Ds,e,o),h(e,Ti,o),h(e,mt,o),s(mt,Lc),s(mt,so),s(so,Gc),s(mt,Wc),h(e,xi,o),m(Is,e,o),h(e,Si,o),h(e,Qa,o),s(Qa,Uc),h(e,Ni,o),h(e,Ja,o),s(Ja,Xc),h(e,zi,o),m(Bs,e,o),h(e,Ci,o),h(e,Ka,o),s(Ka,Yc),h(e,Di,o),m(Hs,e,o),h(e,Ii,o),h(e,vt,o),s(vt,Qc),s(vt,Za),s(Za,Jc),s(vt,Kc),h(e,Bi,o),h(e,ue,o),s(ue,gt),s(gt,ao),m(Fs,ao,null),s(ue,Zc),s(ue,no),s(no,eu),h(e,Hi,o),h(e,me,o),s(me,wt),s(wt,ro),m(Ms,ro,null),s(me,tu),s(me,oo),s(oo,su),h(e,Fi,o),h(e,en,o),s(en,au),h(e,Mi,o),h(e,tn,o),s(tn,nu),h(e,Oi,o),h(e,C,o),s(C,ve),s(ve,ru),s(ve,sn),s(sn,ou),s(ve,lu),s(ve,lo),s(lo,iu),s(ve,hu),s(C,pu),s(C,ge),s(ge,fu),s(ge,an),s(an,du),s(ge,cu),s(ge,io),s(io,uu),s(ge,mu),s(C,vu),s(C,we),s(we,gu),s(we,nn),s(nn,wu),s(we,bu),s(we,ho),s(ho,_u),s(we,$u),s(C,ku),s(C,x),s(x,Eu),s(x,rn),s(rn,yu),s(x,Au),s(x,on),s(on,qu),s(x,ju),s(x,po),s(po,Pu),s(x,Tu),s(x,fo),s(fo,xu),s(x,Su),h(e,Ri,o),m(bt,e,o),h(e,Vi,o),h(e,_t,o),s(_t,Nu),s(_t,ln),s(ln,zu),s(_t,Cu),h(e,Li,o),h(e,be,o),s(be,$t),s($t,co),m(Os,co,null),s(be,Du),s(be,uo),s(uo,Iu),h(e,Gi,o),h(e,_e,o),s(_e,kt),s(kt,mo),m(Rs,mo,null),s(_e,Bu),s(_e,vo),s(vo,Hu),h(e,Wi,o),h(e,hn,o),s(hn,Fu),h(e,Ui,o),h(e,$e,o),s($e,Et),s(Et,go),m(Vs,go,null),s($e,Mu),s($e,wo),s(wo,Ou),h(e,Xi,o),h(e,pn,o),s(pn,Ru),h(e,Yi,o),h(e,ke,o),s(ke,yt),s(yt,bo),m(Ls,bo,null),s(ke,Vu),s(ke,_o),s(_o,Lu),h(e,Qi,o),h(e,Ee,o),s(Ee,At),s(At,$o),m(Gs,$o,null),s(Ee,Gu),s(Ee,ko),s(ko,Wu),h(e,Ji,o),h(e,fn,o),s(fn,Uu),h(e,Ki,o),h(e,ye,o),s(ye,qt),s(qt,Eo),m(Ws,Eo,null),s(ye,Xu),s(ye,yo),s(yo,Yu),h(e,Zi,o),h(e,dn,o),s(dn,Qu),h(e,eh,o),h(e,Ae,o),s(Ae,jt),s(jt,Ao),m(Us,Ao,null),s(Ae,Ju),s(Ae,qo),s(qo,Ku),h(e,th,o),h(e,cn,o),s(cn,Zu),h(e,sh,o),h(e,qe,o),s(qe,Pt),s(Pt,jo),m(Xs,jo,null),s(qe,em),s(qe,Po),s(Po,tm),h(e,ah,o),h(e,je,o),s(je,Tt),s(Tt,To),m(Ys,To,null),s(je,sm),s(je,xo),s(xo,am),h(e,nh,o),h(e,j,o),s(j,nm),s(j,So),s(So,rm),s(j,om),s(j,No),s(No,lm),s(j,im),s(j,zo),s(zo,hm),s(j,pm),s(j,Co),s(Co,fm),s(j,dm),h(e,rh,o),h(e,Pe,o),s(Pe,xt),s(xt,Do),m(Qs,Do,null),s(Pe,cm),s(Pe,Io),s(Io,um),h(e,oh,o),h(e,un,o),s(un,mm),h(e,lh,o),h(e,Te,o),s(Te,St),s(St,Bo),m(Js,Bo,null),s(Te,vm),s(Te,Ho),s(Ho,gm),h(e,ih,o),h(e,Nt,o),s(Nt,wm),s(Nt,Fo),s(Fo,bm),s(Nt,_m),h(e,hh,o),h(e,zt,o),s(zt,$m),s(zt,Mo),s(Mo,km),s(zt,Em),h(e,ph,o),h(e,Ct,o),s(Ct,ym),s(Ct,Oo),s(Oo,Am),s(Ct,qm),h(e,fh,o),h(e,xe,o),s(xe,Dt),s(Dt,Ro),m(Ks,Ro,null),s(xe,jm),s(xe,Vo),s(Vo,Pm),h(e,dh,o),h(e,H,o),s(H,Tm),s(H,mn),s(mn,xm),s(H,Sm),s(H,vn),s(vn,Nm),s(H,zm),h(e,ch,o),h(e,gn,o),s(gn,Cm),h(e,uh,o),h(e,Se,o),s(Se,It),s(It,Lo),m(Zs,Lo,null),s(Se,Dm),s(Se,Go),s(Go,Im),h(e,mh,o),h(e,Ne,o),s(Ne,Bt),s(Bt,Wo),m(ea,Wo,null),s(Ne,Bm),s(Ne,Uo),s(Uo,Hm),h(e,vh,o),h(e,wn,o),s(wn,Fm),h(e,gh,o),h(e,ze,o),s(ze,Ht),s(Ht,Xo),m(ta,Xo,null),s(ze,Mm),s(ze,Yo),s(Yo,Om),h(e,wh,o),h(e,Ce,o),s(Ce,Ft),s(Ft,Qo),m(sa,Qo,null),s(Ce,Rm),s(Ce,Jo),s(Jo,Vm),h(e,bh,o),h(e,bn,o),s(bn,Lm),h(e,_h,o),h(e,De,o),s(De,Mt),s(Mt,Ko),m(aa,Ko,null),s(De,Gm),s(De,Zo),s(Zo,Wm),h(e,$h,o),h(e,_n,o),s(_n,Um),h(e,kh,o),h(e,Ie,o),s(Ie,Ot),s(Ot,el),m(na,el,null),s(Ie,Xm),s(Ie,tl),s(tl,Ym),h(e,Eh,o),h(e,F,o),s(F,Qm),s(F,$n),s($n,Jm),s(F,Km),s(F,kn),s(kn,Zm),s(F,ev),h(e,yh,o),h(e,Be,o),s(Be,Rt),s(Rt,sl),m(ra,sl,null),s(Be,tv),s(Be,al),s(al,sv),h(e,Ah,o),h(e,M,o),s(M,av),s(M,En),s(En,nv),s(M,rv),s(M,yn),s(yn,ov),s(M,lv),h(e,qh,o),h(e,He,o),s(He,Vt),s(Vt,nl),m(oa,nl,null),s(He,iv),s(He,rl),s(rl,hv),h(e,jh,o),h(e,Fe,o),s(Fe,Lt),s(Lt,ol),m(la,ol,null),s(Fe,pv),s(Fe,ll),s(ll,fv),h(e,Ph,o),h(e,An,o),s(An,dv),h(e,Th,o),h(e,Me,o),s(Me,Gt),s(Gt,il),m(ia,il,null),s(Me,cv),s(Me,hl),s(hl,uv),h(e,xh,o),h(e,qn,o),s(qn,mv),h(e,Sh,o),m(ha,e,o),h(e,Nh,o),h(e,O,o),s(O,vv),s(O,pl),s(pl,gv),s(O,wv),s(O,fl),s(fl,bv),s(O,_v),h(e,zh,o),m(pa,e,o),h(e,Ch,o),h(e,Wt,o),s(Wt,$v),s(Wt,dl),s(dl,kv),s(Wt,Ev),h(e,Dh,o),m(fa,e,o),h(e,Ih,o),h(e,jn,o),s(jn,yv),h(e,Bh,o),m(da,e,o),h(e,Hh,o),h(e,Pn,o),s(Pn,Av),h(e,Fh,o),h(e,Tn,o),s(Tn,qv),h(e,Mh,o),m(ca,e,o),h(e,Oh,o),h(e,R,o),s(R,jv),s(R,cl),s(cl,Pv),s(R,Tv),s(R,ul),s(ul,xv),s(R,Sv),h(e,Rh,o),h(e,V,o),s(V,Nv),s(V,xn),s(xn,zv),s(V,Cv),s(V,ml),s(ml,Dv),s(V,Iv),h(e,Vh,o),h(e,Oe,o),s(Oe,Ut),s(Ut,vl),m(ua,vl,null),s(Oe,Bv),s(Oe,gl),s(gl,Hv),h(e,Lh,o),h(e,Sn,o),s(Sn,Fv),Gh=!0},p(e,[o]){const ma={};o&2&&(ma.$$scope={dirty:o,ctx:e}),bt.$set(ma)},i(e){Gh||(v(Kt.$$.fragment,e),v(Zt.$$.fragment,e),v(es.$$.fragment,e),v(ts.$$.fragment,e),v(ss.$$.fragment,e),v(as.$$.fragment,e),v(ns.$$.fragment,e),v(rs.$$.fragment,e),v(os.$$.fragment,e),v(ls.$$.fragment,e),v(hs.$$.fragment,e),v(fs.$$.fragment,e),v(ds.$$.fragment,e),v(cs.$$.fragment,e),v(us.$$.fragment,e),v(ms.$$.fragment,e),v(vs.$$.fragment,e),v(gs.$$.fragment,e),v(ws.$$.fragment,e),v(bs.$$.fragment,e),v(_s.$$.fragment,e),v($s.$$.fragment,e),v(ks.$$.fragment,e),v(ys.$$.fragment,e),v(As.$$.fragment,e),v(qs.$$.fragment,e),v(js.$$.fragment,e),v(Ps.$$.fragment,e),v(Ts.$$.fragment,e),v(Ss.$$.fragment,e),v(Ns.$$.fragment,e),v(zs.$$.fragment,e),v(Ds.$$.fragment,e),v(Is.$$.fragment,e),v(Bs.$$.fragment,e),v(Hs.$$.fragment,e),v(Fs.$$.fragment,e),v(Ms.$$.fragment,e),v(bt.$$.fragment,e),v(Os.$$.fragment,e),v(Rs.$$.fragment,e),v(Vs.$$.fragment,e),v(Ls.$$.fragment,e),v(Gs.$$.fragment,e),v(Ws.$$.fragment,e),v(Us.$$.fragment,e),v(Xs.$$.fragment,e),v(Ys.$$.fragment,e),v(Qs.$$.fragment,e),v(Js.$$.fragment,e),v(Ks.$$.fragment,e),v(Zs.$$.fragment,e),v(ea.$$.fragment,e),v(ta.$$.fragment,e),v(sa.$$.fragment,e),v(aa.$$.fragment,e),v(na.$$.fragment,e),v(ra.$$.fragment,e),v(oa.$$.fragment,e),v(la.$$.fragment,e),v(ia.$$.fragment,e),v(ha.$$.fragment,e),v(pa.$$.fragment,e),v(fa.$$.fragment,e),v(da.$$.fragment,e),v(ca.$$.fragment,e),v(ua.$$.fragment,e),Gh=!0)},o(e){g(Kt.$$.fragment,e),g(Zt.$$.fragment,e),g(es.$$.fragment,e),g(ts.$$.fragment,e),g(ss.$$.fragment,e),g(as.$$.fragment,e),g(ns.$$.fragment,e),g(rs.$$.fragment,e),g(os.$$.fragment,e),g(ls.$$.fragment,e),g(hs.$$.fragment,e),g(fs.$$.fragment,e),g(ds.$$.fragment,e),g(cs.$$.fragment,e),g(us.$$.fragment,e),g(ms.$$.fragment,e),g(vs.$$.fragment,e),g(gs.$$.fragment,e),g(ws.$$.fragment,e),g(bs.$$.fragment,e),g(_s.$$.fragment,e),g($s.$$.fragment,e),g(ks.$$.fragment,e),g(ys.$$.fragment,e),g(As.$$.fragment,e),g(qs.$$.fragment,e),g(js.$$.fragment,e),g(Ps.$$.fragment,e),g(Ts.$$.fragment,e),g(Ss.$$.fragment,e),g(Ns.$$.fragment,e),g(zs.$$.fragment,e),g(Ds.$$.fragment,e),g(Is.$$.fragment,e),g(Bs.$$.fragment,e),g(Hs.$$.fragment,e),g(Fs.$$.fragment,e),g(Ms.$$.fragment,e),g(bt.$$.fragment,e),g(Os.$$.fragment,e),g(Rs.$$.fragment,e),g(Vs.$$.fragment,e),g(Ls.$$.fragment,e),g(Gs.$$.fragment,e),g(Ws.$$.fragment,e),g(Us.$$.fragment,e),g(Xs.$$.fragment,e),g(Ys.$$.fragment,e),g(Qs.$$.fragment,e),g(Js.$$.fragment,e),g(Ks.$$.fragment,e),g(Zs.$$.fragment,e),g(ea.$$.fragment,e),g(ta.$$.fragment,e),g(sa.$$.fragment,e),g(aa.$$.fragment,e),g(na.$$.fragment,e),g(ra.$$.fragment,e),g(oa.$$.fragment,e),g(la.$$.fragment,e),g(ia.$$.fragment,e),g(ha.$$.fragment,e),g(pa.$$.fragment,e),g(fa.$$.fragment,e),g(da.$$.fragment,e),g(ca.$$.fragment,e),g(ua.$$.fragment,e),Gh=!1},d(e){t(E),e&&t(Re),e&&t(A),w(Kt),e&&t(_l),e&&t(wa),e&&t($l),e&&t(U),w(Zt),e&&t(kl),e&&t(X),w(es),e&&t(El),e&&t(ba),e&&t(yl),w(ts,e),e&&t(Al),e&&t(_a),e&&t(ql),e&&t($a),e&&t(jl),w(ss,e),e&&t(Pl),e&&t(ka),e&&t(Tl),w(as,e),e&&t(xl),e&&t(Ea),e&&t(Sl),e&&t(ya),e&&t(Nl),w(ns,e),e&&t(zl),e&&t(Aa),e&&t(Cl),w(rs,e),e&&t(Dl),e&&t(S),e&&t(Il),w(os,e),e&&t(Bl),e&&t(Y),w(ls),e&&t(Hl),e&&t(is),e&&t(Fl),e&&t(Q),w(hs),e&&t(Ml),e&&t(ps),e&&t(Ol),e&&t(J),w(fs),e&&t(Rl),e&&t(K),w(ds),e&&t(Vl),e&&t(q),e&&t(Ll),e&&t(Z),w(cs),e&&t(Gl),e&&t(ee),w(us),e&&t(Wl),e&&t($),e&&t(Ul),e&&t(te),w(ms),e&&t(Xl),e&&t(Na),e&&t(Yl),e&&t(se),w(vs),e&&t(Ql),e&&t(za),e&&t(Jl),e&&t(ae),w(gs),e&&t(Kl),e&&t(Ca),e&&t(Zl),e&&t(ne),w(ws),e&&t(ei),e&&t(re),w(bs),e&&t(ti),e&&t(Da),e&&t(si),e&&t(N),e&&t(ai),e&&t(Ia),e&&t(ni),e&&t(oe),w(_s),e&&t(ri),e&&t(Ba),e&&t(oi),e&&t(le),w($s),e&&t(li),e&&t(ie),w(ks),e&&t(ii),e&&t(rt),e&&t(hi),e&&t(_),e&&t(pi),e&&t(z),e&&t(fi),e&&t(he),w(ys),e&&t(di),e&&t(pe),w(As),e&&t(ci),e&&t(Fa),e&&t(ui),e&&t(D),e&&t(mi),e&&t(fe),w(qs),e&&t(vi),e&&t(de),w(js),e&&t(gi),e&&t(ft),e&&t(wi),e&&t(ce),w(Ps),e&&t(bi),e&&t(Ua),e&&t(_i),w(Ts,e),e&&t($i),e&&t(ct),e&&t(ki),w(Ss,e),e&&t(Ei),e&&t(Xa),e&&t(yi),w(Ns,e),e&&t(Ai),e&&t(Ya),e&&t(qi),w(zs,e),e&&t(ji),e&&t(ut),e&&t(Pi),w(Ds,e),e&&t(Ti),e&&t(mt),e&&t(xi),w(Is,e),e&&t(Si),e&&t(Qa),e&&t(Ni),e&&t(Ja),e&&t(zi),w(Bs,e),e&&t(Ci),e&&t(Ka),e&&t(Di),w(Hs,e),e&&t(Ii),e&&t(vt),e&&t(Bi),e&&t(ue),w(Fs),e&&t(Hi),e&&t(me),w(Ms),e&&t(Fi),e&&t(en),e&&t(Mi),e&&t(tn),e&&t(Oi),e&&t(C),e&&t(Ri),w(bt,e),e&&t(Vi),e&&t(_t),e&&t(Li),e&&t(be),w(Os),e&&t(Gi),e&&t(_e),w(Rs),e&&t(Wi),e&&t(hn),e&&t(Ui),e&&t($e),w(Vs),e&&t(Xi),e&&t(pn),e&&t(Yi),e&&t(ke),w(Ls),e&&t(Qi),e&&t(Ee),w(Gs),e&&t(Ji),e&&t(fn),e&&t(Ki),e&&t(ye),w(Ws),e&&t(Zi),e&&t(dn),e&&t(eh),e&&t(Ae),w(Us),e&&t(th),e&&t(cn),e&&t(sh),e&&t(qe),w(Xs),e&&t(ah),e&&t(je),w(Ys),e&&t(nh),e&&t(j),e&&t(rh),e&&t(Pe),w(Qs),e&&t(oh),e&&t(un),e&&t(lh),e&&t(Te),w(Js),e&&t(ih),e&&t(Nt),e&&t(hh),e&&t(zt),e&&t(ph),e&&t(Ct),e&&t(fh),e&&t(xe),w(Ks),e&&t(dh),e&&t(H),e&&t(ch),e&&t(gn),e&&t(uh),e&&t(Se),w(Zs),e&&t(mh),e&&t(Ne),w(ea),e&&t(vh),e&&t(wn),e&&t(gh),e&&t(ze),w(ta),e&&t(wh),e&&t(Ce),w(sa),e&&t(bh),e&&t(bn),e&&t(_h),e&&t(De),w(aa),e&&t($h),e&&t(_n),e&&t(kh),e&&t(Ie),w(na),e&&t(Eh),e&&t(F),e&&t(yh),e&&t(Be),w(ra),e&&t(Ah),e&&t(M),e&&t(qh),e&&t(He),w(oa),e&&t(jh),e&&t(Fe),w(la),e&&t(Ph),e&&t(An),e&&t(Th),e&&t(Me),w(ia),e&&t(xh),e&&t(qn),e&&t(Sh),w(ha,e),e&&t(Nh),e&&t(O),e&&t(zh),w(pa,e),e&&t(Ch),e&&t(Wt),e&&t(Dh),w(fa,e),e&&t(Ih),e&&t(jn),e&&t(Bh),w(da,e),e&&t(Hh),e&&t(Pn),e&&t(Fh),e&&t(Tn),e&&t(Mh),w(ca,e),e&&t(Oh),e&&t(R),e&&t(Rh),e&&t(V),e&&t(Vh),e&&t(Oe),w(ua),e&&t(Lh),e&&t(Sn)}}}const D_={local:"glossary",sections:[{local:"a",sections:[{local:"attention-mask",title:"attention mask"},{local:"autoencoding-models",title:"autoencoding models "},{local:"autoregressive-models",title:"autoregressive models"}],title:"A"},{local:"b",sections:[{local:"backbone",title:"backbone"}],title:"B"},{local:"c",sections:[{local:"channel",title:"channel"},{local:"causal-language-modeling",title:"causal language modeling"},{local:"connectionist-temporal-classification-ctc",title:"connectionist temporal classification (CTC)"},{local:"convolution",title:"convolution"}],title:"C"},{local:"d",sections:[{local:"decoder-input-ids",title:"decoder input IDs"},{local:"deep-learning",title:"deep learning"}],title:"D"},{local:"f",sections:[{local:"feed-forward-chunking",title:"feed forward chunking"}],title:"F"},{local:"h",sections:[{local:"head",title:"head"}],title:"H"},{local:"i",sections:[{local:"image-patch",title:"image patch"},{local:"input-ids",title:"input IDs"}],title:"I"},{local:"l",sections:[{local:"labels",title:"labels"}],title:"L"},{local:"m",sections:[{local:"masked-language-modeling",title:"masked language modeling"},{local:"multimodal",title:"multimodal"}],title:"M"},{local:"n",sections:[{local:"natural-language-generation",title:"Natural language generation"},{local:"natural-language-processing",title:"Natural language processing"},{local:"natural-language-understanding",title:"Natural language understanding"}],title:"N"},{local:"p",sections:[{local:"pixel-values",title:"pixel values"},{local:"pooling",title:"pooling"},{local:"position-ids",title:"position IDs"},{local:"pretrained-model",title:"pretrained model"}],title:"P"},{local:"r",sections:[{local:"recurrent-neural-network",title:"recurrent neural network"}],title:"R"},{local:"s",sections:[{local:"sampling-rate",title:"sampling rate"},{local:"selfattention",title:"self-attention"},{local:"sequencetosequence-seq2seq",title:"sequence-to-sequence (seq2seq)"},{local:"stride",title:"stride"}],title:"S"},{local:"t",sections:[{local:"token",title:"token"},{local:"token-type-ids",title:"token Type IDs"},{local:"transformer",title:"transformer"}],title:"T"}],title:"Glossary"};function I_(bl){return S_(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class R_ extends j_{constructor(E){super();P_(this,E,I_,C_,T_,{})}}export{R_ as default,D_ as metadata};
