import{S as La,i as Na,s as xa,e as r,k as f,w,t as s,M as Ea,c as a,d as o,m as u,a as n,x as P,h as i,b as c,N as Ga,G as t,g,y as $,q as y,o as L,B as N,v as Ta,L as Dr}from"../../chunks/vendor-hf-doc-builder.js";import{T as ro}from"../../chunks/Tip-hf-doc-builder.js";import{D as Ae}from"../../chunks/Docstring-hf-doc-builder.js";import{C as Ar}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as it}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{E as zr}from"../../chunks/ExampleCodeBlock-hf-doc-builder.js";function ka(x){let d,v,h,m,b;return{c(){d=r("p"),v=s(`This is a recently introduced model so the API hasn\u2019t been tested extensively. There may be some bugs or slight
breaking changes to fix it in the future. If you see something strange, file a `),h=r("a"),m=s("Github Issue"),b=s("."),this.h()},l(l){d=a(l,"P",{});var _=n(d);v=i(_,`This is a recently introduced model so the API hasn\u2019t been tested extensively. There may be some bugs or slight
breaking changes to fix it in the future. If you see something strange, file a `),h=a(_,"A",{href:!0,rel:!0});var E=n(h);m=i(E,"Github Issue"),E.forEach(o),b=i(_,"."),_.forEach(o),this.h()},h(){c(h,"href","https://github.com/huggingface/transformers/issues/new?assignees=&labels=&template=bug-report.md&title"),c(h,"rel","nofollow")},m(l,_){g(l,d,_),t(d,v),t(d,h),t(h,m),t(d,b)},d(l){l&&o(d)}}}function Fa(x){let d,v,h,m,b;return m=new Ar({props:{code:`from transformers import GLPNModel, GLPNConfig

# Initializing a GLPN vinvino02/glpn-kitti style configuration
configuration = GLPNConfig()

# Initializing a model from the vinvino02/glpn-kitti style configuration
model = GLPNModel(configuration)

# Accessing the model configuration
configuration = model.config`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> GLPNModel, GLPNConfig

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a GLPN vinvino02/glpn-kitti style configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = GLPNConfig()

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a model from the vinvino02/glpn-kitti style configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = GLPNModel(configuration)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Accessing the model configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = model.config`}}),{c(){d=r("p"),v=s("Example:"),h=f(),w(m.$$.fragment)},l(l){d=a(l,"P",{});var _=n(d);v=i(_,"Example:"),_.forEach(o),h=u(l),P(m.$$.fragment,l)},m(l,_){g(l,d,_),t(d,v),g(l,h,_),$(m,l,_),b=!0},p:Dr,i(l){b||(y(m.$$.fragment,l),b=!0)},o(l){L(m.$$.fragment,l),b=!1},d(l){l&&o(d),l&&o(h),N(m,l)}}}function ja(x){let d,v;return{c(){d=r("p"),v=s(`NumPy arrays and PyTorch tensors are converted to PIL images when resizing, so the most efficient is to pass
PIL images.`)},l(h){d=a(h,"P",{});var m=n(d);v=i(m,`NumPy arrays and PyTorch tensors are converted to PIL images when resizing, so the most efficient is to pass
PIL images.`),m.forEach(o)},m(h,m){g(h,d,m),t(d,v)},d(h){h&&o(d)}}}function Ia(x){let d,v,h,m,b;return{c(){d=r("p"),v=s("Although the recipe for forward pass needs to be defined within this function, one should call the "),h=r("code"),m=s("Module"),b=s(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(l){d=a(l,"P",{});var _=n(d);v=i(_,"Although the recipe for forward pass needs to be defined within this function, one should call the "),h=a(_,"CODE",{});var E=n(h);m=i(E,"Module"),E.forEach(o),b=i(_,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),_.forEach(o)},m(l,_){g(l,d,_),t(d,v),t(d,h),t(h,m),t(d,b)},d(l){l&&o(d)}}}function Ma(x){let d,v,h,m,b;return m=new Ar({props:{code:`from transformers import GLPNFeatureExtractor, GLPNModel
import torch
from datasets import load_dataset

dataset = load_dataset("huggingface/cats-image")
image = dataset["test"]["image"][0]

feature_extractor = GLPNFeatureExtractor.from_pretrained("vinvino02/glpn-kitti")
model = GLPNModel.from_pretrained("vinvino02/glpn-kitti")

inputs = feature_extractor(image, return_tensors="pt")

with torch.no_grad():
    outputs = model(**inputs)

last_hidden_states = outputs.last_hidden_state
list(last_hidden_states.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> GLPNFeatureExtractor, GLPNModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&quot;huggingface/cats-image&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>image = dataset[<span class="hljs-string">&quot;test&quot;</span>][<span class="hljs-string">&quot;image&quot;</span>][<span class="hljs-number">0</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>feature_extractor = GLPNFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;vinvino02/glpn-kitti&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = GLPNModel.from_pretrained(<span class="hljs-string">&quot;vinvino02/glpn-kitti&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = feature_extractor(image, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(last_hidden_states.shape)
[<span class="hljs-number">1</span>, <span class="hljs-number">512</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>]`}}),{c(){d=r("p"),v=s("Example:"),h=f(),w(m.$$.fragment)},l(l){d=a(l,"P",{});var _=n(d);v=i(_,"Example:"),_.forEach(o),h=u(l),P(m.$$.fragment,l)},m(l,_){g(l,d,_),t(d,v),g(l,h,_),$(m,l,_),b=!0},p:Dr,i(l){b||(y(m.$$.fragment,l),b=!0)},o(l){L(m.$$.fragment,l),b=!1},d(l){l&&o(d),l&&o(h),N(m,l)}}}function Ca(x){let d,v,h,m,b;return{c(){d=r("p"),v=s("Although the recipe for forward pass needs to be defined within this function, one should call the "),h=r("code"),m=s("Module"),b=s(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(l){d=a(l,"P",{});var _=n(d);v=i(_,"Although the recipe for forward pass needs to be defined within this function, one should call the "),h=a(_,"CODE",{});var E=n(h);m=i(E,"Module"),E.forEach(o),b=i(_,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),_.forEach(o)},m(l,_){g(l,d,_),t(d,v),t(d,h),t(h,m),t(d,b)},d(l){l&&o(d)}}}function za(x){let d,v,h,m,b;return m=new Ar({props:{code:`from transformers import GLPNFeatureExtractor, GLPNForDepthEstimation
import torch
import numpy as np
from PIL import Image
import requests

url = "http://images.cocodataset.org/val2017/000000039769.jpg"
image = Image.open(requests.get(url, stream=True).raw)

feature_extractor = GLPNFeatureExtractor.from_pretrained("vinvino02/glpn-kitti")
model = GLPNForDepthEstimation.from_pretrained("vinvino02/glpn-kitti")

# prepare image for the model
inputs = feature_extractor(images=image, return_tensors="pt")

with torch.no_grad():
    outputs = model(**inputs)
    predicted_depth = outputs.predicted_depth

# interpolate to original size
prediction = torch.nn.functional.interpolate(
    predicted_depth.unsqueeze(1),
    size=image.size[::-1],
    mode="bicubic",
    align_corners=False,
)

# visualize the prediction
output = prediction.squeeze().cpu().numpy()
formatted = (output * 255 / np.max(output)).astype("uint8")
depth = Image.fromarray(formatted)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> GLPNFeatureExtractor, GLPNForDepthEstimation
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> requests

<span class="hljs-meta">&gt;&gt;&gt; </span>url = <span class="hljs-string">&quot;http://images.cocodataset.org/val2017/000000039769.jpg&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>image = Image.<span class="hljs-built_in">open</span>(requests.get(url, stream=<span class="hljs-literal">True</span>).raw)

<span class="hljs-meta">&gt;&gt;&gt; </span>feature_extractor = GLPNFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;vinvino02/glpn-kitti&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = GLPNForDepthEstimation.from_pretrained(<span class="hljs-string">&quot;vinvino02/glpn-kitti&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># prepare image for the model</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = feature_extractor(images=image, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    outputs = model(**inputs)
<span class="hljs-meta">... </span>    predicted_depth = outputs.predicted_depth

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># interpolate to original size</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>prediction = torch.nn.functional.interpolate(
<span class="hljs-meta">... </span>    predicted_depth.unsqueeze(<span class="hljs-number">1</span>),
<span class="hljs-meta">... </span>    size=image.size[::-<span class="hljs-number">1</span>],
<span class="hljs-meta">... </span>    mode=<span class="hljs-string">&quot;bicubic&quot;</span>,
<span class="hljs-meta">... </span>    align_corners=<span class="hljs-literal">False</span>,
<span class="hljs-meta">... </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># visualize the prediction</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>output = prediction.squeeze().cpu().numpy()
<span class="hljs-meta">&gt;&gt;&gt; </span>formatted = (output * <span class="hljs-number">255</span> / np.<span class="hljs-built_in">max</span>(output)).astype(<span class="hljs-string">&quot;uint8&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>depth = Image.fromarray(formatted)`}}),{c(){d=r("p"),v=s("Examples:"),h=f(),w(m.$$.fragment)},l(l){d=a(l,"P",{});var _=n(d);v=i(_,"Examples:"),_.forEach(o),h=u(l),P(m.$$.fragment,l)},m(l,_){g(l,d,_),t(d,v),g(l,h,_),$(m,l,_),b=!0},p:Dr,i(l){b||(y(m.$$.fragment,l),b=!0)},o(l){L(m.$$.fragment,l),b=!1},d(l){l&&o(d),l&&o(h),N(m,l)}}}function Da(x){let d,v,h,m,b,l,_,E,ao,Gt,V,Tt,D,J,lt,he,no,dt,so,kt,M,io,me,lo,co,qe,po,ho,Ft,Se,mo,jt,Oe,ct,fo,It,Be,uo,Mt,K,A,go,Re,_o,vo,fe,bo,wo,Po,ue,$o,Ue,yo,Lo,Ct,Y,qr,zt,X,No,ge,xo,Eo,Dt,C,Go,_e,To,ko,ve,Fo,jo,At,q,Z,pt,be,Io,ht,Mo,qt,G,we,Co,S,zo,We,Do,Ao,Pe,qo,So,Oo,O,Bo,He,Ro,Uo,Ve,Wo,Ho,Vo,Q,St,B,ee,mt,$e,Jo,ft,Ko,Ot,T,ye,Yo,ut,Xo,Zo,Le,Qo,Je,er,tr,or,z,Ne,rr,gt,ar,nr,te,Bt,R,oe,_t,xe,sr,vt,ir,Rt,j,Ee,lr,Ge,dr,Te,cr,pr,hr,k,ke,mr,U,fr,Ke,ur,gr,bt,_r,vr,br,re,wr,ae,Ut,W,ne,wt,Fe,Pr,Pt,$r,Wt,I,je,yr,Ie,Lr,Me,Nr,xr,Er,F,Ce,Gr,H,Tr,Ye,kr,Fr,$t,jr,Ir,Mr,se,Cr,ie,Ht;return l=new it({}),V=new ro({props:{$$slots:{default:[ka]},$$scope:{ctx:x}}}),he=new it({}),be=new it({}),we=new Ae({props:{name:"class transformers.GLPNConfig",anchor:"transformers.GLPNConfig",parameters:[{name:"num_channels",val:" = 3"},{name:"num_encoder_blocks",val:" = 4"},{name:"depths",val:" = [2, 2, 2, 2]"},{name:"sr_ratios",val:" = [8, 4, 2, 1]"},{name:"hidden_sizes",val:" = [32, 64, 160, 256]"},{name:"patch_sizes",val:" = [7, 3, 3, 3]"},{name:"strides",val:" = [4, 2, 2, 2]"},{name:"num_attention_heads",val:" = [1, 2, 5, 8]"},{name:"mlp_ratios",val:" = [4, 4, 4, 4]"},{name:"hidden_act",val:" = 'gelu'"},{name:"hidden_dropout_prob",val:" = 0.0"},{name:"attention_probs_dropout_prob",val:" = 0.0"},{name:"initializer_range",val:" = 0.02"},{name:"drop_path_rate",val:" = 0.1"},{name:"layer_norm_eps",val:" = 1e-06"},{name:"is_encoder_decoder",val:" = False"},{name:"decoder_hidden_size",val:" = 64"},{name:"max_depth",val:" = 10"},{name:"head_in_index",val:" = -1"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.GLPNConfig.num_channels",description:`<strong>num_channels</strong> (<code>int</code>, <em>optional</em>, defaults to 3) &#x2014;
The number of input channels.`,name:"num_channels"},{anchor:"transformers.GLPNConfig.num_encoder_blocks",description:`<strong>num_encoder_blocks</strong> (<code>int</code>, <em>optional</em>, defaults to 4) &#x2014;
The number of encoder blocks (i.e. stages in the Mix Transformer encoder).`,name:"num_encoder_blocks"},{anchor:"transformers.GLPNConfig.depths",description:`<strong>depths</strong> (<code>List[int]</code>, <em>optional</em>, defaults to <code>[2, 2, 2, 2]</code>) &#x2014;
The number of layers in each encoder block.`,name:"depths"},{anchor:"transformers.GLPNConfig.sr_ratios",description:`<strong>sr_ratios</strong> (<code>List[int]</code>, <em>optional</em>, defaults to <code>[8, 4, 2, 1]</code>) &#x2014;
Sequence reduction ratios in each encoder block.`,name:"sr_ratios"},{anchor:"transformers.GLPNConfig.hidden_sizes",description:`<strong>hidden_sizes</strong> (<code>List[int]</code>, <em>optional</em>, defaults to <code>[32, 64, 160, 256]</code>) &#x2014;
Dimension of each of the encoder blocks.`,name:"hidden_sizes"},{anchor:"transformers.GLPNConfig.patch_sizes",description:`<strong>patch_sizes</strong> (<code>List[int]</code>, <em>optional</em>, defaults to <code>[7, 3, 3, 3]</code>) &#x2014;
Patch size before each encoder block.`,name:"patch_sizes"},{anchor:"transformers.GLPNConfig.strides",description:`<strong>strides</strong> (<code>List[int]</code>, <em>optional</em>, defaults to <code>[4, 2, 2, 2]</code>) &#x2014;
Stride before each encoder block.`,name:"strides"},{anchor:"transformers.GLPNConfig.num_attention_heads",description:`<strong>num_attention_heads</strong> (<code>List[int]</code>, <em>optional</em>, defaults to <code>[1, 2, 4, 8]</code>) &#x2014;
Number of attention heads for each attention layer in each block of the Transformer encoder.`,name:"num_attention_heads"},{anchor:"transformers.GLPNConfig.mlp_ratios",description:`<strong>mlp_ratios</strong> (<code>List[int]</code>, <em>optional</em>, defaults to <code>[4, 4, 4, 4]</code>) &#x2014;
Ratio of the size of the hidden layer compared to the size of the input layer of the Mix FFNs in the
encoder blocks.`,name:"mlp_ratios"},{anchor:"transformers.GLPNConfig.hidden_act",description:`<strong>hidden_act</strong> (<code>str</code> or <code>function</code>, <em>optional</em>, defaults to <code>&quot;gelu&quot;</code>) &#x2014;
The non-linear activation function (function or string) in the encoder and pooler. If string, <code>&quot;gelu&quot;</code>,
<code>&quot;relu&quot;</code>, <code>&quot;selu&quot;</code> and <code>&quot;gelu_new&quot;</code> are supported.`,name:"hidden_act"},{anchor:"transformers.GLPNConfig.hidden_dropout_prob",description:`<strong>hidden_dropout_prob</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.`,name:"hidden_dropout_prob"},{anchor:"transformers.GLPNConfig.attention_probs_dropout_prob",description:`<strong>attention_probs_dropout_prob</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
The dropout ratio for the attention probabilities.`,name:"attention_probs_dropout_prob"},{anchor:"transformers.GLPNConfig.initializer_range",description:`<strong>initializer_range</strong> (<code>float</code>, <em>optional</em>, defaults to 0.02) &#x2014;
The standard deviation of the truncated_normal_initializer for initializing all weight matrices.`,name:"initializer_range"},{anchor:"transformers.GLPNConfig.drop_path_rate",description:`<strong>drop_path_rate</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The dropout probability for stochastic depth, used in the blocks of the Transformer encoder.`,name:"drop_path_rate"},{anchor:"transformers.GLPNConfig.layer_norm_eps",description:`<strong>layer_norm_eps</strong> (<code>float</code>, <em>optional</em>, defaults to 1e-6) &#x2014;
The epsilon used by the layer normalization layers.`,name:"layer_norm_eps"},{anchor:"transformers.GLPNConfig.decoder_hidden_size",description:`<strong>decoder_hidden_size</strong> (<code>int</code>, <em>optional</em>, defaults to 32) &#x2014;
The dimension of the decoder.`,name:"decoder_hidden_size"},{anchor:"transformers.GLPNConfig.max_depth",description:`<strong>max_depth</strong> (<code>int</code>, <em>optional</em>, defaults to 10) &#x2014;
The maximum depth of the decoder.`,name:"max_depth"},{anchor:"transformers.GLPNConfig.head_in_index",description:`<strong>head_in_index</strong> (<code>int</code>, <em>optional</em>, defaults to -1) &#x2014;
The index of the features to use in the head.`,name:"head_in_index"}],source:"https://github.com/huggingface/transformers/blob/v4.22.0/src/transformers/models/glpn/configuration_glpn.py#L29"}}),Q=new zr({props:{anchor:"transformers.GLPNConfig.example",$$slots:{default:[Fa]},$$scope:{ctx:x}}}),$e=new it({}),ye=new Ae({props:{name:"class transformers.GLPNFeatureExtractor",anchor:"transformers.GLPNFeatureExtractor",parameters:[{name:"do_resize",val:" = True"},{name:"size_divisor",val:" = 32"},{name:"resample",val:" = <Resampling.BILINEAR: 2>"},{name:"do_rescale",val:" = True"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.GLPNFeatureExtractor.do_resize",description:`<strong>do_resize</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to resize the input based on certain <code>size_divisor</code>.`,name:"do_resize"},{anchor:"transformers.GLPNFeatureExtractor.size_divisor",description:`<strong>size_divisor</strong> (<code>int</code> or <code>Tuple(int)</code>, <em>optional</em>, defaults to 32) &#x2014;
Make sure the input is divisible by this value. Only has an effect if <code>do_resize</code> is set to <code>True</code>.`,name:"size_divisor"},{anchor:"transformers.GLPNFeatureExtractor.resample",description:`<strong>resample</strong> (<code>int</code>, <em>optional</em>, defaults to <code>PIL.Image.BILINEAR</code>) &#x2014;
An optional resampling filter. This can be one of <code>PIL.Image.NEAREST</code>, <code>PIL.Image.BOX</code>,
<code>PIL.Image.BILINEAR</code>, <code>PIL.Image.HAMMING</code>, <code>PIL.Image.BICUBIC</code> or <code>PIL.Image.LANCZOS</code>. Only has an effect
if <code>do_resize</code> is set to <code>True</code>.`,name:"resample"},{anchor:"transformers.GLPNFeatureExtractor.do_rescale",description:`<strong>do_rescale</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to apply the scaling factor (to make pixel values floats between 0. and 1.).`,name:"do_rescale"}],source:"https://github.com/huggingface/transformers/blob/v4.22.0/src/transformers/models/glpn/feature_extraction_glpn.py#L30"}}),Ne=new Ae({props:{name:"__call__",anchor:"transformers.GLPNFeatureExtractor.__call__",parameters:[{name:"images",val:": typing.Union[PIL.Image.Image, numpy.ndarray, ForwardRef('torch.Tensor'), typing.List[PIL.Image.Image], typing.List[numpy.ndarray], typing.List[ForwardRef('torch.Tensor')]]"},{name:"return_tensors",val:": typing.Union[str, transformers.utils.generic.TensorType, NoneType] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.GLPNFeatureExtractor.__call__.images",description:`<strong>images</strong> (<code>PIL.Image.Image</code>, <code>np.ndarray</code>, <code>torch.Tensor</code>, <code>List[PIL.Image.Image]</code>, <code>List[np.ndarray]</code>, <code>List[torch.Tensor]</code>) &#x2014;
The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch
tensor. In case of a NumPy array/PyTorch tensor, each image should be of shape (C, H, W), where C is a
number of channels, H and W are image height and width.`,name:"images"},{anchor:"transformers.GLPNFeatureExtractor.__call__.return_tensors",description:`<strong>return_tensors</strong> (<code>str</code> or <a href="/docs/transformers/v4.22.0/en/internal/file_utils#transformers.TensorType">TensorType</a>, <em>optional</em>, defaults to <code>&apos;np&apos;</code>) &#x2014;
If set, will return tensors of a particular framework. Acceptable values are:</p>
<ul>
<li><code>&apos;tf&apos;</code>: Return TensorFlow <code>tf.constant</code> objects.</li>
<li><code>&apos;pt&apos;</code>: Return PyTorch <code>torch.Tensor</code> objects.</li>
<li><code>&apos;np&apos;</code>: Return NumPy <code>np.ndarray</code> objects.</li>
<li><code>&apos;jax&apos;</code>: Return JAX <code>jnp.ndarray</code> objects.</li>
</ul>`,name:"return_tensors"}],source:"https://github.com/huggingface/transformers/blob/v4.22.0/src/transformers/models/glpn/feature_extraction_glpn.py#L70",returnDescription:`
<p>A <a
  href="/docs/transformers/v4.22.0/en/main_classes/feature_extractor#transformers.BatchFeature"
>BatchFeature</a> with the following fields:</p>
<ul>
<li><strong>pixel_values</strong> \u2014 Pixel values to be fed to a model, of shape (batch_size, num_channels, height,
width).</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.22.0/en/main_classes/feature_extractor#transformers.BatchFeature"
>BatchFeature</a></p>
`}}),te=new ro({props:{warning:!0,$$slots:{default:[ja]},$$scope:{ctx:x}}}),xe=new it({}),Ee=new Ae({props:{name:"class transformers.GLPNModel",anchor:"transformers.GLPNModel",parameters:[{name:"config",val:""}],parametersDescription:[{anchor:"transformers.GLPNModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/v4.22.0/en/model_doc/glpn#transformers.GLPNConfig">GLPNConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/v4.22.0/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/v4.22.0/src/transformers/models/glpn/modeling_glpn.py#L484"}}),ke=new Ae({props:{name:"forward",anchor:"transformers.GLPNModel.forward",parameters:[{name:"pixel_values",val:": FloatTensor"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.GLPNModel.forward.pixel_values",description:`<strong>pixel_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values. Padding will be ignored by default should you provide it. Pixel values can be obtained using
<a href="/docs/transformers/v4.22.0/en/model_doc/glpn#transformers.GLPNFeatureExtractor">GLPNFeatureExtractor</a>. See <a href="/docs/transformers/v4.22.0/en/model_doc/glpn#transformers.GLPNFeatureExtractor.__call__">GLPNFeatureExtractor.<strong>call</strong>()</a> for details.`,name:"pixel_values"},{anchor:"transformers.GLPNModel.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.GLPNModel.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.GLPNModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.22.0/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],source:"https://github.com/huggingface/transformers/blob/v4.22.0/src/transformers/models/glpn/modeling_glpn.py#L504",returnDescription:`
<p>A <a
  href="/docs/transformers/v4.22.0/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/v4.22.0/en/model_doc/glpn#transformers.GLPNConfig"
>GLPNConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.22.0/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),re=new ro({props:{$$slots:{default:[Ia]},$$scope:{ctx:x}}}),ae=new zr({props:{anchor:"transformers.GLPNModel.forward.example",$$slots:{default:[Ma]},$$scope:{ctx:x}}}),Fe=new it({}),je=new Ae({props:{name:"class transformers.GLPNForDepthEstimation",anchor:"transformers.GLPNForDepthEstimation",parameters:[{name:"config",val:""}],parametersDescription:[{anchor:"transformers.GLPNForDepthEstimation.config",description:`<strong>config</strong> (<a href="/docs/transformers/v4.22.0/en/model_doc/glpn#transformers.GLPNConfig">GLPNConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/v4.22.0/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/v4.22.0/src/transformers/models/glpn/modeling_glpn.py#L686"}}),Ce=new Ae({props:{name:"forward",anchor:"transformers.GLPNForDepthEstimation.forward",parameters:[{name:"pixel_values",val:""},{name:"labels",val:" = None"},{name:"output_attentions",val:" = None"},{name:"output_hidden_states",val:" = None"},{name:"return_dict",val:" = None"}],parametersDescription:[{anchor:"transformers.GLPNForDepthEstimation.forward.pixel_values",description:`<strong>pixel_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values. Padding will be ignored by default should you provide it. Pixel values can be obtained using
<a href="/docs/transformers/v4.22.0/en/model_doc/glpn#transformers.GLPNFeatureExtractor">GLPNFeatureExtractor</a>. See <a href="/docs/transformers/v4.22.0/en/model_doc/glpn#transformers.GLPNFeatureExtractor.__call__">GLPNFeatureExtractor.<strong>call</strong>()</a> for details.`,name:"pixel_values"},{anchor:"transformers.GLPNForDepthEstimation.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.GLPNForDepthEstimation.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.GLPNForDepthEstimation.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.22.0/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.GLPNForDepthEstimation.forward.labels",description:`<strong>labels</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, height, width)</code>, <em>optional</em>) &#x2014;
Ground truth depth estimation maps for computing the loss.`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/v4.22.0/src/transformers/models/glpn/modeling_glpn.py#L697",returnDescription:`
<p>A <a
  href="/docs/transformers/v4.22.0/en/main_classes/output#transformers.modeling_outputs.DepthEstimatorOutput"
>transformers.modeling_outputs.DepthEstimatorOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/v4.22.0/en/model_doc/glpn#transformers.GLPNConfig"
>GLPNConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification (or regression if config.num_labels==1) loss.</p>
</li>
<li>
<p><strong>predicted_depth</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, height, width)</code>) \u2014 Predicted depth for each pixel.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, num_channels, height, width)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, patch_size, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.22.0/en/main_classes/output#transformers.modeling_outputs.DepthEstimatorOutput"
>transformers.modeling_outputs.DepthEstimatorOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),se=new ro({props:{$$slots:{default:[Ca]},$$scope:{ctx:x}}}),ie=new zr({props:{anchor:"transformers.GLPNForDepthEstimation.forward.example",$$slots:{default:[za]},$$scope:{ctx:x}}}),{c(){d=r("meta"),v=f(),h=r("h1"),m=r("a"),b=r("span"),w(l.$$.fragment),_=f(),E=r("span"),ao=s("GLPN"),Gt=f(),w(V.$$.fragment),Tt=f(),D=r("h2"),J=r("a"),lt=r("span"),w(he.$$.fragment),no=f(),dt=r("span"),so=s("Overview"),kt=f(),M=r("p"),io=s("The GLPN model was proposed in "),me=r("a"),lo=s("Global-Local Path Networks for Monocular Depth Estimation with Vertical CutDepth"),co=s(`  by Doyeon Kim, Woonghyun Ga, Pyungwhan Ahn, Donggyu Joo, Sehwan Chun, Junmo Kim.
GLPN combines `),qe=r("a"),po=s("SegFormer"),ho=s(`\u2019s hierarchical mix-Transformer with a lightweight decoder for monocular depth estimation. The proposed decoder shows better performance than the previously proposed decoders, with considerably
less computational complexity.`),Ft=f(),Se=r("p"),mo=s("The abstract from the paper is the following:"),jt=f(),Oe=r("p"),ct=r("em"),fo=s("Depth estimation from a single image is an important task that can be applied to various fields in computer vision, and has grown rapidly with the development of convolutional neural networks. In this paper, we propose a novel structure and training strategy for monocular depth estimation to further improve the prediction accuracy of the network. We deploy a hierarchical transformer encoder to capture and convey the global context, and design a lightweight yet powerful decoder to generate an estimated depth map while considering local connectivity. By constructing connected paths between multi-scale local features and the global decoding stream with our proposed selective feature fusion module, the network can integrate both representations and recover fine details. In addition, the proposed decoder shows better performance than the previously proposed decoders, with considerably less computational complexity. Furthermore, we improve the depth-specific augmentation method by utilizing an important observation in depth estimation to enhance the model. Our network achieves state-of-the-art performance over the challenging depth dataset NYU Depth V2. Extensive experiments have been conducted to validate and show the effectiveness of the proposed approach. Finally, our model shows better generalisation ability and robustness than other comparative models."),It=f(),Be=r("p"),uo=s("Tips:"),Mt=f(),K=r("ul"),A=r("li"),go=s("A notebook illustrating inference with "),Re=r("a"),_o=s("GLPNForDepthEstimation"),vo=s(" can be found "),fe=r("a"),bo=s("here"),wo=s("."),Po=f(),ue=r("li"),$o=s("One can use "),Ue=r("a"),yo=s("GLPNFeatureExtractor"),Lo=s(" to prepare images for the model."),Ct=f(),Y=r("img"),zt=f(),X=r("small"),No=s("Summary of the approach. Taken from the "),ge=r("a"),xo=s("original paper"),Eo=s("."),Dt=f(),C=r("p"),Go=s("This model was contributed by "),_e=r("a"),To=s("nielsr"),ko=s(". The original code can be found "),ve=r("a"),Fo=s("here"),jo=s("."),At=f(),q=r("h2"),Z=r("a"),pt=r("span"),w(be.$$.fragment),Io=f(),ht=r("span"),Mo=s("GLPNConfig"),qt=f(),G=r("div"),w(we.$$.fragment),Co=f(),S=r("p"),zo=s("This is the configuration class to store the configuration of a "),We=r("a"),Do=s("GLPNModel"),Ao=s(`. It is used to instantiate an GLPN
model according to the specified arguments, defining the model architecture. Instantiating a configuration with the
defaults will yield a similar configuration to that of the GLPN
`),Pe=r("a"),qo=s("vinvino02/glpn-kitti"),So=s(" architecture."),Oo=f(),O=r("p"),Bo=s("Configuration objects inherit from "),He=r("a"),Ro=s("PretrainedConfig"),Uo=s(` and can be used to control the model outputs. Read the
documentation from `),Ve=r("a"),Wo=s("PretrainedConfig"),Ho=s(" for more information."),Vo=f(),w(Q.$$.fragment),St=f(),B=r("h2"),ee=r("a"),mt=r("span"),w($e.$$.fragment),Jo=f(),ft=r("span"),Ko=s("GLPNFeatureExtractor"),Ot=f(),T=r("div"),w(ye.$$.fragment),Yo=f(),ut=r("p"),Xo=s("Constructs a GLPN feature extractor."),Zo=f(),Le=r("p"),Qo=s("This feature extractor inherits from "),Je=r("a"),er=s("FeatureExtractionMixin"),tr=s(` which contains most of the main methods. Users
should refer to this superclass for more information regarding those methods.`),or=f(),z=r("div"),w(Ne.$$.fragment),rr=f(),gt=r("p"),ar=s("Main method to prepare for the model one or several image(s)."),nr=f(),w(te.$$.fragment),Bt=f(),R=r("h2"),oe=r("a"),_t=r("span"),w(xe.$$.fragment),sr=f(),vt=r("span"),ir=s("GLPNModel"),Rt=f(),j=r("div"),w(Ee.$$.fragment),lr=f(),Ge=r("p"),dr=s(`The bare GLPN encoder (Mix-Transformer) outputting raw hidden-states without any specific head on top.
This model is a PyTorch `),Te=r("a"),cr=s("torch.nn.Module"),pr=s(` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),hr=f(),k=r("div"),w(ke.$$.fragment),mr=f(),U=r("p"),fr=s("The "),Ke=r("a"),ur=s("GLPNModel"),gr=s(" forward method, overrides the "),bt=r("code"),_r=s("__call__"),vr=s(" special method."),br=f(),w(re.$$.fragment),wr=f(),w(ae.$$.fragment),Ut=f(),W=r("h2"),ne=r("a"),wt=r("span"),w(Fe.$$.fragment),Pr=f(),Pt=r("span"),$r=s("GLPNForDepthEstimation"),Wt=f(),I=r("div"),w(je.$$.fragment),yr=f(),Ie=r("p"),Lr=s(`GLPN Model transformer with a lightweight depth estimation head on top e.g. for KITTI, NYUv2.
This model is a PyTorch `),Me=r("a"),Nr=s("torch.nn.Module"),xr=s(` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),Er=f(),F=r("div"),w(Ce.$$.fragment),Gr=f(),H=r("p"),Tr=s("The "),Ye=r("a"),kr=s("GLPNForDepthEstimation"),Fr=s(" forward method, overrides the "),$t=r("code"),jr=s("__call__"),Ir=s(" special method."),Mr=f(),w(se.$$.fragment),Cr=f(),w(ie.$$.fragment),this.h()},l(e){const p=Ea('[data-svelte="svelte-1phssyn"]',document.head);d=a(p,"META",{name:!0,content:!0}),p.forEach(o),v=u(e),h=a(e,"H1",{class:!0});var ze=n(h);m=a(ze,"A",{id:!0,class:!0,href:!0});var yt=n(m);b=a(yt,"SPAN",{});var Lt=n(b);P(l.$$.fragment,Lt),Lt.forEach(o),yt.forEach(o),_=u(ze),E=a(ze,"SPAN",{});var Nt=n(E);ao=i(Nt,"GLPN"),Nt.forEach(o),ze.forEach(o),Gt=u(e),P(V.$$.fragment,e),Tt=u(e),D=a(e,"H2",{class:!0});var De=n(D);J=a(De,"A",{id:!0,class:!0,href:!0});var xt=n(J);lt=a(xt,"SPAN",{});var Et=n(lt);P(he.$$.fragment,Et),Et.forEach(o),xt.forEach(o),no=u(De),dt=a(De,"SPAN",{});var Sr=n(dt);so=i(Sr,"Overview"),Sr.forEach(o),De.forEach(o),kt=u(e),M=a(e,"P",{});var Xe=n(M);io=i(Xe,"The GLPN model was proposed in "),me=a(Xe,"A",{href:!0,rel:!0});var Or=n(me);lo=i(Or,"Global-Local Path Networks for Monocular Depth Estimation with Vertical CutDepth"),Or.forEach(o),co=i(Xe,`  by Doyeon Kim, Woonghyun Ga, Pyungwhan Ahn, Donggyu Joo, Sehwan Chun, Junmo Kim.
GLPN combines `),qe=a(Xe,"A",{href:!0});var Br=n(qe);po=i(Br,"SegFormer"),Br.forEach(o),ho=i(Xe,`\u2019s hierarchical mix-Transformer with a lightweight decoder for monocular depth estimation. The proposed decoder shows better performance than the previously proposed decoders, with considerably
less computational complexity.`),Xe.forEach(o),Ft=u(e),Se=a(e,"P",{});var Rr=n(Se);mo=i(Rr,"The abstract from the paper is the following:"),Rr.forEach(o),jt=u(e),Oe=a(e,"P",{});var Ur=n(Oe);ct=a(Ur,"EM",{});var Wr=n(ct);fo=i(Wr,"Depth estimation from a single image is an important task that can be applied to various fields in computer vision, and has grown rapidly with the development of convolutional neural networks. In this paper, we propose a novel structure and training strategy for monocular depth estimation to further improve the prediction accuracy of the network. We deploy a hierarchical transformer encoder to capture and convey the global context, and design a lightweight yet powerful decoder to generate an estimated depth map while considering local connectivity. By constructing connected paths between multi-scale local features and the global decoding stream with our proposed selective feature fusion module, the network can integrate both representations and recover fine details. In addition, the proposed decoder shows better performance than the previously proposed decoders, with considerably less computational complexity. Furthermore, we improve the depth-specific augmentation method by utilizing an important observation in depth estimation to enhance the model. Our network achieves state-of-the-art performance over the challenging depth dataset NYU Depth V2. Extensive experiments have been conducted to validate and show the effectiveness of the proposed approach. Finally, our model shows better generalisation ability and robustness than other comparative models."),Wr.forEach(o),Ur.forEach(o),It=u(e),Be=a(e,"P",{});var Hr=n(Be);uo=i(Hr,"Tips:"),Hr.forEach(o),Mt=u(e),K=a(e,"UL",{});var Vt=n(K);A=a(Vt,"LI",{});var Ze=n(A);go=i(Ze,"A notebook illustrating inference with "),Re=a(Ze,"A",{href:!0});var Vr=n(Re);_o=i(Vr,"GLPNForDepthEstimation"),Vr.forEach(o),vo=i(Ze," can be found "),fe=a(Ze,"A",{href:!0,rel:!0});var Jr=n(fe);bo=i(Jr,"here"),Jr.forEach(o),wo=i(Ze,"."),Ze.forEach(o),Po=u(Vt),ue=a(Vt,"LI",{});var Jt=n(ue);$o=i(Jt,"One can use "),Ue=a(Jt,"A",{href:!0});var Kr=n(Ue);yo=i(Kr,"GLPNFeatureExtractor"),Kr.forEach(o),Lo=i(Jt," to prepare images for the model."),Jt.forEach(o),Vt.forEach(o),Ct=u(e),Y=a(e,"IMG",{src:!0,alt:!0,width:!0}),zt=u(e),X=a(e,"SMALL",{});var Kt=n(X);No=i(Kt,"Summary of the approach. Taken from the "),ge=a(Kt,"A",{href:!0,target:!0});var Yr=n(ge);xo=i(Yr,"original paper"),Yr.forEach(o),Eo=i(Kt,"."),Kt.forEach(o),Dt=u(e),C=a(e,"P",{});var Qe=n(C);Go=i(Qe,"This model was contributed by "),_e=a(Qe,"A",{href:!0,rel:!0});var Xr=n(_e);To=i(Xr,"nielsr"),Xr.forEach(o),ko=i(Qe,". The original code can be found "),ve=a(Qe,"A",{href:!0,rel:!0});var Zr=n(ve);Fo=i(Zr,"here"),Zr.forEach(o),jo=i(Qe,"."),Qe.forEach(o),At=u(e),q=a(e,"H2",{class:!0});var Yt=n(q);Z=a(Yt,"A",{id:!0,class:!0,href:!0});var Qr=n(Z);pt=a(Qr,"SPAN",{});var ea=n(pt);P(be.$$.fragment,ea),ea.forEach(o),Qr.forEach(o),Io=u(Yt),ht=a(Yt,"SPAN",{});var ta=n(ht);Mo=i(ta,"GLPNConfig"),ta.forEach(o),Yt.forEach(o),qt=u(e),G=a(e,"DIV",{class:!0});var le=n(G);P(we.$$.fragment,le),Co=u(le),S=a(le,"P",{});var et=n(S);zo=i(et,"This is the configuration class to store the configuration of a "),We=a(et,"A",{href:!0});var oa=n(We);Do=i(oa,"GLPNModel"),oa.forEach(o),Ao=i(et,`. It is used to instantiate an GLPN
model according to the specified arguments, defining the model architecture. Instantiating a configuration with the
defaults will yield a similar configuration to that of the GLPN
`),Pe=a(et,"A",{href:!0,rel:!0});var ra=n(Pe);qo=i(ra,"vinvino02/glpn-kitti"),ra.forEach(o),So=i(et," architecture."),et.forEach(o),Oo=u(le),O=a(le,"P",{});var tt=n(O);Bo=i(tt,"Configuration objects inherit from "),He=a(tt,"A",{href:!0});var aa=n(He);Ro=i(aa,"PretrainedConfig"),aa.forEach(o),Uo=i(tt,` and can be used to control the model outputs. Read the
documentation from `),Ve=a(tt,"A",{href:!0});var na=n(Ve);Wo=i(na,"PretrainedConfig"),na.forEach(o),Ho=i(tt," for more information."),tt.forEach(o),Vo=u(le),P(Q.$$.fragment,le),le.forEach(o),St=u(e),B=a(e,"H2",{class:!0});var Xt=n(B);ee=a(Xt,"A",{id:!0,class:!0,href:!0});var sa=n(ee);mt=a(sa,"SPAN",{});var ia=n(mt);P($e.$$.fragment,ia),ia.forEach(o),sa.forEach(o),Jo=u(Xt),ft=a(Xt,"SPAN",{});var la=n(ft);Ko=i(la,"GLPNFeatureExtractor"),la.forEach(o),Xt.forEach(o),Ot=u(e),T=a(e,"DIV",{class:!0});var de=n(T);P(ye.$$.fragment,de),Yo=u(de),ut=a(de,"P",{});var da=n(ut);Xo=i(da,"Constructs a GLPN feature extractor."),da.forEach(o),Zo=u(de),Le=a(de,"P",{});var Zt=n(Le);Qo=i(Zt,"This feature extractor inherits from "),Je=a(Zt,"A",{href:!0});var ca=n(Je);er=i(ca,"FeatureExtractionMixin"),ca.forEach(o),tr=i(Zt,` which contains most of the main methods. Users
should refer to this superclass for more information regarding those methods.`),Zt.forEach(o),or=u(de),z=a(de,"DIV",{class:!0});var ot=n(z);P(Ne.$$.fragment,ot),rr=u(ot),gt=a(ot,"P",{});var pa=n(gt);ar=i(pa,"Main method to prepare for the model one or several image(s)."),pa.forEach(o),nr=u(ot),P(te.$$.fragment,ot),ot.forEach(o),de.forEach(o),Bt=u(e),R=a(e,"H2",{class:!0});var Qt=n(R);oe=a(Qt,"A",{id:!0,class:!0,href:!0});var ha=n(oe);_t=a(ha,"SPAN",{});var ma=n(_t);P(xe.$$.fragment,ma),ma.forEach(o),ha.forEach(o),sr=u(Qt),vt=a(Qt,"SPAN",{});var fa=n(vt);ir=i(fa,"GLPNModel"),fa.forEach(o),Qt.forEach(o),Rt=u(e),j=a(e,"DIV",{class:!0});var rt=n(j);P(Ee.$$.fragment,rt),lr=u(rt),Ge=a(rt,"P",{});var eo=n(Ge);dr=i(eo,`The bare GLPN encoder (Mix-Transformer) outputting raw hidden-states without any specific head on top.
This model is a PyTorch `),Te=a(eo,"A",{href:!0,rel:!0});var ua=n(Te);cr=i(ua,"torch.nn.Module"),ua.forEach(o),pr=i(eo,` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),eo.forEach(o),hr=u(rt),k=a(rt,"DIV",{class:!0});var ce=n(k);P(ke.$$.fragment,ce),mr=u(ce),U=a(ce,"P",{});var at=n(U);fr=i(at,"The "),Ke=a(at,"A",{href:!0});var ga=n(Ke);ur=i(ga,"GLPNModel"),ga.forEach(o),gr=i(at," forward method, overrides the "),bt=a(at,"CODE",{});var _a=n(bt);_r=i(_a,"__call__"),_a.forEach(o),vr=i(at," special method."),at.forEach(o),br=u(ce),P(re.$$.fragment,ce),wr=u(ce),P(ae.$$.fragment,ce),ce.forEach(o),rt.forEach(o),Ut=u(e),W=a(e,"H2",{class:!0});var to=n(W);ne=a(to,"A",{id:!0,class:!0,href:!0});var va=n(ne);wt=a(va,"SPAN",{});var ba=n(wt);P(Fe.$$.fragment,ba),ba.forEach(o),va.forEach(o),Pr=u(to),Pt=a(to,"SPAN",{});var wa=n(Pt);$r=i(wa,"GLPNForDepthEstimation"),wa.forEach(o),to.forEach(o),Wt=u(e),I=a(e,"DIV",{class:!0});var nt=n(I);P(je.$$.fragment,nt),yr=u(nt),Ie=a(nt,"P",{});var oo=n(Ie);Lr=i(oo,`GLPN Model transformer with a lightweight depth estimation head on top e.g. for KITTI, NYUv2.
This model is a PyTorch `),Me=a(oo,"A",{href:!0,rel:!0});var Pa=n(Me);Nr=i(Pa,"torch.nn.Module"),Pa.forEach(o),xr=i(oo,` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),oo.forEach(o),Er=u(nt),F=a(nt,"DIV",{class:!0});var pe=n(F);P(Ce.$$.fragment,pe),Gr=u(pe),H=a(pe,"P",{});var st=n(H);Tr=i(st,"The "),Ye=a(st,"A",{href:!0});var $a=n(Ye);kr=i($a,"GLPNForDepthEstimation"),$a.forEach(o),Fr=i(st," forward method, overrides the "),$t=a(st,"CODE",{});var ya=n($t);jr=i(ya,"__call__"),ya.forEach(o),Ir=i(st," special method."),st.forEach(o),Mr=u(pe),P(se.$$.fragment,pe),Cr=u(pe),P(ie.$$.fragment,pe),pe.forEach(o),nt.forEach(o),this.h()},h(){c(d,"name","hf:doc:metadata"),c(d,"content",JSON.stringify(Aa)),c(m,"id","glpn"),c(m,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(m,"href","#glpn"),c(h,"class","relative group"),c(J,"id","overview"),c(J,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(J,"href","#overview"),c(D,"class","relative group"),c(me,"href","https://arxiv.org/abs/2201.07436"),c(me,"rel","nofollow"),c(qe,"href","segformer"),c(Re,"href","/docs/transformers/v4.22.0/en/model_doc/glpn#transformers.GLPNForDepthEstimation"),c(fe,"href","https://github.com/NielsRogge/Transformers-Tutorials/blob/master/GLPN/GLPN_inference_(depth_estimation).ipynb"),c(fe,"rel","nofollow"),c(Ue,"href","/docs/transformers/v4.22.0/en/model_doc/glpn#transformers.GLPNFeatureExtractor"),Ga(Y.src,qr="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/glpn_architecture.jpg")||c(Y,"src",qr),c(Y,"alt","drawing"),c(Y,"width","600"),c(ge,"href","https://arxiv.org/abs/2201.07436"),c(ge,"target","_blank"),c(_e,"href","https://huggingface.co/nielsr"),c(_e,"rel","nofollow"),c(ve,"href","https://github.com/vinvino02/GLPDepth"),c(ve,"rel","nofollow"),c(Z,"id","transformers.GLPNConfig"),c(Z,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Z,"href","#transformers.GLPNConfig"),c(q,"class","relative group"),c(We,"href","/docs/transformers/v4.22.0/en/model_doc/glpn#transformers.GLPNModel"),c(Pe,"href","https://huggingface.co/vinvino02/glpn-kitti"),c(Pe,"rel","nofollow"),c(He,"href","/docs/transformers/v4.22.0/en/main_classes/configuration#transformers.PretrainedConfig"),c(Ve,"href","/docs/transformers/v4.22.0/en/main_classes/configuration#transformers.PretrainedConfig"),c(G,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(ee,"id","transformers.GLPNFeatureExtractor"),c(ee,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(ee,"href","#transformers.GLPNFeatureExtractor"),c(B,"class","relative group"),c(Je,"href","/docs/transformers/v4.22.0/en/main_classes/feature_extractor#transformers.FeatureExtractionMixin"),c(z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(T,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(oe,"id","transformers.GLPNModel"),c(oe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(oe,"href","#transformers.GLPNModel"),c(R,"class","relative group"),c(Te,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(Te,"rel","nofollow"),c(Ke,"href","/docs/transformers/v4.22.0/en/model_doc/glpn#transformers.GLPNModel"),c(k,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(j,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(ne,"id","transformers.GLPNForDepthEstimation"),c(ne,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(ne,"href","#transformers.GLPNForDepthEstimation"),c(W,"class","relative group"),c(Me,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(Me,"rel","nofollow"),c(Ye,"href","/docs/transformers/v4.22.0/en/model_doc/glpn#transformers.GLPNForDepthEstimation"),c(F,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(I,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(e,p){t(document.head,d),g(e,v,p),g(e,h,p),t(h,m),t(m,b),$(l,b,null),t(h,_),t(h,E),t(E,ao),g(e,Gt,p),$(V,e,p),g(e,Tt,p),g(e,D,p),t(D,J),t(J,lt),$(he,lt,null),t(D,no),t(D,dt),t(dt,so),g(e,kt,p),g(e,M,p),t(M,io),t(M,me),t(me,lo),t(M,co),t(M,qe),t(qe,po),t(M,ho),g(e,Ft,p),g(e,Se,p),t(Se,mo),g(e,jt,p),g(e,Oe,p),t(Oe,ct),t(ct,fo),g(e,It,p),g(e,Be,p),t(Be,uo),g(e,Mt,p),g(e,K,p),t(K,A),t(A,go),t(A,Re),t(Re,_o),t(A,vo),t(A,fe),t(fe,bo),t(A,wo),t(K,Po),t(K,ue),t(ue,$o),t(ue,Ue),t(Ue,yo),t(ue,Lo),g(e,Ct,p),g(e,Y,p),g(e,zt,p),g(e,X,p),t(X,No),t(X,ge),t(ge,xo),t(X,Eo),g(e,Dt,p),g(e,C,p),t(C,Go),t(C,_e),t(_e,To),t(C,ko),t(C,ve),t(ve,Fo),t(C,jo),g(e,At,p),g(e,q,p),t(q,Z),t(Z,pt),$(be,pt,null),t(q,Io),t(q,ht),t(ht,Mo),g(e,qt,p),g(e,G,p),$(we,G,null),t(G,Co),t(G,S),t(S,zo),t(S,We),t(We,Do),t(S,Ao),t(S,Pe),t(Pe,qo),t(S,So),t(G,Oo),t(G,O),t(O,Bo),t(O,He),t(He,Ro),t(O,Uo),t(O,Ve),t(Ve,Wo),t(O,Ho),t(G,Vo),$(Q,G,null),g(e,St,p),g(e,B,p),t(B,ee),t(ee,mt),$($e,mt,null),t(B,Jo),t(B,ft),t(ft,Ko),g(e,Ot,p),g(e,T,p),$(ye,T,null),t(T,Yo),t(T,ut),t(ut,Xo),t(T,Zo),t(T,Le),t(Le,Qo),t(Le,Je),t(Je,er),t(Le,tr),t(T,or),t(T,z),$(Ne,z,null),t(z,rr),t(z,gt),t(gt,ar),t(z,nr),$(te,z,null),g(e,Bt,p),g(e,R,p),t(R,oe),t(oe,_t),$(xe,_t,null),t(R,sr),t(R,vt),t(vt,ir),g(e,Rt,p),g(e,j,p),$(Ee,j,null),t(j,lr),t(j,Ge),t(Ge,dr),t(Ge,Te),t(Te,cr),t(Ge,pr),t(j,hr),t(j,k),$(ke,k,null),t(k,mr),t(k,U),t(U,fr),t(U,Ke),t(Ke,ur),t(U,gr),t(U,bt),t(bt,_r),t(U,vr),t(k,br),$(re,k,null),t(k,wr),$(ae,k,null),g(e,Ut,p),g(e,W,p),t(W,ne),t(ne,wt),$(Fe,wt,null),t(W,Pr),t(W,Pt),t(Pt,$r),g(e,Wt,p),g(e,I,p),$(je,I,null),t(I,yr),t(I,Ie),t(Ie,Lr),t(Ie,Me),t(Me,Nr),t(Ie,xr),t(I,Er),t(I,F),$(Ce,F,null),t(F,Gr),t(F,H),t(H,Tr),t(H,Ye),t(Ye,kr),t(H,Fr),t(H,$t),t($t,jr),t(H,Ir),t(F,Mr),$(se,F,null),t(F,Cr),$(ie,F,null),Ht=!0},p(e,[p]){const ze={};p&2&&(ze.$$scope={dirty:p,ctx:e}),V.$set(ze);const yt={};p&2&&(yt.$$scope={dirty:p,ctx:e}),Q.$set(yt);const Lt={};p&2&&(Lt.$$scope={dirty:p,ctx:e}),te.$set(Lt);const Nt={};p&2&&(Nt.$$scope={dirty:p,ctx:e}),re.$set(Nt);const De={};p&2&&(De.$$scope={dirty:p,ctx:e}),ae.$set(De);const xt={};p&2&&(xt.$$scope={dirty:p,ctx:e}),se.$set(xt);const Et={};p&2&&(Et.$$scope={dirty:p,ctx:e}),ie.$set(Et)},i(e){Ht||(y(l.$$.fragment,e),y(V.$$.fragment,e),y(he.$$.fragment,e),y(be.$$.fragment,e),y(we.$$.fragment,e),y(Q.$$.fragment,e),y($e.$$.fragment,e),y(ye.$$.fragment,e),y(Ne.$$.fragment,e),y(te.$$.fragment,e),y(xe.$$.fragment,e),y(Ee.$$.fragment,e),y(ke.$$.fragment,e),y(re.$$.fragment,e),y(ae.$$.fragment,e),y(Fe.$$.fragment,e),y(je.$$.fragment,e),y(Ce.$$.fragment,e),y(se.$$.fragment,e),y(ie.$$.fragment,e),Ht=!0)},o(e){L(l.$$.fragment,e),L(V.$$.fragment,e),L(he.$$.fragment,e),L(be.$$.fragment,e),L(we.$$.fragment,e),L(Q.$$.fragment,e),L($e.$$.fragment,e),L(ye.$$.fragment,e),L(Ne.$$.fragment,e),L(te.$$.fragment,e),L(xe.$$.fragment,e),L(Ee.$$.fragment,e),L(ke.$$.fragment,e),L(re.$$.fragment,e),L(ae.$$.fragment,e),L(Fe.$$.fragment,e),L(je.$$.fragment,e),L(Ce.$$.fragment,e),L(se.$$.fragment,e),L(ie.$$.fragment,e),Ht=!1},d(e){o(d),e&&o(v),e&&o(h),N(l),e&&o(Gt),N(V,e),e&&o(Tt),e&&o(D),N(he),e&&o(kt),e&&o(M),e&&o(Ft),e&&o(Se),e&&o(jt),e&&o(Oe),e&&o(It),e&&o(Be),e&&o(Mt),e&&o(K),e&&o(Ct),e&&o(Y),e&&o(zt),e&&o(X),e&&o(Dt),e&&o(C),e&&o(At),e&&o(q),N(be),e&&o(qt),e&&o(G),N(we),N(Q),e&&o(St),e&&o(B),N($e),e&&o(Ot),e&&o(T),N(ye),N(Ne),N(te),e&&o(Bt),e&&o(R),N(xe),e&&o(Rt),e&&o(j),N(Ee),N(ke),N(re),N(ae),e&&o(Ut),e&&o(W),N(Fe),e&&o(Wt),e&&o(I),N(je),N(Ce),N(se),N(ie)}}}const Aa={local:"glpn",sections:[{local:"overview",title:"Overview"},{local:"transformers.GLPNConfig",title:"GLPNConfig"},{local:"transformers.GLPNFeatureExtractor",title:"GLPNFeatureExtractor"},{local:"transformers.GLPNModel",title:"GLPNModel"},{local:"transformers.GLPNForDepthEstimation",title:"GLPNForDepthEstimation"}],title:"GLPN"};function qa(x){return Ta(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Ha extends La{constructor(d){super();Na(this,d,qa,Da,xa,{})}}export{Ha as default,Aa as metadata};
