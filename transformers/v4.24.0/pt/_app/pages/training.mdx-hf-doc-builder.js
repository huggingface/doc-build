import{S as Nm,i as Im,s as Lm,e as o,k as m,w as u,t as i,M as Mm,c as r,d as a,m as c,a as n,x as f,h as p,b as d,G as s,g as l,y as h,q as g,o as _,B as v,v as Hm}from"../chunks/vendor-hf-doc-builder.js";import{T as Mi}from"../chunks/Tip-hf-doc-builder.js";import{Y as Kr}from"../chunks/Youtube-hf-doc-builder.js";import{I as T}from"../chunks/IconCopyLink-hf-doc-builder.js";import{C as j}from"../chunks/CodeBlock-hf-doc-builder.js";import{D as Rm}from"../chunks/DocNotebookDropdown-hf-doc-builder.js";function Bm(oe){let $,y;return{c(){$=o("p"),y=i(`Voc\xEA ver\xE1 um alerta sobre alguns pesos pr\xE9-treinados que n\xE3o est\xE3o sendo utilizados e que alguns pesos est\xE3o
sendo inicializados aleatoriamente. N\xE3o se preocupe, essa mensagem \xE9 completamente normal.
O header/cabe\xE7\xE1rio pr\xE9-treinado do modelo BERT \xE9 descartado e substitui-se por um header de classifica\xE7\xE3o
inicializado aleatoriamente. Assim, pode aplicar o fine-tuning a este novo header do modelo em sua tarefa
de classifica\xE7\xE3o de sequ\xEAncias fazendo um transfer learning do modelo pr\xE9-treinado.`)},l(b){$=r(b,"P",{});var k=n($);y=p(k,`Voc\xEA ver\xE1 um alerta sobre alguns pesos pr\xE9-treinados que n\xE3o est\xE3o sendo utilizados e que alguns pesos est\xE3o
sendo inicializados aleatoriamente. N\xE3o se preocupe, essa mensagem \xE9 completamente normal.
O header/cabe\xE7\xE1rio pr\xE9-treinado do modelo BERT \xE9 descartado e substitui-se por um header de classifica\xE7\xE3o
inicializado aleatoriamente. Assim, pode aplicar o fine-tuning a este novo header do modelo em sua tarefa
de classifica\xE7\xE3o de sequ\xEAncias fazendo um transfer learning do modelo pr\xE9-treinado.`),k.forEach(a)},m(b,k){l(b,$,k),s($,y)},d(b){b&&a($)}}}function Km(oe){let $,y,b,k,P,E,O,z;return{c(){$=o("p"),y=i("O "),b=o("code"),k=i("Trainer"),P=i(" utiliza "),E=o("code"),O=i("DataCollatorWithPadding"),z=i(` por padr\xE3o, ent\xE3o voc\xEA n\xE3o precisa especificar explicitamente um
colador de dados (data collator).`)},l(A){$=r(A,"P",{});var w=n($);y=p(w,"O "),b=r(w,"CODE",{});var C=n(b);k=p(C,"Trainer"),C.forEach(a),P=p(w," utiliza "),E=r(w,"CODE",{});var F=n(E);O=p(F,"DataCollatorWithPadding"),F.forEach(a),z=p(w,` por padr\xE3o, ent\xE3o voc\xEA n\xE3o precisa especificar explicitamente um
colador de dados (data collator).`),w.forEach(a)},m(A,w){l(A,$,w),s($,y),s($,b),s(b,k),s($,P),s($,E),s(E,O),s($,z)},d(A){A&&a($)}}}function Um(oe){let $,y,b,k,P,E,O,z;return{c(){$=o("p"),y=i(`Se necess\xE1rio, voc\xEA pode obter o acesso gratuito a uma GPU na n\xFAvem por meio de um notebook no
`),b=o("a"),k=i("Colaboratory"),P=i(" ou "),E=o("a"),O=i("SageMaker StudioLab"),z=i(`
se n\xE3o tiver esse recurso de forma local.`),this.h()},l(A){$=r(A,"P",{});var w=n($);y=p(w,`Se necess\xE1rio, voc\xEA pode obter o acesso gratuito a uma GPU na n\xFAvem por meio de um notebook no
`),b=r(w,"A",{href:!0,rel:!0});var C=n(b);k=p(C,"Colaboratory"),C.forEach(a),P=p(w," ou "),E=r(w,"A",{href:!0,rel:!0});var F=n(E);O=p(F,"SageMaker StudioLab"),F.forEach(a),z=p(w,`
se n\xE3o tiver esse recurso de forma local.`),w.forEach(a),this.h()},h(){d(b,"href","https://colab.research.google.com/"),d(b,"rel","nofollow"),d(E,"href","https://studiolab.sagemaker.aws/"),d(E,"rel","nofollow")},m(A,w){l(A,$,w),s($,y),s($,b),s(b,k),s($,P),s($,E),s(E,O),s($,z)},d(A){A&&a($)}}}function Wm(oe){let $,y,b,k,P,E,O,z,A,w,C,F,Ga,Ur,xt,N,Le,Wr,bs,Gr,Yr,Qr,js,Vr,Jr,ws,Xr,St,Ya,Ot,B,re,ks,Me,Zr,Es,en,Ft,He,Nt,Qa,an,It,ne,sn,Re,tn,on,Lt,Be,Mt,le,rn,Ke,ys,nn,ln,Ht,Ue,Rt,Va,pn,Bt,We,Kt,Ja,Ut,K,ie,qs,Ge,mn,Xa,cn,As,dn,Wt,Ye,Gt,I,un,Ts,fn,hn,Ps,gn,_n,Yt,pe,vn,Qe,$n,bn,Qt,Ve,Vt,me,Jt,U,ce,zs,Je,jn,Cs,wn,Xt,L,kn,Ds,En,yn,Xe,qn,An,Zt,Za,Tn,eo,Ze,ao,W,de,xs,ea,Pn,Ss,zn,so,q,Cn,Os,Dn,xn,Fs,Sn,On,aa,Ns,Fn,Nn,Is,In,Ln,sa,Mn,Hn,to,ta,oo,D,Rn,Ls,Bn,Kn,Ms,Un,Wn,Hs,Gn,Yn,ro,oa,no,ue,Qn,Rs,Vn,Jn,lo,ra,io,G,fe,Bs,na,Xn,Ks,Zn,po,he,el,Us,al,sl,mo,la,co,ge,tl,Ws,ol,rl,uo,ia,fo,es,ho,Y,_e,Gs,pa,nl,Ys,ll,go,ma,_o,as,il,vo,Q,ve,Qs,ca,pl,Vs,ml,$o,M,cl,Js,dl,ul,Xs,fl,hl,bo,da,jo,$e,wo,x,gl,ua,Zs,_l,vl,et,$l,bl,at,jl,wl,ko,fa,Eo,V,be,st,ha,kl,tt,El,yo,ss,yl,qo,ga,Ao,je,ql,_a,ot,Al,Tl,To,va,Po,ts,zo,J,we,rt,$a,Pl,nt,zl,Co,ba,Do,ke,Cl,lt,Dl,xl,xo,os,Sl,So,ja,Oo,Ee,Ol,it,Fl,Nl,Fo,H,wa,ka,Il,pt,Ll,Ml,Hl,Ea,Rl,ya,X,Bl,mt,Kl,Ul,ct,Wl,Gl,Yl,qa,Ql,Aa,dt,Vl,Jl,Ta,No,rs,Xl,Io,Pa,Lo,Z,ye,ut,za,Zl,ft,ei,Mo,qe,ai,ht,si,ti,Ho,Ca,Ro,ns,oi,Bo,Da,Ko,ee,Ae,gt,xa,ri,_t,ni,Uo,Te,li,Sa,vt,ii,pi,Wo,Oa,Go,Pe,mi,$t,ci,di,Yo,Fa,Qo,ze,ui,bt,fi,hi,Vo,Na,Jo,Ce,Xo,ls,gi,Zo,ae,De,jt,Ia,_i,wt,vi,er,xe,$i,La,bi,ji,ar,Ma,sr,se,Se,kt,Ha,wi,Et,ki,tr,R,Ei,yt,yi,qi,Ra,qt,Ai,Ti,or,Ba,rr,is,nr,te,Oe,At,Ka,Pi,Tt,zi,lr,ps,Ci,ir,Fe,Pt,ms,Ua,Di,xi,Si,zt,cs,ds,Oi,Fi,pr;return E=new T({}),C=new Rm({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Mixed",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/main/transformers_doc/pt/training.ipynb"},{label:"PyTorch",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/main/transformers_doc/pt/pytorch/training.ipynb"},{label:"TensorFlow",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/main/transformers_doc/pt/tensorflow/training.ipynb"},{label:"Mixed",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/main/transformers_doc/pt/training.ipynb"},{label:"PyTorch",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/main/transformers_doc/pt/pytorch/training.ipynb"},{label:"TensorFlow",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/main/transformers_doc/pt/tensorflow/training.ipynb"}]}}),Me=new T({}),He=new Kr({props:{id:"_BZearw7f0w"}}),Be=new j({props:{code:`from datasets import load_dataset

dataset = load_dataset("yelp_review_full")
dataset[100]`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&quot;yelp_review_full&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>dataset[<span class="hljs-number">100</span>]
{<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;text&#x27;</span>: <span class="hljs-string">&#x27;My expectations for McDonalds are t rarely high. But for one to still fail so spectacularly...that takes something special!\\\\nThe cashier took my friends\\&#x27;s order, then promptly ignored me. I had to force myself in front of a cashier who opened his register to wait on the person BEHIND me. I waited over five minutes for a gigantic order that included precisely one kid\\&#x27;s meal. After watching two people who ordered after me be handed their food, I asked where mine was. The manager started yelling at the cashiers for \\\\&quot;serving off their orders\\\\&quot; when they didn\\&#x27;t have their food. But neither cashier was anywhere near those controls, and the manager was the one serving food to customers and clearing the boards.\\\\nThe manager was rude when giving me my order. She didn\\&#x27;t make sure that I had everything ON MY RECEIPT, and never even had the decency to apologize that I felt I was getting poor service.\\\\nI\\&#x27;ve eaten at various McDonalds restaurants for over 30 years. I\\&#x27;ve worked at more than one location. I expect bad days, bad moods, and the occasional mistake. But I have yet to have a decent experience at this store. It will remain a place I avoid unless someone in my party needs to avoid illness from low blood sugar. Perhaps I should go back to the racially biased service of Steak n Shake instead!&#x27;</span>}`}}),Ue=new j({props:{code:`from transformers import AutoTokenizer

tokenizer = AutoTokenizer.from_pretrained("bert-base-cased")


def tokenize_function(examples):
    return tokenizer(examples["text"], padding="max_length", truncation=True)


tokenized_datasets = dataset.map(tokenize_function, batched=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;bert-base-cased&quot;</span>)


<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize_function</span>(<span class="hljs-params">examples</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> tokenizer(examples[<span class="hljs-string">&quot;text&quot;</span>], padding=<span class="hljs-string">&quot;max_length&quot;</span>, truncation=<span class="hljs-literal">True</span>)


<span class="hljs-meta">&gt;&gt;&gt; </span>tokenized_datasets = dataset.<span class="hljs-built_in">map</span>(tokenize_function, batched=<span class="hljs-literal">True</span>)`}}),We=new j({props:{code:`small_train_dataset = tokenized_datasets["train"].shuffle(seed=42).select(range(1000))
small_eval_dataset = tokenized_datasets["test"].shuffle(seed=42).select(range(1000))`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>small_train_dataset = tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>].shuffle(seed=<span class="hljs-number">42</span>).select(<span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>small_eval_dataset = tokenized_datasets[<span class="hljs-string">&quot;test&quot;</span>].shuffle(seed=<span class="hljs-number">42</span>).select(<span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>))`}}),Ge=new T({}),Ye=new Kr({props:{id:"nvBXf7s7vTI"}}),Ve=new j({props:{code:`from transformers import AutoModelForSequenceClassification

model = AutoModelForSequenceClassification.from_pretrained("bert-base-cased", num_labels=5)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>model = AutoModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;bert-base-cased&quot;</span>, num_labels=<span class="hljs-number">5</span>)`}}),me=new Mi({props:{$$slots:{default:[Bm]},$$scope:{ctx:oe}}}),Je=new T({}),Ze=new j({props:{code:`from transformers import TrainingArguments

training_args = TrainingArguments(output_dir="test_trainer")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

<span class="hljs-meta">&gt;&gt;&gt; </span>training_args = TrainingArguments(output_dir=<span class="hljs-string">&quot;test_trainer&quot;</span>)`}}),ea=new T({}),ta=new j({props:{code:`import numpy as np
from datasets import load_metric

metric = load_metric("accuracy")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_metric

<span class="hljs-meta">&gt;&gt;&gt; </span>metric = load_metric(<span class="hljs-string">&quot;accuracy&quot;</span>)`}}),oa=new j({props:{code:`def compute_metrics(eval_pred):
    logits, labels = eval_pred
    predictions = np.argmax(logits, axis=-1)
    return metric.compute(predictions=predictions, references=labels)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_metrics</span>(<span class="hljs-params">eval_pred</span>):
<span class="hljs-meta">... </span>    logits, labels = eval_pred
<span class="hljs-meta">... </span>    predictions = np.argmax(logits, axis=-<span class="hljs-number">1</span>)
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> metric.compute(predictions=predictions, references=labels)`}}),ra=new j({props:{code:`from transformers import TrainingArguments

training_args = TrainingArguments(output_dir="test_trainer", evaluation_strategy="epoch")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

<span class="hljs-meta">&gt;&gt;&gt; </span>training_args = TrainingArguments(output_dir=<span class="hljs-string">&quot;test_trainer&quot;</span>, evaluation_strategy=<span class="hljs-string">&quot;epoch&quot;</span>)`}}),na=new T({}),la=new j({props:{code:`trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=small_train_dataset,
    eval_dataset=small_eval_dataset,
    compute_metrics=compute_metrics,
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>trainer = Trainer(
<span class="hljs-meta">... </span>    model=model,
<span class="hljs-meta">... </span>    args=training_args,
<span class="hljs-meta">... </span>    train_dataset=small_train_dataset,
<span class="hljs-meta">... </span>    eval_dataset=small_eval_dataset,
<span class="hljs-meta">... </span>    compute_metrics=compute_metrics,
<span class="hljs-meta">... </span>)`}}),ia=new j({props:{code:"trainer.train()",highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>trainer.train()'}}),pa=new T({}),ma=new Kr({props:{id:"rnTGBy2ax1c"}}),ca=new T({}),da=new j({props:{code:`from transformers import DefaultDataCollator

data_collator = DefaultDataCollator(return_tensors="tf")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DefaultDataCollator

<span class="hljs-meta">&gt;&gt;&gt; </span>data_collator = DefaultDataCollator(return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)`}}),$e=new Mi({props:{$$slots:{default:[Km]},$$scope:{ctx:oe}}}),fa=new j({props:{code:`tf_train_dataset = small_train_dataset.to_tf_dataset(
    columns=["attention_mask", "input_ids", "token_type_ids"],
    label_cols=["labels"],
    shuffle=True,
    collate_fn=data_collator,
    batch_size=8,
)

tf_validation_dataset = small_eval_dataset.to_tf_dataset(
    columns=["attention_mask", "input_ids", "token_type_ids"],
    label_cols=["labels"],
    shuffle=False,
    collate_fn=data_collator,
    batch_size=8,
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>tf_train_dataset = small_train_dataset.to_tf_dataset(
<span class="hljs-meta">... </span>    columns=[<span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">... </span>    label_cols=[<span class="hljs-string">&quot;labels&quot;</span>],
<span class="hljs-meta">... </span>    shuffle=<span class="hljs-literal">True</span>,
<span class="hljs-meta">... </span>    collate_fn=data_collator,
<span class="hljs-meta">... </span>    batch_size=<span class="hljs-number">8</span>,
<span class="hljs-meta">... </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>tf_validation_dataset = small_eval_dataset.to_tf_dataset(
<span class="hljs-meta">... </span>    columns=[<span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">... </span>    label_cols=[<span class="hljs-string">&quot;labels&quot;</span>],
<span class="hljs-meta">... </span>    shuffle=<span class="hljs-literal">False</span>,
<span class="hljs-meta">... </span>    collate_fn=data_collator,
<span class="hljs-meta">... </span>    batch_size=<span class="hljs-number">8</span>,
<span class="hljs-meta">... </span>)`}}),ha=new T({}),ga=new j({props:{code:`import tensorflow as tf
from transformers import TFAutoModelForSequenceClassification

model = TFAutoModelForSequenceClassification.from_pretrained("bert-base-cased", num_labels=5)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFAutoModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;bert-base-cased&quot;</span>, num_labels=<span class="hljs-number">5</span>)`}}),va=new j({props:{code:`model.compile(
    optimizer=tf.keras.optimizers.Adam(learning_rate=5e-5),
    loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
    metrics=tf.metrics.SparseCategoricalAccuracy(),
)

model.fit(tf_train_dataset, validation_data=tf_validation_dataset, epochs=3)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>model.<span class="hljs-built_in">compile</span>(
<span class="hljs-meta">... </span>    optimizer=tf.keras.optimizers.Adam(learning_rate=<span class="hljs-number">5e-5</span>),
<span class="hljs-meta">... </span>    loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="hljs-literal">True</span>),
<span class="hljs-meta">... </span>    metrics=tf.metrics.SparseCategoricalAccuracy(),
<span class="hljs-meta">... </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>model.fit(tf_train_dataset, validation_data=tf_validation_dataset, epochs=<span class="hljs-number">3</span>)`}}),$a=new T({}),ba=new Kr({props:{id:"Dh9CL8fyG80"}}),ja=new j({props:{code:`del model
del pytorch_model
del trainer
torch.cuda.empty_cache()`,highlighted:`<span class="hljs-keyword">del</span> model
<span class="hljs-keyword">del</span> pytorch_model
<span class="hljs-keyword">del</span> trainer
torch.cuda.empty_cache()`}}),Ea=new j({props:{code:'tokenized_datasets = tokenized_datasets.remove_columns(["text"])',highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>tokenized_datasets = tokenized_datasets.remove_columns([<span class="hljs-string">&quot;text&quot;</span>])'}}),qa=new j({props:{code:'tokenized_datasets = tokenized_datasets.rename_column("label", "labels")',highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>tokenized_datasets = tokenized_datasets.rename_column(<span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;labels&quot;</span>)'}}),Ta=new j({props:{code:'tokenized_datasets.set_format("torch")',highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>tokenized_datasets.set_format(<span class="hljs-string">&quot;torch&quot;</span>)'}}),Pa=new j({props:{code:`small_train_dataset = tokenized_datasets["train"].shuffle(seed=42).select(range(1000))
small_eval_dataset = tokenized_datasets["test"].shuffle(seed=42).select(range(1000))`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>small_train_dataset = tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>].shuffle(seed=<span class="hljs-number">42</span>).select(<span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>small_eval_dataset = tokenized_datasets[<span class="hljs-string">&quot;test&quot;</span>].shuffle(seed=<span class="hljs-number">42</span>).select(<span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>))`}}),za=new T({}),Ca=new j({props:{code:`from torch.utils.data import DataLoader

train_dataloader = DataLoader(small_train_dataset, shuffle=True, batch_size=8)
eval_dataloader = DataLoader(small_eval_dataset, batch_size=8)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader

<span class="hljs-meta">&gt;&gt;&gt; </span>train_dataloader = DataLoader(small_train_dataset, shuffle=<span class="hljs-literal">True</span>, batch_size=<span class="hljs-number">8</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>eval_dataloader = DataLoader(small_eval_dataset, batch_size=<span class="hljs-number">8</span>)`}}),Da=new j({props:{code:`from transformers import AutoModelForSequenceClassification

model = AutoModelForSequenceClassification.from_pretrained("bert-base-cased", num_labels=5)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>model = AutoModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;bert-base-cased&quot;</span>, num_labels=<span class="hljs-number">5</span>)`}}),xa=new T({}),Oa=new j({props:{code:`from torch.optim import AdamW

optimizer = AdamW(model.parameters(), lr=5e-5)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> torch.optim <span class="hljs-keyword">import</span> AdamW

<span class="hljs-meta">&gt;&gt;&gt; </span>optimizer = AdamW(model.parameters(), lr=<span class="hljs-number">5e-5</span>)`}}),Fa=new j({props:{code:`from transformers import get_scheduler

num_epochs = 3
num_training_steps = num_epochs * len(train_dataloader)
lr_scheduler = get_scheduler(
    name="linear", optimizer=optimizer, num_warmup_steps=0, num_training_steps=num_training_steps
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> get_scheduler

<span class="hljs-meta">&gt;&gt;&gt; </span>num_epochs = <span class="hljs-number">3</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>num_training_steps = num_epochs * <span class="hljs-built_in">len</span>(train_dataloader)
<span class="hljs-meta">&gt;&gt;&gt; </span>lr_scheduler = get_scheduler(
<span class="hljs-meta">... </span>    name=<span class="hljs-string">&quot;linear&quot;</span>, optimizer=optimizer, num_warmup_steps=<span class="hljs-number">0</span>, num_training_steps=num_training_steps
<span class="hljs-meta">... </span>)`}}),Na=new j({props:{code:`import torch

device = torch.device("cuda") if torch.cuda.is_available() else torch.device("cpu")
model.to(device)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span>) <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> torch.device(<span class="hljs-string">&quot;cpu&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model.to(device)`}}),Ce=new Mi({props:{$$slots:{default:[Um]},$$scope:{ctx:oe}}}),Ia=new T({}),Ma=new j({props:{code:`from tqdm.auto import tqdm

progress_bar = tqdm(range(num_training_steps))

model.train()
for epoch in range(num_epochs):
    for batch in train_dataloader:
        batch = {k: v.to(device) for k, v in batch.items()}
        outputs = model(**batch)
        loss = outputs.loss
        loss.backward()

        optimizer.step()
        lr_scheduler.step()
        optimizer.zero_grad()
        progress_bar.update(1)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> tqdm.auto <span class="hljs-keyword">import</span> tqdm

<span class="hljs-meta">&gt;&gt;&gt; </span>progress_bar = tqdm(<span class="hljs-built_in">range</span>(num_training_steps))

<span class="hljs-meta">&gt;&gt;&gt; </span>model.train()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">for</span> batch <span class="hljs-keyword">in</span> train_dataloader:
<span class="hljs-meta">... </span>        batch = {k: v.to(device) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> batch.items()}
<span class="hljs-meta">... </span>        outputs = model(**batch)
<span class="hljs-meta">... </span>        loss = outputs.loss
<span class="hljs-meta">... </span>        loss.backward()

<span class="hljs-meta">... </span>        optimizer.step()
<span class="hljs-meta">... </span>        lr_scheduler.step()
<span class="hljs-meta">... </span>        optimizer.zero_grad()
<span class="hljs-meta">... </span>        progress_bar.update(<span class="hljs-number">1</span>)`}}),Ha=new T({}),Ba=new j({props:{code:`metric = load_metric("accuracy")
model.eval()
for batch in eval_dataloader:
    batch = {k: v.to(device) for k, v in batch.items()}
    with torch.no_grad():
        outputs = model(**batch)

    logits = outputs.logits
    predictions = torch.argmax(logits, dim=-1)
    metric.add_batch(predictions=predictions, references=batch["labels"])

metric.compute()`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>metric = load_metric(<span class="hljs-string">&quot;accuracy&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model.<span class="hljs-built_in">eval</span>()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> batch <span class="hljs-keyword">in</span> eval_dataloader:
<span class="hljs-meta">... </span>    batch = {k: v.to(device) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> batch.items()}
<span class="hljs-meta">... </span>    <span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>        outputs = model(**batch)

<span class="hljs-meta">... </span>    logits = outputs.logits
<span class="hljs-meta">... </span>    predictions = torch.argmax(logits, dim=-<span class="hljs-number">1</span>)
<span class="hljs-meta">... </span>    metric.add_batch(predictions=predictions, references=batch[<span class="hljs-string">&quot;labels&quot;</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>metric.compute()`}}),Ka=new T({}),{c(){$=o("meta"),y=m(),b=o("h1"),k=o("a"),P=o("span"),u(E.$$.fragment),O=m(),z=o("span"),A=i("Fine-tuning de um modelo pr\xE9-treinado"),w=m(),u(C.$$.fragment),F=m(),Ga=o("p"),Ur=i(`O uso de um modelo pr\xE9-treinado tem importantes vantagens. Redu\xE7\xE3o do custo computacional, a pegada de carbono, e te
permite utilizar modelos de \xFAltima gera\xE7\xE3o sem ter que treinar um novo desde o in\xEDcio.
O \u{1F917} Transformers proporciona acesso a milhares de modelos pr\xE9-treinados numa ampla gama de tarefas.
Quando utilizar um modelo pr\xE9-treinado, treine-o com um dataset espec\xEDfico para a sua tarefa.
Isto \xE9 chamado de fine-tuning, uma t\xE9cnica de treinamento incrivelmente poderosa. Neste tutorial faremos o fine-tuning
de um modelo pr\xE9-treinado com um framework de Deep Learning da sua escolha:`),xt=m(),N=o("ul"),Le=o("li"),Wr=i("Fine-tuning de um modelo pr\xE9-treinado com o \u{1F917} Transformers "),bs=o("code"),Gr=i("Trainer"),Yr=i("."),Qr=m(),js=o("li"),Vr=i("Fine-tuning de um modelo pr\xE9-treinado no TensorFlow com o Keras."),Jr=m(),ws=o("li"),Xr=i("Fine-tuning de um modelo pr\xE9-treinado em PyTorch nativo."),St=m(),Ya=o("a"),Ot=m(),B=o("h2"),re=o("a"),ks=o("span"),u(Me.$$.fragment),Zr=m(),Es=o("span"),en=i("Preparando um dataset"),Ft=m(),u(He.$$.fragment),Nt=m(),Qa=o("p"),an=i(`Antes de aplicar o fine-tuning a um modelo pr\xE9-treinado, baixe um dataset e prepare-o para o treinamento.
O tutorial anterior ensinar\xE1 a processar os dados para o treinamento, e ent\xE3o poder\xE1 ter a oportunidade de testar
esse novo conhecimento em algo pr\xE1tico.`),It=m(),ne=o("p"),sn=i("Comece carregando o dataset "),Re=o("a"),tn=i("Yelp Reviews"),on=i(":"),Lt=m(),u(Be.$$.fragment),Mt=m(),le=o("p"),rn=i(`Como j\xE1 sabe, \xE9 necess\xE1rio ter um tokenizador para processar o texto e incluir uma estrat\xE9gia de padding e truncamento,
para manejar qualquer tamanho var\xEDavel de sequ\xEAncia. Para processar o seu dataset em apenas um passo, utilize o m\xE9todo de
\u{1F917} Datasets `),Ke=o("a"),ys=o("code"),nn=i("map"),ln=i(` para aplicar uma fun\xE7\xE3o de preprocessamento sobre
todo o dataset.`),Ht=m(),u(Ue.$$.fragment),Rt=m(),Va=o("p"),pn=i("Se desejar, \xE9 poss\xEDvel criar um subconjunto menor do dataset completo para aplicar o fine-tuning e assim reduzir o tempo necess\xE1rio."),Bt=m(),u(We.$$.fragment),Kt=m(),Ja=o("a"),Ut=m(),K=o("h2"),ie=o("a"),qs=o("span"),u(Ge.$$.fragment),mn=m(),Xa=o("span"),cn=i("Fine-tuning com o "),As=o("code"),dn=i("Trainer"),Wt=m(),u(Ye.$$.fragment),Gt=m(),I=o("p"),un=i("O \u{1F917} Transformers proporciona uma classe "),Ts=o("code"),fn=i("Trainer"),hn=i(` otimizada para o treinamento de modelos de \u{1F917} Transformers,
facilitando os primeiros passos do treinamento sem a necessidade de escrever manualmente o seu pr\xF3prio ciclo.
A API do `),Ps=o("code"),gn=i("Trainer"),_n=i(` suporta um grande conjunto de op\xE7\xF5es de treinamento e funcionalidades, como o logging,
o gradient accumulation e o mixed precision.`),Yt=m(),pe=o("p"),vn=i(`Comece carregando seu modelo e especifique o n\xFAmero de labels de previs\xE3o.
A partir do `),Qe=o("a"),$n=i("Card Dataset"),bn=i(` do Yelp Reveiw, que ja
sabemos ter 5 labels usamos o seguinte c\xF3digo:`),Qt=m(),u(Ve.$$.fragment),Vt=m(),u(me.$$.fragment),Jt=m(),U=o("h3"),ce=o("a"),zs=o("span"),u(Je.$$.fragment),jn=m(),Cs=o("span"),wn=i("Hiperpar\xE2metros de treinamento"),Xt=m(),L=o("p"),kn=i("Em seguida, crie uma classe "),Ds=o("code"),En=i("TrainingArguments"),yn=i(` que contenha todos os hiperpar\xE2metros que possam ser ajustados, assim
como os indicadores para ativar as diferentes op\xE7\xF5es de treinamento. Para este tutorial, voc\xEA pode come\xE7ar o treinamento
usando os `),Xe=o("a"),qn=i("hiperpar\xE1metros"),An=i(` padr\xE3o,
por\xE9m, sinta-se livre para experimentar com eles e encontrar uma configura\xE7\xE3o \xF3tima.`),Zt=m(),Za=o("p"),Tn=i("Especifique onde salvar os checkpoints do treinamento:"),eo=m(),u(Ze.$$.fragment),ao=m(),W=o("h3"),de=o("a"),xs=o("span"),u(ea.$$.fragment),Pn=m(),Ss=o("span"),zn=i("M\xE9tricas"),so=m(),q=o("p"),Cn=i("O "),Os=o("code"),Dn=i("Trainer"),xn=i(` n\xE3o avalia automaticamente o rendimento do modelo durante o treinamento. Ser\xE1 necess\xE1rio passar ao
`),Fs=o("code"),Sn=i("Trainer"),On=i(` uma fun\xE7\xE3o para calcular e fazer um diagn\xF3stico sobre as m\xE9tricas. A biblioteca \u{1F917} Datasets proporciona
uma fun\xE7\xE3o de `),aa=o("a"),Ns=o("code"),Fn=i("accuracy"),Nn=i(` simples que pode ser carregada com a fun\xE7\xE3o
`),Is=o("code"),In=i("load_metric"),Ln=i(" (ver este "),sa=o("a"),Mn=i("tutorial"),Hn=i(" para mais informa\xE7\xF5es):"),to=m(),u(ta.$$.fragment),oo=m(),D=o("p"),Rn=i("Defina a fun\xE7\xE3o "),Ls=o("code"),Bn=i("compute"),Kn=i(" dentro de "),Ms=o("code"),Un=i("metric"),Wn=i(` para calcular a precis\xE3o das suas predi\xE7\xF5es.
Antes de passar as suas predi\xE7\xF5es ao `),Hs=o("code"),Gn=i("compute"),Yn=i(`, \xE9 necess\xE1rio converter as predi\xE7\xF5es \xE0 logits (lembre-se que
todos os modelos de \u{1F917} Transformers retornam logits).`),ro=m(),u(oa.$$.fragment),no=m(),ue=o("p"),Qn=i("Se quiser controlar as suas m\xE9tricas de avalia\xE7\xE3o durante o fine-tuning, especifique o par\xE2metro "),Rs=o("code"),Vn=i("evaluation_strategy"),Jn=i(`
nos seus argumentos de treinamento para que o modelo considere a m\xE9trica de avalia\xE7\xE3o ao final de cada \xE9poca:`),lo=m(),u(ra.$$.fragment),io=m(),G=o("h3"),fe=o("a"),Bs=o("span"),u(na.$$.fragment),Xn=m(),Ks=o("span"),Zn=i("Trainer"),po=m(),he=o("p"),el=i("Crie um objeto "),Us=o("code"),al=i("Trainer"),sl=i(" com o seu modelo, argumentos de treinamento, conjuntos de dados de treinamento e de teste, e a sua fun\xE7\xE3o de avalia\xE7\xE3o:"),mo=m(),u(la.$$.fragment),co=m(),ge=o("p"),tl=i("Em seguida, aplique o fine-tuning a seu modelo chamado "),Ws=o("code"),ol=i("train()"),rl=i(":"),uo=m(),u(ia.$$.fragment),fo=m(),es=o("a"),ho=m(),Y=o("h2"),_e=o("a"),Gs=o("span"),u(pa.$$.fragment),nl=m(),Ys=o("span"),ll=i("Fine-tuning com Keras"),go=m(),u(ma.$$.fragment),_o=m(),as=o("p"),il=i(`Os modelos de \u{1F917} Transformers tamb\xE9m permitem realizar o treinamento com o TensorFlow com a API do Keras.
Contudo, ser\xE1 necess\xE1rio fazer algumas mudan\xE7as antes de realizar o fine-tuning.`),vo=m(),Q=o("h3"),ve=o("a"),Qs=o("span"),u(ca.$$.fragment),pl=m(),Vs=o("span"),ml=i("Convers\xE3o do dataset ao formato do TensorFlow"),$o=m(),M=o("p"),cl=i("O "),Js=o("code"),dl=i("DefaultDataCollator"),ul=i(` junta os tensores em um batch para que o modelo possa ser treinado em cima deles.
Assegure-se de especificar os `),Xs=o("code"),fl=i("return_tensors"),hl=i(" para retornar os tensores do TensorFlow:"),bo=m(),u(da.$$.fragment),jo=m(),u($e.$$.fragment),wo=m(),x=o("p"),gl=i(`Em seguida, converta os datasets tokenizados em datasets do TensorFlow com o m\xE9todo
`),ua=o("a"),Zs=o("code"),_l=i("to_tf_dataset"),vl=i(`.
Especifique suas entradas em `),et=o("code"),$l=i("columns"),bl=i(" e seu r\xF3tulo em "),at=o("code"),jl=i("label_cols"),wl=i(":"),ko=m(),u(fa.$$.fragment),Eo=m(),V=o("h3"),be=o("a"),st=o("span"),u(ha.$$.fragment),kl=m(),tt=o("span"),El=i("Compila\xE7\xE3o e ajustes"),yo=m(),ss=o("p"),yl=i("Carregue um modelo do TensorFlow com o n\xFAmero esperado de r\xF3tulos:"),qo=m(),u(ga.$$.fragment),Ao=m(),je=o("p"),ql=i("A seguir, compile e ajuste o fine-tuning a seu modelo com "),_a=o("a"),ot=o("code"),Al=i("fit"),Tl=i(` como
faria com qualquer outro modelo do Keras:`),To=m(),u(va.$$.fragment),Po=m(),ts=o("a"),zo=m(),J=o("h2"),we=o("a"),rt=o("span"),u($a.$$.fragment),Pl=m(),nt=o("span"),zl=i("Fine-tune em PyTorch nativo"),Co=m(),u(ba.$$.fragment),Do=m(),ke=o("p"),Cl=i("O "),lt=o("code"),Dl=i("Trainer"),xl=i(` se encarrega do ciclo de treinamento e permite aplicar o fine-tuning a um modelo em uma linha de c\xF3digo apenas.
Para os usu\xE1rios que preferirem escrever o seu pr\xF3prio ciclo de treinamento, tamb\xE9m \xE9 poss\xEDvel aplicar o fine-tuning a um
modelo de \u{1F917} Transformers em PyTorch nativo.`),xo=m(),os=o("p"),Sl=i(`Neste momento, talvez ocorra a necessidade de reinicar seu notebook ou executar a seguinte linha de c\xF3digo para liberar
mem\xF3ria:`),So=m(),u(ja.$$.fragment),Oo=m(),Ee=o("p"),Ol=i("Em sequ\xEAncia, faremos um post-processing manual do "),it=o("code"),Fl=i("tokenized_dataset"),Nl=i(" e assim prepar\xE1-lo para o treinamento."),Fo=m(),H=o("ol"),wa=o("li"),ka=o("p"),Il=i("Apague a coluna de "),pt=o("code"),Ll=i("text"),Ml=i(" porque o modelo n\xE3o aceita texto cru como entrada:"),Hl=m(),u(Ea.$$.fragment),Rl=m(),ya=o("li"),X=o("p"),Bl=i("Troque o nome da coluna "),mt=o("code"),Kl=i("label"),Ul=i(" para "),ct=o("code"),Wl=i("labels"),Gl=i(", pois o modelo espera um argumento de mesmo nome:"),Yl=m(),u(qa.$$.fragment),Ql=m(),Aa=o("li"),dt=o("p"),Vl=i("Defina o formato do dataset para retornar tensores do PyTorch no lugar de listas:"),Jl=m(),u(Ta.$$.fragment),No=m(),rs=o("p"),Xl=i("Em sequ\xEAncia, crie um subconjunto menor do dataset, como foi mostrado anteriormente, para aceler\xE1-lo o fine-tuning."),Io=m(),u(Pa.$$.fragment),Lo=m(),Z=o("h3"),ye=o("a"),ut=o("span"),u(za.$$.fragment),Zl=m(),ft=o("span"),ei=i("DataLoader"),Mo=m(),qe=o("p"),ai=i("Crie um "),ht=o("code"),si=i("DataLoader"),ti=i(" para os seus datasets de treinamento e de teste para poder iterar sobre batches de dados:"),Ho=m(),u(Ca.$$.fragment),Ro=m(),ns=o("p"),oi=i("Carregue seu modelo com o n\xFAmero de labels esperados:"),Bo=m(),u(Da.$$.fragment),Ko=m(),ee=o("h3"),Ae=o("a"),gt=o("span"),u(xa.$$.fragment),ri=m(),_t=o("span"),ni=i("Otimiza\xE7\xE3o e configura\xE7\xE3o do Learning Rate"),Uo=m(),Te=o("p"),li=i(`Crie um otimizador e um learning rate para aplicar o fine-tuning ao modelo.
Iremos utilizar o otimizador `),Sa=o("a"),vt=o("code"),ii=i("AdamW"),pi=i(" do PyTorch:"),Wo=m(),u(Oa.$$.fragment),Go=m(),Pe=o("p"),mi=i("Defina o learning rate do "),$t=o("code"),ci=i("Trainer"),di=i(":"),Yo=m(),u(Fa.$$.fragment),Qo=m(),ze=o("p"),ui=i("Por \xFAltimo, especifique o "),bt=o("code"),fi=i("device"),hi=i(` do ambiente para utilizar uma GPU se tiver acesso \xE0 alguma. Caso contr\xE1rio, o treinamento
em uma CPU pode acabar levando v\xE1rias horas em vez de minutos.`),Vo=m(),u(Na.$$.fragment),Jo=m(),u(Ce.$$.fragment),Xo=m(),ls=o("p"),gi=i("Perfeito, agora estamos prontos para come\xE7ar o treinamento! \u{1F973}"),Zo=m(),ae=o("h3"),De=o("a"),jt=o("span"),u(Ia.$$.fragment),_i=m(),wt=o("span"),vi=i("Ciclo de treinamento"),er=m(),xe=o("p"),$i=i("Para visualizar melhor o processo de treinamento, utilize a biblioteca "),La=o("a"),bi=i("tqdm"),ji=i(` para adicionar
uma barra de progresso sobre o n\xFAmero de passos percorridos no treinamento atual:`),ar=m(),u(Ma.$$.fragment),sr=m(),se=o("h3"),Se=o("a"),kt=o("span"),u(Ha.$$.fragment),wi=m(),Et=o("span"),ki=i("M\xE9tricas"),tr=m(),R=o("p"),Ei=i("Da mesma forma que \xE9 necess\xE1rio adicionar uma fun\xE7\xE3o de avalia\xE7\xE3o ao "),yt=o("code"),yi=i("Trainer"),qi=i(`, \xE9 necess\xE1rio fazer o mesmo quando
escrevendo o pr\xF3prio ciclo de treinamento. Contudo, em vez de calcular e retornar a m\xE9trica final de cada \xE9poca,
voc\xEA dever\xE1 adicionar todos os batches com `),Ra=o("a"),qt=o("code"),Ai=i("add_batch"),Ti=i(`
e calcular a m\xE9trica apenas no final.`),or=m(),u(Ba.$$.fragment),rr=m(),is=o("a"),nr=m(),te=o("h2"),Oe=o("a"),At=o("span"),u(Ka.$$.fragment),Pi=m(),Tt=o("span"),zi=i("Recursos adicionais"),lr=m(),ps=o("p"),Ci=i("Para mais exemplos de fine-tuning acesse:"),ir=m(),Fe=o("ul"),Pt=o("li"),ms=o("p"),Ua=o("a"),Di=i("\u{1F917} Transformers Examples"),xi=i(` inclui scripts
para treinas tarefas comuns de NLP em PyTorch e TensorFlow.`),Si=m(),zt=o("li"),cs=o("p"),ds=o("a"),Oi=i("\u{1F917} Transformers Notebooks"),Fi=i(` cont\xE9m v\xE1rios notebooks sobre como aplicar o fine-tuning a um modelo
para tarefas espec\xEDficas no PyTorch e TensorFlow.`),this.h()},l(e){const t=Mm('[data-svelte="svelte-1phssyn"]',document.head);$=r(t,"META",{name:!0,content:!0}),t.forEach(a),y=c(e),b=r(e,"H1",{class:!0});var Wa=n(b);k=r(Wa,"A",{id:!0,class:!0,href:!0});var Ct=n(k);P=r(Ct,"SPAN",{});var Dt=n(P);f(E.$$.fragment,Dt),Dt.forEach(a),Ct.forEach(a),O=c(Wa),z=r(Wa,"SPAN",{});var Hi=n(z);A=p(Hi,"Fine-tuning de um modelo pr\xE9-treinado"),Hi.forEach(a),Wa.forEach(a),w=c(e),f(C.$$.fragment,e),F=c(e),Ga=r(e,"P",{});var Ri=n(Ga);Ur=p(Ri,`O uso de um modelo pr\xE9-treinado tem importantes vantagens. Redu\xE7\xE3o do custo computacional, a pegada de carbono, e te
permite utilizar modelos de \xFAltima gera\xE7\xE3o sem ter que treinar um novo desde o in\xEDcio.
O \u{1F917} Transformers proporciona acesso a milhares de modelos pr\xE9-treinados numa ampla gama de tarefas.
Quando utilizar um modelo pr\xE9-treinado, treine-o com um dataset espec\xEDfico para a sua tarefa.
Isto \xE9 chamado de fine-tuning, uma t\xE9cnica de treinamento incrivelmente poderosa. Neste tutorial faremos o fine-tuning
de um modelo pr\xE9-treinado com um framework de Deep Learning da sua escolha:`),Ri.forEach(a),xt=c(e),N=r(e,"UL",{});var us=n(N);Le=r(us,"LI",{});var mr=n(Le);Wr=p(mr,"Fine-tuning de um modelo pr\xE9-treinado com o \u{1F917} Transformers "),bs=r(mr,"CODE",{});var Bi=n(bs);Gr=p(Bi,"Trainer"),Bi.forEach(a),Yr=p(mr,"."),mr.forEach(a),Qr=c(us),js=r(us,"LI",{});var Ki=n(js);Vr=p(Ki,"Fine-tuning de um modelo pr\xE9-treinado no TensorFlow com o Keras."),Ki.forEach(a),Jr=c(us),ws=r(us,"LI",{});var Ui=n(ws);Xr=p(Ui,"Fine-tuning de um modelo pr\xE9-treinado em PyTorch nativo."),Ui.forEach(a),us.forEach(a),St=c(e),Ya=r(e,"A",{id:!0}),n(Ya).forEach(a),Ot=c(e),B=r(e,"H2",{class:!0});var cr=n(B);re=r(cr,"A",{id:!0,class:!0,href:!0});var Wi=n(re);ks=r(Wi,"SPAN",{});var Gi=n(ks);f(Me.$$.fragment,Gi),Gi.forEach(a),Wi.forEach(a),Zr=c(cr),Es=r(cr,"SPAN",{});var Yi=n(Es);en=p(Yi,"Preparando um dataset"),Yi.forEach(a),cr.forEach(a),Ft=c(e),f(He.$$.fragment,e),Nt=c(e),Qa=r(e,"P",{});var Qi=n(Qa);an=p(Qi,`Antes de aplicar o fine-tuning a um modelo pr\xE9-treinado, baixe um dataset e prepare-o para o treinamento.
O tutorial anterior ensinar\xE1 a processar os dados para o treinamento, e ent\xE3o poder\xE1 ter a oportunidade de testar
esse novo conhecimento em algo pr\xE1tico.`),Qi.forEach(a),It=c(e),ne=r(e,"P",{});var dr=n(ne);sn=p(dr,"Comece carregando o dataset "),Re=r(dr,"A",{href:!0,rel:!0});var Vi=n(Re);tn=p(Vi,"Yelp Reviews"),Vi.forEach(a),on=p(dr,":"),dr.forEach(a),Lt=c(e),f(Be.$$.fragment,e),Mt=c(e),le=r(e,"P",{});var ur=n(le);rn=p(ur,`Como j\xE1 sabe, \xE9 necess\xE1rio ter um tokenizador para processar o texto e incluir uma estrat\xE9gia de padding e truncamento,
para manejar qualquer tamanho var\xEDavel de sequ\xEAncia. Para processar o seu dataset em apenas um passo, utilize o m\xE9todo de
\u{1F917} Datasets `),Ke=r(ur,"A",{href:!0,rel:!0});var Ji=n(Ke);ys=r(Ji,"CODE",{});var Xi=n(ys);nn=p(Xi,"map"),Xi.forEach(a),Ji.forEach(a),ln=p(ur,` para aplicar uma fun\xE7\xE3o de preprocessamento sobre
todo o dataset.`),ur.forEach(a),Ht=c(e),f(Ue.$$.fragment,e),Rt=c(e),Va=r(e,"P",{});var Zi=n(Va);pn=p(Zi,"Se desejar, \xE9 poss\xEDvel criar um subconjunto menor do dataset completo para aplicar o fine-tuning e assim reduzir o tempo necess\xE1rio."),Zi.forEach(a),Bt=c(e),f(We.$$.fragment,e),Kt=c(e),Ja=r(e,"A",{id:!0}),n(Ja).forEach(a),Ut=c(e),K=r(e,"H2",{class:!0});var fr=n(K);ie=r(fr,"A",{id:!0,class:!0,href:!0});var ep=n(ie);qs=r(ep,"SPAN",{});var ap=n(qs);f(Ge.$$.fragment,ap),ap.forEach(a),ep.forEach(a),mn=c(fr),Xa=r(fr,"SPAN",{});var Ni=n(Xa);cn=p(Ni,"Fine-tuning com o "),As=r(Ni,"CODE",{});var sp=n(As);dn=p(sp,"Trainer"),sp.forEach(a),Ni.forEach(a),fr.forEach(a),Wt=c(e),f(Ye.$$.fragment,e),Gt=c(e),I=r(e,"P",{});var fs=n(I);un=p(fs,"O \u{1F917} Transformers proporciona uma classe "),Ts=r(fs,"CODE",{});var tp=n(Ts);fn=p(tp,"Trainer"),tp.forEach(a),hn=p(fs,` otimizada para o treinamento de modelos de \u{1F917} Transformers,
facilitando os primeiros passos do treinamento sem a necessidade de escrever manualmente o seu pr\xF3prio ciclo.
A API do `),Ps=r(fs,"CODE",{});var op=n(Ps);gn=p(op,"Trainer"),op.forEach(a),_n=p(fs,` suporta um grande conjunto de op\xE7\xF5es de treinamento e funcionalidades, como o logging,
o gradient accumulation e o mixed precision.`),fs.forEach(a),Yt=c(e),pe=r(e,"P",{});var hr=n(pe);vn=p(hr,`Comece carregando seu modelo e especifique o n\xFAmero de labels de previs\xE3o.
A partir do `),Qe=r(hr,"A",{href:!0,rel:!0});var rp=n(Qe);$n=p(rp,"Card Dataset"),rp.forEach(a),bn=p(hr,` do Yelp Reveiw, que ja
sabemos ter 5 labels usamos o seguinte c\xF3digo:`),hr.forEach(a),Qt=c(e),f(Ve.$$.fragment,e),Vt=c(e),f(me.$$.fragment,e),Jt=c(e),U=r(e,"H3",{class:!0});var gr=n(U);ce=r(gr,"A",{id:!0,class:!0,href:!0});var np=n(ce);zs=r(np,"SPAN",{});var lp=n(zs);f(Je.$$.fragment,lp),lp.forEach(a),np.forEach(a),jn=c(gr),Cs=r(gr,"SPAN",{});var ip=n(Cs);wn=p(ip,"Hiperpar\xE2metros de treinamento"),ip.forEach(a),gr.forEach(a),Xt=c(e),L=r(e,"P",{});var hs=n(L);kn=p(hs,"Em seguida, crie uma classe "),Ds=r(hs,"CODE",{});var pp=n(Ds);En=p(pp,"TrainingArguments"),pp.forEach(a),yn=p(hs,` que contenha todos os hiperpar\xE2metros que possam ser ajustados, assim
como os indicadores para ativar as diferentes op\xE7\xF5es de treinamento. Para este tutorial, voc\xEA pode come\xE7ar o treinamento
usando os `),Xe=r(hs,"A",{href:!0,rel:!0});var mp=n(Xe);qn=p(mp,"hiperpar\xE1metros"),mp.forEach(a),An=p(hs,` padr\xE3o,
por\xE9m, sinta-se livre para experimentar com eles e encontrar uma configura\xE7\xE3o \xF3tima.`),hs.forEach(a),Zt=c(e),Za=r(e,"P",{});var cp=n(Za);Tn=p(cp,"Especifique onde salvar os checkpoints do treinamento:"),cp.forEach(a),eo=c(e),f(Ze.$$.fragment,e),ao=c(e),W=r(e,"H3",{class:!0});var _r=n(W);de=r(_r,"A",{id:!0,class:!0,href:!0});var dp=n(de);xs=r(dp,"SPAN",{});var up=n(xs);f(ea.$$.fragment,up),up.forEach(a),dp.forEach(a),Pn=c(_r),Ss=r(_r,"SPAN",{});var fp=n(Ss);zn=p(fp,"M\xE9tricas"),fp.forEach(a),_r.forEach(a),so=c(e),q=r(e,"P",{});var S=n(q);Cn=p(S,"O "),Os=r(S,"CODE",{});var hp=n(Os);Dn=p(hp,"Trainer"),hp.forEach(a),xn=p(S,` n\xE3o avalia automaticamente o rendimento do modelo durante o treinamento. Ser\xE1 necess\xE1rio passar ao
`),Fs=r(S,"CODE",{});var gp=n(Fs);Sn=p(gp,"Trainer"),gp.forEach(a),On=p(S,` uma fun\xE7\xE3o para calcular e fazer um diagn\xF3stico sobre as m\xE9tricas. A biblioteca \u{1F917} Datasets proporciona
uma fun\xE7\xE3o de `),aa=r(S,"A",{href:!0,rel:!0});var _p=n(aa);Ns=r(_p,"CODE",{});var vp=n(Ns);Fn=p(vp,"accuracy"),vp.forEach(a),_p.forEach(a),Nn=p(S,` simples que pode ser carregada com a fun\xE7\xE3o
`),Is=r(S,"CODE",{});var $p=n(Is);In=p($p,"load_metric"),$p.forEach(a),Ln=p(S," (ver este "),sa=r(S,"A",{href:!0,rel:!0});var bp=n(sa);Mn=p(bp,"tutorial"),bp.forEach(a),Hn=p(S," para mais informa\xE7\xF5es):"),S.forEach(a),to=c(e),f(ta.$$.fragment,e),oo=c(e),D=r(e,"P",{});var Ne=n(D);Rn=p(Ne,"Defina a fun\xE7\xE3o "),Ls=r(Ne,"CODE",{});var jp=n(Ls);Bn=p(jp,"compute"),jp.forEach(a),Kn=p(Ne," dentro de "),Ms=r(Ne,"CODE",{});var wp=n(Ms);Un=p(wp,"metric"),wp.forEach(a),Wn=p(Ne,` para calcular a precis\xE3o das suas predi\xE7\xF5es.
Antes de passar as suas predi\xE7\xF5es ao `),Hs=r(Ne,"CODE",{});var kp=n(Hs);Gn=p(kp,"compute"),kp.forEach(a),Yn=p(Ne,`, \xE9 necess\xE1rio converter as predi\xE7\xF5es \xE0 logits (lembre-se que
todos os modelos de \u{1F917} Transformers retornam logits).`),Ne.forEach(a),ro=c(e),f(oa.$$.fragment,e),no=c(e),ue=r(e,"P",{});var vr=n(ue);Qn=p(vr,"Se quiser controlar as suas m\xE9tricas de avalia\xE7\xE3o durante o fine-tuning, especifique o par\xE2metro "),Rs=r(vr,"CODE",{});var Ep=n(Rs);Vn=p(Ep,"evaluation_strategy"),Ep.forEach(a),Jn=p(vr,`
nos seus argumentos de treinamento para que o modelo considere a m\xE9trica de avalia\xE7\xE3o ao final de cada \xE9poca:`),vr.forEach(a),lo=c(e),f(ra.$$.fragment,e),io=c(e),G=r(e,"H3",{class:!0});var $r=n(G);fe=r($r,"A",{id:!0,class:!0,href:!0});var yp=n(fe);Bs=r(yp,"SPAN",{});var qp=n(Bs);f(na.$$.fragment,qp),qp.forEach(a),yp.forEach(a),Xn=c($r),Ks=r($r,"SPAN",{});var Ap=n(Ks);Zn=p(Ap,"Trainer"),Ap.forEach(a),$r.forEach(a),po=c(e),he=r(e,"P",{});var br=n(he);el=p(br,"Crie um objeto "),Us=r(br,"CODE",{});var Tp=n(Us);al=p(Tp,"Trainer"),Tp.forEach(a),sl=p(br," com o seu modelo, argumentos de treinamento, conjuntos de dados de treinamento e de teste, e a sua fun\xE7\xE3o de avalia\xE7\xE3o:"),br.forEach(a),mo=c(e),f(la.$$.fragment,e),co=c(e),ge=r(e,"P",{});var jr=n(ge);tl=p(jr,"Em seguida, aplique o fine-tuning a seu modelo chamado "),Ws=r(jr,"CODE",{});var Pp=n(Ws);ol=p(Pp,"train()"),Pp.forEach(a),rl=p(jr,":"),jr.forEach(a),uo=c(e),f(ia.$$.fragment,e),fo=c(e),es=r(e,"A",{id:!0}),n(es).forEach(a),ho=c(e),Y=r(e,"H2",{class:!0});var wr=n(Y);_e=r(wr,"A",{id:!0,class:!0,href:!0});var zp=n(_e);Gs=r(zp,"SPAN",{});var Cp=n(Gs);f(pa.$$.fragment,Cp),Cp.forEach(a),zp.forEach(a),nl=c(wr),Ys=r(wr,"SPAN",{});var Dp=n(Ys);ll=p(Dp,"Fine-tuning com Keras"),Dp.forEach(a),wr.forEach(a),go=c(e),f(ma.$$.fragment,e),_o=c(e),as=r(e,"P",{});var xp=n(as);il=p(xp,`Os modelos de \u{1F917} Transformers tamb\xE9m permitem realizar o treinamento com o TensorFlow com a API do Keras.
Contudo, ser\xE1 necess\xE1rio fazer algumas mudan\xE7as antes de realizar o fine-tuning.`),xp.forEach(a),vo=c(e),Q=r(e,"H3",{class:!0});var kr=n(Q);ve=r(kr,"A",{id:!0,class:!0,href:!0});var Sp=n(ve);Qs=r(Sp,"SPAN",{});var Op=n(Qs);f(ca.$$.fragment,Op),Op.forEach(a),Sp.forEach(a),pl=c(kr),Vs=r(kr,"SPAN",{});var Fp=n(Vs);ml=p(Fp,"Convers\xE3o do dataset ao formato do TensorFlow"),Fp.forEach(a),kr.forEach(a),$o=c(e),M=r(e,"P",{});var gs=n(M);cl=p(gs,"O "),Js=r(gs,"CODE",{});var Np=n(Js);dl=p(Np,"DefaultDataCollator"),Np.forEach(a),ul=p(gs,` junta os tensores em um batch para que o modelo possa ser treinado em cima deles.
Assegure-se de especificar os `),Xs=r(gs,"CODE",{});var Ip=n(Xs);fl=p(Ip,"return_tensors"),Ip.forEach(a),hl=p(gs," para retornar os tensores do TensorFlow:"),gs.forEach(a),bo=c(e),f(da.$$.fragment,e),jo=c(e),f($e.$$.fragment,e),wo=c(e),x=r(e,"P",{});var Ie=n(x);gl=p(Ie,`Em seguida, converta os datasets tokenizados em datasets do TensorFlow com o m\xE9todo
`),ua=r(Ie,"A",{href:!0,rel:!0});var Lp=n(ua);Zs=r(Lp,"CODE",{});var Mp=n(Zs);_l=p(Mp,"to_tf_dataset"),Mp.forEach(a),Lp.forEach(a),vl=p(Ie,`.
Especifique suas entradas em `),et=r(Ie,"CODE",{});var Hp=n(et);$l=p(Hp,"columns"),Hp.forEach(a),bl=p(Ie," e seu r\xF3tulo em "),at=r(Ie,"CODE",{});var Rp=n(at);jl=p(Rp,"label_cols"),Rp.forEach(a),wl=p(Ie,":"),Ie.forEach(a),ko=c(e),f(fa.$$.fragment,e),Eo=c(e),V=r(e,"H3",{class:!0});var Er=n(V);be=r(Er,"A",{id:!0,class:!0,href:!0});var Bp=n(be);st=r(Bp,"SPAN",{});var Kp=n(st);f(ha.$$.fragment,Kp),Kp.forEach(a),Bp.forEach(a),kl=c(Er),tt=r(Er,"SPAN",{});var Up=n(tt);El=p(Up,"Compila\xE7\xE3o e ajustes"),Up.forEach(a),Er.forEach(a),yo=c(e),ss=r(e,"P",{});var Wp=n(ss);yl=p(Wp,"Carregue um modelo do TensorFlow com o n\xFAmero esperado de r\xF3tulos:"),Wp.forEach(a),qo=c(e),f(ga.$$.fragment,e),Ao=c(e),je=r(e,"P",{});var yr=n(je);ql=p(yr,"A seguir, compile e ajuste o fine-tuning a seu modelo com "),_a=r(yr,"A",{href:!0,rel:!0});var Gp=n(_a);ot=r(Gp,"CODE",{});var Yp=n(ot);Al=p(Yp,"fit"),Yp.forEach(a),Gp.forEach(a),Tl=p(yr,` como
faria com qualquer outro modelo do Keras:`),yr.forEach(a),To=c(e),f(va.$$.fragment,e),Po=c(e),ts=r(e,"A",{id:!0}),n(ts).forEach(a),zo=c(e),J=r(e,"H2",{class:!0});var qr=n(J);we=r(qr,"A",{id:!0,class:!0,href:!0});var Qp=n(we);rt=r(Qp,"SPAN",{});var Vp=n(rt);f($a.$$.fragment,Vp),Vp.forEach(a),Qp.forEach(a),Pl=c(qr),nt=r(qr,"SPAN",{});var Jp=n(nt);zl=p(Jp,"Fine-tune em PyTorch nativo"),Jp.forEach(a),qr.forEach(a),Co=c(e),f(ba.$$.fragment,e),Do=c(e),ke=r(e,"P",{});var Ar=n(ke);Cl=p(Ar,"O "),lt=r(Ar,"CODE",{});var Xp=n(lt);Dl=p(Xp,"Trainer"),Xp.forEach(a),xl=p(Ar,` se encarrega do ciclo de treinamento e permite aplicar o fine-tuning a um modelo em uma linha de c\xF3digo apenas.
Para os usu\xE1rios que preferirem escrever o seu pr\xF3prio ciclo de treinamento, tamb\xE9m \xE9 poss\xEDvel aplicar o fine-tuning a um
modelo de \u{1F917} Transformers em PyTorch nativo.`),Ar.forEach(a),xo=c(e),os=r(e,"P",{});var Zp=n(os);Sl=p(Zp,`Neste momento, talvez ocorra a necessidade de reinicar seu notebook ou executar a seguinte linha de c\xF3digo para liberar
mem\xF3ria:`),Zp.forEach(a),So=c(e),f(ja.$$.fragment,e),Oo=c(e),Ee=r(e,"P",{});var Tr=n(Ee);Ol=p(Tr,"Em sequ\xEAncia, faremos um post-processing manual do "),it=r(Tr,"CODE",{});var em=n(it);Fl=p(em,"tokenized_dataset"),em.forEach(a),Nl=p(Tr," e assim prepar\xE1-lo para o treinamento."),Tr.forEach(a),Fo=c(e),H=r(e,"OL",{});var _s=n(H);wa=r(_s,"LI",{});var Pr=n(wa);ka=r(Pr,"P",{});var zr=n(ka);Il=p(zr,"Apague a coluna de "),pt=r(zr,"CODE",{});var am=n(pt);Ll=p(am,"text"),am.forEach(a),Ml=p(zr," porque o modelo n\xE3o aceita texto cru como entrada:"),zr.forEach(a),Hl=c(Pr),f(Ea.$$.fragment,Pr),Pr.forEach(a),Rl=c(_s),ya=r(_s,"LI",{});var Cr=n(ya);X=r(Cr,"P",{});var vs=n(X);Bl=p(vs,"Troque o nome da coluna "),mt=r(vs,"CODE",{});var sm=n(mt);Kl=p(sm,"label"),sm.forEach(a),Ul=p(vs," para "),ct=r(vs,"CODE",{});var tm=n(ct);Wl=p(tm,"labels"),tm.forEach(a),Gl=p(vs,", pois o modelo espera um argumento de mesmo nome:"),vs.forEach(a),Yl=c(Cr),f(qa.$$.fragment,Cr),Cr.forEach(a),Ql=c(_s),Aa=r(_s,"LI",{});var Dr=n(Aa);dt=r(Dr,"P",{});var om=n(dt);Vl=p(om,"Defina o formato do dataset para retornar tensores do PyTorch no lugar de listas:"),om.forEach(a),Jl=c(Dr),f(Ta.$$.fragment,Dr),Dr.forEach(a),_s.forEach(a),No=c(e),rs=r(e,"P",{});var rm=n(rs);Xl=p(rm,"Em sequ\xEAncia, crie um subconjunto menor do dataset, como foi mostrado anteriormente, para aceler\xE1-lo o fine-tuning."),rm.forEach(a),Io=c(e),f(Pa.$$.fragment,e),Lo=c(e),Z=r(e,"H3",{class:!0});var xr=n(Z);ye=r(xr,"A",{id:!0,class:!0,href:!0});var nm=n(ye);ut=r(nm,"SPAN",{});var lm=n(ut);f(za.$$.fragment,lm),lm.forEach(a),nm.forEach(a),Zl=c(xr),ft=r(xr,"SPAN",{});var im=n(ft);ei=p(im,"DataLoader"),im.forEach(a),xr.forEach(a),Mo=c(e),qe=r(e,"P",{});var Sr=n(qe);ai=p(Sr,"Crie um "),ht=r(Sr,"CODE",{});var pm=n(ht);si=p(pm,"DataLoader"),pm.forEach(a),ti=p(Sr," para os seus datasets de treinamento e de teste para poder iterar sobre batches de dados:"),Sr.forEach(a),Ho=c(e),f(Ca.$$.fragment,e),Ro=c(e),ns=r(e,"P",{});var mm=n(ns);oi=p(mm,"Carregue seu modelo com o n\xFAmero de labels esperados:"),mm.forEach(a),Bo=c(e),f(Da.$$.fragment,e),Ko=c(e),ee=r(e,"H3",{class:!0});var Or=n(ee);Ae=r(Or,"A",{id:!0,class:!0,href:!0});var cm=n(Ae);gt=r(cm,"SPAN",{});var dm=n(gt);f(xa.$$.fragment,dm),dm.forEach(a),cm.forEach(a),ri=c(Or),_t=r(Or,"SPAN",{});var um=n(_t);ni=p(um,"Otimiza\xE7\xE3o e configura\xE7\xE3o do Learning Rate"),um.forEach(a),Or.forEach(a),Uo=c(e),Te=r(e,"P",{});var Fr=n(Te);li=p(Fr,`Crie um otimizador e um learning rate para aplicar o fine-tuning ao modelo.
Iremos utilizar o otimizador `),Sa=r(Fr,"A",{href:!0,rel:!0});var fm=n(Sa);vt=r(fm,"CODE",{});var hm=n(vt);ii=p(hm,"AdamW"),hm.forEach(a),fm.forEach(a),pi=p(Fr," do PyTorch:"),Fr.forEach(a),Wo=c(e),f(Oa.$$.fragment,e),Go=c(e),Pe=r(e,"P",{});var Nr=n(Pe);mi=p(Nr,"Defina o learning rate do "),$t=r(Nr,"CODE",{});var gm=n($t);ci=p(gm,"Trainer"),gm.forEach(a),di=p(Nr,":"),Nr.forEach(a),Yo=c(e),f(Fa.$$.fragment,e),Qo=c(e),ze=r(e,"P",{});var Ir=n(ze);ui=p(Ir,"Por \xFAltimo, especifique o "),bt=r(Ir,"CODE",{});var _m=n(bt);fi=p(_m,"device"),_m.forEach(a),hi=p(Ir,` do ambiente para utilizar uma GPU se tiver acesso \xE0 alguma. Caso contr\xE1rio, o treinamento
em uma CPU pode acabar levando v\xE1rias horas em vez de minutos.`),Ir.forEach(a),Vo=c(e),f(Na.$$.fragment,e),Jo=c(e),f(Ce.$$.fragment,e),Xo=c(e),ls=r(e,"P",{});var vm=n(ls);gi=p(vm,"Perfeito, agora estamos prontos para come\xE7ar o treinamento! \u{1F973}"),vm.forEach(a),Zo=c(e),ae=r(e,"H3",{class:!0});var Lr=n(ae);De=r(Lr,"A",{id:!0,class:!0,href:!0});var $m=n(De);jt=r($m,"SPAN",{});var bm=n(jt);f(Ia.$$.fragment,bm),bm.forEach(a),$m.forEach(a),_i=c(Lr),wt=r(Lr,"SPAN",{});var jm=n(wt);vi=p(jm,"Ciclo de treinamento"),jm.forEach(a),Lr.forEach(a),er=c(e),xe=r(e,"P",{});var Mr=n(xe);$i=p(Mr,"Para visualizar melhor o processo de treinamento, utilize a biblioteca "),La=r(Mr,"A",{href:!0,rel:!0});var wm=n(La);bi=p(wm,"tqdm"),wm.forEach(a),ji=p(Mr,` para adicionar
uma barra de progresso sobre o n\xFAmero de passos percorridos no treinamento atual:`),Mr.forEach(a),ar=c(e),f(Ma.$$.fragment,e),sr=c(e),se=r(e,"H3",{class:!0});var Hr=n(se);Se=r(Hr,"A",{id:!0,class:!0,href:!0});var km=n(Se);kt=r(km,"SPAN",{});var Em=n(kt);f(Ha.$$.fragment,Em),Em.forEach(a),km.forEach(a),wi=c(Hr),Et=r(Hr,"SPAN",{});var ym=n(Et);ki=p(ym,"M\xE9tricas"),ym.forEach(a),Hr.forEach(a),tr=c(e),R=r(e,"P",{});var $s=n(R);Ei=p($s,"Da mesma forma que \xE9 necess\xE1rio adicionar uma fun\xE7\xE3o de avalia\xE7\xE3o ao "),yt=r($s,"CODE",{});var qm=n(yt);yi=p(qm,"Trainer"),qm.forEach(a),qi=p($s,`, \xE9 necess\xE1rio fazer o mesmo quando
escrevendo o pr\xF3prio ciclo de treinamento. Contudo, em vez de calcular e retornar a m\xE9trica final de cada \xE9poca,
voc\xEA dever\xE1 adicionar todos os batches com `),Ra=r($s,"A",{href:!0,rel:!0});var Am=n(Ra);qt=r(Am,"CODE",{});var Tm=n(qt);Ai=p(Tm,"add_batch"),Tm.forEach(a),Am.forEach(a),Ti=p($s,`
e calcular a m\xE9trica apenas no final.`),$s.forEach(a),or=c(e),f(Ba.$$.fragment,e),rr=c(e),is=r(e,"A",{id:!0}),n(is).forEach(a),nr=c(e),te=r(e,"H2",{class:!0});var Rr=n(te);Oe=r(Rr,"A",{id:!0,class:!0,href:!0});var Pm=n(Oe);At=r(Pm,"SPAN",{});var zm=n(At);f(Ka.$$.fragment,zm),zm.forEach(a),Pm.forEach(a),Pi=c(Rr),Tt=r(Rr,"SPAN",{});var Cm=n(Tt);zi=p(Cm,"Recursos adicionais"),Cm.forEach(a),Rr.forEach(a),lr=c(e),ps=r(e,"P",{});var Dm=n(ps);Ci=p(Dm,"Para mais exemplos de fine-tuning acesse:"),Dm.forEach(a),ir=c(e),Fe=r(e,"UL",{});var Br=n(Fe);Pt=r(Br,"LI",{});var xm=n(Pt);ms=r(xm,"P",{});var Ii=n(ms);Ua=r(Ii,"A",{href:!0,rel:!0});var Sm=n(Ua);Di=p(Sm,"\u{1F917} Transformers Examples"),Sm.forEach(a),xi=p(Ii,` inclui scripts
para treinas tarefas comuns de NLP em PyTorch e TensorFlow.`),Ii.forEach(a),xm.forEach(a),Si=c(Br),zt=r(Br,"LI",{});var Om=n(zt);cs=r(Om,"P",{});var Li=n(cs);ds=r(Li,"A",{href:!0});var Fm=n(ds);Oi=p(Fm,"\u{1F917} Transformers Notebooks"),Fm.forEach(a),Fi=p(Li,` cont\xE9m v\xE1rios notebooks sobre como aplicar o fine-tuning a um modelo
para tarefas espec\xEDficas no PyTorch e TensorFlow.`),Li.forEach(a),Om.forEach(a),Br.forEach(a),this.h()},h(){d($,"name","hf:doc:metadata"),d($,"content",JSON.stringify(Gm)),d(k,"id","finetuning-de-um-modelo-prtreinado"),d(k,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(k,"href","#finetuning-de-um-modelo-prtreinado"),d(b,"class","relative group"),d(Ya,"id","data-processing"),d(re,"id","preparando-um-dataset"),d(re,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(re,"href","#preparando-um-dataset"),d(B,"class","relative group"),d(Re,"href","https://huggingface.co/datasets/yelp_review_full"),d(Re,"rel","nofollow"),d(Ke,"href","https://huggingface.co/docs/datasets/process.html#map"),d(Ke,"rel","nofollow"),d(Ja,"id","trainer"),d(ie,"id","finetuning-com-o-trainer"),d(ie,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(ie,"href","#finetuning-com-o-trainer"),d(K,"class","relative group"),d(Qe,"href","https://huggingface.co/datasets/yelp_review_full#data-fields"),d(Qe,"rel","nofollow"),d(ce,"id","hiperparmetros-de-treinamento"),d(ce,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(ce,"href","#hiperparmetros-de-treinamento"),d(U,"class","relative group"),d(Xe,"href","https://huggingface.co/docs/transformers/main_classes/trainer#transformers.TrainingArguments"),d(Xe,"rel","nofollow"),d(de,"id","mtricas"),d(de,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(de,"href","#mtricas"),d(W,"class","relative group"),d(aa,"href","https://huggingface.co/metrics/accuracy"),d(aa,"rel","nofollow"),d(sa,"href","https://huggingface.co/docs/datasets/metrics.html"),d(sa,"rel","nofollow"),d(fe,"id","trainer"),d(fe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(fe,"href","#trainer"),d(G,"class","relative group"),d(es,"id","keras"),d(_e,"id","finetuning-com-keras"),d(_e,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(_e,"href","#finetuning-com-keras"),d(Y,"class","relative group"),d(ve,"id","converso-do-dataset-ao-formato-do-tensorflow"),d(ve,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(ve,"href","#converso-do-dataset-ao-formato-do-tensorflow"),d(Q,"class","relative group"),d(ua,"href","https://huggingface.co/docs/datasets/package_reference/main_classes.html#datasets.Dataset.to_tf_dataset"),d(ua,"rel","nofollow"),d(be,"id","compilao-e-ajustes"),d(be,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(be,"href","#compilao-e-ajustes"),d(V,"class","relative group"),d(_a,"href","https://keras.io/api/models/model_training_apis/"),d(_a,"rel","nofollow"),d(ts,"id","pytorch_native"),d(we,"id","finetune-em-pytorch-nativo"),d(we,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(we,"href","#finetune-em-pytorch-nativo"),d(J,"class","relative group"),d(ye,"id","dataloader"),d(ye,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(ye,"href","#dataloader"),d(Z,"class","relative group"),d(Ae,"id","otimizao-e-configurao-do-learning-rate"),d(Ae,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Ae,"href","#otimizao-e-configurao-do-learning-rate"),d(ee,"class","relative group"),d(Sa,"href","https://pytorch.org/docs/stable/generated/torch.optim.AdamW.html"),d(Sa,"rel","nofollow"),d(De,"id","ciclo-de-treinamento"),d(De,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(De,"href","#ciclo-de-treinamento"),d(ae,"class","relative group"),d(La,"href","https://tqdm.github.io/"),d(La,"rel","nofollow"),d(Se,"id","mtricas"),d(Se,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Se,"href","#mtricas"),d(se,"class","relative group"),d(Ra,"href","https://huggingface.co/docs/datasets/package_reference/main_classes.html?highlight=add_batch#datasets.Metric.add_batch"),d(Ra,"rel","nofollow"),d(is,"id","additional-resources"),d(Oe,"id","recursos-adicionais"),d(Oe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Oe,"href","#recursos-adicionais"),d(te,"class","relative group"),d(Ua,"href","https://github.com/huggingface/transformers/tree/main/examples"),d(Ua,"rel","nofollow"),d(ds,"href","notebooks")},m(e,t){s(document.head,$),l(e,y,t),l(e,b,t),s(b,k),s(k,P),h(E,P,null),s(b,O),s(b,z),s(z,A),l(e,w,t),h(C,e,t),l(e,F,t),l(e,Ga,t),s(Ga,Ur),l(e,xt,t),l(e,N,t),s(N,Le),s(Le,Wr),s(Le,bs),s(bs,Gr),s(Le,Yr),s(N,Qr),s(N,js),s(js,Vr),s(N,Jr),s(N,ws),s(ws,Xr),l(e,St,t),l(e,Ya,t),l(e,Ot,t),l(e,B,t),s(B,re),s(re,ks),h(Me,ks,null),s(B,Zr),s(B,Es),s(Es,en),l(e,Ft,t),h(He,e,t),l(e,Nt,t),l(e,Qa,t),s(Qa,an),l(e,It,t),l(e,ne,t),s(ne,sn),s(ne,Re),s(Re,tn),s(ne,on),l(e,Lt,t),h(Be,e,t),l(e,Mt,t),l(e,le,t),s(le,rn),s(le,Ke),s(Ke,ys),s(ys,nn),s(le,ln),l(e,Ht,t),h(Ue,e,t),l(e,Rt,t),l(e,Va,t),s(Va,pn),l(e,Bt,t),h(We,e,t),l(e,Kt,t),l(e,Ja,t),l(e,Ut,t),l(e,K,t),s(K,ie),s(ie,qs),h(Ge,qs,null),s(K,mn),s(K,Xa),s(Xa,cn),s(Xa,As),s(As,dn),l(e,Wt,t),h(Ye,e,t),l(e,Gt,t),l(e,I,t),s(I,un),s(I,Ts),s(Ts,fn),s(I,hn),s(I,Ps),s(Ps,gn),s(I,_n),l(e,Yt,t),l(e,pe,t),s(pe,vn),s(pe,Qe),s(Qe,$n),s(pe,bn),l(e,Qt,t),h(Ve,e,t),l(e,Vt,t),h(me,e,t),l(e,Jt,t),l(e,U,t),s(U,ce),s(ce,zs),h(Je,zs,null),s(U,jn),s(U,Cs),s(Cs,wn),l(e,Xt,t),l(e,L,t),s(L,kn),s(L,Ds),s(Ds,En),s(L,yn),s(L,Xe),s(Xe,qn),s(L,An),l(e,Zt,t),l(e,Za,t),s(Za,Tn),l(e,eo,t),h(Ze,e,t),l(e,ao,t),l(e,W,t),s(W,de),s(de,xs),h(ea,xs,null),s(W,Pn),s(W,Ss),s(Ss,zn),l(e,so,t),l(e,q,t),s(q,Cn),s(q,Os),s(Os,Dn),s(q,xn),s(q,Fs),s(Fs,Sn),s(q,On),s(q,aa),s(aa,Ns),s(Ns,Fn),s(q,Nn),s(q,Is),s(Is,In),s(q,Ln),s(q,sa),s(sa,Mn),s(q,Hn),l(e,to,t),h(ta,e,t),l(e,oo,t),l(e,D,t),s(D,Rn),s(D,Ls),s(Ls,Bn),s(D,Kn),s(D,Ms),s(Ms,Un),s(D,Wn),s(D,Hs),s(Hs,Gn),s(D,Yn),l(e,ro,t),h(oa,e,t),l(e,no,t),l(e,ue,t),s(ue,Qn),s(ue,Rs),s(Rs,Vn),s(ue,Jn),l(e,lo,t),h(ra,e,t),l(e,io,t),l(e,G,t),s(G,fe),s(fe,Bs),h(na,Bs,null),s(G,Xn),s(G,Ks),s(Ks,Zn),l(e,po,t),l(e,he,t),s(he,el),s(he,Us),s(Us,al),s(he,sl),l(e,mo,t),h(la,e,t),l(e,co,t),l(e,ge,t),s(ge,tl),s(ge,Ws),s(Ws,ol),s(ge,rl),l(e,uo,t),h(ia,e,t),l(e,fo,t),l(e,es,t),l(e,ho,t),l(e,Y,t),s(Y,_e),s(_e,Gs),h(pa,Gs,null),s(Y,nl),s(Y,Ys),s(Ys,ll),l(e,go,t),h(ma,e,t),l(e,_o,t),l(e,as,t),s(as,il),l(e,vo,t),l(e,Q,t),s(Q,ve),s(ve,Qs),h(ca,Qs,null),s(Q,pl),s(Q,Vs),s(Vs,ml),l(e,$o,t),l(e,M,t),s(M,cl),s(M,Js),s(Js,dl),s(M,ul),s(M,Xs),s(Xs,fl),s(M,hl),l(e,bo,t),h(da,e,t),l(e,jo,t),h($e,e,t),l(e,wo,t),l(e,x,t),s(x,gl),s(x,ua),s(ua,Zs),s(Zs,_l),s(x,vl),s(x,et),s(et,$l),s(x,bl),s(x,at),s(at,jl),s(x,wl),l(e,ko,t),h(fa,e,t),l(e,Eo,t),l(e,V,t),s(V,be),s(be,st),h(ha,st,null),s(V,kl),s(V,tt),s(tt,El),l(e,yo,t),l(e,ss,t),s(ss,yl),l(e,qo,t),h(ga,e,t),l(e,Ao,t),l(e,je,t),s(je,ql),s(je,_a),s(_a,ot),s(ot,Al),s(je,Tl),l(e,To,t),h(va,e,t),l(e,Po,t),l(e,ts,t),l(e,zo,t),l(e,J,t),s(J,we),s(we,rt),h($a,rt,null),s(J,Pl),s(J,nt),s(nt,zl),l(e,Co,t),h(ba,e,t),l(e,Do,t),l(e,ke,t),s(ke,Cl),s(ke,lt),s(lt,Dl),s(ke,xl),l(e,xo,t),l(e,os,t),s(os,Sl),l(e,So,t),h(ja,e,t),l(e,Oo,t),l(e,Ee,t),s(Ee,Ol),s(Ee,it),s(it,Fl),s(Ee,Nl),l(e,Fo,t),l(e,H,t),s(H,wa),s(wa,ka),s(ka,Il),s(ka,pt),s(pt,Ll),s(ka,Ml),s(wa,Hl),h(Ea,wa,null),s(H,Rl),s(H,ya),s(ya,X),s(X,Bl),s(X,mt),s(mt,Kl),s(X,Ul),s(X,ct),s(ct,Wl),s(X,Gl),s(ya,Yl),h(qa,ya,null),s(H,Ql),s(H,Aa),s(Aa,dt),s(dt,Vl),s(Aa,Jl),h(Ta,Aa,null),l(e,No,t),l(e,rs,t),s(rs,Xl),l(e,Io,t),h(Pa,e,t),l(e,Lo,t),l(e,Z,t),s(Z,ye),s(ye,ut),h(za,ut,null),s(Z,Zl),s(Z,ft),s(ft,ei),l(e,Mo,t),l(e,qe,t),s(qe,ai),s(qe,ht),s(ht,si),s(qe,ti),l(e,Ho,t),h(Ca,e,t),l(e,Ro,t),l(e,ns,t),s(ns,oi),l(e,Bo,t),h(Da,e,t),l(e,Ko,t),l(e,ee,t),s(ee,Ae),s(Ae,gt),h(xa,gt,null),s(ee,ri),s(ee,_t),s(_t,ni),l(e,Uo,t),l(e,Te,t),s(Te,li),s(Te,Sa),s(Sa,vt),s(vt,ii),s(Te,pi),l(e,Wo,t),h(Oa,e,t),l(e,Go,t),l(e,Pe,t),s(Pe,mi),s(Pe,$t),s($t,ci),s(Pe,di),l(e,Yo,t),h(Fa,e,t),l(e,Qo,t),l(e,ze,t),s(ze,ui),s(ze,bt),s(bt,fi),s(ze,hi),l(e,Vo,t),h(Na,e,t),l(e,Jo,t),h(Ce,e,t),l(e,Xo,t),l(e,ls,t),s(ls,gi),l(e,Zo,t),l(e,ae,t),s(ae,De),s(De,jt),h(Ia,jt,null),s(ae,_i),s(ae,wt),s(wt,vi),l(e,er,t),l(e,xe,t),s(xe,$i),s(xe,La),s(La,bi),s(xe,ji),l(e,ar,t),h(Ma,e,t),l(e,sr,t),l(e,se,t),s(se,Se),s(Se,kt),h(Ha,kt,null),s(se,wi),s(se,Et),s(Et,ki),l(e,tr,t),l(e,R,t),s(R,Ei),s(R,yt),s(yt,yi),s(R,qi),s(R,Ra),s(Ra,qt),s(qt,Ai),s(R,Ti),l(e,or,t),h(Ba,e,t),l(e,rr,t),l(e,is,t),l(e,nr,t),l(e,te,t),s(te,Oe),s(Oe,At),h(Ka,At,null),s(te,Pi),s(te,Tt),s(Tt,zi),l(e,lr,t),l(e,ps,t),s(ps,Ci),l(e,ir,t),l(e,Fe,t),s(Fe,Pt),s(Pt,ms),s(ms,Ua),s(Ua,Di),s(ms,xi),s(Fe,Si),s(Fe,zt),s(zt,cs),s(cs,ds),s(ds,Oi),s(cs,Fi),pr=!0},p(e,[t]){const Wa={};t&2&&(Wa.$$scope={dirty:t,ctx:e}),me.$set(Wa);const Ct={};t&2&&(Ct.$$scope={dirty:t,ctx:e}),$e.$set(Ct);const Dt={};t&2&&(Dt.$$scope={dirty:t,ctx:e}),Ce.$set(Dt)},i(e){pr||(g(E.$$.fragment,e),g(C.$$.fragment,e),g(Me.$$.fragment,e),g(He.$$.fragment,e),g(Be.$$.fragment,e),g(Ue.$$.fragment,e),g(We.$$.fragment,e),g(Ge.$$.fragment,e),g(Ye.$$.fragment,e),g(Ve.$$.fragment,e),g(me.$$.fragment,e),g(Je.$$.fragment,e),g(Ze.$$.fragment,e),g(ea.$$.fragment,e),g(ta.$$.fragment,e),g(oa.$$.fragment,e),g(ra.$$.fragment,e),g(na.$$.fragment,e),g(la.$$.fragment,e),g(ia.$$.fragment,e),g(pa.$$.fragment,e),g(ma.$$.fragment,e),g(ca.$$.fragment,e),g(da.$$.fragment,e),g($e.$$.fragment,e),g(fa.$$.fragment,e),g(ha.$$.fragment,e),g(ga.$$.fragment,e),g(va.$$.fragment,e),g($a.$$.fragment,e),g(ba.$$.fragment,e),g(ja.$$.fragment,e),g(Ea.$$.fragment,e),g(qa.$$.fragment,e),g(Ta.$$.fragment,e),g(Pa.$$.fragment,e),g(za.$$.fragment,e),g(Ca.$$.fragment,e),g(Da.$$.fragment,e),g(xa.$$.fragment,e),g(Oa.$$.fragment,e),g(Fa.$$.fragment,e),g(Na.$$.fragment,e),g(Ce.$$.fragment,e),g(Ia.$$.fragment,e),g(Ma.$$.fragment,e),g(Ha.$$.fragment,e),g(Ba.$$.fragment,e),g(Ka.$$.fragment,e),pr=!0)},o(e){_(E.$$.fragment,e),_(C.$$.fragment,e),_(Me.$$.fragment,e),_(He.$$.fragment,e),_(Be.$$.fragment,e),_(Ue.$$.fragment,e),_(We.$$.fragment,e),_(Ge.$$.fragment,e),_(Ye.$$.fragment,e),_(Ve.$$.fragment,e),_(me.$$.fragment,e),_(Je.$$.fragment,e),_(Ze.$$.fragment,e),_(ea.$$.fragment,e),_(ta.$$.fragment,e),_(oa.$$.fragment,e),_(ra.$$.fragment,e),_(na.$$.fragment,e),_(la.$$.fragment,e),_(ia.$$.fragment,e),_(pa.$$.fragment,e),_(ma.$$.fragment,e),_(ca.$$.fragment,e),_(da.$$.fragment,e),_($e.$$.fragment,e),_(fa.$$.fragment,e),_(ha.$$.fragment,e),_(ga.$$.fragment,e),_(va.$$.fragment,e),_($a.$$.fragment,e),_(ba.$$.fragment,e),_(ja.$$.fragment,e),_(Ea.$$.fragment,e),_(qa.$$.fragment,e),_(Ta.$$.fragment,e),_(Pa.$$.fragment,e),_(za.$$.fragment,e),_(Ca.$$.fragment,e),_(Da.$$.fragment,e),_(xa.$$.fragment,e),_(Oa.$$.fragment,e),_(Fa.$$.fragment,e),_(Na.$$.fragment,e),_(Ce.$$.fragment,e),_(Ia.$$.fragment,e),_(Ma.$$.fragment,e),_(Ha.$$.fragment,e),_(Ba.$$.fragment,e),_(Ka.$$.fragment,e),pr=!1},d(e){a($),e&&a(y),e&&a(b),v(E),e&&a(w),v(C,e),e&&a(F),e&&a(Ga),e&&a(xt),e&&a(N),e&&a(St),e&&a(Ya),e&&a(Ot),e&&a(B),v(Me),e&&a(Ft),v(He,e),e&&a(Nt),e&&a(Qa),e&&a(It),e&&a(ne),e&&a(Lt),v(Be,e),e&&a(Mt),e&&a(le),e&&a(Ht),v(Ue,e),e&&a(Rt),e&&a(Va),e&&a(Bt),v(We,e),e&&a(Kt),e&&a(Ja),e&&a(Ut),e&&a(K),v(Ge),e&&a(Wt),v(Ye,e),e&&a(Gt),e&&a(I),e&&a(Yt),e&&a(pe),e&&a(Qt),v(Ve,e),e&&a(Vt),v(me,e),e&&a(Jt),e&&a(U),v(Je),e&&a(Xt),e&&a(L),e&&a(Zt),e&&a(Za),e&&a(eo),v(Ze,e),e&&a(ao),e&&a(W),v(ea),e&&a(so),e&&a(q),e&&a(to),v(ta,e),e&&a(oo),e&&a(D),e&&a(ro),v(oa,e),e&&a(no),e&&a(ue),e&&a(lo),v(ra,e),e&&a(io),e&&a(G),v(na),e&&a(po),e&&a(he),e&&a(mo),v(la,e),e&&a(co),e&&a(ge),e&&a(uo),v(ia,e),e&&a(fo),e&&a(es),e&&a(ho),e&&a(Y),v(pa),e&&a(go),v(ma,e),e&&a(_o),e&&a(as),e&&a(vo),e&&a(Q),v(ca),e&&a($o),e&&a(M),e&&a(bo),v(da,e),e&&a(jo),v($e,e),e&&a(wo),e&&a(x),e&&a(ko),v(fa,e),e&&a(Eo),e&&a(V),v(ha),e&&a(yo),e&&a(ss),e&&a(qo),v(ga,e),e&&a(Ao),e&&a(je),e&&a(To),v(va,e),e&&a(Po),e&&a(ts),e&&a(zo),e&&a(J),v($a),e&&a(Co),v(ba,e),e&&a(Do),e&&a(ke),e&&a(xo),e&&a(os),e&&a(So),v(ja,e),e&&a(Oo),e&&a(Ee),e&&a(Fo),e&&a(H),v(Ea),v(qa),v(Ta),e&&a(No),e&&a(rs),e&&a(Io),v(Pa,e),e&&a(Lo),e&&a(Z),v(za),e&&a(Mo),e&&a(qe),e&&a(Ho),v(Ca,e),e&&a(Ro),e&&a(ns),e&&a(Bo),v(Da,e),e&&a(Ko),e&&a(ee),v(xa),e&&a(Uo),e&&a(Te),e&&a(Wo),v(Oa,e),e&&a(Go),e&&a(Pe),e&&a(Yo),v(Fa,e),e&&a(Qo),e&&a(ze),e&&a(Vo),v(Na,e),e&&a(Jo),v(Ce,e),e&&a(Xo),e&&a(ls),e&&a(Zo),e&&a(ae),v(Ia),e&&a(er),e&&a(xe),e&&a(ar),v(Ma,e),e&&a(sr),e&&a(se),v(Ha),e&&a(tr),e&&a(R),e&&a(or),v(Ba,e),e&&a(rr),e&&a(is),e&&a(nr),e&&a(te),v(Ka),e&&a(lr),e&&a(ps),e&&a(ir),e&&a(Fe)}}}const Gm={local:"finetuning-de-um-modelo-prtreinado",sections:[{local:"preparando-um-dataset",title:"Preparando um dataset"},{local:"finetuning-com-o-trainer",sections:[{local:"hiperparmetros-de-treinamento",title:"Hiperpar\xE2metros de treinamento"},{local:"mtricas",title:"M\xE9tricas"},{local:"trainer",title:"Trainer"}],title:"Fine-tuning com o `Trainer`"},{local:"finetuning-com-keras",sections:[{local:"converso-do-dataset-ao-formato-do-tensorflow",title:"Convers\xE3o do dataset ao formato do TensorFlow"},{local:"compilao-e-ajustes",title:"Compila\xE7\xE3o e ajustes"}],title:"Fine-tuning com Keras"},{local:"finetune-em-pytorch-nativo",sections:[{local:"dataloader",title:"DataLoader"},{local:"otimizao-e-configurao-do-learning-rate",title:"Otimiza\xE7\xE3o e configura\xE7\xE3o do Learning Rate"},{local:"ciclo-de-treinamento",title:"Ciclo de treinamento"},{local:"mtricas",title:"M\xE9tricas"}],title:"Fine-tune em PyTorch nativo"},{local:"recursos-adicionais",title:"Recursos adicionais"}],title:"Fine-tuning de um modelo pr\xE9-treinado"};function Ym(oe){return Hm(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class ac extends Nm{constructor($){super();Im(this,$,Ym,Wm,Lm,{})}}export{ac as default,Gm as metadata};
