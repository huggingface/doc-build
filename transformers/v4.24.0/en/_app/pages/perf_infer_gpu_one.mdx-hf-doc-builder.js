import{S as Si,i as Ni,s as Bi,e as i,k as p,w as G,t as s,M as Ri,c as a,d as t,m as u,a as l,x as A,h as n,b as m,N as kt,G as o,g as f,y as U,L as ji,q as k,o as q,B as M,v as Di}from"../chunks/vendor-hf-doc-builder.js";import{I as $e}from"../chunks/IconCopyLink-hf-doc-builder.js";import{C as So}from"../chunks/CodeBlock-hf-doc-builder.js";function Fi(No){let g,Ze,w,C,xe,j,qt,Pe,Mt,Je,d,Ct,te,It,Tt,oe,Ot,Lt,Qe,y,I,Ge,D,St,ie,Ae,Nt,Bt,Ye,ae,Rt,et,h,jt,F,Ue,Dt,Ft,ke,Ht,Wt,qe,Xt,zt,Me,Vt,Kt,Ce,Zt,Jt,tt,le,re,Bo,ot,b,Qt,H,Yt,eo,W,to,oo,it,se,ne,Ro,at,T,io,me,ao,lo,lt,E,O,Ie,X,ro,Te,so,rt,_,Oe,no,mo,L,fo,Le,po,uo,Se,ho,co,S,bo,Ne,_o,vo,Be,go,st,$,N,Re,z,wo,je,yo,nt,fe,Eo,mt,V,ft,x,B,De,K,$o,Fe,xo,pt,pe,Po,ut,Z,ht,v,Go,He,Ao,Uo,We,ko,qo,ct,J,dt,ue,Mo,bt,P,R,Xe,Q,Co,ze,Io,_t,he,To,vt,ce,Y,de,jo,gt,be,Oo,wt,_e,ee,ve,Do,yt;return j=new $e({}),D=new $e({}),X=new $e({}),z=new $e({}),V=new So({props:{code:`model_name = "bigscience/bloom-2b5"
model_8bit = AutoModelForCausalLM.from_pretrained(model_name, device_map="auto", load_in_8bit=True)`,highlighted:`model_name = <span class="hljs-string">&quot;bigscience/bloom-2b5&quot;</span>
model_8bit = AutoModelForCausalLM.from_pretrained(model_name, device_map=<span class="hljs-string">&quot;auto&quot;</span>, load_in_8bit=<span class="hljs-literal">True</span>)`}}),K=new $e({}),Z=new So({props:{code:`model_name = "bigscience/bloom-2b5"
model_8bit = AutoModelForCausalLM.from_pretrained(model_name, device_map="auto", load_in_8bit=True)`,highlighted:`model_name = <span class="hljs-string">&quot;bigscience/bloom-2b5&quot;</span>
model_8bit = AutoModelForCausalLM.from_pretrained(model_name, device_map=<span class="hljs-string">&quot;auto&quot;</span>, load_in_8bit=<span class="hljs-literal">True</span>)`}}),J=new So({props:{code:`max_memory_mapping = {0: "1GB", 1: "2GB"}
model_name = "bigscience/bloom-3b"
model_8bit = AutoModelForCausalLM.from_pretrained(
    model_name, device_map="auto", load_in_8bit=True, max_memory=max_memory_mapping
)`,highlighted:`max_memory_mapping = {<span class="hljs-number">0</span>: <span class="hljs-string">&quot;1GB&quot;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&quot;2GB&quot;</span>}
model_name = <span class="hljs-string">&quot;bigscience/bloom-3b&quot;</span>
model_8bit = AutoModelForCausalLM.from_pretrained(
    model_name, device_map=<span class="hljs-string">&quot;auto&quot;</span>, load_in_8bit=<span class="hljs-literal">True</span>, max_memory=max_memory_mapping
)`}}),Q=new $e({}),{c(){g=i("meta"),Ze=p(),w=i("h1"),C=i("a"),xe=i("span"),G(j.$$.fragment),qt=p(),Pe=i("span"),Mt=s("Efficient Inference on a Single GPU"),Je=p(),d=i("p"),Ct=s("This document will be completed soon with information on how to infer on a single GPU. In the meantime you can check out "),te=i("a"),It=s("the guide for training on a single GPU"),Tt=s(" and "),oe=i("a"),Ot=s("the guide for inference on CPUs"),Lt=s("."),Qe=p(),y=i("h2"),I=i("a"),Ge=i("span"),G(D.$$.fragment),St=p(),ie=i("span"),Ae=i("code"),Nt=s("bitsandbytes"),Bt=s(" integration for Int8 mixed-precision matrix decomposition"),Ye=p(),ae=i("p"),Rt=s("Note that this feature is also totally applicable in a multi GPU setup as well."),et=p(),h=i("p"),jt=s("From the paper "),F=i("a"),Ue=i("code"),Dt=s("LLM.int8() : 8-bit Matrix Multiplication for Transformers at Scale"),Ft=s(`, we support HuggingFace integration for all models in the Hub with a few lines of code.
The method reduce `),ke=i("code"),Ht=s("nn.Linear"),Wt=s(" size by 2 for "),qe=i("code"),Xt=s("float16"),zt=s(" and "),Me=i("code"),Vt=s("bfloat16"),Kt=s(" weights and by 4 for "),Ce=i("code"),Zt=s("float32"),Jt=s(" weights, with close to no impact to the quality by operating on the outliers in half-precision."),tt=p(),le=i("p"),re=i("img"),ot=p(),b=i("p"),Qt=s(`Int8 mixed-precision matrix decomposition works by separating a matrix multiplication into two streams: (1) a systematic feature outlier stream matrix multiplied in fp16 (0.01%), (2) a regular stream of int8 matrix multiplication (99.9%). With this method, int8 inference with no predictive degradation is possible for very large models.
For more details regarding the method, check out the `),H=i("a"),Yt=s("paper"),eo=s(" or our "),W=i("a"),to=s("blogpost about the integration"),oo=s("."),it=p(),se=i("p"),ne=i("img"),at=p(),T=i("p"),io=s(`Note, that you would require a GPU to run mixed-8bit models as the kernels have been compiled for GPUs only. Make sure that you have enough GPU memory to store the quarter (or half if your model weights are in half precision) of the model before using this feature.
Below are some notes to help you use this module, or follow the demos on `),me=i("a"),ao=s("Google colab"),lo=s("."),lt=p(),E=i("h3"),O=i("a"),Ie=i("span"),G(X.$$.fragment),ro=p(),Te=i("span"),so=s("Requirements"),rt=p(),_=i("ul"),Oe=i("li"),no=s("Make sure you run that on NVIDIA GPUs that support 8-bit tensor cores (Turing, Ampere or newer architectures - e.g. T4, RTX20s RTX30s, A40-A100)."),mo=p(),L=i("li"),fo=s("Install the correct version of "),Le=i("code"),po=s("bitsandbytes"),uo=s(` by running:
`),Se=i("code"),ho=s("pip install bitsandbytes>=0.31.5"),co=p(),S=i("li"),bo=s("Install "),Ne=i("code"),_o=s("accelerate"),vo=p(),Be=i("code"),go=s("pip install accelerate>=0.12.0"),st=p(),$=i("h3"),N=i("a"),Re=i("span"),G(z.$$.fragment),wo=p(),je=i("span"),yo=s("Running mixed-int8 models - single GPU setup"),nt=p(),fe=i("p"),Eo=s("After installing the required libraries, the way to load your mixed 8-bit model is as follows:"),mt=p(),G(V.$$.fragment),ft=p(),x=i("h3"),B=i("a"),De=i("span"),G(K.$$.fragment),$o=p(),Fe=i("span"),xo=s("Running mixed-int8 models - multi GPU setup"),pt=p(),pe=i("p"),Po=s("The way to load your mixed 8-bit model in multiple GPUs is as follows (same command as single GPU setup):"),ut=p(),G(Z.$$.fragment),ht=p(),v=i("p"),Go=s("But you can control the GPU RAM you want to allocate on each GPU using "),He=i("code"),Ao=s("accelerate"),Uo=s(". Use the "),We=i("code"),ko=s("max_memory"),qo=s(" argument as follows:"),ct=p(),G(J.$$.fragment),dt=p(),ue=i("p"),Mo=s("In this example, the first GPU will use 1GB of memory and the second 2GB."),bt=p(),P=i("h3"),R=i("a"),Xe=i("span"),G(Q.$$.fragment),Co=p(),ze=i("span"),Io=s("Colab demos"),_t=p(),he=i("p"),To=s(`With this method you can infer on models that were not possible to infer on a Google Colab before.
Check out the demo for running T5-11b (42GB in fp32)! Using 8-bit quantization on Google Colab:`),vt=p(),ce=i("p"),Y=i("a"),de=i("img"),gt=p(),be=i("p"),Oo=s("Or this demo for BLOOM-3B:"),wt=p(),_e=i("p"),ee=i("a"),ve=i("img"),this.h()},l(e){const r=Ri('[data-svelte="svelte-1phssyn"]',document.head);g=a(r,"META",{name:!0,content:!0}),r.forEach(t),Ze=u(e),w=a(e,"H1",{class:!0});var Et=l(w);C=a(Et,"A",{id:!0,class:!0,href:!0});var Fo=l(C);xe=a(Fo,"SPAN",{});var Ho=l(xe);A(j.$$.fragment,Ho),Ho.forEach(t),Fo.forEach(t),qt=u(Et),Pe=a(Et,"SPAN",{});var Wo=l(Pe);Mt=n(Wo,"Efficient Inference on a Single GPU"),Wo.forEach(t),Et.forEach(t),Je=u(e),d=a(e,"P",{});var ge=l(d);Ct=n(ge,"This document will be completed soon with information on how to infer on a single GPU. In the meantime you can check out "),te=a(ge,"A",{href:!0});var Xo=l(te);It=n(Xo,"the guide for training on a single GPU"),Xo.forEach(t),Tt=n(ge," and "),oe=a(ge,"A",{href:!0});var zo=l(oe);Ot=n(zo,"the guide for inference on CPUs"),zo.forEach(t),Lt=n(ge,"."),ge.forEach(t),Qe=u(e),y=a(e,"H2",{class:!0});var $t=l(y);I=a($t,"A",{id:!0,class:!0,href:!0});var Vo=l(I);Ge=a(Vo,"SPAN",{});var Ko=l(Ge);A(D.$$.fragment,Ko),Ko.forEach(t),Vo.forEach(t),St=u($t),ie=a($t,"SPAN",{});var Lo=l(ie);Ae=a(Lo,"CODE",{});var Zo=l(Ae);Nt=n(Zo,"bitsandbytes"),Zo.forEach(t),Bt=n(Lo," integration for Int8 mixed-precision matrix decomposition"),Lo.forEach(t),$t.forEach(t),Ye=u(e),ae=a(e,"P",{});var Jo=l(ae);Rt=n(Jo,"Note that this feature is also totally applicable in a multi GPU setup as well."),Jo.forEach(t),et=u(e),h=a(e,"P",{});var c=l(h);jt=n(c,"From the paper "),F=a(c,"A",{href:!0,rel:!0});var Qo=l(F);Ue=a(Qo,"CODE",{});var Yo=l(Ue);Dt=n(Yo,"LLM.int8() : 8-bit Matrix Multiplication for Transformers at Scale"),Yo.forEach(t),Qo.forEach(t),Ft=n(c,`, we support HuggingFace integration for all models in the Hub with a few lines of code.
The method reduce `),ke=a(c,"CODE",{});var ei=l(ke);Ht=n(ei,"nn.Linear"),ei.forEach(t),Wt=n(c," size by 2 for "),qe=a(c,"CODE",{});var ti=l(qe);Xt=n(ti,"float16"),ti.forEach(t),zt=n(c," and "),Me=a(c,"CODE",{});var oi=l(Me);Vt=n(oi,"bfloat16"),oi.forEach(t),Kt=n(c," weights and by 4 for "),Ce=a(c,"CODE",{});var ii=l(Ce);Zt=n(ii,"float32"),ii.forEach(t),Jt=n(c," weights, with close to no impact to the quality by operating on the outliers in half-precision."),c.forEach(t),tt=u(e),le=a(e,"P",{});var ai=l(le);re=a(ai,"IMG",{src:!0,alt:!0}),ai.forEach(t),ot=u(e),b=a(e,"P",{});var we=l(b);Qt=n(we,`Int8 mixed-precision matrix decomposition works by separating a matrix multiplication into two streams: (1) a systematic feature outlier stream matrix multiplied in fp16 (0.01%), (2) a regular stream of int8 matrix multiplication (99.9%). With this method, int8 inference with no predictive degradation is possible for very large models.
For more details regarding the method, check out the `),H=a(we,"A",{href:!0,rel:!0});var li=l(H);Yt=n(li,"paper"),li.forEach(t),eo=n(we," or our "),W=a(we,"A",{href:!0,rel:!0});var ri=l(W);to=n(ri,"blogpost about the integration"),ri.forEach(t),oo=n(we,"."),we.forEach(t),it=u(e),se=a(e,"P",{});var si=l(se);ne=a(si,"IMG",{src:!0,alt:!0}),si.forEach(t),at=u(e),T=a(e,"P",{});var xt=l(T);io=n(xt,`Note, that you would require a GPU to run mixed-8bit models as the kernels have been compiled for GPUs only. Make sure that you have enough GPU memory to store the quarter (or half if your model weights are in half precision) of the model before using this feature.
Below are some notes to help you use this module, or follow the demos on `),me=a(xt,"A",{href:!0});var ni=l(me);ao=n(ni,"Google colab"),ni.forEach(t),lo=n(xt,"."),xt.forEach(t),lt=u(e),E=a(e,"H3",{class:!0});var Pt=l(E);O=a(Pt,"A",{id:!0,class:!0,href:!0});var mi=l(O);Ie=a(mi,"SPAN",{});var fi=l(Ie);A(X.$$.fragment,fi),fi.forEach(t),mi.forEach(t),ro=u(Pt),Te=a(Pt,"SPAN",{});var pi=l(Te);so=n(pi,"Requirements"),pi.forEach(t),Pt.forEach(t),rt=u(e),_=a(e,"UL",{});var ye=l(_);Oe=a(ye,"LI",{});var ui=l(Oe);no=n(ui,"Make sure you run that on NVIDIA GPUs that support 8-bit tensor cores (Turing, Ampere or newer architectures - e.g. T4, RTX20s RTX30s, A40-A100)."),ui.forEach(t),mo=u(ye),L=a(ye,"LI",{});var Ve=l(L);fo=n(Ve,"Install the correct version of "),Le=a(Ve,"CODE",{});var hi=l(Le);po=n(hi,"bitsandbytes"),hi.forEach(t),uo=n(Ve,` by running:
`),Se=a(Ve,"CODE",{});var ci=l(Se);ho=n(ci,"pip install bitsandbytes>=0.31.5"),ci.forEach(t),Ve.forEach(t),co=u(ye),S=a(ye,"LI",{});var Ke=l(S);bo=n(Ke,"Install "),Ne=a(Ke,"CODE",{});var di=l(Ne);_o=n(di,"accelerate"),di.forEach(t),vo=u(Ke),Be=a(Ke,"CODE",{});var bi=l(Be);go=n(bi,"pip install accelerate>=0.12.0"),bi.forEach(t),Ke.forEach(t),ye.forEach(t),st=u(e),$=a(e,"H3",{class:!0});var Gt=l($);N=a(Gt,"A",{id:!0,class:!0,href:!0});var _i=l(N);Re=a(_i,"SPAN",{});var vi=l(Re);A(z.$$.fragment,vi),vi.forEach(t),_i.forEach(t),wo=u(Gt),je=a(Gt,"SPAN",{});var gi=l(je);yo=n(gi,"Running mixed-int8 models - single GPU setup"),gi.forEach(t),Gt.forEach(t),nt=u(e),fe=a(e,"P",{});var wi=l(fe);Eo=n(wi,"After installing the required libraries, the way to load your mixed 8-bit model is as follows:"),wi.forEach(t),mt=u(e),A(V.$$.fragment,e),ft=u(e),x=a(e,"H3",{class:!0});var At=l(x);B=a(At,"A",{id:!0,class:!0,href:!0});var yi=l(B);De=a(yi,"SPAN",{});var Ei=l(De);A(K.$$.fragment,Ei),Ei.forEach(t),yi.forEach(t),$o=u(At),Fe=a(At,"SPAN",{});var $i=l(Fe);xo=n($i,"Running mixed-int8 models - multi GPU setup"),$i.forEach(t),At.forEach(t),pt=u(e),pe=a(e,"P",{});var xi=l(pe);Po=n(xi,"The way to load your mixed 8-bit model in multiple GPUs is as follows (same command as single GPU setup):"),xi.forEach(t),ut=u(e),A(Z.$$.fragment,e),ht=u(e),v=a(e,"P",{});var Ee=l(v);Go=n(Ee,"But you can control the GPU RAM you want to allocate on each GPU using "),He=a(Ee,"CODE",{});var Pi=l(He);Ao=n(Pi,"accelerate"),Pi.forEach(t),Uo=n(Ee,". Use the "),We=a(Ee,"CODE",{});var Gi=l(We);ko=n(Gi,"max_memory"),Gi.forEach(t),qo=n(Ee," argument as follows:"),Ee.forEach(t),ct=u(e),A(J.$$.fragment,e),dt=u(e),ue=a(e,"P",{});var Ai=l(ue);Mo=n(Ai,"In this example, the first GPU will use 1GB of memory and the second 2GB."),Ai.forEach(t),bt=u(e),P=a(e,"H3",{class:!0});var Ut=l(P);R=a(Ut,"A",{id:!0,class:!0,href:!0});var Ui=l(R);Xe=a(Ui,"SPAN",{});var ki=l(Xe);A(Q.$$.fragment,ki),ki.forEach(t),Ui.forEach(t),Co=u(Ut),ze=a(Ut,"SPAN",{});var qi=l(ze);Io=n(qi,"Colab demos"),qi.forEach(t),Ut.forEach(t),_t=u(e),he=a(e,"P",{});var Mi=l(he);To=n(Mi,`With this method you can infer on models that were not possible to infer on a Google Colab before.
Check out the demo for running T5-11b (42GB in fp32)! Using 8-bit quantization on Google Colab:`),Mi.forEach(t),vt=u(e),ce=a(e,"P",{});var Ci=l(ce);Y=a(Ci,"A",{href:!0,rel:!0});var Ii=l(Y);de=a(Ii,"IMG",{src:!0,alt:!0}),Ii.forEach(t),Ci.forEach(t),gt=u(e),be=a(e,"P",{});var Ti=l(be);Oo=n(Ti,"Or this demo for BLOOM-3B:"),Ti.forEach(t),wt=u(e),_e=a(e,"P",{});var Oi=l(_e);ee=a(Oi,"A",{href:!0,rel:!0});var Li=l(ee);ve=a(Li,"IMG",{src:!0,alt:!0}),Li.forEach(t),Oi.forEach(t),this.h()},h(){m(g,"name","hf:doc:metadata"),m(g,"content",JSON.stringify(Hi)),m(C,"id","efficient-inference-on-a-single-gpu"),m(C,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(C,"href","#efficient-inference-on-a-single-gpu"),m(w,"class","relative group"),m(te,"href","perf_train_gpu_one"),m(oe,"href","perf_infer_cpu"),m(I,"id","bitsandbytes-integration-for-int8-mixedprecision-matrix-decomposition"),m(I,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(I,"href","#bitsandbytes-integration-for-int8-mixedprecision-matrix-decomposition"),m(y,"class","relative group"),m(F,"href","https://arxiv.org/abs/2208.07339"),m(F,"rel","nofollow"),kt(re.src,Bo="https://s3.amazonaws.com/moonup/production/uploads/1659861207959-62441d1d9fdefb55a0b7d12c.png")||m(re,"src",Bo),m(re,"alt","HFxbitsandbytes.png"),m(H,"href","https://arxiv.org/abs/2208.07339"),m(H,"rel","nofollow"),m(W,"href","https://huggingface.co/blog/hf-bitsandbytes-integration"),m(W,"rel","nofollow"),kt(ne.src,Ro="https://s3.amazonaws.com/moonup/production/uploads/1660567469965-62441d1d9fdefb55a0b7d12c.gif")||m(ne,"src",Ro),m(ne,"alt","MixedInt8.gif"),m(me,"href","#colab-demos"),m(O,"id","requirements"),m(O,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(O,"href","#requirements"),m(E,"class","relative group"),m(N,"id","running-mixedint8-models-single-gpu-setup"),m(N,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(N,"href","#running-mixedint8-models-single-gpu-setup"),m($,"class","relative group"),m(B,"id","running-mixedint8-models-multi-gpu-setup"),m(B,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(B,"href","#running-mixedint8-models-multi-gpu-setup"),m(x,"class","relative group"),m(R,"id","colab-demos"),m(R,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(R,"href","#colab-demos"),m(P,"class","relative group"),kt(de.src,jo="https://colab.research.google.com/assets/colab-badge.svg")||m(de,"src",jo),m(de,"alt","Open In Colab: T5-11b demo"),m(Y,"href","https://colab.research.google.com/drive/1YORPWx4okIHXnjW7MSAidXN29mPVNT7F?usp=sharing"),m(Y,"rel","nofollow"),kt(ve.src,Do="https://colab.research.google.com/assets/colab-badge.svg")||m(ve,"src",Do),m(ve,"alt","Open In Colab: BLOOM-3b demo"),m(ee,"href","https://colab.research.google.com/drive/1qOjXfQIAULfKvZqwCen8-MoWKGdSatZ4?usp=sharing"),m(ee,"rel","nofollow")},m(e,r){o(document.head,g),f(e,Ze,r),f(e,w,r),o(w,C),o(C,xe),U(j,xe,null),o(w,qt),o(w,Pe),o(Pe,Mt),f(e,Je,r),f(e,d,r),o(d,Ct),o(d,te),o(te,It),o(d,Tt),o(d,oe),o(oe,Ot),o(d,Lt),f(e,Qe,r),f(e,y,r),o(y,I),o(I,Ge),U(D,Ge,null),o(y,St),o(y,ie),o(ie,Ae),o(Ae,Nt),o(ie,Bt),f(e,Ye,r),f(e,ae,r),o(ae,Rt),f(e,et,r),f(e,h,r),o(h,jt),o(h,F),o(F,Ue),o(Ue,Dt),o(h,Ft),o(h,ke),o(ke,Ht),o(h,Wt),o(h,qe),o(qe,Xt),o(h,zt),o(h,Me),o(Me,Vt),o(h,Kt),o(h,Ce),o(Ce,Zt),o(h,Jt),f(e,tt,r),f(e,le,r),o(le,re),f(e,ot,r),f(e,b,r),o(b,Qt),o(b,H),o(H,Yt),o(b,eo),o(b,W),o(W,to),o(b,oo),f(e,it,r),f(e,se,r),o(se,ne),f(e,at,r),f(e,T,r),o(T,io),o(T,me),o(me,ao),o(T,lo),f(e,lt,r),f(e,E,r),o(E,O),o(O,Ie),U(X,Ie,null),o(E,ro),o(E,Te),o(Te,so),f(e,rt,r),f(e,_,r),o(_,Oe),o(Oe,no),o(_,mo),o(_,L),o(L,fo),o(L,Le),o(Le,po),o(L,uo),o(L,Se),o(Se,ho),o(_,co),o(_,S),o(S,bo),o(S,Ne),o(Ne,_o),o(S,vo),o(S,Be),o(Be,go),f(e,st,r),f(e,$,r),o($,N),o(N,Re),U(z,Re,null),o($,wo),o($,je),o(je,yo),f(e,nt,r),f(e,fe,r),o(fe,Eo),f(e,mt,r),U(V,e,r),f(e,ft,r),f(e,x,r),o(x,B),o(B,De),U(K,De,null),o(x,$o),o(x,Fe),o(Fe,xo),f(e,pt,r),f(e,pe,r),o(pe,Po),f(e,ut,r),U(Z,e,r),f(e,ht,r),f(e,v,r),o(v,Go),o(v,He),o(He,Ao),o(v,Uo),o(v,We),o(We,ko),o(v,qo),f(e,ct,r),U(J,e,r),f(e,dt,r),f(e,ue,r),o(ue,Mo),f(e,bt,r),f(e,P,r),o(P,R),o(R,Xe),U(Q,Xe,null),o(P,Co),o(P,ze),o(ze,Io),f(e,_t,r),f(e,he,r),o(he,To),f(e,vt,r),f(e,ce,r),o(ce,Y),o(Y,de),f(e,gt,r),f(e,be,r),o(be,Oo),f(e,wt,r),f(e,_e,r),o(_e,ee),o(ee,ve),yt=!0},p:ji,i(e){yt||(k(j.$$.fragment,e),k(D.$$.fragment,e),k(X.$$.fragment,e),k(z.$$.fragment,e),k(V.$$.fragment,e),k(K.$$.fragment,e),k(Z.$$.fragment,e),k(J.$$.fragment,e),k(Q.$$.fragment,e),yt=!0)},o(e){q(j.$$.fragment,e),q(D.$$.fragment,e),q(X.$$.fragment,e),q(z.$$.fragment,e),q(V.$$.fragment,e),q(K.$$.fragment,e),q(Z.$$.fragment,e),q(J.$$.fragment,e),q(Q.$$.fragment,e),yt=!1},d(e){t(g),e&&t(Ze),e&&t(w),M(j),e&&t(Je),e&&t(d),e&&t(Qe),e&&t(y),M(D),e&&t(Ye),e&&t(ae),e&&t(et),e&&t(h),e&&t(tt),e&&t(le),e&&t(ot),e&&t(b),e&&t(it),e&&t(se),e&&t(at),e&&t(T),e&&t(lt),e&&t(E),M(X),e&&t(rt),e&&t(_),e&&t(st),e&&t($),M(z),e&&t(nt),e&&t(fe),e&&t(mt),M(V,e),e&&t(ft),e&&t(x),M(K),e&&t(pt),e&&t(pe),e&&t(ut),M(Z,e),e&&t(ht),e&&t(v),e&&t(ct),M(J,e),e&&t(dt),e&&t(ue),e&&t(bt),e&&t(P),M(Q),e&&t(_t),e&&t(he),e&&t(vt),e&&t(ce),e&&t(gt),e&&t(be),e&&t(wt),e&&t(_e)}}}const Hi={local:"efficient-inference-on-a-single-gpu",sections:[{local:"bitsandbytes-integration-for-int8-mixedprecision-matrix-decomposition",sections:[{local:"requirements",title:"Requirements"},{local:"running-mixedint8-models-single-gpu-setup",title:"Running mixed-int8 models - single GPU setup"},{local:"running-mixedint8-models-multi-gpu-setup",title:"Running mixed-int8 models - multi GPU setup"},{local:"colab-demos",title:"Colab demos"}],title:"`bitsandbytes` integration for Int8 mixed-precision matrix decomposition"}],title:"Efficient Inference on a Single GPU"};function Wi(No){return Di(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Ki extends Si{constructor(g){super();Ni(this,g,Wi,Fi,Bi,{})}}export{Ki as default,Hi as metadata};
