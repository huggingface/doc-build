import{S as B0,i as W0,s as Q0,e as r,k as l,w as k,t,M as U0,c as a,d as n,m as d,a as i,x as F,h as o,b as c,F as e,g as h,y,q as w,o as b,B as $,v as R0}from"../../chunks/vendor-6b77c823.js";import{T as qe}from"../../chunks/Tip-39098574.js";import{D as X}from"../../chunks/Docstring-abef54e3.js";import{C as ye}from"../../chunks/CodeBlock-3a8b25a8.js";import{I as je}from"../../chunks/IconCopyLink-7a11ce68.js";function H0(V){let u,z,g,_,T;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),T=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(v){u=a(v,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),T=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(v,m){h(v,u,m),e(u,z),e(u,g),e(g,_),e(u,T)},d(v){v&&n(u)}}}function V0(V){let u,z,g,_,T;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),T=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(v){u=a(v,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),T=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(v,m){h(v,u,m),e(u,z),e(u,g),e(g,_),e(u,T)},d(v){v&&n(u)}}}function Y0(V){let u,z,g,_,T;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),T=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(v){u=a(v,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),T=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(v,m){h(v,u,m),e(u,z),e(u,g),e(g,_),e(u,T)},d(v){v&&n(u)}}}function K0(V){let u,z,g,_,T;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),T=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(v){u=a(v,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),T=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(v,m){h(v,u,m),e(u,z),e(u,g),e(g,_),e(u,T)},d(v){v&&n(u)}}}function G0(V){let u,z,g,_,T;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),T=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(v){u=a(v,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),T=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(v,m){h(v,u,m),e(u,z),e(u,g),e(g,_),e(u,T)},d(v){v&&n(u)}}}function Z0(V){let u,z,g,_,T;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),T=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(v){u=a(v,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),T=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(v,m){h(v,u,m),e(u,z),e(u,g),e(g,_),e(u,T)},d(v){v&&n(u)}}}function X0(V){let u,z,g,_,T;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),T=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(v){u=a(v,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),T=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(v,m){h(v,u,m),e(u,z),e(u,g),e(g,_),e(u,T)},d(v){v&&n(u)}}}function J0(V){let u,z,g,_,T;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),T=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(v){u=a(v,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),T=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(v,m){h(v,u,m),e(u,z),e(u,g),e(g,_),e(u,T)},d(v){v&&n(u)}}}function e$(V){let u,z,g,_,T,v,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,C,oe,W,le,se,S,he,de,j,fe,B,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),T=r("li"),v=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),C=r("li"),oe=t("a single Tensor with "),W=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),j=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);T=a(Z,"LI",{});var ve=i(T);v=o(ve,"having all inputs as keyword arguments (like PyTorch models), or"),ve.forEach(n),m=d(Z),M=a(Z,"LI",{});var we=i(M);ce=o(we,"having all inputs as a list, tuple or dict in the first positional arguments."),we.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var Te=i(A);ne=o(Te,"tf.keras.Model.fit"),Te.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var be=i(N);ue=o(be,"model(inputs)"),be.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var x=i(P);C=a(x,"LI",{});var R=i(C);oe=o(R,"a single Tensor with "),W=a(R,"CODE",{});var Ee=i(W);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var ke=i(S);he=o(ke,"model(inputs_ids)"),ke.forEach(n),R.forEach(n),de=d(x),j=a(x,"LI",{});var H=i(j);fe=o(H,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=a(H,"CODE",{});var Me=i(B);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(H," or "),Q=a(H,"CODE",{});var Fe=i(Q);me=o(Fe,"model([input_ids, attention_mask, token_type_ids])"),Fe.forEach(n),H.forEach(n),I=d(x),O=a(x,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),x.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,T),e(T,v),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,C),e(C,oe),e(C,W),e(W,le),e(C,se),e(C,S),e(S,he),e(P,de),e(P,j),e(j,fe),e(j,B),e(B,ee),e(j,ae),e(j,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function n$(V){let u,z,g,_,T;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),T=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(v){u=a(v,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),T=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(v,m){h(v,u,m),e(u,z),e(u,g),e(g,_),e(u,T)},d(v){v&&n(u)}}}function t$(V){let u,z,g,_,T,v,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,C,oe,W,le,se,S,he,de,j,fe,B,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),T=r("li"),v=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),C=r("li"),oe=t("a single Tensor with "),W=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),j=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);T=a(Z,"LI",{});var ve=i(T);v=o(ve,"having all inputs as keyword arguments (like PyTorch models), or"),ve.forEach(n),m=d(Z),M=a(Z,"LI",{});var we=i(M);ce=o(we,"having all inputs as a list, tuple or dict in the first positional arguments."),we.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var Te=i(A);ne=o(Te,"tf.keras.Model.fit"),Te.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var be=i(N);ue=o(be,"model(inputs)"),be.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var x=i(P);C=a(x,"LI",{});var R=i(C);oe=o(R,"a single Tensor with "),W=a(R,"CODE",{});var Ee=i(W);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var ke=i(S);he=o(ke,"model(inputs_ids)"),ke.forEach(n),R.forEach(n),de=d(x),j=a(x,"LI",{});var H=i(j);fe=o(H,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=a(H,"CODE",{});var Me=i(B);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(H," or "),Q=a(H,"CODE",{});var Fe=i(Q);me=o(Fe,"model([input_ids, attention_mask, token_type_ids])"),Fe.forEach(n),H.forEach(n),I=d(x),O=a(x,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),x.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,T),e(T,v),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,C),e(C,oe),e(C,W),e(W,le),e(C,se),e(C,S),e(S,he),e(P,de),e(P,j),e(j,fe),e(j,B),e(B,ee),e(j,ae),e(j,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function o$(V){let u,z,g,_,T;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),T=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(v){u=a(v,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),T=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(v,m){h(v,u,m),e(u,z),e(u,g),e(g,_),e(u,T)},d(v){v&&n(u)}}}function s$(V){let u,z,g,_,T,v,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,C,oe,W,le,se,S,he,de,j,fe,B,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),T=r("li"),v=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),C=r("li"),oe=t("a single Tensor with "),W=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),j=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);T=a(Z,"LI",{});var ve=i(T);v=o(ve,"having all inputs as keyword arguments (like PyTorch models), or"),ve.forEach(n),m=d(Z),M=a(Z,"LI",{});var we=i(M);ce=o(we,"having all inputs as a list, tuple or dict in the first positional arguments."),we.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var Te=i(A);ne=o(Te,"tf.keras.Model.fit"),Te.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var be=i(N);ue=o(be,"model(inputs)"),be.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var x=i(P);C=a(x,"LI",{});var R=i(C);oe=o(R,"a single Tensor with "),W=a(R,"CODE",{});var Ee=i(W);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var ke=i(S);he=o(ke,"model(inputs_ids)"),ke.forEach(n),R.forEach(n),de=d(x),j=a(x,"LI",{});var H=i(j);fe=o(H,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=a(H,"CODE",{});var Me=i(B);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(H," or "),Q=a(H,"CODE",{});var Fe=i(Q);me=o(Fe,"model([input_ids, attention_mask, token_type_ids])"),Fe.forEach(n),H.forEach(n),I=d(x),O=a(x,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),x.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,T),e(T,v),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,C),e(C,oe),e(C,W),e(W,le),e(C,se),e(C,S),e(S,he),e(P,de),e(P,j),e(j,fe),e(j,B),e(B,ee),e(j,ae),e(j,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function r$(V){let u,z,g,_,T;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),T=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(v){u=a(v,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),T=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(v,m){h(v,u,m),e(u,z),e(u,g),e(g,_),e(u,T)},d(v){v&&n(u)}}}function a$(V){let u,z,g,_,T,v,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,C,oe,W,le,se,S,he,de,j,fe,B,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),T=r("li"),v=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),C=r("li"),oe=t("a single Tensor with "),W=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),j=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);T=a(Z,"LI",{});var ve=i(T);v=o(ve,"having all inputs as keyword arguments (like PyTorch models), or"),ve.forEach(n),m=d(Z),M=a(Z,"LI",{});var we=i(M);ce=o(we,"having all inputs as a list, tuple or dict in the first positional arguments."),we.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var Te=i(A);ne=o(Te,"tf.keras.Model.fit"),Te.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var be=i(N);ue=o(be,"model(inputs)"),be.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var x=i(P);C=a(x,"LI",{});var R=i(C);oe=o(R,"a single Tensor with "),W=a(R,"CODE",{});var Ee=i(W);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var ke=i(S);he=o(ke,"model(inputs_ids)"),ke.forEach(n),R.forEach(n),de=d(x),j=a(x,"LI",{});var H=i(j);fe=o(H,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=a(H,"CODE",{});var Me=i(B);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(H," or "),Q=a(H,"CODE",{});var Fe=i(Q);me=o(Fe,"model([input_ids, attention_mask, token_type_ids])"),Fe.forEach(n),H.forEach(n),I=d(x),O=a(x,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),x.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,T),e(T,v),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,C),e(C,oe),e(C,W),e(W,le),e(C,se),e(C,S),e(S,he),e(P,de),e(P,j),e(j,fe),e(j,B),e(B,ee),e(j,ae),e(j,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function i$(V){let u,z,g,_,T;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),T=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(v){u=a(v,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),T=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(v,m){h(v,u,m),e(u,z),e(u,g),e(g,_),e(u,T)},d(v){v&&n(u)}}}function l$(V){let u,z,g,_,T,v,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,C,oe,W,le,se,S,he,de,j,fe,B,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),T=r("li"),v=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),C=r("li"),oe=t("a single Tensor with "),W=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),j=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);T=a(Z,"LI",{});var ve=i(T);v=o(ve,"having all inputs as keyword arguments (like PyTorch models), or"),ve.forEach(n),m=d(Z),M=a(Z,"LI",{});var we=i(M);ce=o(we,"having all inputs as a list, tuple or dict in the first positional arguments."),we.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var Te=i(A);ne=o(Te,"tf.keras.Model.fit"),Te.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var be=i(N);ue=o(be,"model(inputs)"),be.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var x=i(P);C=a(x,"LI",{});var R=i(C);oe=o(R,"a single Tensor with "),W=a(R,"CODE",{});var Ee=i(W);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var ke=i(S);he=o(ke,"model(inputs_ids)"),ke.forEach(n),R.forEach(n),de=d(x),j=a(x,"LI",{});var H=i(j);fe=o(H,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=a(H,"CODE",{});var Me=i(B);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(H," or "),Q=a(H,"CODE",{});var Fe=i(Q);me=o(Fe,"model([input_ids, attention_mask, token_type_ids])"),Fe.forEach(n),H.forEach(n),I=d(x),O=a(x,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),x.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,T),e(T,v),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,C),e(C,oe),e(C,W),e(W,le),e(C,se),e(C,S),e(S,he),e(P,de),e(P,j),e(j,fe),e(j,B),e(B,ee),e(j,ae),e(j,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function d$(V){let u,z,g,_,T;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),T=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(v){u=a(v,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),T=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(v,m){h(v,u,m),e(u,z),e(u,g),e(g,_),e(u,T)},d(v){v&&n(u)}}}function c$(V){let u,z,g,_,T,v,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,C,oe,W,le,se,S,he,de,j,fe,B,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),T=r("li"),v=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),C=r("li"),oe=t("a single Tensor with "),W=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),j=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);T=a(Z,"LI",{});var ve=i(T);v=o(ve,"having all inputs as keyword arguments (like PyTorch models), or"),ve.forEach(n),m=d(Z),M=a(Z,"LI",{});var we=i(M);ce=o(we,"having all inputs as a list, tuple or dict in the first positional arguments."),we.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var Te=i(A);ne=o(Te,"tf.keras.Model.fit"),Te.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var be=i(N);ue=o(be,"model(inputs)"),be.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var x=i(P);C=a(x,"LI",{});var R=i(C);oe=o(R,"a single Tensor with "),W=a(R,"CODE",{});var Ee=i(W);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var ke=i(S);he=o(ke,"model(inputs_ids)"),ke.forEach(n),R.forEach(n),de=d(x),j=a(x,"LI",{});var H=i(j);fe=o(H,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=a(H,"CODE",{});var Me=i(B);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(H," or "),Q=a(H,"CODE",{});var Fe=i(Q);me=o(Fe,"model([input_ids, attention_mask, token_type_ids])"),Fe.forEach(n),H.forEach(n),I=d(x),O=a(x,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),x.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,T),e(T,v),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,C),e(C,oe),e(C,W),e(W,le),e(C,se),e(C,S),e(S,he),e(P,de),e(P,j),e(j,fe),e(j,B),e(B,ee),e(j,ae),e(j,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function p$(V){let u,z,g,_,T;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),T=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(v){u=a(v,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),T=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(v,m){h(v,u,m),e(u,z),e(u,g),e(g,_),e(u,T)},d(v){v&&n(u)}}}function u$(V){let u,z,g,_,T,v,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,C,oe,W,le,se,S,he,de,j,fe,B,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),T=r("li"),v=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),C=r("li"),oe=t("a single Tensor with "),W=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),j=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);T=a(Z,"LI",{});var ve=i(T);v=o(ve,"having all inputs as keyword arguments (like PyTorch models), or"),ve.forEach(n),m=d(Z),M=a(Z,"LI",{});var we=i(M);ce=o(we,"having all inputs as a list, tuple or dict in the first positional arguments."),we.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var Te=i(A);ne=o(Te,"tf.keras.Model.fit"),Te.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var be=i(N);ue=o(be,"model(inputs)"),be.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var x=i(P);C=a(x,"LI",{});var R=i(C);oe=o(R,"a single Tensor with "),W=a(R,"CODE",{});var Ee=i(W);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var ke=i(S);he=o(ke,"model(inputs_ids)"),ke.forEach(n),R.forEach(n),de=d(x),j=a(x,"LI",{});var H=i(j);fe=o(H,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=a(H,"CODE",{});var Me=i(B);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(H," or "),Q=a(H,"CODE",{});var Fe=i(Q);me=o(Fe,"model([input_ids, attention_mask, token_type_ids])"),Fe.forEach(n),H.forEach(n),I=d(x),O=a(x,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),x.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,T),e(T,v),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,C),e(C,oe),e(C,W),e(W,le),e(C,se),e(C,S),e(S,he),e(P,de),e(P,j),e(j,fe),e(j,B),e(B,ee),e(j,ae),e(j,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function h$(V){let u,z,g,_,T;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),T=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(v){u=a(v,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),T=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(v,m){h(v,u,m),e(u,z),e(u,g),e(g,_),e(u,T)},d(v){v&&n(u)}}}function f$(V){let u,z,g,_,T,v,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,C,oe,W,le,se,S,he,de,j,fe,B,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),T=r("li"),v=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),C=r("li"),oe=t("a single Tensor with "),W=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),j=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);T=a(Z,"LI",{});var ve=i(T);v=o(ve,"having all inputs as keyword arguments (like PyTorch models), or"),ve.forEach(n),m=d(Z),M=a(Z,"LI",{});var we=i(M);ce=o(we,"having all inputs as a list, tuple or dict in the first positional arguments."),we.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var Te=i(A);ne=o(Te,"tf.keras.Model.fit"),Te.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var be=i(N);ue=o(be,"model(inputs)"),be.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var x=i(P);C=a(x,"LI",{});var R=i(C);oe=o(R,"a single Tensor with "),W=a(R,"CODE",{});var Ee=i(W);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var ke=i(S);he=o(ke,"model(inputs_ids)"),ke.forEach(n),R.forEach(n),de=d(x),j=a(x,"LI",{});var H=i(j);fe=o(H,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),B=a(H,"CODE",{});var Me=i(B);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(H," or "),Q=a(H,"CODE",{});var Fe=i(Q);me=o(Fe,"model([input_ids, attention_mask, token_type_ids])"),Fe.forEach(n),H.forEach(n),I=d(x),O=a(x,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),x.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,T),e(T,v),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,C),e(C,oe),e(C,W),e(W,le),e(C,se),e(C,S),e(S,he),e(P,de),e(P,j),e(j,fe),e(j,B),e(B,ee),e(j,ae),e(j,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function m$(V){let u,z,g,_,T;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),T=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(v){u=a(v,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),T=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(v,m){h(v,u,m),e(u,z),e(u,g),e(g,_),e(u,T)},d(v){v&&n(u)}}}function g$(V){let u,z,g,_,T,v,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,C,oe,W,le,se,S,he,de,j,fe,B,ee,ae,Q,me,I,O,re,U,ge,p,E,Z,ve,we,D,Te,be,$e,x,R,Ee,ke,H,Me,Fe,_e,ze,oi,Yu,Ku,Oc,In,Gu,No,Zu,Xu,So,Ju,eh,Dc,Zn,Bt,kl,Io,nh,Fl,th,Ac,Nn,Bo,oh,Sn,sh,si,rh,ah,ri,ih,lh,Wo,dh,ch,ph,Xn,uh,ai,hh,fh,ii,mh,gh,Nc,Jn,Wt,yl,Qo,_h,wl,vh,Sc,Ce,Uo,Th,bl,kh,Fh,Qt,li,yh,wh,di,bh,$h,Eh,Ro,Mh,ci,zh,qh,Ph,Bn,Ho,jh,$l,Ch,xh,Vo,pi,Lh,El,Oh,Dh,ui,Ah,Ml,Nh,Sh,Ut,Yo,Ih,Ko,Bh,zl,Wh,Qh,Uh,yn,Go,Rh,ql,Hh,Vh,Zo,Yh,et,Kh,Pl,Gh,Zh,jl,Xh,Jh,ef,hi,Xo,Ic,nt,Rt,Cl,Jo,nf,xl,tf,Bc,sn,es,of,ns,sf,Ll,rf,af,lf,Ht,fi,df,cf,mi,pf,uf,hf,ts,ff,gi,mf,gf,_f,wn,os,vf,Ol,Tf,kf,ss,Ff,tt,yf,Dl,wf,bf,Al,$f,Ef,Wc,ot,Vt,Nl,rs,Mf,Sl,zf,Qc,st,as,qf,is,Pf,_i,jf,Cf,Uc,rt,ls,xf,ds,Lf,vi,Of,Df,Rc,at,Yt,Il,cs,Af,Bl,Nf,Hc,Qe,ps,Sf,Wl,If,Bf,us,Wf,hs,Qf,Uf,Rf,fs,Hf,Ti,Vf,Yf,Kf,ms,Gf,gs,Zf,Xf,Jf,rn,_s,em,it,nm,ki,tm,om,Ql,sm,rm,am,Kt,im,Ul,lm,dm,vs,Vc,lt,Gt,Rl,Ts,cm,Hl,pm,Yc,Ue,ks,um,Vl,hm,fm,Fs,mm,ys,gm,_m,vm,ws,Tm,Fi,km,Fm,ym,bs,wm,$s,bm,$m,Em,an,Es,Mm,dt,zm,yi,qm,Pm,Yl,jm,Cm,xm,Zt,Lm,Kl,Om,Dm,Ms,Kc,ct,Xt,Gl,zs,Am,Zl,Nm,Gc,pt,qs,Sm,ln,Ps,Im,ut,Bm,wi,Wm,Qm,Xl,Um,Rm,Hm,Jt,Vm,Jl,Ym,Km,js,Zc,ht,eo,ed,Cs,Gm,nd,Zm,Xc,Re,xs,Xm,Ls,Jm,td,eg,ng,tg,Os,og,Ds,sg,rg,ag,As,ig,bi,lg,dg,cg,Ns,pg,Ss,ug,hg,fg,Ge,Is,mg,ft,gg,$i,_g,vg,od,Tg,kg,Fg,no,yg,sd,wg,bg,Bs,$g,Ws,Jc,mt,to,rd,Qs,Eg,ad,Mg,ep,He,Us,zg,id,qg,Pg,Rs,jg,Hs,Cg,xg,Lg,Vs,Og,Ei,Dg,Ag,Ng,Ys,Sg,Ks,Ig,Bg,Wg,Pe,Gs,Qg,gt,Ug,Mi,Rg,Hg,ld,Vg,Yg,Kg,oo,Gg,dd,Zg,Xg,Zs,Jg,Xs,e_,cd,n_,t_,Js,o_,er,np,_t,so,pd,nr,s_,ud,r_,tp,Ve,tr,a_,hd,i_,l_,or,d_,sr,c_,p_,u_,rr,h_,zi,f_,m_,g_,ar,__,ir,v_,T_,k_,dn,lr,F_,vt,y_,qi,w_,b_,fd,$_,E_,M_,ro,z_,md,q_,P_,dr,op,Tt,ao,gd,cr,j_,_d,C_,sp,Ye,pr,x_,vd,L_,O_,ur,D_,hr,A_,N_,S_,fr,I_,Pi,B_,W_,Q_,mr,U_,gr,R_,H_,V_,Ze,_r,Y_,kt,K_,ji,G_,Z_,Td,X_,J_,ev,io,nv,kd,tv,ov,vr,sv,Tr,rp,Ft,lo,Fd,kr,rv,yd,av,ap,Ke,Fr,iv,yt,lv,wd,dv,cv,bd,pv,uv,hv,yr,fv,wr,mv,gv,_v,br,vv,Ci,Tv,kv,Fv,$r,yv,Er,wv,bv,$v,Xe,Mr,Ev,wt,Mv,xi,zv,qv,$d,Pv,jv,Cv,co,xv,Ed,Lv,Ov,zr,Dv,qr,ip,bt,po,Md,Pr,Av,zd,Nv,lp,Le,jr,Sv,qd,Iv,Bv,Cr,Wv,xr,Qv,Uv,Rv,Lr,Hv,Li,Vv,Yv,Kv,Or,Gv,Dr,Zv,Xv,Jv,uo,eT,cn,Ar,nT,$t,tT,Oi,oT,sT,Pd,rT,aT,iT,ho,lT,jd,dT,cT,Nr,dp,Et,fo,Cd,Sr,pT,xd,uT,cp,Oe,Ir,hT,Ld,fT,mT,Br,gT,Wr,_T,vT,TT,Qr,kT,Di,FT,yT,wT,Ur,bT,Rr,$T,ET,MT,mo,zT,pn,Hr,qT,Mt,PT,Ai,jT,CT,Od,xT,LT,OT,go,DT,Dd,AT,NT,Vr,pp,zt,_o,Ad,Yr,ST,Nd,IT,up,De,Kr,BT,Sd,WT,QT,Gr,UT,Zr,RT,HT,VT,Xr,YT,Ni,KT,GT,ZT,Jr,XT,ea,JT,ek,nk,vo,tk,un,na,ok,qt,sk,Si,rk,ak,Id,ik,lk,dk,To,ck,Bd,pk,uk,ta,hp,Pt,ko,Wd,oa,hk,Qd,fk,fp,Ae,sa,mk,ra,gk,Ud,_k,vk,Tk,aa,kk,ia,Fk,yk,wk,la,bk,Ii,$k,Ek,Mk,da,zk,ca,qk,Pk,jk,Fo,Ck,Je,pa,xk,jt,Lk,Bi,Ok,Dk,Rd,Ak,Nk,Sk,yo,Ik,Hd,Bk,Wk,ua,Qk,ha,mp,Ct,wo,Vd,fa,Uk,Yd,Rk,gp,Ne,ma,Hk,Kd,Vk,Yk,ga,Kk,_a,Gk,Zk,Xk,va,Jk,Wi,eF,nF,tF,Ta,oF,ka,sF,rF,aF,bo,iF,en,Fa,lF,xt,dF,Qi,cF,pF,Gd,uF,hF,fF,$o,mF,Zd,gF,_F,ya,vF,wa,_p,Lt,Eo,Xd,ba,TF,Jd,kF,vp,Se,$a,FF,ec,yF,wF,Ea,bF,Ma,$F,EF,MF,za,zF,Ui,qF,PF,jF,qa,CF,Pa,xF,LF,OF,Mo,DF,hn,ja,AF,Ot,NF,Ri,SF,IF,nc,BF,WF,QF,zo,UF,tc,RF,HF,Ca,Tp,Dt,qo,oc,xa,VF,sc,YF,kp,Ie,La,KF,rc,GF,ZF,Oa,XF,Da,JF,ey,ny,Aa,ty,Hi,oy,sy,ry,Na,ay,Sa,iy,ly,dy,Po,cy,nn,Ia,py,At,uy,Vi,hy,fy,ac,my,gy,_y,jo,vy,ic,Ty,ky,Ba,Fy,Wa,Fp,Nt,Co,lc,Qa,yy,dc,wy,yp,Be,Ua,by,St,$y,cc,Ey,My,pc,zy,qy,Py,Ra,jy,Ha,Cy,xy,Ly,Va,Oy,Yi,Dy,Ay,Ny,Ya,Sy,Ka,Iy,By,Wy,xo,Qy,tn,Ga,Uy,It,Ry,Ki,Hy,Vy,uc,Yy,Ky,Gy,Lo,Zy,hc,Xy,Jy,Za,e1,Xa,wp;return v=new je({}),ne=new je({}),Io=new je({}),Bo=new X({props:{name:"class transformers.FunnelConfig",anchor:"transformers.FunnelConfig",parameters:[{name:"vocab_size",val:" = 30522"},{name:"block_sizes",val:" = [4, 4, 4]"},{name:"block_repeats",val:" = None"},{name:"num_decoder_layers",val:" = 2"},{name:"d_model",val:" = 768"},{name:"n_head",val:" = 12"},{name:"d_head",val:" = 64"},{name:"d_inner",val:" = 3072"},{name:"hidden_act",val:" = 'gelu_new'"},{name:"hidden_dropout",val:" = 0.1"},{name:"attention_dropout",val:" = 0.1"},{name:"activation_dropout",val:" = 0.0"},{name:"max_position_embeddings",val:" = 512"},{name:"type_vocab_size",val:" = 3"},{name:"initializer_range",val:" = 0.1"},{name:"initializer_std",val:" = None"},{name:"layer_norm_eps",val:" = 1e-09"},{name:"pooling_type",val:" = 'mean'"},{name:"attention_type",val:" = 'relative_shift'"},{name:"separate_cls",val:" = True"},{name:"truncate_seq",val:" = True"},{name:"pool_q_only",val:" = True"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/configuration_funnel.py#L37",parametersDescription:[{anchor:"transformers.FunnelConfig.vocab_size",description:`<strong>vocab_size</strong> (<code>int</code>, <em>optional</em>, defaults to 30522) &#x2014;
Vocabulary size of the Funnel transformer. Defines the number of different tokens that can be represented
by the <code>inputs_ids</code> passed when calling <a href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelModel">FunnelModel</a> or <a href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.TFFunnelModel">TFFunnelModel</a>.`,name:"vocab_size"},{anchor:"transformers.FunnelConfig.block_sizes",description:`<strong>block_sizes</strong> (<code>List[int]</code>, <em>optional</em>, defaults to <code>[4, 4, 4]</code>) &#x2014;
The sizes of the blocks used in the model.`,name:"block_sizes"},{anchor:"transformers.FunnelConfig.block_repeats",description:`<strong>block_repeats</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
If passed along, each layer of each block is repeated the number of times indicated.`,name:"block_repeats"},{anchor:"transformers.FunnelConfig.num_decoder_layers",description:`<strong>num_decoder_layers</strong> (<code>int</code>, <em>optional</em>, defaults to 2) &#x2014;
The number of layers in the decoder (when not using the base model).`,name:"num_decoder_layers"},{anchor:"transformers.FunnelConfig.d_model",description:`<strong>d_model</strong> (<code>int</code>, <em>optional</em>, defaults to 768) &#x2014;
Dimensionality of the model&#x2019;s hidden states.`,name:"d_model"},{anchor:"transformers.FunnelConfig.n_head",description:`<strong>n_head</strong> (<code>int</code>, <em>optional</em>, defaults to 12) &#x2014;
Number of attention heads for each attention layer in the Transformer encoder.`,name:"n_head"},{anchor:"transformers.FunnelConfig.d_head",description:`<strong>d_head</strong> (<code>int</code>, <em>optional</em>, defaults to 64) &#x2014;
Dimensionality of the model&#x2019;s heads.`,name:"d_head"},{anchor:"transformers.FunnelConfig.d_inner",description:`<strong>d_inner</strong> (<code>int</code>, <em>optional</em>, defaults to 3072) &#x2014;
Inner dimension in the feed-forward blocks.`,name:"d_inner"},{anchor:"transformers.FunnelConfig.hidden_act",description:`<strong>hidden_act</strong> (<code>str</code> or <code>callable</code>, <em>optional</em>, defaults to <code>&quot;gelu_new&quot;</code>) &#x2014;
The non-linear activation function (function or string) in the encoder and pooler. If string, <code>&quot;gelu&quot;</code>,
<code>&quot;relu&quot;</code>, <code>&quot;silu&quot;</code> and <code>&quot;gelu_new&quot;</code> are supported.`,name:"hidden_act"},{anchor:"transformers.FunnelConfig.hidden_dropout",description:`<strong>hidden_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.`,name:"hidden_dropout"},{anchor:"transformers.FunnelConfig.attention_dropout",description:`<strong>attention_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The dropout probability for the attention probabilities.`,name:"attention_dropout"},{anchor:"transformers.FunnelConfig.activation_dropout",description:`<strong>activation_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
The dropout probability used between the two layers of the feed-forward blocks.`,name:"activation_dropout"},{anchor:"transformers.FunnelConfig.max_position_embeddings",description:`<strong>max_position_embeddings</strong> (<code>int</code>, <em>optional</em>, defaults to 512) &#x2014;
The maximum sequence length that this model might ever be used with. Typically set this to something large
just in case (e.g., 512 or 1024 or 2048).`,name:"max_position_embeddings"},{anchor:"transformers.FunnelConfig.type_vocab_size",description:`<strong>type_vocab_size</strong> (<code>int</code>, <em>optional</em>, defaults to 3) &#x2014;
The vocabulary size of the <code>token_type_ids</code> passed when calling <a href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelModel">FunnelModel</a> or <a href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.TFFunnelModel">TFFunnelModel</a>.`,name:"type_vocab_size"},{anchor:"transformers.FunnelConfig.initializer_range",description:`<strong>initializer_range</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The upper bound of the <em>uniform initializer</em> for initializing all weight matrices in attention layers.`,name:"initializer_range"},{anchor:"transformers.FunnelConfig.initializer_std",description:`<strong>initializer_std</strong> (<code>float</code>, <em>optional</em>) &#x2014;
The standard deviation of the <em>normal initializer</em> for initializing the embedding matrix and the weight of
linear layers. Will default to 1 for the embedding matrix and the value given by Xavier initialization for
linear layers.`,name:"initializer_std"},{anchor:"transformers.FunnelConfig.layer_norm_eps",description:`<strong>layer_norm_eps</strong> (<code>float</code>, <em>optional</em>, defaults to 1e-9) &#x2014;
The epsilon used by the layer normalization layers.`,name:"layer_norm_eps"},{anchor:"transformers.FunnelConfig.pooling_type",description:`<strong>pooling_type</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;mean&quot;</code>) &#x2014;
Possible values are <code>&quot;mean&quot;</code> or <code>&quot;max&quot;</code>. The way pooling is performed at the beginning of each block.`,name:"pooling_type"},{anchor:"transformers.FunnelConfig.attention_type",description:`<strong>attention_type</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;relative_shift&quot;</code>) &#x2014;
Possible values are <code>&quot;relative_shift&quot;</code> or <code>&quot;factorized&quot;</code>. The former is faster on CPU/GPU while the latter
is faster on TPU.`,name:"attention_type"},{anchor:"transformers.FunnelConfig.separate_cls",description:`<strong>separate_cls</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to separate the cls token when applying pooling.`,name:"separate_cls"},{anchor:"transformers.FunnelConfig.truncate_seq",description:`<strong>truncate_seq</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
When using <code>separate_cls</code>, whether or not to truncate the last token when pooling, to avoid getting a
sequence length that is not a multiple of 2.`,name:"truncate_seq"},{anchor:"transformers.FunnelConfig.pool_q_only",description:`<strong>pool_q_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to apply the pooling only to the query or to query, key and values for the attention layers.`,name:"pool_q_only"}]}}),Qo=new je({}),Uo=new X({props:{name:"class transformers.FunnelTokenizer",anchor:"transformers.FunnelTokenizer",parameters:[{name:"vocab_file",val:""},{name:"do_lower_case",val:" = True"},{name:"do_basic_tokenize",val:" = True"},{name:"never_split",val:" = None"},{name:"unk_token",val:" = '<unk>'"},{name:"sep_token",val:" = '<sep>'"},{name:"pad_token",val:" = '<pad>'"},{name:"cls_token",val:" = '<cls>'"},{name:"mask_token",val:" = '<mask>'"},{name:"bos_token",val:" = '<s>'"},{name:"eos_token",val:" = '</s>'"},{name:"tokenize_chinese_chars",val:" = True"},{name:"strip_accents",val:" = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/tokenization_funnel.py#L58"}}),Ho=new X({props:{name:"build_inputs_with_special_tokens",anchor:"transformers.FunnelTokenizer.build_inputs_with_special_tokens",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/bert/tokenization_bert.py#L248",parametersDescription:[{anchor:"transformers.FunnelTokenizer.build_inputs_with_special_tokens.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs to which the special tokens will be added.`,name:"token_ids_0"},{anchor:"transformers.FunnelTokenizer.build_inputs_with_special_tokens.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"}],returnDescription:`
<p>List of <a href="../glossary#input-ids">input IDs</a> with the appropriate special tokens.</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),Yo=new X({props:{name:"get_special_tokens_mask",anchor:"transformers.FunnelTokenizer.get_special_tokens_mask",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"},{name:"already_has_special_tokens",val:": bool = False"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/bert/tokenization_bert.py#L273",parametersDescription:[{anchor:"transformers.FunnelTokenizer.get_special_tokens_mask.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs.`,name:"token_ids_0"},{anchor:"transformers.FunnelTokenizer.get_special_tokens_mask.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"},{anchor:"transformers.FunnelTokenizer.get_special_tokens_mask.already_has_special_tokens",description:`<strong>already_has_special_tokens</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not the token list is already formatted with special tokens for the model.`,name:"already_has_special_tokens"}],returnDescription:`
<p>A list of integers in the range [0, 1]: 1 for a special token, 0 for a sequence token.</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),Go=new X({props:{name:"create_token_type_ids_from_sequences",anchor:"transformers.FunnelTokenizer.create_token_type_ids_from_sequences",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/tokenization_funnel.py#L108",parametersDescription:[{anchor:"transformers.FunnelTokenizer.create_token_type_ids_from_sequences.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs.`,name:"token_ids_0"},{anchor:"transformers.FunnelTokenizer.create_token_type_ids_from_sequences.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"}],returnDescription:`
<p>List of <a href="../glossary#token-type-ids">token type IDs</a> according to the given sequence(s).</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),Zo=new ye({props:{code:`2 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1
| first sequence    | second sequence |`,highlighted:`2<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1 1
| first sequence    | second sequence |`}}),Xo=new X({props:{name:"save_vocabulary",anchor:"transformers.FunnelTokenizer.save_vocabulary",parameters:[{name:"save_directory",val:": str"},{name:"filename_prefix",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/bert/tokenization_bert.py#L330"}}),Jo=new je({}),es=new X({props:{name:"class transformers.FunnelTokenizerFast",anchor:"transformers.FunnelTokenizerFast",parameters:[{name:"vocab_file",val:" = None"},{name:"tokenizer_file",val:" = None"},{name:"do_lower_case",val:" = True"},{name:"unk_token",val:" = '<unk>'"},{name:"sep_token",val:" = '<sep>'"},{name:"pad_token",val:" = '<pad>'"},{name:"cls_token",val:" = '<cls>'"},{name:"mask_token",val:" = '<mask>'"},{name:"bos_token",val:" = '<s>'"},{name:"eos_token",val:" = '</s>'"},{name:"clean_text",val:" = True"},{name:"tokenize_chinese_chars",val:" = True"},{name:"strip_accents",val:" = None"},{name:"wordpieces_prefix",val:" = '##'"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/tokenization_funnel_fast.py#L71"}}),os=new X({props:{name:"create_token_type_ids_from_sequences",anchor:"transformers.FunnelTokenizerFast.create_token_type_ids_from_sequences",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/tokenization_funnel_fast.py#L124",parametersDescription:[{anchor:"transformers.FunnelTokenizerFast.create_token_type_ids_from_sequences.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs.`,name:"token_ids_0"},{anchor:"transformers.FunnelTokenizerFast.create_token_type_ids_from_sequences.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"}],returnDescription:`
<p>List of <a href="../glossary#token-type-ids">token type IDs</a> according to the given sequence(s).</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),ss=new ye({props:{code:`2 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1
| first sequence    | second sequence |`,highlighted:`2<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1 1
| first sequence    | second sequence |`}}),rs=new je({}),as=new X({props:{name:"class transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput",anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput",parameters:[{name:"loss",val:": typing.Optional[torch.FloatTensor] = None"},{name:"logits",val:": FloatTensor = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"attentions",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_funnel.py#L834",parametersDescription:[{anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput.loss",description:`<strong>loss</strong> (<em>optional</em>, returned when <code>labels</code> is provided, <code>torch.FloatTensor</code> of shape <code>(1,)</code>) &#x2014;
Total loss of the ELECTRA-style objective.`,name:"loss"},{anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput.logits",description:`<strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Prediction scores of the head (scores for each token before SoftMax).`,name:"logits"},{anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput.hidden_states",description:`<strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.`,name:"hidden_states"},{anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput.attentions",description:`<strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.`,name:"attentions"}]}}),ls=new X({props:{name:"class transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput",anchor:"transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput",parameters:[{name:"logits",val:": Tensor = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[tensorflow.python.framework.ops.Tensor]] = None"},{name:"attentions",val:": typing.Optional[typing.Tuple[tensorflow.python.framework.ops.Tensor]] = None"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_tf_funnel.py#L978",parametersDescription:[{anchor:"transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput.logits",description:`<strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Prediction scores of the head (scores for each token before SoftMax).`,name:"logits"},{anchor:"transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput.hidden_states",description:`<strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.`,name:"hidden_states"},{anchor:"transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput.attentions",description:`<strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) &#x2014;
Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.`,name:"attentions"}]}}),cs=new je({}),ps=new X({props:{name:"class transformers.FunnelBaseModel",anchor:"transformers.FunnelBaseModel",parameters:[{name:"config",val:": FunnelConfig"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_funnel.py#L927",parametersDescription:[{anchor:"transformers.FunnelBaseModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),_s=new X({props:{name:"forward",anchor:"transformers.FunnelBaseModel.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"position_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"head_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_funnel.py#L943",parametersDescription:[{anchor:"transformers.FunnelBaseModel.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/v4.18.0/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelBaseModel.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelBaseModel.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelBaseModel.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelBaseModel.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelBaseModel.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelBaseModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],returnDescription:`
<p>A <a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Kt=new qe({props:{$$slots:{default:[H0]},$$scope:{ctx:V}}}),vs=new ye({props:{code:`from transformers import FunnelTokenizer, FunnelBaseModel
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = FunnelBaseModel.from_pretrained("funnel-transformer/small-base")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
outputs = model(**inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelBaseModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelBaseModel.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),Ts=new je({}),ks=new X({props:{name:"class transformers.FunnelModel",anchor:"transformers.FunnelModel",parameters:[{name:"config",val:": FunnelConfig"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_funnel.py#L1004",parametersDescription:[{anchor:"transformers.FunnelModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Es=new X({props:{name:"forward",anchor:"transformers.FunnelModel.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_funnel.py#L1021",parametersDescription:[{anchor:"transformers.FunnelModel.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/v4.18.0/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelModel.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelModel.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelModel.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelModel.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelModel.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],returnDescription:`
<p>A <a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Zt=new qe({props:{$$slots:{default:[V0]},$$scope:{ctx:V}}}),Ms=new ye({props:{code:`from transformers import FunnelTokenizer, FunnelModel
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelModel.from_pretrained("funnel-transformer/small")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
outputs = model(**inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelModel.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),zs=new je({}),qs=new X({props:{name:"class transformers.FunnelForPreTraining",anchor:"transformers.FunnelForPreTraining",parameters:[{name:"config",val:": FunnelConfig"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_funnel.py#L1112"}}),Ps=new X({props:{name:"forward",anchor:"transformers.FunnelForPreTraining.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_funnel.py#L1121",parametersDescription:[{anchor:"transformers.FunnelForPreTraining.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/v4.18.0/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForPreTraining.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForPreTraining.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForPreTraining.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForPreTraining.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForPreTraining.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForPreTraining.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForPreTraining.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the ELECTRA-style loss. Input should be a sequence of tokens (see <code>input_ids</code>
docstring) Indices should be in <code>[0, 1]</code>:</p>
<ul>
<li>0 indicates the token is an original token,</li>
<li>1 indicates the token was replaced.</li>
</ul>`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput"
>transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<em>optional</em>, returned when <code>labels</code> is provided, <code>torch.FloatTensor</code> of shape <code>(1,)</code>) \u2014 Total loss of the ELECTRA-style objective.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Prediction scores of the head (scores for each token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput"
>transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Jt=new qe({props:{$$slots:{default:[Y0]},$$scope:{ctx:V}}}),js=new ye({props:{code:`from transformers import FunnelTokenizer, FunnelForPreTraining
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelForPreTraining.from_pretrained("funnel-transformer/small")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
logits = model(**inputs).logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForPreTraining
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForPreTraining.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(**inputs).logits`}}),Cs=new je({}),xs=new X({props:{name:"class transformers.FunnelForMaskedLM",anchor:"transformers.FunnelForMaskedLM",parameters:[{name:"config",val:": FunnelConfig"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_funnel.py#L1195",parametersDescription:[{anchor:"transformers.FunnelForMaskedLM.config",description:`<strong>config</strong> (<a href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Is=new X({props:{name:"forward",anchor:"transformers.FunnelForMaskedLM.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_funnel.py#L1211",parametersDescription:[{anchor:"transformers.FunnelForMaskedLM.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/v4.18.0/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForMaskedLM.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForMaskedLM.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForMaskedLM.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForMaskedLM.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForMaskedLM.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForMaskedLM.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForMaskedLM.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the masked language modeling loss. Indices should be in <code>[-100, 0, ..., config.vocab_size]</code> (see <code>input_ids</code> docstring) Tokens with indices set to <code>-100</code> are ignored (masked), the
loss is only computed for the tokens with labels in <code>[0, ..., config.vocab_size]</code>`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_outputs.MaskedLMOutput"
>transformers.modeling_outputs.MaskedLMOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Masked language modeling (MLM) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, config.vocab_size)</code>) \u2014 Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_outputs.MaskedLMOutput"
>transformers.modeling_outputs.MaskedLMOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),no=new qe({props:{$$slots:{default:[K0]},$$scope:{ctx:V}}}),Bs=new ye({props:{code:`from transformers import FunnelTokenizer, FunnelForMaskedLM
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelForMaskedLM.from_pretrained("funnel-transformer/small")

inputs = tokenizer("The capital of France is <mask>.", return_tensors="pt")

with torch.no_grad():
    logits = model(**inputs).logits

# retrieve index of <mask>
mask_token_index = (inputs.input_ids == tokenizer.mask_token_id)[0].nonzero(as_tuple=True)[0]

predicted_token_id = logits[0, mask_token_index].argmax(axis=-1)
tokenizer.decode(predicted_token_id)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForMaskedLM
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForMaskedLM.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;The capital of France is &lt;mask&gt;.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># retrieve index of &lt;mask&gt;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>mask_token_index = (inputs.input_ids == tokenizer.mask_token_id)[<span class="hljs-number">0</span>].nonzero(as_tuple=<span class="hljs-literal">True</span>)[<span class="hljs-number">0</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_token_id = logits[<span class="hljs-number">0</span>, mask_token_index].argmax(axis=-<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.decode(predicted_token_id)
`}}),Ws=new ye({props:{code:`labels = tokenizer("The capital of France is Paris.", return_tensors="pt")["input_ids"]
# mask labels of non-<mask> tokens
labels = torch.where(inputs.input_ids == tokenizer.mask_token_id, labels, -100)

outputs = model(**inputs, labels=labels)
round(outputs.loss.item(), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>labels = tokenizer(<span class="hljs-string">&quot;The capital of France is Paris.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)[<span class="hljs-string">&quot;input_ids&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># mask labels of non-&lt;mask&gt; tokens</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.where(inputs.input_ids == tokenizer.mask_token_id, labels, -<span class="hljs-number">100</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, labels=labels)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(outputs.loss.item(), <span class="hljs-number">2</span>)
`}}),Qs=new je({}),Us=new X({props:{name:"class transformers.FunnelForSequenceClassification",anchor:"transformers.FunnelForSequenceClassification",parameters:[{name:"config",val:": FunnelConfig"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_funnel.py#L1275",parametersDescription:[{anchor:"transformers.FunnelForSequenceClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Gs=new X({props:{name:"forward",anchor:"transformers.FunnelForSequenceClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_funnel.py#L1286",parametersDescription:[{anchor:"transformers.FunnelForSequenceClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/v4.18.0/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForSequenceClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForSequenceClassification.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForSequenceClassification.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForSequenceClassification.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForSequenceClassification.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForSequenceClassification.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForSequenceClassification.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the sequence classification/regression loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>. If <code>config.num_labels == 1</code> a regression loss is computed (Mean-Square loss), If
<code>config.num_labels &gt; 1</code> a classification loss is computed (Cross-Entropy).`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_outputs.SequenceClassifierOutput"
>transformers.modeling_outputs.SequenceClassifierOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification (or regression if config.num_labels==1) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.num_labels)</code>) \u2014 Classification (or regression if config.num_labels==1) scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_outputs.SequenceClassifierOutput"
>transformers.modeling_outputs.SequenceClassifierOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),oo=new qe({props:{$$slots:{default:[G0]},$$scope:{ctx:V}}}),Zs=new ye({props:{code:`import torch
from transformers import FunnelTokenizer, FunnelForSequenceClassification

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = FunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")

with torch.no_grad():
    logits = model(**inputs).logits

predicted_class_id = logits.argmax().item()
model.config.id2label[predicted_class_id]
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_class_id = logits.argmax().item()
<span class="hljs-meta">&gt;&gt;&gt; </span>model.config.id2label[predicted_class_id]
`}}),Xs=new ye({props:{code:`# To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`
num_labels = len(model.config.id2label)
model = FunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base", num_labels=num_labels)

labels = torch.tensor(1)
loss = model(**inputs, labels=labels).loss
round(loss.item(), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>num_labels = <span class="hljs-built_in">len</span>(model.config.id2label)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>, num_labels=num_labels)

<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.tensor(<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = model(**inputs, labels=labels).loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(loss.item(), <span class="hljs-number">2</span>)
`}}),Js=new ye({props:{code:`import torch
from transformers import FunnelTokenizer, FunnelForSequenceClassification

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = FunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base", problem_type="multi_label_classification")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")

with torch.no_grad():
    logits = model(**inputs).logits

predicted_class_id = logits.argmax().item()
model.config.id2label[predicted_class_id]
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>, problem_type=<span class="hljs-string">&quot;multi_label_classification&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_class_id = logits.argmax().item()
<span class="hljs-meta">&gt;&gt;&gt; </span>model.config.id2label[predicted_class_id]
`}}),er=new ye({props:{code:`# To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`
num_labels = len(model.config.id2label)
model = FunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base", num_labels=num_labels)

num_labels = len(model.config.id2label)
labels = torch.nn.functional.one_hot(torch.tensor([predicted_class_id]), num_classes=num_labels).to(
    torch.float
)
loss = model(**inputs, labels=labels).loss
loss.backward()`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>num_labels = <span class="hljs-built_in">len</span>(model.config.id2label)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>, num_labels=num_labels)

<span class="hljs-meta">&gt;&gt;&gt; </span>num_labels = <span class="hljs-built_in">len</span>(model.config.id2label)
<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.nn.functional.one_hot(torch.tensor([predicted_class_id]), num_classes=num_labels).to(
<span class="hljs-meta">... </span>    torch.<span class="hljs-built_in">float</span>
<span class="hljs-meta">... </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = model(**inputs, labels=labels).loss
<span class="hljs-meta">&gt;&gt;&gt; </span>loss.backward()`}}),nr=new je({}),tr=new X({props:{name:"class transformers.FunnelForMultipleChoice",anchor:"transformers.FunnelForMultipleChoice",parameters:[{name:"config",val:": FunnelConfig"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_funnel.py#L1368",parametersDescription:[{anchor:"transformers.FunnelForMultipleChoice.config",description:`<strong>config</strong> (<a href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),lr=new X({props:{name:"forward",anchor:"transformers.FunnelForMultipleChoice.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_funnel.py#L1377",parametersDescription:[{anchor:"transformers.FunnelForMultipleChoice.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/v4.18.0/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForMultipleChoice.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForMultipleChoice.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForMultipleChoice.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForMultipleChoice.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForMultipleChoice.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForMultipleChoice.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForMultipleChoice.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the multiple choice classification loss. Indices should be in <code>[0, ..., num_choices-1]</code> where <code>num_choices</code> is the size of the second dimension of the input tensors. (See
<code>input_ids</code> above)`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_outputs.MultipleChoiceModelOutput"
>transformers.modeling_outputs.MultipleChoiceModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <em>(1,)</em>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices)</code>) \u2014 <em>num_choices</em> is the second dimension of the input tensors. (see <em>input_ids</em> above).</p>
<p>Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_outputs.MultipleChoiceModelOutput"
>transformers.modeling_outputs.MultipleChoiceModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),ro=new qe({props:{$$slots:{default:[Z0]},$$scope:{ctx:V}}}),dr=new ye({props:{code:`from transformers import FunnelTokenizer, FunnelForMultipleChoice
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = FunnelForMultipleChoice.from_pretrained("funnel-transformer/small-base")

prompt = "In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced."
choice0 = "It is eaten with a fork and a knife."
choice1 = "It is eaten while held in the hand."
labels = torch.tensor(0).unsqueeze(0)  # choice0 is correct (according to Wikipedia ;)), batch size 1

encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors="pt", padding=True)
outputs = model(**{k: v.unsqueeze(0) for k, v in encoding.items()}, labels=labels)  # batch size is 1

# the linear classifier still needs to be trained
loss = outputs.loss
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForMultipleChoice
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForMultipleChoice.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>prompt = <span class="hljs-string">&quot;In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice0 = <span class="hljs-string">&quot;It is eaten with a fork and a knife.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice1 = <span class="hljs-string">&quot;It is eaten while held in the hand.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.tensor(<span class="hljs-number">0</span>).unsqueeze(<span class="hljs-number">0</span>)  <span class="hljs-comment"># choice0 is correct (according to Wikipedia ;)), batch size 1</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors=<span class="hljs-string">&quot;pt&quot;</span>, padding=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**{k: v.unsqueeze(<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> encoding.items()}, labels=labels)  <span class="hljs-comment"># batch size is 1</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># the linear classifier still needs to be trained</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = outputs.loss
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),cr=new je({}),pr=new X({props:{name:"class transformers.FunnelForTokenClassification",anchor:"transformers.FunnelForTokenClassification",parameters:[{name:"config",val:": FunnelConfig"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_funnel.py#L1452",parametersDescription:[{anchor:"transformers.FunnelForTokenClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),_r=new X({props:{name:"forward",anchor:"transformers.FunnelForTokenClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_funnel.py#L1464",parametersDescription:[{anchor:"transformers.FunnelForTokenClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/v4.18.0/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForTokenClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForTokenClassification.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForTokenClassification.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForTokenClassification.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForTokenClassification.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForTokenClassification.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForTokenClassification.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the token classification loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>.`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_outputs.TokenClassifierOutput"
>transformers.modeling_outputs.TokenClassifierOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided)  \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, config.num_labels)</code>) \u2014 Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_outputs.TokenClassifierOutput"
>transformers.modeling_outputs.TokenClassifierOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),io=new qe({props:{$$slots:{default:[X0]},$$scope:{ctx:V}}}),vr=new ye({props:{code:`from transformers import FunnelTokenizer, FunnelForTokenClassification
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelForTokenClassification.from_pretrained("funnel-transformer/small")

inputs = tokenizer(
    "HuggingFace is a company based in Paris and New York", add_special_tokens=False, return_tensors="pt"
)

with torch.no_grad():
    logits = model(**inputs).logits

predicted_token_class_ids = logits.argmax(-1)

# Note that tokens are classified rather then input words which means that
# there might be more predicted token classes than words.
# Multiple token classes might account for the same word
predicted_tokens_classes = [model.config.id2label[t.item()] for t in predicted_token_class_ids[0]]
predicted_tokens_classes
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForTokenClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;HuggingFace is a company based in Paris and New York&quot;</span>, add_special_tokens=<span class="hljs-literal">False</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>
<span class="hljs-meta">... </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_token_class_ids = logits.argmax(-<span class="hljs-number">1</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Note that tokens are classified rather then input words which means that</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># there might be more predicted token classes than words.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Multiple token classes might account for the same word</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_tokens_classes = [model.config.id2label[t.item()] <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> predicted_token_class_ids[<span class="hljs-number">0</span>]]
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_tokens_classes
`}}),Tr=new ye({props:{code:`labels = predicted_token_class_ids
loss = model(**inputs, labels=labels).loss
round(loss.item(), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>labels = predicted_token_class_ids
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = model(**inputs, labels=labels).loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(loss.item(), <span class="hljs-number">2</span>)
`}}),kr=new je({}),Fr=new X({props:{name:"class transformers.FunnelForQuestionAnswering",anchor:"transformers.FunnelForQuestionAnswering",parameters:[{name:"config",val:": FunnelConfig"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_funnel.py#L1526",parametersDescription:[{anchor:"transformers.FunnelForQuestionAnswering.config",description:`<strong>config</strong> (<a href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Mr=new X({props:{name:"forward",anchor:"transformers.FunnelForQuestionAnswering.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"start_positions",val:": typing.Optional[torch.Tensor] = None"},{name:"end_positions",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_funnel.py#L1537",parametersDescription:[{anchor:"transformers.FunnelForQuestionAnswering.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/v4.18.0/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForQuestionAnswering.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForQuestionAnswering.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForQuestionAnswering.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForQuestionAnswering.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForQuestionAnswering.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForQuestionAnswering.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForQuestionAnswering.forward.start_positions",description:`<strong>start_positions</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the start of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"start_positions"},{anchor:"transformers.FunnelForQuestionAnswering.forward.end_positions",description:`<strong>end_positions</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the end of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"end_positions"}],returnDescription:`
<p>A <a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_outputs.QuestionAnsweringModelOutput"
>transformers.modeling_outputs.QuestionAnsweringModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.</p>
</li>
<li>
<p><strong>start_logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-start scores (before SoftMax).</p>
</li>
<li>
<p><strong>end_logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-end scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_outputs.QuestionAnsweringModelOutput"
>transformers.modeling_outputs.QuestionAnsweringModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),co=new qe({props:{$$slots:{default:[J0]},$$scope:{ctx:V}}}),zr=new ye({props:{code:`from transformers import FunnelTokenizer, FunnelForQuestionAnswering
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelForQuestionAnswering.from_pretrained("funnel-transformer/small")

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"

inputs = tokenizer(question, text, return_tensors="pt")
with torch.no_grad():
    outputs = model(**inputs)

answer_start_index = outputs.start_logits.argmax()
answer_end_index = outputs.end_logits.argmax()

predict_answer_tokens = inputs.input_ids[0, answer_start_index : answer_end_index + 1]
tokenizer.decode(predict_answer_tokens)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForQuestionAnswering
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(question, text, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>answer_start_index = outputs.start_logits.argmax()
<span class="hljs-meta">&gt;&gt;&gt; </span>answer_end_index = outputs.end_logits.argmax()

<span class="hljs-meta">&gt;&gt;&gt; </span>predict_answer_tokens = inputs.input_ids[<span class="hljs-number">0</span>, answer_start_index : answer_end_index + <span class="hljs-number">1</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.decode(predict_answer_tokens)
`}}),qr=new ye({props:{code:`# target is "nice puppet"
target_start_index, target_end_index = torch.tensor([14]), torch.tensor([15])

outputs = model(**inputs, start_positions=target_start_index, end_positions=target_end_index)
loss = outputs.loss
round(loss.item(), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># target is &quot;nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>target_start_index, target_end_index = torch.tensor([<span class="hljs-number">14</span>]), torch.tensor([<span class="hljs-number">15</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, start_positions=target_start_index, end_positions=target_end_index)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = outputs.loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(loss.item(), <span class="hljs-number">2</span>)
`}}),Pr=new je({}),jr=new X({props:{name:"class transformers.TFFunnelBaseModel",anchor:"transformers.TFFunnelBaseModel",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_tf_funnel.py#L1095",parametersDescription:[{anchor:"transformers.TFFunnelBaseModel.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),uo=new qe({props:{$$slots:{default:[e$]},$$scope:{ctx:V}}}),Ar=new X({props:{name:"call",anchor:"transformers.TFFunnelBaseModel.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"training",val:": bool = False"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_tf_funnel.py#L1100",parametersDescription:[{anchor:"transformers.TFFunnelBaseModel.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelBaseModel.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelBaseModel.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelBaseModel.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelBaseModel.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelBaseModel.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelBaseModel.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelBaseModel.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"}],returnDescription:`
<p>A <a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_tf_outputs.TFBaseModelOutput"
>transformers.modeling_tf_outputs.TFBaseModelOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_tf_outputs.TFBaseModelOutput"
>transformers.modeling_tf_outputs.TFBaseModelOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),ho=new qe({props:{$$slots:{default:[n$]},$$scope:{ctx:V}}}),Nr=new ye({props:{code:`from transformers import FunnelTokenizer, TFFunnelBaseModel
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = TFFunnelBaseModel.from_pretrained("funnel-transformer/small-base")

inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")
outputs = model(inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelBaseModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelBaseModel.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),Sr=new je({}),Ir=new X({props:{name:"class transformers.TFFunnelModel",anchor:"transformers.TFFunnelModel",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_tf_funnel.py#L1142",parametersDescription:[{anchor:"transformers.TFFunnelModel.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),mo=new qe({props:{$$slots:{default:[t$]},$$scope:{ctx:V}}}),Hr=new X({props:{name:"call",anchor:"transformers.TFFunnelModel.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"training",val:": bool = False"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_tf_funnel.py#L1147",parametersDescription:[{anchor:"transformers.TFFunnelModel.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelModel.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelModel.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelModel.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelModel.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelModel.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelModel.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelModel.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"}],returnDescription:`
<p>A <a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_tf_outputs.TFBaseModelOutput"
>transformers.modeling_tf_outputs.TFBaseModelOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_tf_outputs.TFBaseModelOutput"
>transformers.modeling_tf_outputs.TFBaseModelOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),go=new qe({props:{$$slots:{default:[o$]},$$scope:{ctx:V}}}),Vr=new ye({props:{code:`from transformers import FunnelTokenizer, TFFunnelModel
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelModel.from_pretrained("funnel-transformer/small")

inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")
outputs = model(inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelModel.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),Yr=new je({}),Kr=new X({props:{name:"class transformers.TFFunnelForPreTraining",anchor:"transformers.TFFunnelForPreTraining",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_tf_funnel.py#L1192",parametersDescription:[{anchor:"transformers.TFFunnelForPreTraining.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),vo=new qe({props:{$$slots:{default:[s$]},$$scope:{ctx:V}}}),na=new X({props:{name:"call",anchor:"transformers.TFFunnelForPreTraining.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"training",val:": bool = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_tf_funnel.py#L1199",parametersDescription:[{anchor:"transformers.TFFunnelForPreTraining.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForPreTraining.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForPreTraining.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForPreTraining.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForPreTraining.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForPreTraining.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForPreTraining.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForPreTraining.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"}],returnDescription:`
<p>A <a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput"
>transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Prediction scores of the head (scores for each token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput"
>transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),To=new qe({props:{$$slots:{default:[r$]},$$scope:{ctx:V}}}),ta=new ye({props:{code:`from transformers import FunnelTokenizer, TFFunnelForPreTraining
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelForPreTraining.from_pretrained("funnel-transformer/small")

inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")
logits = model(inputs).logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForPreTraining
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForPreTraining.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(inputs).logits`}}),oa=new je({}),sa=new X({props:{name:"class transformers.TFFunnelForMaskedLM",anchor:"transformers.TFFunnelForMaskedLM",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_tf_funnel.py#L1259",parametersDescription:[{anchor:"transformers.TFFunnelForMaskedLM.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Fo=new qe({props:{$$slots:{default:[a$]},$$scope:{ctx:V}}}),pa=new X({props:{name:"call",anchor:"transformers.TFFunnelForMaskedLM.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"labels",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_tf_funnel.py#L1273",parametersDescription:[{anchor:"transformers.TFFunnelForMaskedLM.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForMaskedLM.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForMaskedLM.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForMaskedLM.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForMaskedLM.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForMaskedLM.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForMaskedLM.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForMaskedLM.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForMaskedLM.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the masked language modeling loss. Indices should be in <code>[-100, 0, ..., config.vocab_size]</code> (see <code>input_ids</code> docstring) Tokens with indices set to <code>-100</code> are ignored (masked), the
loss is only computed for the tokens with labels in <code>[0, ..., config.vocab_size]</code>`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_tf_outputs.TFMaskedLMOutput"
>transformers.modeling_tf_outputs.TFMaskedLMOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(n,)</code>, <em>optional</em>, where n is the number of non-masked labels, returned when <code>labels</code> is provided) \u2014 Masked language modeling (MLM) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, config.vocab_size)</code>) \u2014 Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_tf_outputs.TFMaskedLMOutput"
>transformers.modeling_tf_outputs.TFMaskedLMOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),yo=new qe({props:{$$slots:{default:[i$]},$$scope:{ctx:V}}}),ua=new ye({props:{code:`from transformers import FunnelTokenizer, TFFunnelForMaskedLM
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelForMaskedLM.from_pretrained("funnel-transformer/small")

inputs = tokenizer("The capital of France is [MASK].", return_tensors="tf")
logits = model(**inputs).logits

# retrieve index of [MASK]
mask_token_index = tf.where(inputs.input_ids == tokenizer.mask_token_id)[0][1]

predicted_token_id = tf.math.argmax(logits[0, mask_token_index], axis=-1)
tokenizer.decode(predicted_token_id)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForMaskedLM
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForMaskedLM.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;The capital of France is [MASK].&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># retrieve index of [MASK]</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>mask_token_index = tf.where(inputs.input_ids == tokenizer.mask_token_id)[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_token_id = tf.math.argmax(logits[<span class="hljs-number">0</span>, mask_token_index], axis=-<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.decode(predicted_token_id)
`}}),ha=new ye({props:{code:`labels = tokenizer("The capital of France is Paris.", return_tensors="tf")["input_ids"]
# mask labels of non-[MASK] tokens
labels = tf.where(inputs.input_ids == tokenizer.mask_token_id, labels, -100)

outputs = model(**inputs, labels=labels)
round(float(outputs.loss), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>labels = tokenizer(<span class="hljs-string">&quot;The capital of France is Paris.&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)[<span class="hljs-string">&quot;input_ids&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># mask labels of non-[MASK] tokens</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>labels = tf.where(inputs.input_ids == tokenizer.mask_token_id, labels, -<span class="hljs-number">100</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, labels=labels)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(<span class="hljs-built_in">float</span>(outputs.loss), <span class="hljs-number">2</span>)
`}}),fa=new je({}),ma=new X({props:{name:"class transformers.TFFunnelForSequenceClassification",anchor:"transformers.TFFunnelForSequenceClassification",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_tf_funnel.py#L1340",parametersDescription:[{anchor:"transformers.TFFunnelForSequenceClassification.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),bo=new qe({props:{$$slots:{default:[l$]},$$scope:{ctx:V}}}),Fa=new X({props:{name:"call",anchor:"transformers.TFFunnelForSequenceClassification.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"labels",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_tf_funnel.py#L1348",parametersDescription:[{anchor:"transformers.TFFunnelForSequenceClassification.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForSequenceClassification.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForSequenceClassification.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForSequenceClassification.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForSequenceClassification.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForSequenceClassification.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForSequenceClassification.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForSequenceClassification.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForSequenceClassification.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the sequence classification/regression loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>. If <code>config.num_labels == 1</code> a regression loss is computed (Mean-Square loss), If
<code>config.num_labels &gt; 1</code> a classification loss is computed (Cross-Entropy).`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_tf_outputs.TFSequenceClassifierOutput"
>transformers.modeling_tf_outputs.TFSequenceClassifierOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, )</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification (or regression if config.num_labels==1) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, config.num_labels)</code>) \u2014 Classification (or regression if config.num_labels==1) scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_tf_outputs.TFSequenceClassifierOutput"
>transformers.modeling_tf_outputs.TFSequenceClassifierOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),$o=new qe({props:{$$slots:{default:[d$]},$$scope:{ctx:V}}}),ya=new ye({props:{code:`from transformers import FunnelTokenizer, TFFunnelForSequenceClassification
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = TFFunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base")

inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")

logits = model(**inputs).logits

predicted_class_id = int(tf.math.argmax(logits, axis=-1)[0])
model.config.id2label[predicted_class_id]
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForSequenceClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_class_id = <span class="hljs-built_in">int</span>(tf.math.argmax(logits, axis=-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>model.config.id2label[predicted_class_id]
`}}),wa=new ye({props:{code:`# To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`
num_labels = len(model.config.id2label)
model = TFFunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base", num_labels=num_labels)

labels = tf.constant(1)
loss = model(**inputs, labels=labels).loss
round(float(loss), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>num_labels = <span class="hljs-built_in">len</span>(model.config.id2label)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>, num_labels=num_labels)

<span class="hljs-meta">&gt;&gt;&gt; </span>labels = tf.constant(<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = model(**inputs, labels=labels).loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(<span class="hljs-built_in">float</span>(loss), <span class="hljs-number">2</span>)
`}}),ba=new je({}),$a=new X({props:{name:"class transformers.TFFunnelForMultipleChoice",anchor:"transformers.TFFunnelForMultipleChoice",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_tf_funnel.py#L1416",parametersDescription:[{anchor:"transformers.TFFunnelForMultipleChoice.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Mo=new qe({props:{$$slots:{default:[c$]},$$scope:{ctx:V}}}),ja=new X({props:{name:"call",anchor:"transformers.TFFunnelForMultipleChoice.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"labels",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_tf_funnel.py#L1433",parametersDescription:[{anchor:"transformers.TFFunnelForMultipleChoice.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForMultipleChoice.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForMultipleChoice.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForMultipleChoice.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, num_choices, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForMultipleChoice.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForMultipleChoice.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForMultipleChoice.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForMultipleChoice.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForMultipleChoice.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the multiple choice classification loss. Indices should be in <code>[0, ..., num_choices]</code>
where <code>num_choices</code> is the size of the second dimension of the input tensors. (See <code>input_ids</code> above)`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput"
>transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <em>(batch_size, )</em>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, num_choices)</code>) \u2014 <em>num_choices</em> is the second dimension of the input tensors. (see <em>input_ids</em> above).</p>
<p>Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput"
>transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),zo=new qe({props:{$$slots:{default:[p$]},$$scope:{ctx:V}}}),Ca=new ye({props:{code:`from transformers import FunnelTokenizer, TFFunnelForMultipleChoice
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = TFFunnelForMultipleChoice.from_pretrained("funnel-transformer/small-base")

prompt = "In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced."
choice0 = "It is eaten with a fork and a knife."
choice1 = "It is eaten while held in the hand."

encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors="tf", padding=True)
inputs = {k: tf.expand_dims(v, 0) for k, v in encoding.items()}
outputs = model(inputs)  # batch size is 1

# the linear classifier still needs to be trained
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForMultipleChoice
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForMultipleChoice.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>prompt = <span class="hljs-string">&quot;In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice0 = <span class="hljs-string">&quot;It is eaten with a fork and a knife.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice1 = <span class="hljs-string">&quot;It is eaten while held in the hand.&quot;</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors=<span class="hljs-string">&quot;tf&quot;</span>, padding=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = {k: tf.expand_dims(v, <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> encoding.items()}
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(inputs)  <span class="hljs-comment"># batch size is 1</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># the linear classifier still needs to be trained</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),xa=new je({}),La=new X({props:{name:"class transformers.TFFunnelForTokenClassification",anchor:"transformers.TFFunnelForTokenClassification",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_tf_funnel.py#L1532",parametersDescription:[{anchor:"transformers.TFFunnelForTokenClassification.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Po=new qe({props:{$$slots:{default:[u$]},$$scope:{ctx:V}}}),Ia=new X({props:{name:"call",anchor:"transformers.TFFunnelForTokenClassification.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"labels",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_tf_funnel.py#L1543",parametersDescription:[{anchor:"transformers.TFFunnelForTokenClassification.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForTokenClassification.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForTokenClassification.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForTokenClassification.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForTokenClassification.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForTokenClassification.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForTokenClassification.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForTokenClassification.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForTokenClassification.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the token classification loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>.`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_tf_outputs.TFTokenClassifierOutput"
>transformers.modeling_tf_outputs.TFTokenClassifierOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(n,)</code>, <em>optional</em>, where n is the number of unmasked labels, returned when <code>labels</code> is provided)  \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, config.num_labels)</code>) \u2014 Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_tf_outputs.TFTokenClassifierOutput"
>transformers.modeling_tf_outputs.TFTokenClassifierOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),jo=new qe({props:{$$slots:{default:[h$]},$$scope:{ctx:V}}}),Ba=new ye({props:{code:`from transformers import FunnelTokenizer, TFFunnelForTokenClassification
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelForTokenClassification.from_pretrained("funnel-transformer/small")

inputs = tokenizer(
    "HuggingFace is a company based in Paris and New York", add_special_tokens=False, return_tensors="tf"
)

logits = model(**inputs).logits
predicted_token_class_ids = tf.math.argmax(logits, axis=-1)

# Note that tokens are classified rather then input words which means that
# there might be more predicted token classes than words.
# Multiple token classes might account for the same word
predicted_tokens_classes = [model.config.id2label[t] for t in predicted_token_class_ids[0].numpy().tolist()]
predicted_tokens_classes
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForTokenClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;HuggingFace is a company based in Paris and New York&quot;</span>, add_special_tokens=<span class="hljs-literal">False</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>
<span class="hljs-meta">... </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(**inputs).logits
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_token_class_ids = tf.math.argmax(logits, axis=-<span class="hljs-number">1</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Note that tokens are classified rather then input words which means that</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># there might be more predicted token classes than words.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Multiple token classes might account for the same word</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_tokens_classes = [model.config.id2label[t] <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> predicted_token_class_ids[<span class="hljs-number">0</span>].numpy().tolist()]
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_tokens_classes
`}}),Wa=new ye({props:{code:`labels = predicted_token_class_ids
loss = tf.math.reduce_mean(model(**inputs, labels=labels).loss)
round(float(loss), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>labels = predicted_token_class_ids
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = tf.math.reduce_mean(model(**inputs, labels=labels).loss)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(<span class="hljs-built_in">float</span>(loss), <span class="hljs-number">2</span>)
`}}),Qa=new je({}),Ua=new X({props:{name:"class transformers.TFFunnelForQuestionAnswering",anchor:"transformers.TFFunnelForQuestionAnswering",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_tf_funnel.py#L1610",parametersDescription:[{anchor:"transformers.TFFunnelForQuestionAnswering.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),xo=new qe({props:{$$slots:{default:[f$]},$$scope:{ctx:V}}}),Ga=new X({props:{name:"call",anchor:"transformers.TFFunnelForQuestionAnswering.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"start_positions",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"end_positions",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"}],source:"https://github.com/huggingface/transformers/blob/v4.18.0/src/transformers/models/funnel/modeling_tf_funnel.py#L1620",parametersDescription:[{anchor:"transformers.TFFunnelForQuestionAnswering.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/v4.18.0/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.start_positions",description:`<strong>start_positions</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the start of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"start_positions"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.end_positions",description:`<strong>end_positions</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the end of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"end_positions"}],returnDescription:`
<p>A <a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput"
>transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, )</code>, <em>optional</em>, returned when <code>start_positions</code> and <code>end_positions</code> are provided) \u2014 Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.</p>
</li>
<li>
<p><strong>start_logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-start scores (before SoftMax).</p>
</li>
<li>
<p><strong>end_logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-end scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.18.0/en/main_classes/output#transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput"
>transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),Lo=new qe({props:{$$slots:{default:[m$]},$$scope:{ctx:V}}}),Za=new ye({props:{code:`from transformers import FunnelTokenizer, TFFunnelForQuestionAnswering
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelForQuestionAnswering.from_pretrained("funnel-transformer/small")

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"

inputs = tokenizer(question, text, return_tensors="tf")
outputs = model(**inputs)

answer_start_index = int(tf.math.argmax(outputs.start_logits, axis=-1)[0])
answer_end_index = int(tf.math.argmax(outputs.end_logits, axis=-1)[0])

predict_answer_tokens = inputs.input_ids[0, answer_start_index : answer_end_index + 1]
tokenizer.decode(predict_answer_tokens)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForQuestionAnswering
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(question, text, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>answer_start_index = <span class="hljs-built_in">int</span>(tf.math.argmax(outputs.start_logits, axis=-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>answer_end_index = <span class="hljs-built_in">int</span>(tf.math.argmax(outputs.end_logits, axis=-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>predict_answer_tokens = inputs.input_ids[<span class="hljs-number">0</span>, answer_start_index : answer_end_index + <span class="hljs-number">1</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.decode(predict_answer_tokens)
`}}),Xa=new ye({props:{code:`# target is "nice puppet"
target_start_index, target_end_index = tf.constant([14]), tf.constant([15])

outputs = model(**inputs, start_positions=target_start_index, end_positions=target_end_index)
loss = tf.math.reduce_mean(outputs.loss)
round(float(loss), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># target is &quot;nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>target_start_index, target_end_index = tf.constant([<span class="hljs-number">14</span>]), tf.constant([<span class="hljs-number">15</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, start_positions=target_start_index, end_positions=target_end_index)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = tf.math.reduce_mean(outputs.loss)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(<span class="hljs-built_in">float</span>(loss), <span class="hljs-number">2</span>)
`}}),{c(){u=r("meta"),z=l(),g=r("h1"),_=r("a"),T=r("span"),k(v.$$.fragment),m=l(),M=r("span"),ce=t("Funnel Transformer"),K=l(),q=r("h2"),J=r("a"),A=r("span"),k(ne.$$.fragment),pe=l(),N=r("span"),ue=t("Overview"),ie=l(),Y=r("p"),L=t("The Funnel Transformer model was proposed in the paper "),te=r("a"),G=t(`Funnel-Transformer: Filtering out Sequential Redundancy for
Efficient Language Processing`),P=t(`. It is a bidirectional transformer model, like
BERT, but with a pooling operation after each block of layers, a bit like in traditional convolutional neural networks
(CNN) in computer vision.`),C=l(),oe=r("p"),W=t("The abstract from the paper is the following:"),le=l(),se=r("p"),S=r("em"),he=t(`With the success of language pretraining, it is highly desirable to develop more efficient architectures of good
scalability that can exploit the abundant unlabeled data at a lower cost. To improve the efficiency, we examine the
much-overlooked redundancy in maintaining a full-length token-level presentation, especially for tasks that only
require a single-vector presentation of the sequence. With this intuition, we propose Funnel-Transformer which
gradually compresses the sequence of hidden states to a shorter one and hence reduces the computation cost. More
importantly, by re-investing the saved FLOPs from length reduction in constructing a deeper or wider model, we further
improve the model capacity. In addition, to perform token-level predictions as required by common pretraining
objectives, Funnel-Transformer is able to recover a deep representation for each token from the reduced hidden sequence
via a decoder. Empirically, with comparable or fewer FLOPs, Funnel-Transformer outperforms the standard Transformer on
a wide variety of sequence-level prediction tasks, including text classification, language understanding, and reading
comprehension.`),de=l(),j=r("p"),fe=t("Tips:"),B=l(),ee=r("ul"),ae=r("li"),Q=t(`Since Funnel Transformer uses pooling, the sequence length of the hidden states changes after each block of layers.
The base model therefore has a final sequence length that is a quarter of the original one. This model can be used
directly for tasks that just require a sentence summary (like sequence classification or multiple choice). For other
tasks, the full model is used; this full model has a decoder that upsamples the final hidden states to the same
sequence length as the input.`),me=l(),I=r("li"),O=t(`The Funnel Transformer checkpoints are all available with a full version and a base version. The first ones should be
used for `),re=r("a"),U=t("FunnelModel"),ge=t(", "),p=r("a"),E=t("FunnelForPreTraining"),Z=t(`,
`),ve=r("a"),we=t("FunnelForMaskedLM"),D=t(", "),Te=r("a"),be=t("FunnelForTokenClassification"),$e=t(` and
class:`),x=r("em"),R=t("~transformers.FunnelForQuestionAnswering"),Ee=t(`. The second ones should be used for
`),ke=r("a"),H=t("FunnelBaseModel"),Me=t(", "),Fe=r("a"),_e=t("FunnelForSequenceClassification"),ze=t(` and
`),oi=r("a"),Yu=t("FunnelForMultipleChoice"),Ku=t("."),Oc=l(),In=r("p"),Gu=t("This model was contributed by "),No=r("a"),Zu=t("sgugger"),Xu=t(". The original code can be found "),So=r("a"),Ju=t("here"),eh=t("."),Dc=l(),Zn=r("h2"),Bt=r("a"),kl=r("span"),k(Io.$$.fragment),nh=l(),Fl=r("span"),th=t("FunnelConfig"),Ac=l(),Nn=r("div"),k(Bo.$$.fragment),oh=l(),Sn=r("p"),sh=t("This is the configuration class to store the configuration of a "),si=r("a"),rh=t("FunnelModel"),ah=t(" or a "),ri=r("a"),ih=t("TFBertModel"),lh=t(`. It is used to
instantiate a Funnel Transformer model according to the specified arguments, defining the model architecture.
Instantiating a configuration with the defaults will yield a similar configuration to that of the Funnel
Transformer `),Wo=r("a"),dh=t("funnel-transformer/small"),ch=t(" architecture."),ph=l(),Xn=r("p"),uh=t("Configuration objects inherit from "),ai=r("a"),hh=t("PretrainedConfig"),fh=t(` and can be used to control the model outputs. Read the
documentation from `),ii=r("a"),mh=t("PretrainedConfig"),gh=t(" for more information."),Nc=l(),Jn=r("h2"),Wt=r("a"),yl=r("span"),k(Qo.$$.fragment),_h=l(),wl=r("span"),vh=t("FunnelTokenizer"),Sc=l(),Ce=r("div"),k(Uo.$$.fragment),Th=l(),bl=r("p"),kh=t("Construct a Funnel Transformer tokenizer."),Fh=l(),Qt=r("p"),li=r("a"),yh=t("FunnelTokenizer"),wh=t(" is identical to "),di=r("a"),bh=t("BertTokenizer"),$h=t(` and runs end-to-end tokenization: punctuation splitting and
wordpiece.`),Eh=l(),Ro=r("p"),Mh=t("Refer to superclass "),ci=r("a"),zh=t("BertTokenizer"),qh=t(" for usage examples and documentation concerning parameters."),Ph=l(),Bn=r("div"),k(Ho.$$.fragment),jh=l(),$l=r("p"),Ch=t(`Build model inputs from a sequence or a pair of sequence for sequence classification tasks by concatenating and
adding special tokens. A BERT sequence has the following format:`),xh=l(),Vo=r("ul"),pi=r("li"),Lh=t("single sequence: "),El=r("code"),Oh=t("[CLS] X [SEP]"),Dh=l(),ui=r("li"),Ah=t("pair of sequences: "),Ml=r("code"),Nh=t("[CLS] A [SEP] B [SEP]"),Sh=l(),Ut=r("div"),k(Yo.$$.fragment),Ih=l(),Ko=r("p"),Bh=t(`Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding
special tokens using the tokenizer `),zl=r("code"),Wh=t("prepare_for_model"),Qh=t(" method."),Uh=l(),yn=r("div"),k(Go.$$.fragment),Rh=l(),ql=r("p"),Hh=t(`Create a mask from the two sequences passed to be used in a sequence-pair classification task. A Funnel
Transformer sequence pair mask has the following format:`),Vh=l(),k(Zo.$$.fragment),Yh=l(),et=r("p"),Kh=t("If "),Pl=r("code"),Gh=t("token_ids_1"),Zh=t(" is "),jl=r("code"),Xh=t("None"),Jh=t(", this method only returns the first portion of the mask (0s)."),ef=l(),hi=r("div"),k(Xo.$$.fragment),Ic=l(),nt=r("h2"),Rt=r("a"),Cl=r("span"),k(Jo.$$.fragment),nf=l(),xl=r("span"),tf=t("FunnelTokenizerFast"),Bc=l(),sn=r("div"),k(es.$$.fragment),of=l(),ns=r("p"),sf=t("Construct a \u201Cfast\u201D Funnel Transformer tokenizer (backed by HuggingFace\u2019s "),Ll=r("em"),rf=t("tokenizers"),af=t(" library)."),lf=l(),Ht=r("p"),fi=r("a"),df=t("FunnelTokenizerFast"),cf=t(" is identical to "),mi=r("a"),pf=t("BertTokenizerFast"),uf=t(` and runs end-to-end tokenization: punctuation
splitting and wordpiece.`),hf=l(),ts=r("p"),ff=t("Refer to superclass "),gi=r("a"),mf=t("BertTokenizerFast"),gf=t(" for usage examples and documentation concerning parameters."),_f=l(),wn=r("div"),k(os.$$.fragment),vf=l(),Ol=r("p"),Tf=t(`Create a mask from the two sequences passed to be used in a sequence-pair classification task. A Funnel
Transformer sequence pair mask has the following format:`),kf=l(),k(ss.$$.fragment),Ff=l(),tt=r("p"),yf=t("If "),Dl=r("code"),wf=t("token_ids_1"),bf=t(" is "),Al=r("code"),$f=t("None"),Ef=t(", this method only returns the first portion of the mask (0s)."),Wc=l(),ot=r("h2"),Vt=r("a"),Nl=r("span"),k(rs.$$.fragment),Mf=l(),Sl=r("span"),zf=t("Funnel specific outputs"),Qc=l(),st=r("div"),k(as.$$.fragment),qf=l(),is=r("p"),Pf=t("Output type of "),_i=r("a"),jf=t("FunnelForPreTraining"),Cf=t("."),Uc=l(),rt=r("div"),k(ls.$$.fragment),xf=l(),ds=r("p"),Lf=t("Output type of "),vi=r("a"),Of=t("FunnelForPreTraining"),Df=t("."),Rc=l(),at=r("h2"),Yt=r("a"),Il=r("span"),k(cs.$$.fragment),Af=l(),Bl=r("span"),Nf=t("FunnelBaseModel"),Hc=l(),Qe=r("div"),k(ps.$$.fragment),Sf=l(),Wl=r("p"),If=t(`The base Funnel Transformer Model transformer outputting raw hidden-states without upsampling head (also called
decoder) or any task-specific head on top.`),Bf=l(),us=r("p"),Wf=t("The Funnel Transformer model was proposed in "),hs=r("a"),Qf=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Uf=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Rf=l(),fs=r("p"),Hf=t("This model inherits from "),Ti=r("a"),Vf=t("PreTrainedModel"),Yf=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Kf=l(),ms=r("p"),Gf=t("This model is also a PyTorch "),gs=r("a"),Zf=t("torch.nn.Module"),Xf=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Jf=l(),rn=r("div"),k(_s.$$.fragment),em=l(),it=r("p"),nm=t("The "),ki=r("a"),tm=t("FunnelBaseModel"),om=t(" forward method, overrides the "),Ql=r("code"),sm=t("__call__"),rm=t(" special method."),am=l(),k(Kt.$$.fragment),im=l(),Ul=r("p"),lm=t("Example:"),dm=l(),k(vs.$$.fragment),Vc=l(),lt=r("h2"),Gt=r("a"),Rl=r("span"),k(Ts.$$.fragment),cm=l(),Hl=r("span"),pm=t("FunnelModel"),Yc=l(),Ue=r("div"),k(ks.$$.fragment),um=l(),Vl=r("p"),hm=t("The bare Funnel Transformer Model transformer outputting raw hidden-states without any specific head on top."),fm=l(),Fs=r("p"),mm=t("The Funnel Transformer model was proposed in "),ys=r("a"),gm=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),_m=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),vm=l(),ws=r("p"),Tm=t("This model inherits from "),Fi=r("a"),km=t("PreTrainedModel"),Fm=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),ym=l(),bs=r("p"),wm=t("This model is also a PyTorch "),$s=r("a"),bm=t("torch.nn.Module"),$m=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Em=l(),an=r("div"),k(Es.$$.fragment),Mm=l(),dt=r("p"),zm=t("The "),yi=r("a"),qm=t("FunnelModel"),Pm=t(" forward method, overrides the "),Yl=r("code"),jm=t("__call__"),Cm=t(" special method."),xm=l(),k(Zt.$$.fragment),Lm=l(),Kl=r("p"),Om=t("Example:"),Dm=l(),k(Ms.$$.fragment),Kc=l(),ct=r("h2"),Xt=r("a"),Gl=r("span"),k(zs.$$.fragment),Am=l(),Zl=r("span"),Nm=t("FunnelModelForPreTraining"),Gc=l(),pt=r("div"),k(qs.$$.fragment),Sm=l(),ln=r("div"),k(Ps.$$.fragment),Im=l(),ut=r("p"),Bm=t("The "),wi=r("a"),Wm=t("FunnelForPreTraining"),Qm=t(" forward method, overrides the "),Xl=r("code"),Um=t("__call__"),Rm=t(" special method."),Hm=l(),k(Jt.$$.fragment),Vm=l(),Jl=r("p"),Ym=t("Examples:"),Km=l(),k(js.$$.fragment),Zc=l(),ht=r("h2"),eo=r("a"),ed=r("span"),k(Cs.$$.fragment),Gm=l(),nd=r("span"),Zm=t("FunnelForMaskedLM"),Xc=l(),Re=r("div"),k(xs.$$.fragment),Xm=l(),Ls=r("p"),Jm=t("Funnel Transformer Model with a "),td=r("code"),eg=t("language modeling"),ng=t(" head on top."),tg=l(),Os=r("p"),og=t("The Funnel Transformer model was proposed in "),Ds=r("a"),sg=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),rg=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),ag=l(),As=r("p"),ig=t("This model inherits from "),bi=r("a"),lg=t("PreTrainedModel"),dg=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),cg=l(),Ns=r("p"),pg=t("This model is also a PyTorch "),Ss=r("a"),ug=t("torch.nn.Module"),hg=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),fg=l(),Ge=r("div"),k(Is.$$.fragment),mg=l(),ft=r("p"),gg=t("The "),$i=r("a"),_g=t("FunnelForMaskedLM"),vg=t(" forward method, overrides the "),od=r("code"),Tg=t("__call__"),kg=t(" special method."),Fg=l(),k(no.$$.fragment),yg=l(),sd=r("p"),wg=t("Example:"),bg=l(),k(Bs.$$.fragment),$g=l(),k(Ws.$$.fragment),Jc=l(),mt=r("h2"),to=r("a"),rd=r("span"),k(Qs.$$.fragment),Eg=l(),ad=r("span"),Mg=t("FunnelForSequenceClassification"),ep=l(),He=r("div"),k(Us.$$.fragment),zg=l(),id=r("p"),qg=t(`Funnel Transformer Model with a sequence classification/regression head on top (two linear layer on top of the
first timestep of the last hidden state) e.g. for GLUE tasks.`),Pg=l(),Rs=r("p"),jg=t("The Funnel Transformer model was proposed in "),Hs=r("a"),Cg=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),xg=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Lg=l(),Vs=r("p"),Og=t("This model inherits from "),Ei=r("a"),Dg=t("PreTrainedModel"),Ag=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Ng=l(),Ys=r("p"),Sg=t("This model is also a PyTorch "),Ks=r("a"),Ig=t("torch.nn.Module"),Bg=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Wg=l(),Pe=r("div"),k(Gs.$$.fragment),Qg=l(),gt=r("p"),Ug=t("The "),Mi=r("a"),Rg=t("FunnelForSequenceClassification"),Hg=t(" forward method, overrides the "),ld=r("code"),Vg=t("__call__"),Yg=t(" special method."),Kg=l(),k(oo.$$.fragment),Gg=l(),dd=r("p"),Zg=t("Example of single-label classification:"),Xg=l(),k(Zs.$$.fragment),Jg=l(),k(Xs.$$.fragment),e_=l(),cd=r("p"),n_=t("Example of multi-label classification:"),t_=l(),k(Js.$$.fragment),o_=l(),k(er.$$.fragment),np=l(),_t=r("h2"),so=r("a"),pd=r("span"),k(nr.$$.fragment),s_=l(),ud=r("span"),r_=t("FunnelForMultipleChoice"),tp=l(),Ve=r("div"),k(tr.$$.fragment),a_=l(),hd=r("p"),i_=t(`Funnel Transformer Model with a multiple choice classification head on top (two linear layer on top of the first
timestep of the last hidden state, and a softmax) e.g. for RocStories/SWAG tasks.`),l_=l(),or=r("p"),d_=t("The Funnel Transformer model was proposed in "),sr=r("a"),c_=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),p_=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),u_=l(),rr=r("p"),h_=t("This model inherits from "),zi=r("a"),f_=t("PreTrainedModel"),m_=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),g_=l(),ar=r("p"),__=t("This model is also a PyTorch "),ir=r("a"),v_=t("torch.nn.Module"),T_=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),k_=l(),dn=r("div"),k(lr.$$.fragment),F_=l(),vt=r("p"),y_=t("The "),qi=r("a"),w_=t("FunnelForMultipleChoice"),b_=t(" forward method, overrides the "),fd=r("code"),$_=t("__call__"),E_=t(" special method."),M_=l(),k(ro.$$.fragment),z_=l(),md=r("p"),q_=t("Example:"),P_=l(),k(dr.$$.fragment),op=l(),Tt=r("h2"),ao=r("a"),gd=r("span"),k(cr.$$.fragment),j_=l(),_d=r("span"),C_=t("FunnelForTokenClassification"),sp=l(),Ye=r("div"),k(pr.$$.fragment),x_=l(),vd=r("p"),L_=t(`Funnel Transformer Model with a token classification head on top (a linear layer on top of the hidden-states
output) e.g. for Named-Entity-Recognition (NER) tasks.`),O_=l(),ur=r("p"),D_=t("The Funnel Transformer model was proposed in "),hr=r("a"),A_=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),N_=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),S_=l(),fr=r("p"),I_=t("This model inherits from "),Pi=r("a"),B_=t("PreTrainedModel"),W_=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Q_=l(),mr=r("p"),U_=t("This model is also a PyTorch "),gr=r("a"),R_=t("torch.nn.Module"),H_=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),V_=l(),Ze=r("div"),k(_r.$$.fragment),Y_=l(),kt=r("p"),K_=t("The "),ji=r("a"),G_=t("FunnelForTokenClassification"),Z_=t(" forward method, overrides the "),Td=r("code"),X_=t("__call__"),J_=t(" special method."),ev=l(),k(io.$$.fragment),nv=l(),kd=r("p"),tv=t("Example:"),ov=l(),k(vr.$$.fragment),sv=l(),k(Tr.$$.fragment),rp=l(),Ft=r("h2"),lo=r("a"),Fd=r("span"),k(kr.$$.fragment),rv=l(),yd=r("span"),av=t("FunnelForQuestionAnswering"),ap=l(),Ke=r("div"),k(Fr.$$.fragment),iv=l(),yt=r("p"),lv=t(`Funnel Transformer Model with a span classification head on top for extractive question-answering tasks like SQuAD
(a linear layer on top of the hidden-states output to compute `),wd=r("code"),dv=t("span start logits"),cv=t(" and "),bd=r("code"),pv=t("span end logits"),uv=t(")."),hv=l(),yr=r("p"),fv=t("The Funnel Transformer model was proposed in "),wr=r("a"),mv=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),gv=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),_v=l(),br=r("p"),vv=t("This model inherits from "),Ci=r("a"),Tv=t("PreTrainedModel"),kv=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Fv=l(),$r=r("p"),yv=t("This model is also a PyTorch "),Er=r("a"),wv=t("torch.nn.Module"),bv=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),$v=l(),Xe=r("div"),k(Mr.$$.fragment),Ev=l(),wt=r("p"),Mv=t("The "),xi=r("a"),zv=t("FunnelForQuestionAnswering"),qv=t(" forward method, overrides the "),$d=r("code"),Pv=t("__call__"),jv=t(" special method."),Cv=l(),k(co.$$.fragment),xv=l(),Ed=r("p"),Lv=t("Example:"),Ov=l(),k(zr.$$.fragment),Dv=l(),k(qr.$$.fragment),ip=l(),bt=r("h2"),po=r("a"),Md=r("span"),k(Pr.$$.fragment),Av=l(),zd=r("span"),Nv=t("TFFunnelBaseModel"),lp=l(),Le=r("div"),k(jr.$$.fragment),Sv=l(),qd=r("p"),Iv=t(`The base Funnel Transformer Model transformer outputting raw hidden-states without upsampling head (also called
decoder) or any task-specific head on top.`),Bv=l(),Cr=r("p"),Wv=t("The Funnel Transformer model was proposed in "),xr=r("a"),Qv=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Uv=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Rv=l(),Lr=r("p"),Hv=t("This model inherits from "),Li=r("a"),Vv=t("TFPreTrainedModel"),Yv=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Kv=l(),Or=r("p"),Gv=t("This model is also a "),Dr=r("a"),Zv=t("tf.keras.Model"),Xv=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Jv=l(),k(uo.$$.fragment),eT=l(),cn=r("div"),k(Ar.$$.fragment),nT=l(),$t=r("p"),tT=t("The "),Oi=r("a"),oT=t("TFFunnelBaseModel"),sT=t(" forward method, overrides the "),Pd=r("code"),rT=t("__call__"),aT=t(" special method."),iT=l(),k(ho.$$.fragment),lT=l(),jd=r("p"),dT=t("Example:"),cT=l(),k(Nr.$$.fragment),dp=l(),Et=r("h2"),fo=r("a"),Cd=r("span"),k(Sr.$$.fragment),pT=l(),xd=r("span"),uT=t("TFFunnelModel"),cp=l(),Oe=r("div"),k(Ir.$$.fragment),hT=l(),Ld=r("p"),fT=t("The bare Funnel Transformer Model transformer outputting raw hidden-states without any specific head on top."),mT=l(),Br=r("p"),gT=t("The Funnel Transformer model was proposed in "),Wr=r("a"),_T=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),vT=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),TT=l(),Qr=r("p"),kT=t("This model inherits from "),Di=r("a"),FT=t("TFPreTrainedModel"),yT=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),wT=l(),Ur=r("p"),bT=t("This model is also a "),Rr=r("a"),$T=t("tf.keras.Model"),ET=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),MT=l(),k(mo.$$.fragment),zT=l(),pn=r("div"),k(Hr.$$.fragment),qT=l(),Mt=r("p"),PT=t("The "),Ai=r("a"),jT=t("TFFunnelModel"),CT=t(" forward method, overrides the "),Od=r("code"),xT=t("__call__"),LT=t(" special method."),OT=l(),k(go.$$.fragment),DT=l(),Dd=r("p"),AT=t("Example:"),NT=l(),k(Vr.$$.fragment),pp=l(),zt=r("h2"),_o=r("a"),Ad=r("span"),k(Yr.$$.fragment),ST=l(),Nd=r("span"),IT=t("TFFunnelModelForPreTraining"),up=l(),De=r("div"),k(Kr.$$.fragment),BT=l(),Sd=r("p"),WT=t("Funnel model with a binary classification head on top as used during pretraining for identifying generated tokens."),QT=l(),Gr=r("p"),UT=t("The Funnel Transformer model was proposed in "),Zr=r("a"),RT=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),HT=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),VT=l(),Xr=r("p"),YT=t("This model inherits from "),Ni=r("a"),KT=t("TFPreTrainedModel"),GT=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),ZT=l(),Jr=r("p"),XT=t("This model is also a "),ea=r("a"),JT=t("tf.keras.Model"),ek=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),nk=l(),k(vo.$$.fragment),tk=l(),un=r("div"),k(na.$$.fragment),ok=l(),qt=r("p"),sk=t("The "),Si=r("a"),rk=t("TFFunnelForPreTraining"),ak=t(" forward method, overrides the "),Id=r("code"),ik=t("__call__"),lk=t(" special method."),dk=l(),k(To.$$.fragment),ck=l(),Bd=r("p"),pk=t("Examples:"),uk=l(),k(ta.$$.fragment),hp=l(),Pt=r("h2"),ko=r("a"),Wd=r("span"),k(oa.$$.fragment),hk=l(),Qd=r("span"),fk=t("TFFunnelForMaskedLM"),fp=l(),Ae=r("div"),k(sa.$$.fragment),mk=l(),ra=r("p"),gk=t("Funnel Model with a "),Ud=r("code"),_k=t("language modeling"),vk=t(" head on top."),Tk=l(),aa=r("p"),kk=t("The Funnel Transformer model was proposed in "),ia=r("a"),Fk=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),yk=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),wk=l(),la=r("p"),bk=t("This model inherits from "),Ii=r("a"),$k=t("TFPreTrainedModel"),Ek=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Mk=l(),da=r("p"),zk=t("This model is also a "),ca=r("a"),qk=t("tf.keras.Model"),Pk=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),jk=l(),k(Fo.$$.fragment),Ck=l(),Je=r("div"),k(pa.$$.fragment),xk=l(),jt=r("p"),Lk=t("The "),Bi=r("a"),Ok=t("TFFunnelForMaskedLM"),Dk=t(" forward method, overrides the "),Rd=r("code"),Ak=t("__call__"),Nk=t(" special method."),Sk=l(),k(yo.$$.fragment),Ik=l(),Hd=r("p"),Bk=t("Example:"),Wk=l(),k(ua.$$.fragment),Qk=l(),k(ha.$$.fragment),mp=l(),Ct=r("h2"),wo=r("a"),Vd=r("span"),k(fa.$$.fragment),Uk=l(),Yd=r("span"),Rk=t("TFFunnelForSequenceClassification"),gp=l(),Ne=r("div"),k(ma.$$.fragment),Hk=l(),Kd=r("p"),Vk=t(`Funnel Model transformer with a sequence classification/regression head on top (a linear layer on top of the pooled
output) e.g. for GLUE tasks.`),Yk=l(),ga=r("p"),Kk=t("The Funnel Transformer model was proposed in "),_a=r("a"),Gk=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Zk=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Xk=l(),va=r("p"),Jk=t("This model inherits from "),Wi=r("a"),eF=t("TFPreTrainedModel"),nF=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),tF=l(),Ta=r("p"),oF=t("This model is also a "),ka=r("a"),sF=t("tf.keras.Model"),rF=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),aF=l(),k(bo.$$.fragment),iF=l(),en=r("div"),k(Fa.$$.fragment),lF=l(),xt=r("p"),dF=t("The "),Qi=r("a"),cF=t("TFFunnelForSequenceClassification"),pF=t(" forward method, overrides the "),Gd=r("code"),uF=t("__call__"),hF=t(" special method."),fF=l(),k($o.$$.fragment),mF=l(),Zd=r("p"),gF=t("Example:"),_F=l(),k(ya.$$.fragment),vF=l(),k(wa.$$.fragment),_p=l(),Lt=r("h2"),Eo=r("a"),Xd=r("span"),k(ba.$$.fragment),TF=l(),Jd=r("span"),kF=t("TFFunnelForMultipleChoice"),vp=l(),Se=r("div"),k($a.$$.fragment),FF=l(),ec=r("p"),yF=t(`Funnel Model with a multiple choice classification head on top (a linear layer on top of the pooled output and a
softmax) e.g. for RocStories/SWAG tasks.`),wF=l(),Ea=r("p"),bF=t("The Funnel Transformer model was proposed in "),Ma=r("a"),$F=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),EF=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),MF=l(),za=r("p"),zF=t("This model inherits from "),Ui=r("a"),qF=t("TFPreTrainedModel"),PF=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),jF=l(),qa=r("p"),CF=t("This model is also a "),Pa=r("a"),xF=t("tf.keras.Model"),LF=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),OF=l(),k(Mo.$$.fragment),DF=l(),hn=r("div"),k(ja.$$.fragment),AF=l(),Ot=r("p"),NF=t("The "),Ri=r("a"),SF=t("TFFunnelForMultipleChoice"),IF=t(" forward method, overrides the "),nc=r("code"),BF=t("__call__"),WF=t(" special method."),QF=l(),k(zo.$$.fragment),UF=l(),tc=r("p"),RF=t("Example:"),HF=l(),k(Ca.$$.fragment),Tp=l(),Dt=r("h2"),qo=r("a"),oc=r("span"),k(xa.$$.fragment),VF=l(),sc=r("span"),YF=t("TFFunnelForTokenClassification"),kp=l(),Ie=r("div"),k(La.$$.fragment),KF=l(),rc=r("p"),GF=t(`Funnel Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g. for
Named-Entity-Recognition (NER) tasks.`),ZF=l(),Oa=r("p"),XF=t("The Funnel Transformer model was proposed in "),Da=r("a"),JF=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),ey=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),ny=l(),Aa=r("p"),ty=t("This model inherits from "),Hi=r("a"),oy=t("TFPreTrainedModel"),sy=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),ry=l(),Na=r("p"),ay=t("This model is also a "),Sa=r("a"),iy=t("tf.keras.Model"),ly=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),dy=l(),k(Po.$$.fragment),cy=l(),nn=r("div"),k(Ia.$$.fragment),py=l(),At=r("p"),uy=t("The "),Vi=r("a"),hy=t("TFFunnelForTokenClassification"),fy=t(" forward method, overrides the "),ac=r("code"),my=t("__call__"),gy=t(" special method."),_y=l(),k(jo.$$.fragment),vy=l(),ic=r("p"),Ty=t("Example:"),ky=l(),k(Ba.$$.fragment),Fy=l(),k(Wa.$$.fragment),Fp=l(),Nt=r("h2"),Co=r("a"),lc=r("span"),k(Qa.$$.fragment),yy=l(),dc=r("span"),wy=t("TFFunnelForQuestionAnswering"),yp=l(),Be=r("div"),k(Ua.$$.fragment),by=l(),St=r("p"),$y=t(`Funnel Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear
layers on top of the hidden-states output to compute `),cc=r("code"),Ey=t("span start logits"),My=t(" and "),pc=r("code"),zy=t("span end logits"),qy=t(")."),Py=l(),Ra=r("p"),jy=t("The Funnel Transformer model was proposed in "),Ha=r("a"),Cy=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),xy=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Ly=l(),Va=r("p"),Oy=t("This model inherits from "),Yi=r("a"),Dy=t("TFPreTrainedModel"),Ay=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Ny=l(),Ya=r("p"),Sy=t("This model is also a "),Ka=r("a"),Iy=t("tf.keras.Model"),By=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Wy=l(),k(xo.$$.fragment),Qy=l(),tn=r("div"),k(Ga.$$.fragment),Uy=l(),It=r("p"),Ry=t("The "),Ki=r("a"),Hy=t("TFFunnelForQuestionAnswering"),Vy=t(" forward method, overrides the "),uc=r("code"),Yy=t("__call__"),Ky=t(" special method."),Gy=l(),k(Lo.$$.fragment),Zy=l(),hc=r("p"),Xy=t("Example:"),Jy=l(),k(Za.$$.fragment),e1=l(),k(Xa.$$.fragment),this.h()},l(s){const f=U0('[data-svelte="svelte-1phssyn"]',document.head);u=a(f,"META",{name:!0,content:!0}),f.forEach(n),z=d(s),g=a(s,"H1",{class:!0});var Ja=i(g);_=a(Ja,"A",{id:!0,class:!0,href:!0});var fc=i(_);T=a(fc,"SPAN",{});var mc=i(T);F(v.$$.fragment,mc),mc.forEach(n),fc.forEach(n),m=d(Ja),M=a(Ja,"SPAN",{});var gc=i(M);ce=o(gc,"Funnel Transformer"),gc.forEach(n),Ja.forEach(n),K=d(s),q=a(s,"H2",{class:!0});var ei=i(q);J=a(ei,"A",{id:!0,class:!0,href:!0});var _c=i(J);A=a(_c,"SPAN",{});var vc=i(A);F(ne.$$.fragment,vc),vc.forEach(n),_c.forEach(n),pe=d(ei),N=a(ei,"SPAN",{});var Tc=i(N);ue=o(Tc,"Overview"),Tc.forEach(n),ei.forEach(n),ie=d(s),Y=a(s,"P",{});var ni=i(Y);L=o(ni,"The Funnel Transformer model was proposed in the paper "),te=a(ni,"A",{href:!0,rel:!0});var kc=i(te);G=o(kc,`Funnel-Transformer: Filtering out Sequential Redundancy for
Efficient Language Processing`),kc.forEach(n),P=o(ni,`. It is a bidirectional transformer model, like
BERT, but with a pooling operation after each block of layers, a bit like in traditional convolutional neural networks
(CNN) in computer vision.`),ni.forEach(n),C=d(s),oe=a(s,"P",{});var Fc=i(oe);W=o(Fc,"The abstract from the paper is the following:"),Fc.forEach(n),le=d(s),se=a(s,"P",{});var yc=i(se);S=a(yc,"EM",{});var wc=i(S);he=o(wc,`With the success of language pretraining, it is highly desirable to develop more efficient architectures of good
scalability that can exploit the abundant unlabeled data at a lower cost. To improve the efficiency, we examine the
much-overlooked redundancy in maintaining a full-length token-level presentation, especially for tasks that only
require a single-vector presentation of the sequence. With this intuition, we propose Funnel-Transformer which
gradually compresses the sequence of hidden states to a shorter one and hence reduces the computation cost. More
importantly, by re-investing the saved FLOPs from length reduction in constructing a deeper or wider model, we further
improve the model capacity. In addition, to perform token-level predictions as required by common pretraining
objectives, Funnel-Transformer is able to recover a deep representation for each token from the reduced hidden sequence
via a decoder. Empirically, with comparable or fewer FLOPs, Funnel-Transformer outperforms the standard Transformer on
a wide variety of sequence-level prediction tasks, including text classification, language understanding, and reading
comprehension.`),wc.forEach(n),yc.forEach(n),de=d(s),j=a(s,"P",{});var bc=i(j);fe=o(bc,"Tips:"),bc.forEach(n),B=d(s),ee=a(s,"UL",{});var ti=i(ee);ae=a(ti,"LI",{});var $c=i(ae);Q=o($c,`Since Funnel Transformer uses pooling, the sequence length of the hidden states changes after each block of layers.
The base model therefore has a final sequence length that is a quarter of the original one. This model can be used
directly for tasks that just require a sentence summary (like sequence classification or multiple choice). For other
tasks, the full model is used; this full model has a decoder that upsamples the final hidden states to the same
sequence length as the input.`),$c.forEach(n),me=d(ti),I=a(ti,"LI",{});var xe=i(I);O=o(xe,`The Funnel Transformer checkpoints are all available with a full version and a base version. The first ones should be
used for `),re=a(xe,"A",{href:!0});var Ec=i(re);U=o(Ec,"FunnelModel"),Ec.forEach(n),ge=o(xe,", "),p=a(xe,"A",{href:!0});var Mc=i(p);E=o(Mc,"FunnelForPreTraining"),Mc.forEach(n),Z=o(xe,`,
`),ve=a(xe,"A",{href:!0});var zc=i(ve);we=o(zc,"FunnelForMaskedLM"),zc.forEach(n),D=o(xe,", "),Te=a(xe,"A",{href:!0});var qc=i(Te);be=o(qc,"FunnelForTokenClassification"),qc.forEach(n),$e=o(xe,` and
class:`),x=a(xe,"EM",{});var Pc=i(x);R=o(Pc,"~transformers.FunnelForQuestionAnswering"),Pc.forEach(n),Ee=o(xe,`. The second ones should be used for
`),ke=a(xe,"A",{href:!0});var jc=i(ke);H=o(jc,"FunnelBaseModel"),jc.forEach(n),Me=o(xe,", "),Fe=a(xe,"A",{href:!0});var Cc=i(Fe);_e=o(Cc,"FunnelForSequenceClassification"),Cc.forEach(n),ze=o(xe,` and
`),oi=a(xe,"A",{href:!0});var o1=i(oi);Yu=o(o1,"FunnelForMultipleChoice"),o1.forEach(n),Ku=o(xe,"."),xe.forEach(n),ti.forEach(n),Oc=d(s),In=a(s,"P",{});var Gi=i(In);Gu=o(Gi,"This model was contributed by "),No=a(Gi,"A",{href:!0,rel:!0});var s1=i(No);Zu=o(s1,"sgugger"),s1.forEach(n),Xu=o(Gi,". The original code can be found "),So=a(Gi,"A",{href:!0,rel:!0});var r1=i(So);Ju=o(r1,"here"),r1.forEach(n),eh=o(Gi,"."),Gi.forEach(n),Dc=d(s),Zn=a(s,"H2",{class:!0});var bp=i(Zn);Bt=a(bp,"A",{id:!0,class:!0,href:!0});var a1=i(Bt);kl=a(a1,"SPAN",{});var i1=i(kl);F(Io.$$.fragment,i1),i1.forEach(n),a1.forEach(n),nh=d(bp),Fl=a(bp,"SPAN",{});var l1=i(Fl);th=o(l1,"FunnelConfig"),l1.forEach(n),bp.forEach(n),Ac=d(s),Nn=a(s,"DIV",{class:!0});var Zi=i(Nn);F(Bo.$$.fragment,Zi),oh=d(Zi),Sn=a(Zi,"P",{});var Oo=i(Sn);sh=o(Oo,"This is the configuration class to store the configuration of a "),si=a(Oo,"A",{href:!0});var d1=i(si);rh=o(d1,"FunnelModel"),d1.forEach(n),ah=o(Oo," or a "),ri=a(Oo,"A",{href:!0});var c1=i(ri);ih=o(c1,"TFBertModel"),c1.forEach(n),lh=o(Oo,`. It is used to
instantiate a Funnel Transformer model according to the specified arguments, defining the model architecture.
Instantiating a configuration with the defaults will yield a similar configuration to that of the Funnel
Transformer `),Wo=a(Oo,"A",{href:!0,rel:!0});var p1=i(Wo);dh=o(p1,"funnel-transformer/small"),p1.forEach(n),ch=o(Oo," architecture."),Oo.forEach(n),ph=d(Zi),Xn=a(Zi,"P",{});var Xi=i(Xn);uh=o(Xi,"Configuration objects inherit from "),ai=a(Xi,"A",{href:!0});var u1=i(ai);hh=o(u1,"PretrainedConfig"),u1.forEach(n),fh=o(Xi,` and can be used to control the model outputs. Read the
documentation from `),ii=a(Xi,"A",{href:!0});var h1=i(ii);mh=o(h1,"PretrainedConfig"),h1.forEach(n),gh=o(Xi," for more information."),Xi.forEach(n),Zi.forEach(n),Nc=d(s),Jn=a(s,"H2",{class:!0});var $p=i(Jn);Wt=a($p,"A",{id:!0,class:!0,href:!0});var f1=i(Wt);yl=a(f1,"SPAN",{});var m1=i(yl);F(Qo.$$.fragment,m1),m1.forEach(n),f1.forEach(n),_h=d($p),wl=a($p,"SPAN",{});var g1=i(wl);vh=o(g1,"FunnelTokenizer"),g1.forEach(n),$p.forEach(n),Sc=d(s),Ce=a(s,"DIV",{class:!0});var on=i(Ce);F(Uo.$$.fragment,on),Th=d(on),bl=a(on,"P",{});var _1=i(bl);kh=o(_1,"Construct a Funnel Transformer tokenizer."),_1.forEach(n),Fh=d(on),Qt=a(on,"P",{});var xc=i(Qt);li=a(xc,"A",{href:!0});var v1=i(li);yh=o(v1,"FunnelTokenizer"),v1.forEach(n),wh=o(xc," is identical to "),di=a(xc,"A",{href:!0});var T1=i(di);bh=o(T1,"BertTokenizer"),T1.forEach(n),$h=o(xc,` and runs end-to-end tokenization: punctuation splitting and
wordpiece.`),xc.forEach(n),Eh=d(on),Ro=a(on,"P",{});var Ep=i(Ro);Mh=o(Ep,"Refer to superclass "),ci=a(Ep,"A",{href:!0});var k1=i(ci);zh=o(k1,"BertTokenizer"),k1.forEach(n),qh=o(Ep," for usage examples and documentation concerning parameters."),Ep.forEach(n),Ph=d(on),Bn=a(on,"DIV",{class:!0});var Ji=i(Bn);F(Ho.$$.fragment,Ji),jh=d(Ji),$l=a(Ji,"P",{});var F1=i($l);Ch=o(F1,`Build model inputs from a sequence or a pair of sequence for sequence classification tasks by concatenating and
adding special tokens. A BERT sequence has the following format:`),F1.forEach(n),xh=d(Ji),Vo=a(Ji,"UL",{});var Mp=i(Vo);pi=a(Mp,"LI",{});var n1=i(pi);Lh=o(n1,"single sequence: "),El=a(n1,"CODE",{});var y1=i(El);Oh=o(y1,"[CLS] X [SEP]"),y1.forEach(n),n1.forEach(n),Dh=d(Mp),ui=a(Mp,"LI",{});var t1=i(ui);Ah=o(t1,"pair of sequences: "),Ml=a(t1,"CODE",{});var w1=i(Ml);Nh=o(w1,"[CLS] A [SEP] B [SEP]"),w1.forEach(n),t1.forEach(n),Mp.forEach(n),Ji.forEach(n),Sh=d(on),Ut=a(on,"DIV",{class:!0});var zp=i(Ut);F(Yo.$$.fragment,zp),Ih=d(zp),Ko=a(zp,"P",{});var qp=i(Ko);Bh=o(qp,`Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding
special tokens using the tokenizer `),zl=a(qp,"CODE",{});var b1=i(zl);Wh=o(b1,"prepare_for_model"),b1.forEach(n),Qh=o(qp," method."),qp.forEach(n),zp.forEach(n),Uh=d(on),yn=a(on,"DIV",{class:!0});var Do=i(yn);F(Go.$$.fragment,Do),Rh=d(Do),ql=a(Do,"P",{});var $1=i(ql);Hh=o($1,`Create a mask from the two sequences passed to be used in a sequence-pair classification task. A Funnel
Transformer sequence pair mask has the following format:`),$1.forEach(n),Vh=d(Do),F(Zo.$$.fragment,Do),Yh=d(Do),et=a(Do,"P",{});var el=i(et);Kh=o(el,"If "),Pl=a(el,"CODE",{});var E1=i(Pl);Gh=o(E1,"token_ids_1"),E1.forEach(n),Zh=o(el," is "),jl=a(el,"CODE",{});var M1=i(jl);Xh=o(M1,"None"),M1.forEach(n),Jh=o(el,", this method only returns the first portion of the mask (0s)."),el.forEach(n),Do.forEach(n),ef=d(on),hi=a(on,"DIV",{class:!0});var z1=i(hi);F(Xo.$$.fragment,z1),z1.forEach(n),on.forEach(n),Ic=d(s),nt=a(s,"H2",{class:!0});var Pp=i(nt);Rt=a(Pp,"A",{id:!0,class:!0,href:!0});var q1=i(Rt);Cl=a(q1,"SPAN",{});var P1=i(Cl);F(Jo.$$.fragment,P1),P1.forEach(n),q1.forEach(n),nf=d(Pp),xl=a(Pp,"SPAN",{});var j1=i(xl);tf=o(j1,"FunnelTokenizerFast"),j1.forEach(n),Pp.forEach(n),Bc=d(s),sn=a(s,"DIV",{class:!0});var Wn=i(sn);F(es.$$.fragment,Wn),of=d(Wn),ns=a(Wn,"P",{});var jp=i(ns);sf=o(jp,"Construct a \u201Cfast\u201D Funnel Transformer tokenizer (backed by HuggingFace\u2019s "),Ll=a(jp,"EM",{});var C1=i(Ll);rf=o(C1,"tokenizers"),C1.forEach(n),af=o(jp," library)."),jp.forEach(n),lf=d(Wn),Ht=a(Wn,"P",{});var Lc=i(Ht);fi=a(Lc,"A",{href:!0});var x1=i(fi);df=o(x1,"FunnelTokenizerFast"),x1.forEach(n),cf=o(Lc," is identical to "),mi=a(Lc,"A",{href:!0});var L1=i(mi);pf=o(L1,"BertTokenizerFast"),L1.forEach(n),uf=o(Lc,` and runs end-to-end tokenization: punctuation
splitting and wordpiece.`),Lc.forEach(n),hf=d(Wn),ts=a(Wn,"P",{});var Cp=i(ts);ff=o(Cp,"Refer to superclass "),gi=a(Cp,"A",{href:!0});var O1=i(gi);mf=o(O1,"BertTokenizerFast"),O1.forEach(n),gf=o(Cp," for usage examples and documentation concerning parameters."),Cp.forEach(n),_f=d(Wn),wn=a(Wn,"DIV",{class:!0});var Ao=i(wn);F(os.$$.fragment,Ao),vf=d(Ao),Ol=a(Ao,"P",{});var D1=i(Ol);Tf=o(D1,`Create a mask from the two sequences passed to be used in a sequence-pair classification task. A Funnel
Transformer sequence pair mask has the following format:`),D1.forEach(n),kf=d(Ao),F(ss.$$.fragment,Ao),Ff=d(Ao),tt=a(Ao,"P",{});var nl=i(tt);yf=o(nl,"If "),Dl=a(nl,"CODE",{});var A1=i(Dl);wf=o(A1,"token_ids_1"),A1.forEach(n),bf=o(nl," is "),Al=a(nl,"CODE",{});var N1=i(Al);$f=o(N1,"None"),N1.forEach(n),Ef=o(nl,", this method only returns the first portion of the mask (0s)."),nl.forEach(n),Ao.forEach(n),Wn.forEach(n),Wc=d(s),ot=a(s,"H2",{class:!0});var xp=i(ot);Vt=a(xp,"A",{id:!0,class:!0,href:!0});var S1=i(Vt);Nl=a(S1,"SPAN",{});var I1=i(Nl);F(rs.$$.fragment,I1),I1.forEach(n),S1.forEach(n),Mf=d(xp),Sl=a(xp,"SPAN",{});var B1=i(Sl);zf=o(B1,"Funnel specific outputs"),B1.forEach(n),xp.forEach(n),Qc=d(s),st=a(s,"DIV",{class:!0});var Lp=i(st);F(as.$$.fragment,Lp),qf=d(Lp),is=a(Lp,"P",{});var Op=i(is);Pf=o(Op,"Output type of "),_i=a(Op,"A",{href:!0});var W1=i(_i);jf=o(W1,"FunnelForPreTraining"),W1.forEach(n),Cf=o(Op,"."),Op.forEach(n),Lp.forEach(n),Uc=d(s),rt=a(s,"DIV",{class:!0});var Dp=i(rt);F(ls.$$.fragment,Dp),xf=d(Dp),ds=a(Dp,"P",{});var Ap=i(ds);Lf=o(Ap,"Output type of "),vi=a(Ap,"A",{href:!0});var Q1=i(vi);Of=o(Q1,"FunnelForPreTraining"),Q1.forEach(n),Df=o(Ap,"."),Ap.forEach(n),Dp.forEach(n),Rc=d(s),at=a(s,"H2",{class:!0});var Np=i(at);Yt=a(Np,"A",{id:!0,class:!0,href:!0});var U1=i(Yt);Il=a(U1,"SPAN",{});var R1=i(Il);F(cs.$$.fragment,R1),R1.forEach(n),U1.forEach(n),Af=d(Np),Bl=a(Np,"SPAN",{});var H1=i(Bl);Nf=o(H1,"FunnelBaseModel"),H1.forEach(n),Np.forEach(n),Hc=d(s),Qe=a(s,"DIV",{class:!0});var bn=i(Qe);F(ps.$$.fragment,bn),Sf=d(bn),Wl=a(bn,"P",{});var V1=i(Wl);If=o(V1,`The base Funnel Transformer Model transformer outputting raw hidden-states without upsampling head (also called
decoder) or any task-specific head on top.`),V1.forEach(n),Bf=d(bn),us=a(bn,"P",{});var Sp=i(us);Wf=o(Sp,"The Funnel Transformer model was proposed in "),hs=a(Sp,"A",{href:!0,rel:!0});var Y1=i(hs);Qf=o(Y1,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Y1.forEach(n),Uf=o(Sp," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Sp.forEach(n),Rf=d(bn),fs=a(bn,"P",{});var Ip=i(fs);Hf=o(Ip,"This model inherits from "),Ti=a(Ip,"A",{href:!0});var K1=i(Ti);Vf=o(K1,"PreTrainedModel"),K1.forEach(n),Yf=o(Ip,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Ip.forEach(n),Kf=d(bn),ms=a(bn,"P",{});var Bp=i(ms);Gf=o(Bp,"This model is also a PyTorch "),gs=a(Bp,"A",{href:!0,rel:!0});var G1=i(gs);Zf=o(G1,"torch.nn.Module"),G1.forEach(n),Xf=o(Bp,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Bp.forEach(n),Jf=d(bn),rn=a(bn,"DIV",{class:!0});var Qn=i(rn);F(_s.$$.fragment,Qn),em=d(Qn),it=a(Qn,"P",{});var tl=i(it);nm=o(tl,"The "),ki=a(tl,"A",{href:!0});var Z1=i(ki);tm=o(Z1,"FunnelBaseModel"),Z1.forEach(n),om=o(tl," forward method, overrides the "),Ql=a(tl,"CODE",{});var X1=i(Ql);sm=o(X1,"__call__"),X1.forEach(n),rm=o(tl," special method."),tl.forEach(n),am=d(Qn),F(Kt.$$.fragment,Qn),im=d(Qn),Ul=a(Qn,"P",{});var J1=i(Ul);lm=o(J1,"Example:"),J1.forEach(n),dm=d(Qn),F(vs.$$.fragment,Qn),Qn.forEach(n),bn.forEach(n),Vc=d(s),lt=a(s,"H2",{class:!0});var Wp=i(lt);Gt=a(Wp,"A",{id:!0,class:!0,href:!0});var ew=i(Gt);Rl=a(ew,"SPAN",{});var nw=i(Rl);F(Ts.$$.fragment,nw),nw.forEach(n),ew.forEach(n),cm=d(Wp),Hl=a(Wp,"SPAN",{});var tw=i(Hl);pm=o(tw,"FunnelModel"),tw.forEach(n),Wp.forEach(n),Yc=d(s),Ue=a(s,"DIV",{class:!0});var $n=i(Ue);F(ks.$$.fragment,$n),um=d($n),Vl=a($n,"P",{});var ow=i(Vl);hm=o(ow,"The bare Funnel Transformer Model transformer outputting raw hidden-states without any specific head on top."),ow.forEach(n),fm=d($n),Fs=a($n,"P",{});var Qp=i(Fs);mm=o(Qp,"The Funnel Transformer model was proposed in "),ys=a(Qp,"A",{href:!0,rel:!0});var sw=i(ys);gm=o(sw,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),sw.forEach(n),_m=o(Qp," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Qp.forEach(n),vm=d($n),ws=a($n,"P",{});var Up=i(ws);Tm=o(Up,"This model inherits from "),Fi=a(Up,"A",{href:!0});var rw=i(Fi);km=o(rw,"PreTrainedModel"),rw.forEach(n),Fm=o(Up,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Up.forEach(n),ym=d($n),bs=a($n,"P",{});var Rp=i(bs);wm=o(Rp,"This model is also a PyTorch "),$s=a(Rp,"A",{href:!0,rel:!0});var aw=i($s);bm=o(aw,"torch.nn.Module"),aw.forEach(n),$m=o(Rp,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Rp.forEach(n),Em=d($n),an=a($n,"DIV",{class:!0});var Un=i(an);F(Es.$$.fragment,Un),Mm=d(Un),dt=a(Un,"P",{});var ol=i(dt);zm=o(ol,"The "),yi=a(ol,"A",{href:!0});var iw=i(yi);qm=o(iw,"FunnelModel"),iw.forEach(n),Pm=o(ol," forward method, overrides the "),Yl=a(ol,"CODE",{});var lw=i(Yl);jm=o(lw,"__call__"),lw.forEach(n),Cm=o(ol," special method."),ol.forEach(n),xm=d(Un),F(Zt.$$.fragment,Un),Lm=d(Un),Kl=a(Un,"P",{});var dw=i(Kl);Om=o(dw,"Example:"),dw.forEach(n),Dm=d(Un),F(Ms.$$.fragment,Un),Un.forEach(n),$n.forEach(n),Kc=d(s),ct=a(s,"H2",{class:!0});var Hp=i(ct);Xt=a(Hp,"A",{id:!0,class:!0,href:!0});var cw=i(Xt);Gl=a(cw,"SPAN",{});var pw=i(Gl);F(zs.$$.fragment,pw),pw.forEach(n),cw.forEach(n),Am=d(Hp),Zl=a(Hp,"SPAN",{});var uw=i(Zl);Nm=o(uw,"FunnelModelForPreTraining"),uw.forEach(n),Hp.forEach(n),Gc=d(s),pt=a(s,"DIV",{class:!0});var Vp=i(pt);F(qs.$$.fragment,Vp),Sm=d(Vp),ln=a(Vp,"DIV",{class:!0});var Rn=i(ln);F(Ps.$$.fragment,Rn),Im=d(Rn),ut=a(Rn,"P",{});var sl=i(ut);Bm=o(sl,"The "),wi=a(sl,"A",{href:!0});var hw=i(wi);Wm=o(hw,"FunnelForPreTraining"),hw.forEach(n),Qm=o(sl," forward method, overrides the "),Xl=a(sl,"CODE",{});var fw=i(Xl);Um=o(fw,"__call__"),fw.forEach(n),Rm=o(sl," special method."),sl.forEach(n),Hm=d(Rn),F(Jt.$$.fragment,Rn),Vm=d(Rn),Jl=a(Rn,"P",{});var mw=i(Jl);Ym=o(mw,"Examples:"),mw.forEach(n),Km=d(Rn),F(js.$$.fragment,Rn),Rn.forEach(n),Vp.forEach(n),Zc=d(s),ht=a(s,"H2",{class:!0});var Yp=i(ht);eo=a(Yp,"A",{id:!0,class:!0,href:!0});var gw=i(eo);ed=a(gw,"SPAN",{});var _w=i(ed);F(Cs.$$.fragment,_w),_w.forEach(n),gw.forEach(n),Gm=d(Yp),nd=a(Yp,"SPAN",{});var vw=i(nd);Zm=o(vw,"FunnelForMaskedLM"),vw.forEach(n),Yp.forEach(n),Xc=d(s),Re=a(s,"DIV",{class:!0});var En=i(Re);F(xs.$$.fragment,En),Xm=d(En),Ls=a(En,"P",{});var Kp=i(Ls);Jm=o(Kp,"Funnel Transformer Model with a "),td=a(Kp,"CODE",{});var Tw=i(td);eg=o(Tw,"language modeling"),Tw.forEach(n),ng=o(Kp," head on top."),Kp.forEach(n),tg=d(En),Os=a(En,"P",{});var Gp=i(Os);og=o(Gp,"The Funnel Transformer model was proposed in "),Ds=a(Gp,"A",{href:!0,rel:!0});var kw=i(Ds);sg=o(kw,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),kw.forEach(n),rg=o(Gp," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Gp.forEach(n),ag=d(En),As=a(En,"P",{});var Zp=i(As);ig=o(Zp,"This model inherits from "),bi=a(Zp,"A",{href:!0});var Fw=i(bi);lg=o(Fw,"PreTrainedModel"),Fw.forEach(n),dg=o(Zp,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Zp.forEach(n),cg=d(En),Ns=a(En,"P",{});var Xp=i(Ns);pg=o(Xp,"This model is also a PyTorch "),Ss=a(Xp,"A",{href:!0,rel:!0});var yw=i(Ss);ug=o(yw,"torch.nn.Module"),yw.forEach(n),hg=o(Xp,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Xp.forEach(n),fg=d(En),Ge=a(En,"DIV",{class:!0});var Mn=i(Ge);F(Is.$$.fragment,Mn),mg=d(Mn),ft=a(Mn,"P",{});var rl=i(ft);gg=o(rl,"The "),$i=a(rl,"A",{href:!0});var ww=i($i);_g=o(ww,"FunnelForMaskedLM"),ww.forEach(n),vg=o(rl," forward method, overrides the "),od=a(rl,"CODE",{});var bw=i(od);Tg=o(bw,"__call__"),bw.forEach(n),kg=o(rl," special method."),rl.forEach(n),Fg=d(Mn),F(no.$$.fragment,Mn),yg=d(Mn),sd=a(Mn,"P",{});var $w=i(sd);wg=o($w,"Example:"),$w.forEach(n),bg=d(Mn),F(Bs.$$.fragment,Mn),$g=d(Mn),F(Ws.$$.fragment,Mn),Mn.forEach(n),En.forEach(n),Jc=d(s),mt=a(s,"H2",{class:!0});var Jp=i(mt);to=a(Jp,"A",{id:!0,class:!0,href:!0});var Ew=i(to);rd=a(Ew,"SPAN",{});var Mw=i(rd);F(Qs.$$.fragment,Mw),Mw.forEach(n),Ew.forEach(n),Eg=d(Jp),ad=a(Jp,"SPAN",{});var zw=i(ad);Mg=o(zw,"FunnelForSequenceClassification"),zw.forEach(n),Jp.forEach(n),ep=d(s),He=a(s,"DIV",{class:!0});var zn=i(He);F(Us.$$.fragment,zn),zg=d(zn),id=a(zn,"P",{});var qw=i(id);qg=o(qw,`Funnel Transformer Model with a sequence classification/regression head on top (two linear layer on top of the
first timestep of the last hidden state) e.g. for GLUE tasks.`),qw.forEach(n),Pg=d(zn),Rs=a(zn,"P",{});var eu=i(Rs);jg=o(eu,"The Funnel Transformer model was proposed in "),Hs=a(eu,"A",{href:!0,rel:!0});var Pw=i(Hs);Cg=o(Pw,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Pw.forEach(n),xg=o(eu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),eu.forEach(n),Lg=d(zn),Vs=a(zn,"P",{});var nu=i(Vs);Og=o(nu,"This model inherits from "),Ei=a(nu,"A",{href:!0});var jw=i(Ei);Dg=o(jw,"PreTrainedModel"),jw.forEach(n),Ag=o(nu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),nu.forEach(n),Ng=d(zn),Ys=a(zn,"P",{});var tu=i(Ys);Sg=o(tu,"This model is also a PyTorch "),Ks=a(tu,"A",{href:!0,rel:!0});var Cw=i(Ks);Ig=o(Cw,"torch.nn.Module"),Cw.forEach(n),Bg=o(tu,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),tu.forEach(n),Wg=d(zn),Pe=a(zn,"DIV",{class:!0});var We=i(Pe);F(Gs.$$.fragment,We),Qg=d(We),gt=a(We,"P",{});var al=i(gt);Ug=o(al,"The "),Mi=a(al,"A",{href:!0});var xw=i(Mi);Rg=o(xw,"FunnelForSequenceClassification"),xw.forEach(n),Hg=o(al," forward method, overrides the "),ld=a(al,"CODE",{});var Lw=i(ld);Vg=o(Lw,"__call__"),Lw.forEach(n),Yg=o(al," special method."),al.forEach(n),Kg=d(We),F(oo.$$.fragment,We),Gg=d(We),dd=a(We,"P",{});var Ow=i(dd);Zg=o(Ow,"Example of single-label classification:"),Ow.forEach(n),Xg=d(We),F(Zs.$$.fragment,We),Jg=d(We),F(Xs.$$.fragment,We),e_=d(We),cd=a(We,"P",{});var Dw=i(cd);n_=o(Dw,"Example of multi-label classification:"),Dw.forEach(n),t_=d(We),F(Js.$$.fragment,We),o_=d(We),F(er.$$.fragment,We),We.forEach(n),zn.forEach(n),np=d(s),_t=a(s,"H2",{class:!0});var ou=i(_t);so=a(ou,"A",{id:!0,class:!0,href:!0});var Aw=i(so);pd=a(Aw,"SPAN",{});var Nw=i(pd);F(nr.$$.fragment,Nw),Nw.forEach(n),Aw.forEach(n),s_=d(ou),ud=a(ou,"SPAN",{});var Sw=i(ud);r_=o(Sw,"FunnelForMultipleChoice"),Sw.forEach(n),ou.forEach(n),tp=d(s),Ve=a(s,"DIV",{class:!0});var qn=i(Ve);F(tr.$$.fragment,qn),a_=d(qn),hd=a(qn,"P",{});var Iw=i(hd);i_=o(Iw,`Funnel Transformer Model with a multiple choice classification head on top (two linear layer on top of the first
timestep of the last hidden state, and a softmax) e.g. for RocStories/SWAG tasks.`),Iw.forEach(n),l_=d(qn),or=a(qn,"P",{});var su=i(or);d_=o(su,"The Funnel Transformer model was proposed in "),sr=a(su,"A",{href:!0,rel:!0});var Bw=i(sr);c_=o(Bw,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Bw.forEach(n),p_=o(su," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),su.forEach(n),u_=d(qn),rr=a(qn,"P",{});var ru=i(rr);h_=o(ru,"This model inherits from "),zi=a(ru,"A",{href:!0});var Ww=i(zi);f_=o(Ww,"PreTrainedModel"),Ww.forEach(n),m_=o(ru,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),ru.forEach(n),g_=d(qn),ar=a(qn,"P",{});var au=i(ar);__=o(au,"This model is also a PyTorch "),ir=a(au,"A",{href:!0,rel:!0});var Qw=i(ir);v_=o(Qw,"torch.nn.Module"),Qw.forEach(n),T_=o(au,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),au.forEach(n),k_=d(qn),dn=a(qn,"DIV",{class:!0});var Hn=i(dn);F(lr.$$.fragment,Hn),F_=d(Hn),vt=a(Hn,"P",{});var il=i(vt);y_=o(il,"The "),qi=a(il,"A",{href:!0});var Uw=i(qi);w_=o(Uw,"FunnelForMultipleChoice"),Uw.forEach(n),b_=o(il," forward method, overrides the "),fd=a(il,"CODE",{});var Rw=i(fd);$_=o(Rw,"__call__"),Rw.forEach(n),E_=o(il," special method."),il.forEach(n),M_=d(Hn),F(ro.$$.fragment,Hn),z_=d(Hn),md=a(Hn,"P",{});var Hw=i(md);q_=o(Hw,"Example:"),Hw.forEach(n),P_=d(Hn),F(dr.$$.fragment,Hn),Hn.forEach(n),qn.forEach(n),op=d(s),Tt=a(s,"H2",{class:!0});var iu=i(Tt);ao=a(iu,"A",{id:!0,class:!0,href:!0});var Vw=i(ao);gd=a(Vw,"SPAN",{});var Yw=i(gd);F(cr.$$.fragment,Yw),Yw.forEach(n),Vw.forEach(n),j_=d(iu),_d=a(iu,"SPAN",{});var Kw=i(_d);C_=o(Kw,"FunnelForTokenClassification"),Kw.forEach(n),iu.forEach(n),sp=d(s),Ye=a(s,"DIV",{class:!0});var Pn=i(Ye);F(pr.$$.fragment,Pn),x_=d(Pn),vd=a(Pn,"P",{});var Gw=i(vd);L_=o(Gw,`Funnel Transformer Model with a token classification head on top (a linear layer on top of the hidden-states
output) e.g. for Named-Entity-Recognition (NER) tasks.`),Gw.forEach(n),O_=d(Pn),ur=a(Pn,"P",{});var lu=i(ur);D_=o(lu,"The Funnel Transformer model was proposed in "),hr=a(lu,"A",{href:!0,rel:!0});var Zw=i(hr);A_=o(Zw,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Zw.forEach(n),N_=o(lu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),lu.forEach(n),S_=d(Pn),fr=a(Pn,"P",{});var du=i(fr);I_=o(du,"This model inherits from "),Pi=a(du,"A",{href:!0});var Xw=i(Pi);B_=o(Xw,"PreTrainedModel"),Xw.forEach(n),W_=o(du,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),du.forEach(n),Q_=d(Pn),mr=a(Pn,"P",{});var cu=i(mr);U_=o(cu,"This model is also a PyTorch "),gr=a(cu,"A",{href:!0,rel:!0});var Jw=i(gr);R_=o(Jw,"torch.nn.Module"),Jw.forEach(n),H_=o(cu,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),cu.forEach(n),V_=d(Pn),Ze=a(Pn,"DIV",{class:!0});var jn=i(Ze);F(_r.$$.fragment,jn),Y_=d(jn),kt=a(jn,"P",{});var ll=i(kt);K_=o(ll,"The "),ji=a(ll,"A",{href:!0});var eb=i(ji);G_=o(eb,"FunnelForTokenClassification"),eb.forEach(n),Z_=o(ll," forward method, overrides the "),Td=a(ll,"CODE",{});var nb=i(Td);X_=o(nb,"__call__"),nb.forEach(n),J_=o(ll," special method."),ll.forEach(n),ev=d(jn),F(io.$$.fragment,jn),nv=d(jn),kd=a(jn,"P",{});var tb=i(kd);tv=o(tb,"Example:"),tb.forEach(n),ov=d(jn),F(vr.$$.fragment,jn),sv=d(jn),F(Tr.$$.fragment,jn),jn.forEach(n),Pn.forEach(n),rp=d(s),Ft=a(s,"H2",{class:!0});var pu=i(Ft);lo=a(pu,"A",{id:!0,class:!0,href:!0});var ob=i(lo);Fd=a(ob,"SPAN",{});var sb=i(Fd);F(kr.$$.fragment,sb),sb.forEach(n),ob.forEach(n),rv=d(pu),yd=a(pu,"SPAN",{});var rb=i(yd);av=o(rb,"FunnelForQuestionAnswering"),rb.forEach(n),pu.forEach(n),ap=d(s),Ke=a(s,"DIV",{class:!0});var Cn=i(Ke);F(Fr.$$.fragment,Cn),iv=d(Cn),yt=a(Cn,"P",{});var dl=i(yt);lv=o(dl,`Funnel Transformer Model with a span classification head on top for extractive question-answering tasks like SQuAD
(a linear layer on top of the hidden-states output to compute `),wd=a(dl,"CODE",{});var ab=i(wd);dv=o(ab,"span start logits"),ab.forEach(n),cv=o(dl," and "),bd=a(dl,"CODE",{});var ib=i(bd);pv=o(ib,"span end logits"),ib.forEach(n),uv=o(dl,")."),dl.forEach(n),hv=d(Cn),yr=a(Cn,"P",{});var uu=i(yr);fv=o(uu,"The Funnel Transformer model was proposed in "),wr=a(uu,"A",{href:!0,rel:!0});var lb=i(wr);mv=o(lb,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),lb.forEach(n),gv=o(uu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),uu.forEach(n),_v=d(Cn),br=a(Cn,"P",{});var hu=i(br);vv=o(hu,"This model inherits from "),Ci=a(hu,"A",{href:!0});var db=i(Ci);Tv=o(db,"PreTrainedModel"),db.forEach(n),kv=o(hu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),hu.forEach(n),Fv=d(Cn),$r=a(Cn,"P",{});var fu=i($r);yv=o(fu,"This model is also a PyTorch "),Er=a(fu,"A",{href:!0,rel:!0});var cb=i(Er);wv=o(cb,"torch.nn.Module"),cb.forEach(n),bv=o(fu,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),fu.forEach(n),$v=d(Cn),Xe=a(Cn,"DIV",{class:!0});var xn=i(Xe);F(Mr.$$.fragment,xn),Ev=d(xn),wt=a(xn,"P",{});var cl=i(wt);Mv=o(cl,"The "),xi=a(cl,"A",{href:!0});var pb=i(xi);zv=o(pb,"FunnelForQuestionAnswering"),pb.forEach(n),qv=o(cl," forward method, overrides the "),$d=a(cl,"CODE",{});var ub=i($d);Pv=o(ub,"__call__"),ub.forEach(n),jv=o(cl," special method."),cl.forEach(n),Cv=d(xn),F(co.$$.fragment,xn),xv=d(xn),Ed=a(xn,"P",{});var hb=i(Ed);Lv=o(hb,"Example:"),hb.forEach(n),Ov=d(xn),F(zr.$$.fragment,xn),Dv=d(xn),F(qr.$$.fragment,xn),xn.forEach(n),Cn.forEach(n),ip=d(s),bt=a(s,"H2",{class:!0});var mu=i(bt);po=a(mu,"A",{id:!0,class:!0,href:!0});var fb=i(po);Md=a(fb,"SPAN",{});var mb=i(Md);F(Pr.$$.fragment,mb),mb.forEach(n),fb.forEach(n),Av=d(mu),zd=a(mu,"SPAN",{});var gb=i(zd);Nv=o(gb,"TFFunnelBaseModel"),gb.forEach(n),mu.forEach(n),lp=d(s),Le=a(s,"DIV",{class:!0});var fn=i(Le);F(jr.$$.fragment,fn),Sv=d(fn),qd=a(fn,"P",{});var _b=i(qd);Iv=o(_b,`The base Funnel Transformer Model transformer outputting raw hidden-states without upsampling head (also called
decoder) or any task-specific head on top.`),_b.forEach(n),Bv=d(fn),Cr=a(fn,"P",{});var gu=i(Cr);Wv=o(gu,"The Funnel Transformer model was proposed in "),xr=a(gu,"A",{href:!0,rel:!0});var vb=i(xr);Qv=o(vb,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),vb.forEach(n),Uv=o(gu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),gu.forEach(n),Rv=d(fn),Lr=a(fn,"P",{});var _u=i(Lr);Hv=o(_u,"This model inherits from "),Li=a(_u,"A",{href:!0});var Tb=i(Li);Vv=o(Tb,"TFPreTrainedModel"),Tb.forEach(n),Yv=o(_u,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),_u.forEach(n),Kv=d(fn),Or=a(fn,"P",{});var vu=i(Or);Gv=o(vu,"This model is also a "),Dr=a(vu,"A",{href:!0,rel:!0});var kb=i(Dr);Zv=o(kb,"tf.keras.Model"),kb.forEach(n),Xv=o(vu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),vu.forEach(n),Jv=d(fn),F(uo.$$.fragment,fn),eT=d(fn),cn=a(fn,"DIV",{class:!0});var Vn=i(cn);F(Ar.$$.fragment,Vn),nT=d(Vn),$t=a(Vn,"P",{});var pl=i($t);tT=o(pl,"The "),Oi=a(pl,"A",{href:!0});var Fb=i(Oi);oT=o(Fb,"TFFunnelBaseModel"),Fb.forEach(n),sT=o(pl," forward method, overrides the "),Pd=a(pl,"CODE",{});var yb=i(Pd);rT=o(yb,"__call__"),yb.forEach(n),aT=o(pl," special method."),pl.forEach(n),iT=d(Vn),F(ho.$$.fragment,Vn),lT=d(Vn),jd=a(Vn,"P",{});var wb=i(jd);dT=o(wb,"Example:"),wb.forEach(n),cT=d(Vn),F(Nr.$$.fragment,Vn),Vn.forEach(n),fn.forEach(n),dp=d(s),Et=a(s,"H2",{class:!0});var Tu=i(Et);fo=a(Tu,"A",{id:!0,class:!0,href:!0});var bb=i(fo);Cd=a(bb,"SPAN",{});var $b=i(Cd);F(Sr.$$.fragment,$b),$b.forEach(n),bb.forEach(n),pT=d(Tu),xd=a(Tu,"SPAN",{});var Eb=i(xd);uT=o(Eb,"TFFunnelModel"),Eb.forEach(n),Tu.forEach(n),cp=d(s),Oe=a(s,"DIV",{class:!0});var mn=i(Oe);F(Ir.$$.fragment,mn),hT=d(mn),Ld=a(mn,"P",{});var Mb=i(Ld);fT=o(Mb,"The bare Funnel Transformer Model transformer outputting raw hidden-states without any specific head on top."),Mb.forEach(n),mT=d(mn),Br=a(mn,"P",{});var ku=i(Br);gT=o(ku,"The Funnel Transformer model was proposed in "),Wr=a(ku,"A",{href:!0,rel:!0});var zb=i(Wr);_T=o(zb,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),zb.forEach(n),vT=o(ku," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),ku.forEach(n),TT=d(mn),Qr=a(mn,"P",{});var Fu=i(Qr);kT=o(Fu,"This model inherits from "),Di=a(Fu,"A",{href:!0});var qb=i(Di);FT=o(qb,"TFPreTrainedModel"),qb.forEach(n),yT=o(Fu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Fu.forEach(n),wT=d(mn),Ur=a(mn,"P",{});var yu=i(Ur);bT=o(yu,"This model is also a "),Rr=a(yu,"A",{href:!0,rel:!0});var Pb=i(Rr);$T=o(Pb,"tf.keras.Model"),Pb.forEach(n),ET=o(yu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),yu.forEach(n),MT=d(mn),F(mo.$$.fragment,mn),zT=d(mn),pn=a(mn,"DIV",{class:!0});var Yn=i(pn);F(Hr.$$.fragment,Yn),qT=d(Yn),Mt=a(Yn,"P",{});var ul=i(Mt);PT=o(ul,"The "),Ai=a(ul,"A",{href:!0});var jb=i(Ai);jT=o(jb,"TFFunnelModel"),jb.forEach(n),CT=o(ul," forward method, overrides the "),Od=a(ul,"CODE",{});var Cb=i(Od);xT=o(Cb,"__call__"),Cb.forEach(n),LT=o(ul," special method."),ul.forEach(n),OT=d(Yn),F(go.$$.fragment,Yn),DT=d(Yn),Dd=a(Yn,"P",{});var xb=i(Dd);AT=o(xb,"Example:"),xb.forEach(n),NT=d(Yn),F(Vr.$$.fragment,Yn),Yn.forEach(n),mn.forEach(n),pp=d(s),zt=a(s,"H2",{class:!0});var wu=i(zt);_o=a(wu,"A",{id:!0,class:!0,href:!0});var Lb=i(_o);Ad=a(Lb,"SPAN",{});var Ob=i(Ad);F(Yr.$$.fragment,Ob),Ob.forEach(n),Lb.forEach(n),ST=d(wu),Nd=a(wu,"SPAN",{});var Db=i(Nd);IT=o(Db,"TFFunnelModelForPreTraining"),Db.forEach(n),wu.forEach(n),up=d(s),De=a(s,"DIV",{class:!0});var gn=i(De);F(Kr.$$.fragment,gn),BT=d(gn),Sd=a(gn,"P",{});var Ab=i(Sd);WT=o(Ab,"Funnel model with a binary classification head on top as used during pretraining for identifying generated tokens."),Ab.forEach(n),QT=d(gn),Gr=a(gn,"P",{});var bu=i(Gr);UT=o(bu,"The Funnel Transformer model was proposed in "),Zr=a(bu,"A",{href:!0,rel:!0});var Nb=i(Zr);RT=o(Nb,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Nb.forEach(n),HT=o(bu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),bu.forEach(n),VT=d(gn),Xr=a(gn,"P",{});var $u=i(Xr);YT=o($u,"This model inherits from "),Ni=a($u,"A",{href:!0});var Sb=i(Ni);KT=o(Sb,"TFPreTrainedModel"),Sb.forEach(n),GT=o($u,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),$u.forEach(n),ZT=d(gn),Jr=a(gn,"P",{});var Eu=i(Jr);XT=o(Eu,"This model is also a "),ea=a(Eu,"A",{href:!0,rel:!0});var Ib=i(ea);JT=o(Ib,"tf.keras.Model"),Ib.forEach(n),ek=o(Eu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Eu.forEach(n),nk=d(gn),F(vo.$$.fragment,gn),tk=d(gn),un=a(gn,"DIV",{class:!0});var Kn=i(un);F(na.$$.fragment,Kn),ok=d(Kn),qt=a(Kn,"P",{});var hl=i(qt);sk=o(hl,"The "),Si=a(hl,"A",{href:!0});var Bb=i(Si);rk=o(Bb,"TFFunnelForPreTraining"),Bb.forEach(n),ak=o(hl," forward method, overrides the "),Id=a(hl,"CODE",{});var Wb=i(Id);ik=o(Wb,"__call__"),Wb.forEach(n),lk=o(hl," special method."),hl.forEach(n),dk=d(Kn),F(To.$$.fragment,Kn),ck=d(Kn),Bd=a(Kn,"P",{});var Qb=i(Bd);pk=o(Qb,"Examples:"),Qb.forEach(n),uk=d(Kn),F(ta.$$.fragment,Kn),Kn.forEach(n),gn.forEach(n),hp=d(s),Pt=a(s,"H2",{class:!0});var Mu=i(Pt);ko=a(Mu,"A",{id:!0,class:!0,href:!0});var Ub=i(ko);Wd=a(Ub,"SPAN",{});var Rb=i(Wd);F(oa.$$.fragment,Rb),Rb.forEach(n),Ub.forEach(n),hk=d(Mu),Qd=a(Mu,"SPAN",{});var Hb=i(Qd);fk=o(Hb,"TFFunnelForMaskedLM"),Hb.forEach(n),Mu.forEach(n),fp=d(s),Ae=a(s,"DIV",{class:!0});var _n=i(Ae);F(sa.$$.fragment,_n),mk=d(_n),ra=a(_n,"P",{});var zu=i(ra);gk=o(zu,"Funnel Model with a "),Ud=a(zu,"CODE",{});var Vb=i(Ud);_k=o(Vb,"language modeling"),Vb.forEach(n),vk=o(zu," head on top."),zu.forEach(n),Tk=d(_n),aa=a(_n,"P",{});var qu=i(aa);kk=o(qu,"The Funnel Transformer model was proposed in "),ia=a(qu,"A",{href:!0,rel:!0});var Yb=i(ia);Fk=o(Yb,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Yb.forEach(n),yk=o(qu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),qu.forEach(n),wk=d(_n),la=a(_n,"P",{});var Pu=i(la);bk=o(Pu,"This model inherits from "),Ii=a(Pu,"A",{href:!0});var Kb=i(Ii);$k=o(Kb,"TFPreTrainedModel"),Kb.forEach(n),Ek=o(Pu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Pu.forEach(n),Mk=d(_n),da=a(_n,"P",{});var ju=i(da);zk=o(ju,"This model is also a "),ca=a(ju,"A",{href:!0,rel:!0});var Gb=i(ca);qk=o(Gb,"tf.keras.Model"),Gb.forEach(n),Pk=o(ju,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),ju.forEach(n),jk=d(_n),F(Fo.$$.fragment,_n),Ck=d(_n),Je=a(_n,"DIV",{class:!0});var Ln=i(Je);F(pa.$$.fragment,Ln),xk=d(Ln),jt=a(Ln,"P",{});var fl=i(jt);Lk=o(fl,"The "),Bi=a(fl,"A",{href:!0});var Zb=i(Bi);Ok=o(Zb,"TFFunnelForMaskedLM"),Zb.forEach(n),Dk=o(fl," forward method, overrides the "),Rd=a(fl,"CODE",{});var Xb=i(Rd);Ak=o(Xb,"__call__"),Xb.forEach(n),Nk=o(fl," special method."),fl.forEach(n),Sk=d(Ln),F(yo.$$.fragment,Ln),Ik=d(Ln),Hd=a(Ln,"P",{});var Jb=i(Hd);Bk=o(Jb,"Example:"),Jb.forEach(n),Wk=d(Ln),F(ua.$$.fragment,Ln),Qk=d(Ln),F(ha.$$.fragment,Ln),Ln.forEach(n),_n.forEach(n),mp=d(s),Ct=a(s,"H2",{class:!0});var Cu=i(Ct);wo=a(Cu,"A",{id:!0,class:!0,href:!0});var e0=i(wo);Vd=a(e0,"SPAN",{});var n0=i(Vd);F(fa.$$.fragment,n0),n0.forEach(n),e0.forEach(n),Uk=d(Cu),Yd=a(Cu,"SPAN",{});var t0=i(Yd);Rk=o(t0,"TFFunnelForSequenceClassification"),t0.forEach(n),Cu.forEach(n),gp=d(s),Ne=a(s,"DIV",{class:!0});var vn=i(Ne);F(ma.$$.fragment,vn),Hk=d(vn),Kd=a(vn,"P",{});var o0=i(Kd);Vk=o(o0,`Funnel Model transformer with a sequence classification/regression head on top (a linear layer on top of the pooled
output) e.g. for GLUE tasks.`),o0.forEach(n),Yk=d(vn),ga=a(vn,"P",{});var xu=i(ga);Kk=o(xu,"The Funnel Transformer model was proposed in "),_a=a(xu,"A",{href:!0,rel:!0});var s0=i(_a);Gk=o(s0,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),s0.forEach(n),Zk=o(xu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),xu.forEach(n),Xk=d(vn),va=a(vn,"P",{});var Lu=i(va);Jk=o(Lu,"This model inherits from "),Wi=a(Lu,"A",{href:!0});var r0=i(Wi);eF=o(r0,"TFPreTrainedModel"),r0.forEach(n),nF=o(Lu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Lu.forEach(n),tF=d(vn),Ta=a(vn,"P",{});var Ou=i(Ta);oF=o(Ou,"This model is also a "),ka=a(Ou,"A",{href:!0,rel:!0});var a0=i(ka);sF=o(a0,"tf.keras.Model"),a0.forEach(n),rF=o(Ou,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Ou.forEach(n),aF=d(vn),F(bo.$$.fragment,vn),iF=d(vn),en=a(vn,"DIV",{class:!0});var On=i(en);F(Fa.$$.fragment,On),lF=d(On),xt=a(On,"P",{});var ml=i(xt);dF=o(ml,"The "),Qi=a(ml,"A",{href:!0});var i0=i(Qi);cF=o(i0,"TFFunnelForSequenceClassification"),i0.forEach(n),pF=o(ml," forward method, overrides the "),Gd=a(ml,"CODE",{});var l0=i(Gd);uF=o(l0,"__call__"),l0.forEach(n),hF=o(ml," special method."),ml.forEach(n),fF=d(On),F($o.$$.fragment,On),mF=d(On),Zd=a(On,"P",{});var d0=i(Zd);gF=o(d0,"Example:"),d0.forEach(n),_F=d(On),F(ya.$$.fragment,On),vF=d(On),F(wa.$$.fragment,On),On.forEach(n),vn.forEach(n),_p=d(s),Lt=a(s,"H2",{class:!0});var Du=i(Lt);Eo=a(Du,"A",{id:!0,class:!0,href:!0});var c0=i(Eo);Xd=a(c0,"SPAN",{});var p0=i(Xd);F(ba.$$.fragment,p0),p0.forEach(n),c0.forEach(n),TF=d(Du),Jd=a(Du,"SPAN",{});var u0=i(Jd);kF=o(u0,"TFFunnelForMultipleChoice"),u0.forEach(n),Du.forEach(n),vp=d(s),Se=a(s,"DIV",{class:!0});var Tn=i(Se);F($a.$$.fragment,Tn),FF=d(Tn),ec=a(Tn,"P",{});var h0=i(ec);yF=o(h0,`Funnel Model with a multiple choice classification head on top (a linear layer on top of the pooled output and a
softmax) e.g. for RocStories/SWAG tasks.`),h0.forEach(n),wF=d(Tn),Ea=a(Tn,"P",{});var Au=i(Ea);bF=o(Au,"The Funnel Transformer model was proposed in "),Ma=a(Au,"A",{href:!0,rel:!0});var f0=i(Ma);$F=o(f0,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),f0.forEach(n),EF=o(Au," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Au.forEach(n),MF=d(Tn),za=a(Tn,"P",{});var Nu=i(za);zF=o(Nu,"This model inherits from "),Ui=a(Nu,"A",{href:!0});var m0=i(Ui);qF=o(m0,"TFPreTrainedModel"),m0.forEach(n),PF=o(Nu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Nu.forEach(n),jF=d(Tn),qa=a(Tn,"P",{});var Su=i(qa);CF=o(Su,"This model is also a "),Pa=a(Su,"A",{href:!0,rel:!0});var g0=i(Pa);xF=o(g0,"tf.keras.Model"),g0.forEach(n),LF=o(Su,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Su.forEach(n),OF=d(Tn),F(Mo.$$.fragment,Tn),DF=d(Tn),hn=a(Tn,"DIV",{class:!0});var Gn=i(hn);F(ja.$$.fragment,Gn),AF=d(Gn),Ot=a(Gn,"P",{});var gl=i(Ot);NF=o(gl,"The "),Ri=a(gl,"A",{href:!0});var _0=i(Ri);SF=o(_0,"TFFunnelForMultipleChoice"),_0.forEach(n),IF=o(gl," forward method, overrides the "),nc=a(gl,"CODE",{});var v0=i(nc);BF=o(v0,"__call__"),v0.forEach(n),WF=o(gl," special method."),gl.forEach(n),QF=d(Gn),F(zo.$$.fragment,Gn),UF=d(Gn),tc=a(Gn,"P",{});var T0=i(tc);RF=o(T0,"Example:"),T0.forEach(n),HF=d(Gn),F(Ca.$$.fragment,Gn),Gn.forEach(n),Tn.forEach(n),Tp=d(s),Dt=a(s,"H2",{class:!0});var Iu=i(Dt);qo=a(Iu,"A",{id:!0,class:!0,href:!0});var k0=i(qo);oc=a(k0,"SPAN",{});var F0=i(oc);F(xa.$$.fragment,F0),F0.forEach(n),k0.forEach(n),VF=d(Iu),sc=a(Iu,"SPAN",{});var y0=i(sc);YF=o(y0,"TFFunnelForTokenClassification"),y0.forEach(n),Iu.forEach(n),kp=d(s),Ie=a(s,"DIV",{class:!0});var kn=i(Ie);F(La.$$.fragment,kn),KF=d(kn),rc=a(kn,"P",{});var w0=i(rc);GF=o(w0,`Funnel Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g. for
Named-Entity-Recognition (NER) tasks.`),w0.forEach(n),ZF=d(kn),Oa=a(kn,"P",{});var Bu=i(Oa);XF=o(Bu,"The Funnel Transformer model was proposed in "),Da=a(Bu,"A",{href:!0,rel:!0});var b0=i(Da);JF=o(b0,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),b0.forEach(n),ey=o(Bu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Bu.forEach(n),ny=d(kn),Aa=a(kn,"P",{});var Wu=i(Aa);ty=o(Wu,"This model inherits from "),Hi=a(Wu,"A",{href:!0});var $0=i(Hi);oy=o($0,"TFPreTrainedModel"),$0.forEach(n),sy=o(Wu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Wu.forEach(n),ry=d(kn),Na=a(kn,"P",{});var Qu=i(Na);ay=o(Qu,"This model is also a "),Sa=a(Qu,"A",{href:!0,rel:!0});var E0=i(Sa);iy=o(E0,"tf.keras.Model"),E0.forEach(n),ly=o(Qu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Qu.forEach(n),dy=d(kn),F(Po.$$.fragment,kn),cy=d(kn),nn=a(kn,"DIV",{class:!0});var Dn=i(nn);F(Ia.$$.fragment,Dn),py=d(Dn),At=a(Dn,"P",{});var _l=i(At);uy=o(_l,"The "),Vi=a(_l,"A",{href:!0});var M0=i(Vi);hy=o(M0,"TFFunnelForTokenClassification"),M0.forEach(n),fy=o(_l," forward method, overrides the "),ac=a(_l,"CODE",{});var z0=i(ac);my=o(z0,"__call__"),z0.forEach(n),gy=o(_l," special method."),_l.forEach(n),_y=d(Dn),F(jo.$$.fragment,Dn),vy=d(Dn),ic=a(Dn,"P",{});var q0=i(ic);Ty=o(q0,"Example:"),q0.forEach(n),ky=d(Dn),F(Ba.$$.fragment,Dn),Fy=d(Dn),F(Wa.$$.fragment,Dn),Dn.forEach(n),kn.forEach(n),Fp=d(s),Nt=a(s,"H2",{class:!0});var Uu=i(Nt);Co=a(Uu,"A",{id:!0,class:!0,href:!0});var P0=i(Co);lc=a(P0,"SPAN",{});var j0=i(lc);F(Qa.$$.fragment,j0),j0.forEach(n),P0.forEach(n),yy=d(Uu),dc=a(Uu,"SPAN",{});var C0=i(dc);wy=o(C0,"TFFunnelForQuestionAnswering"),C0.forEach(n),Uu.forEach(n),yp=d(s),Be=a(s,"DIV",{class:!0});var Fn=i(Be);F(Ua.$$.fragment,Fn),by=d(Fn),St=a(Fn,"P",{});var vl=i(St);$y=o(vl,`Funnel Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear
layers on top of the hidden-states output to compute `),cc=a(vl,"CODE",{});var x0=i(cc);Ey=o(x0,"span start logits"),x0.forEach(n),My=o(vl," and "),pc=a(vl,"CODE",{});var L0=i(pc);zy=o(L0,"span end logits"),L0.forEach(n),qy=o(vl,")."),vl.forEach(n),Py=d(Fn),Ra=a(Fn,"P",{});var Ru=i(Ra);jy=o(Ru,"The Funnel Transformer model was proposed in "),Ha=a(Ru,"A",{href:!0,rel:!0});var O0=i(Ha);Cy=o(O0,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),O0.forEach(n),xy=o(Ru," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Ru.forEach(n),Ly=d(Fn),Va=a(Fn,"P",{});var Hu=i(Va);Oy=o(Hu,"This model inherits from "),Yi=a(Hu,"A",{href:!0});var D0=i(Yi);Dy=o(D0,"TFPreTrainedModel"),D0.forEach(n),Ay=o(Hu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Hu.forEach(n),Ny=d(Fn),Ya=a(Fn,"P",{});var Vu=i(Ya);Sy=o(Vu,"This model is also a "),Ka=a(Vu,"A",{href:!0,rel:!0});var A0=i(Ka);Iy=o(A0,"tf.keras.Model"),A0.forEach(n),By=o(Vu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Vu.forEach(n),Wy=d(Fn),F(xo.$$.fragment,Fn),Qy=d(Fn),tn=a(Fn,"DIV",{class:!0});var An=i(tn);F(Ga.$$.fragment,An),Uy=d(An),It=a(An,"P",{});var Tl=i(It);Ry=o(Tl,"The "),Ki=a(Tl,"A",{href:!0});var N0=i(Ki);Hy=o(N0,"TFFunnelForQuestionAnswering"),N0.forEach(n),Vy=o(Tl," forward method, overrides the "),uc=a(Tl,"CODE",{});var S0=i(uc);Yy=o(S0,"__call__"),S0.forEach(n),Ky=o(Tl," special method."),Tl.forEach(n),Gy=d(An),F(Lo.$$.fragment,An),Zy=d(An),hc=a(An,"P",{});var I0=i(hc);Xy=o(I0,"Example:"),I0.forEach(n),Jy=d(An),F(Za.$$.fragment,An),e1=d(An),F(Xa.$$.fragment,An),An.forEach(n),Fn.forEach(n),this.h()},h(){c(u,"name","hf:doc:metadata"),c(u,"content",JSON.stringify(_$)),c(_,"id","funnel-transformer"),c(_,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(_,"href","#funnel-transformer"),c(g,"class","relative group"),c(J,"id","overview"),c(J,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(J,"href","#overview"),c(q,"class","relative group"),c(te,"href","https://arxiv.org/abs/2006.03236"),c(te,"rel","nofollow"),c(re,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelModel"),c(p,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelForPreTraining"),c(ve,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelForMaskedLM"),c(Te,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelForTokenClassification"),c(ke,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelBaseModel"),c(Fe,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelForSequenceClassification"),c(oi,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelForMultipleChoice"),c(No,"href","https://huggingface.co/sgugger"),c(No,"rel","nofollow"),c(So,"href","https://github.com/laiguokun/Funnel-Transformer"),c(So,"rel","nofollow"),c(Bt,"id","transformers.FunnelConfig"),c(Bt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Bt,"href","#transformers.FunnelConfig"),c(Zn,"class","relative group"),c(si,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelModel"),c(ri,"href","/docs/transformers/v4.18.0/en/model_doc/bert#transformers.TFBertModel"),c(Wo,"href","https://huggingface.co/funnel-transformer/small"),c(Wo,"rel","nofollow"),c(ai,"href","/docs/transformers/v4.18.0/en/main_classes/configuration#transformers.PretrainedConfig"),c(ii,"href","/docs/transformers/v4.18.0/en/main_classes/configuration#transformers.PretrainedConfig"),c(Nn,"class","docstring"),c(Wt,"id","transformers.FunnelTokenizer"),c(Wt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Wt,"href","#transformers.FunnelTokenizer"),c(Jn,"class","relative group"),c(li,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelTokenizer"),c(di,"href","/docs/transformers/v4.18.0/en/model_doc/bert#transformers.BertTokenizer"),c(ci,"href","/docs/transformers/v4.18.0/en/model_doc/bert#transformers.BertTokenizer"),c(Bn,"class","docstring"),c(Ut,"class","docstring"),c(yn,"class","docstring"),c(hi,"class","docstring"),c(Ce,"class","docstring"),c(Rt,"id","transformers.FunnelTokenizerFast"),c(Rt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Rt,"href","#transformers.FunnelTokenizerFast"),c(nt,"class","relative group"),c(fi,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelTokenizerFast"),c(mi,"href","/docs/transformers/v4.18.0/en/model_doc/bert#transformers.BertTokenizerFast"),c(gi,"href","/docs/transformers/v4.18.0/en/model_doc/bert#transformers.BertTokenizerFast"),c(wn,"class","docstring"),c(sn,"class","docstring"),c(Vt,"id","transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput"),c(Vt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Vt,"href","#transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput"),c(ot,"class","relative group"),c(_i,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelForPreTraining"),c(st,"class","docstring"),c(vi,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelForPreTraining"),c(rt,"class","docstring"),c(Yt,"id","transformers.FunnelBaseModel"),c(Yt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Yt,"href","#transformers.FunnelBaseModel"),c(at,"class","relative group"),c(hs,"href","https://arxiv.org/abs/2006.03236"),c(hs,"rel","nofollow"),c(Ti,"href","/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel"),c(gs,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(gs,"rel","nofollow"),c(ki,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelBaseModel"),c(rn,"class","docstring"),c(Qe,"class","docstring"),c(Gt,"id","transformers.FunnelModel"),c(Gt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Gt,"href","#transformers.FunnelModel"),c(lt,"class","relative group"),c(ys,"href","https://arxiv.org/abs/2006.03236"),c(ys,"rel","nofollow"),c(Fi,"href","/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel"),c($s,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c($s,"rel","nofollow"),c(yi,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelModel"),c(an,"class","docstring"),c(Ue,"class","docstring"),c(Xt,"id","transformers.FunnelForPreTraining"),c(Xt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Xt,"href","#transformers.FunnelForPreTraining"),c(ct,"class","relative group"),c(wi,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelForPreTraining"),c(ln,"class","docstring"),c(pt,"class","docstring"),c(eo,"id","transformers.FunnelForMaskedLM"),c(eo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(eo,"href","#transformers.FunnelForMaskedLM"),c(ht,"class","relative group"),c(Ds,"href","https://arxiv.org/abs/2006.03236"),c(Ds,"rel","nofollow"),c(bi,"href","/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel"),c(Ss,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(Ss,"rel","nofollow"),c($i,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelForMaskedLM"),c(Ge,"class","docstring"),c(Re,"class","docstring"),c(to,"id","transformers.FunnelForSequenceClassification"),c(to,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(to,"href","#transformers.FunnelForSequenceClassification"),c(mt,"class","relative group"),c(Hs,"href","https://arxiv.org/abs/2006.03236"),c(Hs,"rel","nofollow"),c(Ei,"href","/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel"),c(Ks,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(Ks,"rel","nofollow"),c(Mi,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelForSequenceClassification"),c(Pe,"class","docstring"),c(He,"class","docstring"),c(so,"id","transformers.FunnelForMultipleChoice"),c(so,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(so,"href","#transformers.FunnelForMultipleChoice"),c(_t,"class","relative group"),c(sr,"href","https://arxiv.org/abs/2006.03236"),c(sr,"rel","nofollow"),c(zi,"href","/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel"),c(ir,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(ir,"rel","nofollow"),c(qi,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelForMultipleChoice"),c(dn,"class","docstring"),c(Ve,"class","docstring"),c(ao,"id","transformers.FunnelForTokenClassification"),c(ao,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(ao,"href","#transformers.FunnelForTokenClassification"),c(Tt,"class","relative group"),c(hr,"href","https://arxiv.org/abs/2006.03236"),c(hr,"rel","nofollow"),c(Pi,"href","/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel"),c(gr,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(gr,"rel","nofollow"),c(ji,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelForTokenClassification"),c(Ze,"class","docstring"),c(Ye,"class","docstring"),c(lo,"id","transformers.FunnelForQuestionAnswering"),c(lo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(lo,"href","#transformers.FunnelForQuestionAnswering"),c(Ft,"class","relative group"),c(wr,"href","https://arxiv.org/abs/2006.03236"),c(wr,"rel","nofollow"),c(Ci,"href","/docs/transformers/v4.18.0/en/main_classes/model#transformers.PreTrainedModel"),c(Er,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(Er,"rel","nofollow"),c(xi,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.FunnelForQuestionAnswering"),c(Xe,"class","docstring"),c(Ke,"class","docstring"),c(po,"id","transformers.TFFunnelBaseModel"),c(po,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(po,"href","#transformers.TFFunnelBaseModel"),c(bt,"class","relative group"),c(xr,"href","https://arxiv.org/abs/2006.03236"),c(xr,"rel","nofollow"),c(Li,"href","/docs/transformers/v4.18.0/en/main_classes/model#transformers.TFPreTrainedModel"),c(Dr,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Dr,"rel","nofollow"),c(Oi,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.TFFunnelBaseModel"),c(cn,"class","docstring"),c(Le,"class","docstring"),c(fo,"id","transformers.TFFunnelModel"),c(fo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(fo,"href","#transformers.TFFunnelModel"),c(Et,"class","relative group"),c(Wr,"href","https://arxiv.org/abs/2006.03236"),c(Wr,"rel","nofollow"),c(Di,"href","/docs/transformers/v4.18.0/en/main_classes/model#transformers.TFPreTrainedModel"),c(Rr,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Rr,"rel","nofollow"),c(Ai,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.TFFunnelModel"),c(pn,"class","docstring"),c(Oe,"class","docstring"),c(_o,"id","transformers.TFFunnelForPreTraining"),c(_o,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(_o,"href","#transformers.TFFunnelForPreTraining"),c(zt,"class","relative group"),c(Zr,"href","https://arxiv.org/abs/2006.03236"),c(Zr,"rel","nofollow"),c(Ni,"href","/docs/transformers/v4.18.0/en/main_classes/model#transformers.TFPreTrainedModel"),c(ea,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(ea,"rel","nofollow"),c(Si,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.TFFunnelForPreTraining"),c(un,"class","docstring"),c(De,"class","docstring"),c(ko,"id","transformers.TFFunnelForMaskedLM"),c(ko,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(ko,"href","#transformers.TFFunnelForMaskedLM"),c(Pt,"class","relative group"),c(ia,"href","https://arxiv.org/abs/2006.03236"),c(ia,"rel","nofollow"),c(Ii,"href","/docs/transformers/v4.18.0/en/main_classes/model#transformers.TFPreTrainedModel"),c(ca,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(ca,"rel","nofollow"),c(Bi,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.TFFunnelForMaskedLM"),c(Je,"class","docstring"),c(Ae,"class","docstring"),c(wo,"id","transformers.TFFunnelForSequenceClassification"),c(wo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(wo,"href","#transformers.TFFunnelForSequenceClassification"),c(Ct,"class","relative group"),c(_a,"href","https://arxiv.org/abs/2006.03236"),c(_a,"rel","nofollow"),c(Wi,"href","/docs/transformers/v4.18.0/en/main_classes/model#transformers.TFPreTrainedModel"),c(ka,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(ka,"rel","nofollow"),c(Qi,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.TFFunnelForSequenceClassification"),c(en,"class","docstring"),c(Ne,"class","docstring"),c(Eo,"id","transformers.TFFunnelForMultipleChoice"),c(Eo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Eo,"href","#transformers.TFFunnelForMultipleChoice"),c(Lt,"class","relative group"),c(Ma,"href","https://arxiv.org/abs/2006.03236"),c(Ma,"rel","nofollow"),c(Ui,"href","/docs/transformers/v4.18.0/en/main_classes/model#transformers.TFPreTrainedModel"),c(Pa,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Pa,"rel","nofollow"),c(Ri,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.TFFunnelForMultipleChoice"),c(hn,"class","docstring"),c(Se,"class","docstring"),c(qo,"id","transformers.TFFunnelForTokenClassification"),c(qo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(qo,"href","#transformers.TFFunnelForTokenClassification"),c(Dt,"class","relative group"),c(Da,"href","https://arxiv.org/abs/2006.03236"),c(Da,"rel","nofollow"),c(Hi,"href","/docs/transformers/v4.18.0/en/main_classes/model#transformers.TFPreTrainedModel"),c(Sa,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Sa,"rel","nofollow"),c(Vi,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.TFFunnelForTokenClassification"),c(nn,"class","docstring"),c(Ie,"class","docstring"),c(Co,"id","transformers.TFFunnelForQuestionAnswering"),c(Co,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Co,"href","#transformers.TFFunnelForQuestionAnswering"),c(Nt,"class","relative group"),c(Ha,"href","https://arxiv.org/abs/2006.03236"),c(Ha,"rel","nofollow"),c(Yi,"href","/docs/transformers/v4.18.0/en/main_classes/model#transformers.TFPreTrainedModel"),c(Ka,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Ka,"rel","nofollow"),c(Ki,"href","/docs/transformers/v4.18.0/en/model_doc/funnel#transformers.TFFunnelForQuestionAnswering"),c(tn,"class","docstring"),c(Be,"class","docstring")},m(s,f){e(document.head,u),h(s,z,f),h(s,g,f),e(g,_),e(_,T),y(v,T,null),e(g,m),e(g,M),e(M,ce),h(s,K,f),h(s,q,f),e(q,J),e(J,A),y(ne,A,null),e(q,pe),e(q,N),e(N,ue),h(s,ie,f),h(s,Y,f),e(Y,L),e(Y,te),e(te,G),e(Y,P),h(s,C,f),h(s,oe,f),e(oe,W),h(s,le,f),h(s,se,f),e(se,S),e(S,he),h(s,de,f),h(s,j,f),e(j,fe),h(s,B,f),h(s,ee,f),e(ee,ae),e(ae,Q),e(ee,me),e(ee,I),e(I,O),e(I,re),e(re,U),e(I,ge),e(I,p),e(p,E),e(I,Z),e(I,ve),e(ve,we),e(I,D),e(I,Te),e(Te,be),e(I,$e),e(I,x),e(x,R),e(I,Ee),e(I,ke),e(ke,H),e(I,Me),e(I,Fe),e(Fe,_e),e(I,ze),e(I,oi),e(oi,Yu),e(I,Ku),h(s,Oc,f),h(s,In,f),e(In,Gu),e(In,No),e(No,Zu),e(In,Xu),e(In,So),e(So,Ju),e(In,eh),h(s,Dc,f),h(s,Zn,f),e(Zn,Bt),e(Bt,kl),y(Io,kl,null),e(Zn,nh),e(Zn,Fl),e(Fl,th),h(s,Ac,f),h(s,Nn,f),y(Bo,Nn,null),e(Nn,oh),e(Nn,Sn),e(Sn,sh),e(Sn,si),e(si,rh),e(Sn,ah),e(Sn,ri),e(ri,ih),e(Sn,lh),e(Sn,Wo),e(Wo,dh),e(Sn,ch),e(Nn,ph),e(Nn,Xn),e(Xn,uh),e(Xn,ai),e(ai,hh),e(Xn,fh),e(Xn,ii),e(ii,mh),e(Xn,gh),h(s,Nc,f),h(s,Jn,f),e(Jn,Wt),e(Wt,yl),y(Qo,yl,null),e(Jn,_h),e(Jn,wl),e(wl,vh),h(s,Sc,f),h(s,Ce,f),y(Uo,Ce,null),e(Ce,Th),e(Ce,bl),e(bl,kh),e(Ce,Fh),e(Ce,Qt),e(Qt,li),e(li,yh),e(Qt,wh),e(Qt,di),e(di,bh),e(Qt,$h),e(Ce,Eh),e(Ce,Ro),e(Ro,Mh),e(Ro,ci),e(ci,zh),e(Ro,qh),e(Ce,Ph),e(Ce,Bn),y(Ho,Bn,null),e(Bn,jh),e(Bn,$l),e($l,Ch),e(Bn,xh),e(Bn,Vo),e(Vo,pi),e(pi,Lh),e(pi,El),e(El,Oh),e(Vo,Dh),e(Vo,ui),e(ui,Ah),e(ui,Ml),e(Ml,Nh),e(Ce,Sh),e(Ce,Ut),y(Yo,Ut,null),e(Ut,Ih),e(Ut,Ko),e(Ko,Bh),e(Ko,zl),e(zl,Wh),e(Ko,Qh),e(Ce,Uh),e(Ce,yn),y(Go,yn,null),e(yn,Rh),e(yn,ql),e(ql,Hh),e(yn,Vh),y(Zo,yn,null),e(yn,Yh),e(yn,et),e(et,Kh),e(et,Pl),e(Pl,Gh),e(et,Zh),e(et,jl),e(jl,Xh),e(et,Jh),e(Ce,ef),e(Ce,hi),y(Xo,hi,null),h(s,Ic,f),h(s,nt,f),e(nt,Rt),e(Rt,Cl),y(Jo,Cl,null),e(nt,nf),e(nt,xl),e(xl,tf),h(s,Bc,f),h(s,sn,f),y(es,sn,null),e(sn,of),e(sn,ns),e(ns,sf),e(ns,Ll),e(Ll,rf),e(ns,af),e(sn,lf),e(sn,Ht),e(Ht,fi),e(fi,df),e(Ht,cf),e(Ht,mi),e(mi,pf),e(Ht,uf),e(sn,hf),e(sn,ts),e(ts,ff),e(ts,gi),e(gi,mf),e(ts,gf),e(sn,_f),e(sn,wn),y(os,wn,null),e(wn,vf),e(wn,Ol),e(Ol,Tf),e(wn,kf),y(ss,wn,null),e(wn,Ff),e(wn,tt),e(tt,yf),e(tt,Dl),e(Dl,wf),e(tt,bf),e(tt,Al),e(Al,$f),e(tt,Ef),h(s,Wc,f),h(s,ot,f),e(ot,Vt),e(Vt,Nl),y(rs,Nl,null),e(ot,Mf),e(ot,Sl),e(Sl,zf),h(s,Qc,f),h(s,st,f),y(as,st,null),e(st,qf),e(st,is),e(is,Pf),e(is,_i),e(_i,jf),e(is,Cf),h(s,Uc,f),h(s,rt,f),y(ls,rt,null),e(rt,xf),e(rt,ds),e(ds,Lf),e(ds,vi),e(vi,Of),e(ds,Df),h(s,Rc,f),h(s,at,f),e(at,Yt),e(Yt,Il),y(cs,Il,null),e(at,Af),e(at,Bl),e(Bl,Nf),h(s,Hc,f),h(s,Qe,f),y(ps,Qe,null),e(Qe,Sf),e(Qe,Wl),e(Wl,If),e(Qe,Bf),e(Qe,us),e(us,Wf),e(us,hs),e(hs,Qf),e(us,Uf),e(Qe,Rf),e(Qe,fs),e(fs,Hf),e(fs,Ti),e(Ti,Vf),e(fs,Yf),e(Qe,Kf),e(Qe,ms),e(ms,Gf),e(ms,gs),e(gs,Zf),e(ms,Xf),e(Qe,Jf),e(Qe,rn),y(_s,rn,null),e(rn,em),e(rn,it),e(it,nm),e(it,ki),e(ki,tm),e(it,om),e(it,Ql),e(Ql,sm),e(it,rm),e(rn,am),y(Kt,rn,null),e(rn,im),e(rn,Ul),e(Ul,lm),e(rn,dm),y(vs,rn,null),h(s,Vc,f),h(s,lt,f),e(lt,Gt),e(Gt,Rl),y(Ts,Rl,null),e(lt,cm),e(lt,Hl),e(Hl,pm),h(s,Yc,f),h(s,Ue,f),y(ks,Ue,null),e(Ue,um),e(Ue,Vl),e(Vl,hm),e(Ue,fm),e(Ue,Fs),e(Fs,mm),e(Fs,ys),e(ys,gm),e(Fs,_m),e(Ue,vm),e(Ue,ws),e(ws,Tm),e(ws,Fi),e(Fi,km),e(ws,Fm),e(Ue,ym),e(Ue,bs),e(bs,wm),e(bs,$s),e($s,bm),e(bs,$m),e(Ue,Em),e(Ue,an),y(Es,an,null),e(an,Mm),e(an,dt),e(dt,zm),e(dt,yi),e(yi,qm),e(dt,Pm),e(dt,Yl),e(Yl,jm),e(dt,Cm),e(an,xm),y(Zt,an,null),e(an,Lm),e(an,Kl),e(Kl,Om),e(an,Dm),y(Ms,an,null),h(s,Kc,f),h(s,ct,f),e(ct,Xt),e(Xt,Gl),y(zs,Gl,null),e(ct,Am),e(ct,Zl),e(Zl,Nm),h(s,Gc,f),h(s,pt,f),y(qs,pt,null),e(pt,Sm),e(pt,ln),y(Ps,ln,null),e(ln,Im),e(ln,ut),e(ut,Bm),e(ut,wi),e(wi,Wm),e(ut,Qm),e(ut,Xl),e(Xl,Um),e(ut,Rm),e(ln,Hm),y(Jt,ln,null),e(ln,Vm),e(ln,Jl),e(Jl,Ym),e(ln,Km),y(js,ln,null),h(s,Zc,f),h(s,ht,f),e(ht,eo),e(eo,ed),y(Cs,ed,null),e(ht,Gm),e(ht,nd),e(nd,Zm),h(s,Xc,f),h(s,Re,f),y(xs,Re,null),e(Re,Xm),e(Re,Ls),e(Ls,Jm),e(Ls,td),e(td,eg),e(Ls,ng),e(Re,tg),e(Re,Os),e(Os,og),e(Os,Ds),e(Ds,sg),e(Os,rg),e(Re,ag),e(Re,As),e(As,ig),e(As,bi),e(bi,lg),e(As,dg),e(Re,cg),e(Re,Ns),e(Ns,pg),e(Ns,Ss),e(Ss,ug),e(Ns,hg),e(Re,fg),e(Re,Ge),y(Is,Ge,null),e(Ge,mg),e(Ge,ft),e(ft,gg),e(ft,$i),e($i,_g),e(ft,vg),e(ft,od),e(od,Tg),e(ft,kg),e(Ge,Fg),y(no,Ge,null),e(Ge,yg),e(Ge,sd),e(sd,wg),e(Ge,bg),y(Bs,Ge,null),e(Ge,$g),y(Ws,Ge,null),h(s,Jc,f),h(s,mt,f),e(mt,to),e(to,rd),y(Qs,rd,null),e(mt,Eg),e(mt,ad),e(ad,Mg),h(s,ep,f),h(s,He,f),y(Us,He,null),e(He,zg),e(He,id),e(id,qg),e(He,Pg),e(He,Rs),e(Rs,jg),e(Rs,Hs),e(Hs,Cg),e(Rs,xg),e(He,Lg),e(He,Vs),e(Vs,Og),e(Vs,Ei),e(Ei,Dg),e(Vs,Ag),e(He,Ng),e(He,Ys),e(Ys,Sg),e(Ys,Ks),e(Ks,Ig),e(Ys,Bg),e(He,Wg),e(He,Pe),y(Gs,Pe,null),e(Pe,Qg),e(Pe,gt),e(gt,Ug),e(gt,Mi),e(Mi,Rg),e(gt,Hg),e(gt,ld),e(ld,Vg),e(gt,Yg),e(Pe,Kg),y(oo,Pe,null),e(Pe,Gg),e(Pe,dd),e(dd,Zg),e(Pe,Xg),y(Zs,Pe,null),e(Pe,Jg),y(Xs,Pe,null),e(Pe,e_),e(Pe,cd),e(cd,n_),e(Pe,t_),y(Js,Pe,null),e(Pe,o_),y(er,Pe,null),h(s,np,f),h(s,_t,f),e(_t,so),e(so,pd),y(nr,pd,null),e(_t,s_),e(_t,ud),e(ud,r_),h(s,tp,f),h(s,Ve,f),y(tr,Ve,null),e(Ve,a_),e(Ve,hd),e(hd,i_),e(Ve,l_),e(Ve,or),e(or,d_),e(or,sr),e(sr,c_),e(or,p_),e(Ve,u_),e(Ve,rr),e(rr,h_),e(rr,zi),e(zi,f_),e(rr,m_),e(Ve,g_),e(Ve,ar),e(ar,__),e(ar,ir),e(ir,v_),e(ar,T_),e(Ve,k_),e(Ve,dn),y(lr,dn,null),e(dn,F_),e(dn,vt),e(vt,y_),e(vt,qi),e(qi,w_),e(vt,b_),e(vt,fd),e(fd,$_),e(vt,E_),e(dn,M_),y(ro,dn,null),e(dn,z_),e(dn,md),e(md,q_),e(dn,P_),y(dr,dn,null),h(s,op,f),h(s,Tt,f),e(Tt,ao),e(ao,gd),y(cr,gd,null),e(Tt,j_),e(Tt,_d),e(_d,C_),h(s,sp,f),h(s,Ye,f),y(pr,Ye,null),e(Ye,x_),e(Ye,vd),e(vd,L_),e(Ye,O_),e(Ye,ur),e(ur,D_),e(ur,hr),e(hr,A_),e(ur,N_),e(Ye,S_),e(Ye,fr),e(fr,I_),e(fr,Pi),e(Pi,B_),e(fr,W_),e(Ye,Q_),e(Ye,mr),e(mr,U_),e(mr,gr),e(gr,R_),e(mr,H_),e(Ye,V_),e(Ye,Ze),y(_r,Ze,null),e(Ze,Y_),e(Ze,kt),e(kt,K_),e(kt,ji),e(ji,G_),e(kt,Z_),e(kt,Td),e(Td,X_),e(kt,J_),e(Ze,ev),y(io,Ze,null),e(Ze,nv),e(Ze,kd),e(kd,tv),e(Ze,ov),y(vr,Ze,null),e(Ze,sv),y(Tr,Ze,null),h(s,rp,f),h(s,Ft,f),e(Ft,lo),e(lo,Fd),y(kr,Fd,null),e(Ft,rv),e(Ft,yd),e(yd,av),h(s,ap,f),h(s,Ke,f),y(Fr,Ke,null),e(Ke,iv),e(Ke,yt),e(yt,lv),e(yt,wd),e(wd,dv),e(yt,cv),e(yt,bd),e(bd,pv),e(yt,uv),e(Ke,hv),e(Ke,yr),e(yr,fv),e(yr,wr),e(wr,mv),e(yr,gv),e(Ke,_v),e(Ke,br),e(br,vv),e(br,Ci),e(Ci,Tv),e(br,kv),e(Ke,Fv),e(Ke,$r),e($r,yv),e($r,Er),e(Er,wv),e($r,bv),e(Ke,$v),e(Ke,Xe),y(Mr,Xe,null),e(Xe,Ev),e(Xe,wt),e(wt,Mv),e(wt,xi),e(xi,zv),e(wt,qv),e(wt,$d),e($d,Pv),e(wt,jv),e(Xe,Cv),y(co,Xe,null),e(Xe,xv),e(Xe,Ed),e(Ed,Lv),e(Xe,Ov),y(zr,Xe,null),e(Xe,Dv),y(qr,Xe,null),h(s,ip,f),h(s,bt,f),e(bt,po),e(po,Md),y(Pr,Md,null),e(bt,Av),e(bt,zd),e(zd,Nv),h(s,lp,f),h(s,Le,f),y(jr,Le,null),e(Le,Sv),e(Le,qd),e(qd,Iv),e(Le,Bv),e(Le,Cr),e(Cr,Wv),e(Cr,xr),e(xr,Qv),e(Cr,Uv),e(Le,Rv),e(Le,Lr),e(Lr,Hv),e(Lr,Li),e(Li,Vv),e(Lr,Yv),e(Le,Kv),e(Le,Or),e(Or,Gv),e(Or,Dr),e(Dr,Zv),e(Or,Xv),e(Le,Jv),y(uo,Le,null),e(Le,eT),e(Le,cn),y(Ar,cn,null),e(cn,nT),e(cn,$t),e($t,tT),e($t,Oi),e(Oi,oT),e($t,sT),e($t,Pd),e(Pd,rT),e($t,aT),e(cn,iT),y(ho,cn,null),e(cn,lT),e(cn,jd),e(jd,dT),e(cn,cT),y(Nr,cn,null),h(s,dp,f),h(s,Et,f),e(Et,fo),e(fo,Cd),y(Sr,Cd,null),e(Et,pT),e(Et,xd),e(xd,uT),h(s,cp,f),h(s,Oe,f),y(Ir,Oe,null),e(Oe,hT),e(Oe,Ld),e(Ld,fT),e(Oe,mT),e(Oe,Br),e(Br,gT),e(Br,Wr),e(Wr,_T),e(Br,vT),e(Oe,TT),e(Oe,Qr),e(Qr,kT),e(Qr,Di),e(Di,FT),e(Qr,yT),e(Oe,wT),e(Oe,Ur),e(Ur,bT),e(Ur,Rr),e(Rr,$T),e(Ur,ET),e(Oe,MT),y(mo,Oe,null),e(Oe,zT),e(Oe,pn),y(Hr,pn,null),e(pn,qT),e(pn,Mt),e(Mt,PT),e(Mt,Ai),e(Ai,jT),e(Mt,CT),e(Mt,Od),e(Od,xT),e(Mt,LT),e(pn,OT),y(go,pn,null),e(pn,DT),e(pn,Dd),e(Dd,AT),e(pn,NT),y(Vr,pn,null),h(s,pp,f),h(s,zt,f),e(zt,_o),e(_o,Ad),y(Yr,Ad,null),e(zt,ST),e(zt,Nd),e(Nd,IT),h(s,up,f),h(s,De,f),y(Kr,De,null),e(De,BT),e(De,Sd),e(Sd,WT),e(De,QT),e(De,Gr),e(Gr,UT),e(Gr,Zr),e(Zr,RT),e(Gr,HT),e(De,VT),e(De,Xr),e(Xr,YT),e(Xr,Ni),e(Ni,KT),e(Xr,GT),e(De,ZT),e(De,Jr),e(Jr,XT),e(Jr,ea),e(ea,JT),e(Jr,ek),e(De,nk),y(vo,De,null),e(De,tk),e(De,un),y(na,un,null),e(un,ok),e(un,qt),e(qt,sk),e(qt,Si),e(Si,rk),e(qt,ak),e(qt,Id),e(Id,ik),e(qt,lk),e(un,dk),y(To,un,null),e(un,ck),e(un,Bd),e(Bd,pk),e(un,uk),y(ta,un,null),h(s,hp,f),h(s,Pt,f),e(Pt,ko),e(ko,Wd),y(oa,Wd,null),e(Pt,hk),e(Pt,Qd),e(Qd,fk),h(s,fp,f),h(s,Ae,f),y(sa,Ae,null),e(Ae,mk),e(Ae,ra),e(ra,gk),e(ra,Ud),e(Ud,_k),e(ra,vk),e(Ae,Tk),e(Ae,aa),e(aa,kk),e(aa,ia),e(ia,Fk),e(aa,yk),e(Ae,wk),e(Ae,la),e(la,bk),e(la,Ii),e(Ii,$k),e(la,Ek),e(Ae,Mk),e(Ae,da),e(da,zk),e(da,ca),e(ca,qk),e(da,Pk),e(Ae,jk),y(Fo,Ae,null),e(Ae,Ck),e(Ae,Je),y(pa,Je,null),e(Je,xk),e(Je,jt),e(jt,Lk),e(jt,Bi),e(Bi,Ok),e(jt,Dk),e(jt,Rd),e(Rd,Ak),e(jt,Nk),e(Je,Sk),y(yo,Je,null),e(Je,Ik),e(Je,Hd),e(Hd,Bk),e(Je,Wk),y(ua,Je,null),e(Je,Qk),y(ha,Je,null),h(s,mp,f),h(s,Ct,f),e(Ct,wo),e(wo,Vd),y(fa,Vd,null),e(Ct,Uk),e(Ct,Yd),e(Yd,Rk),h(s,gp,f),h(s,Ne,f),y(ma,Ne,null),e(Ne,Hk),e(Ne,Kd),e(Kd,Vk),e(Ne,Yk),e(Ne,ga),e(ga,Kk),e(ga,_a),e(_a,Gk),e(ga,Zk),e(Ne,Xk),e(Ne,va),e(va,Jk),e(va,Wi),e(Wi,eF),e(va,nF),e(Ne,tF),e(Ne,Ta),e(Ta,oF),e(Ta,ka),e(ka,sF),e(Ta,rF),e(Ne,aF),y(bo,Ne,null),e(Ne,iF),e(Ne,en),y(Fa,en,null),e(en,lF),e(en,xt),e(xt,dF),e(xt,Qi),e(Qi,cF),e(xt,pF),e(xt,Gd),e(Gd,uF),e(xt,hF),e(en,fF),y($o,en,null),e(en,mF),e(en,Zd),e(Zd,gF),e(en,_F),y(ya,en,null),e(en,vF),y(wa,en,null),h(s,_p,f),h(s,Lt,f),e(Lt,Eo),e(Eo,Xd),y(ba,Xd,null),e(Lt,TF),e(Lt,Jd),e(Jd,kF),h(s,vp,f),h(s,Se,f),y($a,Se,null),e(Se,FF),e(Se,ec),e(ec,yF),e(Se,wF),e(Se,Ea),e(Ea,bF),e(Ea,Ma),e(Ma,$F),e(Ea,EF),e(Se,MF),e(Se,za),e(za,zF),e(za,Ui),e(Ui,qF),e(za,PF),e(Se,jF),e(Se,qa),e(qa,CF),e(qa,Pa),e(Pa,xF),e(qa,LF),e(Se,OF),y(Mo,Se,null),e(Se,DF),e(Se,hn),y(ja,hn,null),e(hn,AF),e(hn,Ot),e(Ot,NF),e(Ot,Ri),e(Ri,SF),e(Ot,IF),e(Ot,nc),e(nc,BF),e(Ot,WF),e(hn,QF),y(zo,hn,null),e(hn,UF),e(hn,tc),e(tc,RF),e(hn,HF),y(Ca,hn,null),h(s,Tp,f),h(s,Dt,f),e(Dt,qo),e(qo,oc),y(xa,oc,null),e(Dt,VF),e(Dt,sc),e(sc,YF),h(s,kp,f),h(s,Ie,f),y(La,Ie,null),e(Ie,KF),e(Ie,rc),e(rc,GF),e(Ie,ZF),e(Ie,Oa),e(Oa,XF),e(Oa,Da),e(Da,JF),e(Oa,ey),e(Ie,ny),e(Ie,Aa),e(Aa,ty),e(Aa,Hi),e(Hi,oy),e(Aa,sy),e(Ie,ry),e(Ie,Na),e(Na,ay),e(Na,Sa),e(Sa,iy),e(Na,ly),e(Ie,dy),y(Po,Ie,null),e(Ie,cy),e(Ie,nn),y(Ia,nn,null),e(nn,py),e(nn,At),e(At,uy),e(At,Vi),e(Vi,hy),e(At,fy),e(At,ac),e(ac,my),e(At,gy),e(nn,_y),y(jo,nn,null),e(nn,vy),e(nn,ic),e(ic,Ty),e(nn,ky),y(Ba,nn,null),e(nn,Fy),y(Wa,nn,null),h(s,Fp,f),h(s,Nt,f),e(Nt,Co),e(Co,lc),y(Qa,lc,null),e(Nt,yy),e(Nt,dc),e(dc,wy),h(s,yp,f),h(s,Be,f),y(Ua,Be,null),e(Be,by),e(Be,St),e(St,$y),e(St,cc),e(cc,Ey),e(St,My),e(St,pc),e(pc,zy),e(St,qy),e(Be,Py),e(Be,Ra),e(Ra,jy),e(Ra,Ha),e(Ha,Cy),e(Ra,xy),e(Be,Ly),e(Be,Va),e(Va,Oy),e(Va,Yi),e(Yi,Dy),e(Va,Ay),e(Be,Ny),e(Be,Ya),e(Ya,Sy),e(Ya,Ka),e(Ka,Iy),e(Ya,By),e(Be,Wy),y(xo,Be,null),e(Be,Qy),e(Be,tn),y(Ga,tn,null),e(tn,Uy),e(tn,It),e(It,Ry),e(It,Ki),e(Ki,Hy),e(It,Vy),e(It,uc),e(uc,Yy),e(It,Ky),e(tn,Gy),y(Lo,tn,null),e(tn,Zy),e(tn,hc),e(hc,Xy),e(tn,Jy),y(Za,tn,null),e(tn,e1),y(Xa,tn,null),wp=!0},p(s,[f]){const Ja={};f&2&&(Ja.$$scope={dirty:f,ctx:s}),Kt.$set(Ja);const fc={};f&2&&(fc.$$scope={dirty:f,ctx:s}),Zt.$set(fc);const mc={};f&2&&(mc.$$scope={dirty:f,ctx:s}),Jt.$set(mc);const gc={};f&2&&(gc.$$scope={dirty:f,ctx:s}),no.$set(gc);const ei={};f&2&&(ei.$$scope={dirty:f,ctx:s}),oo.$set(ei);const _c={};f&2&&(_c.$$scope={dirty:f,ctx:s}),ro.$set(_c);const vc={};f&2&&(vc.$$scope={dirty:f,ctx:s}),io.$set(vc);const Tc={};f&2&&(Tc.$$scope={dirty:f,ctx:s}),co.$set(Tc);const ni={};f&2&&(ni.$$scope={dirty:f,ctx:s}),uo.$set(ni);const kc={};f&2&&(kc.$$scope={dirty:f,ctx:s}),ho.$set(kc);const Fc={};f&2&&(Fc.$$scope={dirty:f,ctx:s}),mo.$set(Fc);const yc={};f&2&&(yc.$$scope={dirty:f,ctx:s}),go.$set(yc);const wc={};f&2&&(wc.$$scope={dirty:f,ctx:s}),vo.$set(wc);const bc={};f&2&&(bc.$$scope={dirty:f,ctx:s}),To.$set(bc);const ti={};f&2&&(ti.$$scope={dirty:f,ctx:s}),Fo.$set(ti);const $c={};f&2&&($c.$$scope={dirty:f,ctx:s}),yo.$set($c);const xe={};f&2&&(xe.$$scope={dirty:f,ctx:s}),bo.$set(xe);const Ec={};f&2&&(Ec.$$scope={dirty:f,ctx:s}),$o.$set(Ec);const Mc={};f&2&&(Mc.$$scope={dirty:f,ctx:s}),Mo.$set(Mc);const zc={};f&2&&(zc.$$scope={dirty:f,ctx:s}),zo.$set(zc);const qc={};f&2&&(qc.$$scope={dirty:f,ctx:s}),Po.$set(qc);const Pc={};f&2&&(Pc.$$scope={dirty:f,ctx:s}),jo.$set(Pc);const jc={};f&2&&(jc.$$scope={dirty:f,ctx:s}),xo.$set(jc);const Cc={};f&2&&(Cc.$$scope={dirty:f,ctx:s}),Lo.$set(Cc)},i(s){wp||(w(v.$$.fragment,s),w(ne.$$.fragment,s),w(Io.$$.fragment,s),w(Bo.$$.fragment,s),w(Qo.$$.fragment,s),w(Uo.$$.fragment,s),w(Ho.$$.fragment,s),w(Yo.$$.fragment,s),w(Go.$$.fragment,s),w(Zo.$$.fragment,s),w(Xo.$$.fragment,s),w(Jo.$$.fragment,s),w(es.$$.fragment,s),w(os.$$.fragment,s),w(ss.$$.fragment,s),w(rs.$$.fragment,s),w(as.$$.fragment,s),w(ls.$$.fragment,s),w(cs.$$.fragment,s),w(ps.$$.fragment,s),w(_s.$$.fragment,s),w(Kt.$$.fragment,s),w(vs.$$.fragment,s),w(Ts.$$.fragment,s),w(ks.$$.fragment,s),w(Es.$$.fragment,s),w(Zt.$$.fragment,s),w(Ms.$$.fragment,s),w(zs.$$.fragment,s),w(qs.$$.fragment,s),w(Ps.$$.fragment,s),w(Jt.$$.fragment,s),w(js.$$.fragment,s),w(Cs.$$.fragment,s),w(xs.$$.fragment,s),w(Is.$$.fragment,s),w(no.$$.fragment,s),w(Bs.$$.fragment,s),w(Ws.$$.fragment,s),w(Qs.$$.fragment,s),w(Us.$$.fragment,s),w(Gs.$$.fragment,s),w(oo.$$.fragment,s),w(Zs.$$.fragment,s),w(Xs.$$.fragment,s),w(Js.$$.fragment,s),w(er.$$.fragment,s),w(nr.$$.fragment,s),w(tr.$$.fragment,s),w(lr.$$.fragment,s),w(ro.$$.fragment,s),w(dr.$$.fragment,s),w(cr.$$.fragment,s),w(pr.$$.fragment,s),w(_r.$$.fragment,s),w(io.$$.fragment,s),w(vr.$$.fragment,s),w(Tr.$$.fragment,s),w(kr.$$.fragment,s),w(Fr.$$.fragment,s),w(Mr.$$.fragment,s),w(co.$$.fragment,s),w(zr.$$.fragment,s),w(qr.$$.fragment,s),w(Pr.$$.fragment,s),w(jr.$$.fragment,s),w(uo.$$.fragment,s),w(Ar.$$.fragment,s),w(ho.$$.fragment,s),w(Nr.$$.fragment,s),w(Sr.$$.fragment,s),w(Ir.$$.fragment,s),w(mo.$$.fragment,s),w(Hr.$$.fragment,s),w(go.$$.fragment,s),w(Vr.$$.fragment,s),w(Yr.$$.fragment,s),w(Kr.$$.fragment,s),w(vo.$$.fragment,s),w(na.$$.fragment,s),w(To.$$.fragment,s),w(ta.$$.fragment,s),w(oa.$$.fragment,s),w(sa.$$.fragment,s),w(Fo.$$.fragment,s),w(pa.$$.fragment,s),w(yo.$$.fragment,s),w(ua.$$.fragment,s),w(ha.$$.fragment,s),w(fa.$$.fragment,s),w(ma.$$.fragment,s),w(bo.$$.fragment,s),w(Fa.$$.fragment,s),w($o.$$.fragment,s),w(ya.$$.fragment,s),w(wa.$$.fragment,s),w(ba.$$.fragment,s),w($a.$$.fragment,s),w(Mo.$$.fragment,s),w(ja.$$.fragment,s),w(zo.$$.fragment,s),w(Ca.$$.fragment,s),w(xa.$$.fragment,s),w(La.$$.fragment,s),w(Po.$$.fragment,s),w(Ia.$$.fragment,s),w(jo.$$.fragment,s),w(Ba.$$.fragment,s),w(Wa.$$.fragment,s),w(Qa.$$.fragment,s),w(Ua.$$.fragment,s),w(xo.$$.fragment,s),w(Ga.$$.fragment,s),w(Lo.$$.fragment,s),w(Za.$$.fragment,s),w(Xa.$$.fragment,s),wp=!0)},o(s){b(v.$$.fragment,s),b(ne.$$.fragment,s),b(Io.$$.fragment,s),b(Bo.$$.fragment,s),b(Qo.$$.fragment,s),b(Uo.$$.fragment,s),b(Ho.$$.fragment,s),b(Yo.$$.fragment,s),b(Go.$$.fragment,s),b(Zo.$$.fragment,s),b(Xo.$$.fragment,s),b(Jo.$$.fragment,s),b(es.$$.fragment,s),b(os.$$.fragment,s),b(ss.$$.fragment,s),b(rs.$$.fragment,s),b(as.$$.fragment,s),b(ls.$$.fragment,s),b(cs.$$.fragment,s),b(ps.$$.fragment,s),b(_s.$$.fragment,s),b(Kt.$$.fragment,s),b(vs.$$.fragment,s),b(Ts.$$.fragment,s),b(ks.$$.fragment,s),b(Es.$$.fragment,s),b(Zt.$$.fragment,s),b(Ms.$$.fragment,s),b(zs.$$.fragment,s),b(qs.$$.fragment,s),b(Ps.$$.fragment,s),b(Jt.$$.fragment,s),b(js.$$.fragment,s),b(Cs.$$.fragment,s),b(xs.$$.fragment,s),b(Is.$$.fragment,s),b(no.$$.fragment,s),b(Bs.$$.fragment,s),b(Ws.$$.fragment,s),b(Qs.$$.fragment,s),b(Us.$$.fragment,s),b(Gs.$$.fragment,s),b(oo.$$.fragment,s),b(Zs.$$.fragment,s),b(Xs.$$.fragment,s),b(Js.$$.fragment,s),b(er.$$.fragment,s),b(nr.$$.fragment,s),b(tr.$$.fragment,s),b(lr.$$.fragment,s),b(ro.$$.fragment,s),b(dr.$$.fragment,s),b(cr.$$.fragment,s),b(pr.$$.fragment,s),b(_r.$$.fragment,s),b(io.$$.fragment,s),b(vr.$$.fragment,s),b(Tr.$$.fragment,s),b(kr.$$.fragment,s),b(Fr.$$.fragment,s),b(Mr.$$.fragment,s),b(co.$$.fragment,s),b(zr.$$.fragment,s),b(qr.$$.fragment,s),b(Pr.$$.fragment,s),b(jr.$$.fragment,s),b(uo.$$.fragment,s),b(Ar.$$.fragment,s),b(ho.$$.fragment,s),b(Nr.$$.fragment,s),b(Sr.$$.fragment,s),b(Ir.$$.fragment,s),b(mo.$$.fragment,s),b(Hr.$$.fragment,s),b(go.$$.fragment,s),b(Vr.$$.fragment,s),b(Yr.$$.fragment,s),b(Kr.$$.fragment,s),b(vo.$$.fragment,s),b(na.$$.fragment,s),b(To.$$.fragment,s),b(ta.$$.fragment,s),b(oa.$$.fragment,s),b(sa.$$.fragment,s),b(Fo.$$.fragment,s),b(pa.$$.fragment,s),b(yo.$$.fragment,s),b(ua.$$.fragment,s),b(ha.$$.fragment,s),b(fa.$$.fragment,s),b(ma.$$.fragment,s),b(bo.$$.fragment,s),b(Fa.$$.fragment,s),b($o.$$.fragment,s),b(ya.$$.fragment,s),b(wa.$$.fragment,s),b(ba.$$.fragment,s),b($a.$$.fragment,s),b(Mo.$$.fragment,s),b(ja.$$.fragment,s),b(zo.$$.fragment,s),b(Ca.$$.fragment,s),b(xa.$$.fragment,s),b(La.$$.fragment,s),b(Po.$$.fragment,s),b(Ia.$$.fragment,s),b(jo.$$.fragment,s),b(Ba.$$.fragment,s),b(Wa.$$.fragment,s),b(Qa.$$.fragment,s),b(Ua.$$.fragment,s),b(xo.$$.fragment,s),b(Ga.$$.fragment,s),b(Lo.$$.fragment,s),b(Za.$$.fragment,s),b(Xa.$$.fragment,s),wp=!1},d(s){n(u),s&&n(z),s&&n(g),$(v),s&&n(K),s&&n(q),$(ne),s&&n(ie),s&&n(Y),s&&n(C),s&&n(oe),s&&n(le),s&&n(se),s&&n(de),s&&n(j),s&&n(B),s&&n(ee),s&&n(Oc),s&&n(In),s&&n(Dc),s&&n(Zn),$(Io),s&&n(Ac),s&&n(Nn),$(Bo),s&&n(Nc),s&&n(Jn),$(Qo),s&&n(Sc),s&&n(Ce),$(Uo),$(Ho),$(Yo),$(Go),$(Zo),$(Xo),s&&n(Ic),s&&n(nt),$(Jo),s&&n(Bc),s&&n(sn),$(es),$(os),$(ss),s&&n(Wc),s&&n(ot),$(rs),s&&n(Qc),s&&n(st),$(as),s&&n(Uc),s&&n(rt),$(ls),s&&n(Rc),s&&n(at),$(cs),s&&n(Hc),s&&n(Qe),$(ps),$(_s),$(Kt),$(vs),s&&n(Vc),s&&n(lt),$(Ts),s&&n(Yc),s&&n(Ue),$(ks),$(Es),$(Zt),$(Ms),s&&n(Kc),s&&n(ct),$(zs),s&&n(Gc),s&&n(pt),$(qs),$(Ps),$(Jt),$(js),s&&n(Zc),s&&n(ht),$(Cs),s&&n(Xc),s&&n(Re),$(xs),$(Is),$(no),$(Bs),$(Ws),s&&n(Jc),s&&n(mt),$(Qs),s&&n(ep),s&&n(He),$(Us),$(Gs),$(oo),$(Zs),$(Xs),$(Js),$(er),s&&n(np),s&&n(_t),$(nr),s&&n(tp),s&&n(Ve),$(tr),$(lr),$(ro),$(dr),s&&n(op),s&&n(Tt),$(cr),s&&n(sp),s&&n(Ye),$(pr),$(_r),$(io),$(vr),$(Tr),s&&n(rp),s&&n(Ft),$(kr),s&&n(ap),s&&n(Ke),$(Fr),$(Mr),$(co),$(zr),$(qr),s&&n(ip),s&&n(bt),$(Pr),s&&n(lp),s&&n(Le),$(jr),$(uo),$(Ar),$(ho),$(Nr),s&&n(dp),s&&n(Et),$(Sr),s&&n(cp),s&&n(Oe),$(Ir),$(mo),$(Hr),$(go),$(Vr),s&&n(pp),s&&n(zt),$(Yr),s&&n(up),s&&n(De),$(Kr),$(vo),$(na),$(To),$(ta),s&&n(hp),s&&n(Pt),$(oa),s&&n(fp),s&&n(Ae),$(sa),$(Fo),$(pa),$(yo),$(ua),$(ha),s&&n(mp),s&&n(Ct),$(fa),s&&n(gp),s&&n(Ne),$(ma),$(bo),$(Fa),$($o),$(ya),$(wa),s&&n(_p),s&&n(Lt),$(ba),s&&n(vp),s&&n(Se),$($a),$(Mo),$(ja),$(zo),$(Ca),s&&n(Tp),s&&n(Dt),$(xa),s&&n(kp),s&&n(Ie),$(La),$(Po),$(Ia),$(jo),$(Ba),$(Wa),s&&n(Fp),s&&n(Nt),$(Qa),s&&n(yp),s&&n(Be),$(Ua),$(xo),$(Ga),$(Lo),$(Za),$(Xa)}}}const _$={local:"funnel-transformer",sections:[{local:"overview",title:"Overview"},{local:"transformers.FunnelConfig",title:"FunnelConfig"},{local:"transformers.FunnelTokenizer",title:"FunnelTokenizer"},{local:"transformers.FunnelTokenizerFast",title:"FunnelTokenizerFast"},{local:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput",title:"Funnel specific outputs"},{local:"transformers.FunnelBaseModel",title:"FunnelBaseModel"},{local:"transformers.FunnelModel",title:"FunnelModel"},{local:"transformers.FunnelForPreTraining",title:"FunnelModelForPreTraining"},{local:"transformers.FunnelForMaskedLM",title:"FunnelForMaskedLM"},{local:"transformers.FunnelForSequenceClassification",title:"FunnelForSequenceClassification"},{local:"transformers.FunnelForMultipleChoice",title:"FunnelForMultipleChoice"},{local:"transformers.FunnelForTokenClassification",title:"FunnelForTokenClassification"},{local:"transformers.FunnelForQuestionAnswering",title:"FunnelForQuestionAnswering"},{local:"transformers.TFFunnelBaseModel",title:"TFFunnelBaseModel"},{local:"transformers.TFFunnelModel",title:"TFFunnelModel"},{local:"transformers.TFFunnelForPreTraining",title:"TFFunnelModelForPreTraining"},{local:"transformers.TFFunnelForMaskedLM",title:"TFFunnelForMaskedLM"},{local:"transformers.TFFunnelForSequenceClassification",title:"TFFunnelForSequenceClassification"},{local:"transformers.TFFunnelForMultipleChoice",title:"TFFunnelForMultipleChoice"},{local:"transformers.TFFunnelForTokenClassification",title:"TFFunnelForTokenClassification"},{local:"transformers.TFFunnelForQuestionAnswering",title:"TFFunnelForQuestionAnswering"}],title:"Funnel Transformer"};function v$(V){return R0(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class b$ extends B0{constructor(u){super();W0(this,u,v$,g$,Q0,{})}}export{b$ as default,_$ as metadata};
