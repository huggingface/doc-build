import{S as Wt,i as Et,s as Ct,e as n,k as l,w as X,t as s,M as $t,c as r,d as t,m as c,a,x as j,h as i,b as p,F as o,g as h,y as Q,L as Vt,q as Z,o as J,B as G}from"../../chunks/vendor-ab4e3193.js";import{D as Qe}from"../../chunks/Docstring-91f1beab.js";import{I as Ko}from"../../chunks/IconCopyLink-d992940d.js";function Lt(Ze){let v,K,_,g,ae,$,Je,se,Ge,ye,b,y,ie,V,Ke,le,Ye,ze,z,eo,L,oo,to,Pe,Y,no,xe,ee,ce,ro,qe,oe,ao,We,u,de,so,io,pe,lo,co,B,po,te,ho,mo,uo,he,fo,_o,me,go,Ee,P,vo,I,ko,To,Ce,F,bo,A,wo,$e,x,yo,N,zo,Po,Ve,q,xo,ue,qo,Wo,Le,w,W,fe,D,Eo,_e,Co,Be,m,S,$o,ge,Vo,Lo,R,Bo,ne,Io,Fo,Ao,E,U,No,ve,Do,So,C,O,Ro,ke,Uo,Oo,k,M,Mo,Te,Ho,Xo,H,jo,be,Qo,Zo,Jo,we,Ie;return $=new Ko({}),V=new Ko({}),D=new Ko({}),S=new Qe({props:{name:"class transformers.Wav2Vec2PhonemeCTCTokenizer",anchor:"transformers.Wav2Vec2PhonemeCTCTokenizer",parameters:[{name:"vocab_file",val:""},{name:"bos_token",val:" = '<s>'"},{name:"eos_token",val:" = '</s>'"},{name:"unk_token",val:" = '<unk>'"},{name:"pad_token",val:" = '<pad>'"},{name:"phone_delimiter_token",val:" = ' '"},{name:"word_delimiter_token",val:" = None"},{name:"do_phonemize",val:" = True"},{name:"phonemizer_lang",val:" = 'en-us'"},{name:"phonemizer_backend",val:" = 'espeak'"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.16.2/src/transformers/models/wav2vec2_phoneme/tokenization_wav2vec2_phoneme.py#L50",parametersDescription:[{anchor:"transformers.Wav2Vec2PhonemeCTCTokenizer.vocab_file",description:`<strong>vocab_file</strong> (<code>str</code>) &#x2014;
File containing the vocabulary.`,name:"vocab_file"},{anchor:"transformers.Wav2Vec2PhonemeCTCTokenizer.bos_token",description:`<strong>bos_token</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;&lt;s&gt;&quot;</code>) &#x2014;
The beginning of sentence token.`,name:"bos_token"},{anchor:"transformers.Wav2Vec2PhonemeCTCTokenizer.eos_token",description:`<strong>eos_token</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;&lt;/s&gt;&quot;</code>) &#x2014;
The end of sentence token.`,name:"eos_token"},{anchor:"transformers.Wav2Vec2PhonemeCTCTokenizer.unk_token",description:`<strong>unk_token</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;&lt;unk&gt;&quot;</code>) &#x2014;
The unknown token. A token that is not in the vocabulary cannot be converted to an ID and is set to be this
token instead.`,name:"unk_token"},{anchor:"transformers.Wav2Vec2PhonemeCTCTokenizer.pad_token",description:`<strong>pad_token</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;&lt;pad&gt;&quot;</code>) &#x2014;
The token used for padding, for example when batching sequences of different lengths.`,name:"pad_token"},{anchor:"transformers.Wav2Vec2PhonemeCTCTokenizer.do_phonemize",description:`<strong>do_phonemize</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the tokenizer should phonetize the input or not. Only if a sequence of phonemes is passed to the
tokenizer, <code>do_phonemize</code> should be set to <code>False</code>.`,name:"do_phonemize"},{anchor:"transformers.Wav2Vec2PhonemeCTCTokenizer.phonemizer_lang",description:`<strong>phonemizer_lang</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;en-us&quot;</code>) &#x2014;
The language of the phoneme set to which the tokenizer should phonetize the input text to.`,name:"phonemizer_lang"},{anchor:"transformers.Wav2Vec2PhonemeCTCTokenizer.phonemizer_backend",description:`<strong>phonemizer_backend</strong> (<code>str</code>, <em>optional</em>. defaults to <code>&quot;espeak&quot;</code>) &#x2014;
The backend phonetization library that shall be used by the phonemizer library. Defaults to <code>espeak-ng</code>.
See the <a href="https://github.com/bootphon/phonemizer#readme" rel="nofollow">phonemizer package</a>. for more information.</p>
<p>**kwargs &#x2014;
Additional keyword arguments passed along to <a href="/docs/transformers/v4.16.2/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>`,name:"phonemizer_backend"}]}}),U=new Qe({props:{name:"__call__",anchor:"transformers.PreTrainedTokenizerBase.__call__",parameters:[{name:"text",val:": typing.Union[str, typing.List[str], typing.List[typing.List[str]]]"},{name:"text_pair",val:": typing.Union[str, typing.List[str], typing.List[typing.List[str]], NoneType] = None"},{name:"add_special_tokens",val:": bool = True"},{name:"padding",val:": typing.Union[bool, str, transformers.file_utils.PaddingStrategy] = False"},{name:"truncation",val:": typing.Union[bool, str, transformers.tokenization_utils_base.TruncationStrategy] = False"},{name:"max_length",val:": typing.Optional[int] = None"},{name:"stride",val:": int = 0"},{name:"is_split_into_words",val:": bool = False"},{name:"pad_to_multiple_of",val:": typing.Optional[int] = None"},{name:"return_tensors",val:": typing.Union[str, transformers.file_utils.TensorType, NoneType] = None"},{name:"return_token_type_ids",val:": typing.Optional[bool] = None"},{name:"return_attention_mask",val:": typing.Optional[bool] = None"},{name:"return_overflowing_tokens",val:": bool = False"},{name:"return_special_tokens_mask",val:": bool = False"},{name:"return_offsets_mapping",val:": bool = False"},{name:"return_length",val:": bool = False"},{name:"verbose",val:": bool = True"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.16.2/src/transformers/tokenization_utils_base.py#L2359",parametersDescription:[{anchor:"transformers.PreTrainedTokenizerBase.__call__.text",description:`<strong>text</strong> (<code>str</code>, <code>List[str]</code>, <code>List[List[str]]</code>) &#x2014;
The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings
(pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set
<code>is_split_into_words=True</code> (to lift the ambiguity with a batch of sequences).`,name:"text"},{anchor:"transformers.PreTrainedTokenizerBase.__call__.text_pair",description:`<strong>text_pair</strong> (<code>str</code>, <code>List[str]</code>, <code>List[List[str]]</code>) &#x2014;
The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings
(pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set
<code>is_split_into_words=True</code> (to lift the ambiguity with a batch of sequences).`,name:"text_pair"},{anchor:"transformers.PreTrainedTokenizerBase.__call__.add_special_tokens",description:`<strong>add_special_tokens</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to encode the sequences with the special tokens relative to their model.`,name:"add_special_tokens"},{anchor:"transformers.PreTrainedTokenizerBase.__call__.padding",description:`<strong>padding</strong> (<code>bool</code>, <code>str</code> or <a href="/docs/transformers/v4.16.2/en/internal/file_utils#transformers.file_utils.PaddingStrategy">PaddingStrategy</a>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Activates and controls padding. Accepts the following values:</p>
<ul>
<li><code>True</code> or <code>&apos;longest&apos;</code>: Pad to the longest sequence in the batch (or no padding if only a single
sequence if provided).</li>
<li><code>&apos;max_length&apos;</code>: Pad to a maximum length specified with the argument <code>max_length</code> or to the maximum
acceptable input length for the model if that argument is not provided.</li>
<li><code>False</code> or <code>&apos;do_not_pad&apos;</code> (default): No padding (i.e., can output a batch with sequences of different
lengths).</li>
</ul>`,name:"padding"},{anchor:"transformers.PreTrainedTokenizerBase.__call__.truncation",description:`<strong>truncation</strong> (<code>bool</code>, <code>str</code> or <a href="/docs/transformers/v4.16.2/en/internal/tokenization_utils#transformers.tokenization_utils_base.TruncationStrategy">TruncationStrategy</a>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Activates and controls truncation. Accepts the following values:</p>
<ul>
<li><code>True</code> or <code>&apos;longest_first&apos;</code>: Truncate to a maximum length specified with the argument <code>max_length</code> or
to the maximum acceptable input length for the model if that argument is not provided. This will
truncate token by token, removing a token from the longest sequence in the pair if a pair of
sequences (or a batch of pairs) is provided.</li>
<li><code>&apos;only_first&apos;</code>: Truncate to a maximum length specified with the argument <code>max_length</code> or to the
maximum acceptable input length for the model if that argument is not provided. This will only
truncate the first sequence of a pair if a pair of sequences (or a batch of pairs) is provided.</li>
<li><code>&apos;only_second&apos;</code>: Truncate to a maximum length specified with the argument <code>max_length</code> or to the
maximum acceptable input length for the model if that argument is not provided. This will only
truncate the second sequence of a pair if a pair of sequences (or a batch of pairs) is provided.</li>
<li><code>False</code> or <code>&apos;do_not_truncate&apos;</code> (default): No truncation (i.e., can output batch with sequence lengths
greater than the model maximum admissible input size).</li>
</ul>`,name:"truncation"},{anchor:"transformers.PreTrainedTokenizerBase.__call__.max_length",description:`<strong>max_length</strong> (<code>int</code>, <em>optional</em>) &#x2014;
Controls the maximum length to use by one of the truncation/padding parameters.</p>
<p>If left unset or set to <code>None</code>, this will use the predefined model maximum length if a maximum length
is required by one of the truncation/padding parameters. If the model has no specific maximum input
length (like XLNet) truncation/padding to a maximum length will be deactivated.`,name:"max_length"},{anchor:"transformers.PreTrainedTokenizerBase.__call__.stride",description:`<strong>stride</strong> (<code>int</code>, <em>optional</em>, defaults to 0) &#x2014;
If set to a number along with <code>max_length</code>, the overflowing tokens returned when
<code>return_overflowing_tokens=True</code> will contain some tokens from the end of the truncated sequence
returned to provide some overlap between truncated and overflowing sequences. The value of this
argument defines the number of overlapping tokens.`,name:"stride"},{anchor:"transformers.PreTrainedTokenizerBase.__call__.is_split_into_words",description:`<strong>is_split_into_words</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not the input is already pre-tokenized (e.g., split into words). If set to <code>True</code>, the
tokenizer assumes the input is already split into words (for instance, by splitting it on whitespace)
which it will tokenize. This is useful for NER or token classification.`,name:"is_split_into_words"},{anchor:"transformers.PreTrainedTokenizerBase.__call__.pad_to_multiple_of",description:`<strong>pad_to_multiple_of</strong> (<code>int</code>, <em>optional</em>) &#x2014;
If set will pad the sequence to a multiple of the provided value. This is especially useful to enable
the use of Tensor Cores on NVIDIA hardware with compute capability &gt;= 7.5 (Volta).`,name:"pad_to_multiple_of"},{anchor:"transformers.PreTrainedTokenizerBase.__call__.return_tensors",description:`<strong>return_tensors</strong> (<code>str</code> or <a href="/docs/transformers/v4.16.2/en/internal/file_utils#transformers.TensorType">TensorType</a>, <em>optional</em>) &#x2014;
If set, will return tensors instead of list of python integers. Acceptable values are:</p>
<ul>
<li><code>&apos;tf&apos;</code>: Return TensorFlow <code>tf.constant</code> objects.</li>
<li><code>&apos;pt&apos;</code>: Return PyTorch <code>torch.Tensor</code> objects.</li>
<li><code>&apos;np&apos;</code>: Return Numpy <code>np.ndarray</code> objects.</li>
</ul>`,name:"return_tensors"},{anchor:"transformers.PreTrainedTokenizerBase.__call__.return_token_type_ids",description:`<strong>return_token_type_ids</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether to return token type IDs. If left to the default, will return the token type IDs according to
the specific tokenizer&#x2019;s default, defined by the <code>return_outputs</code> attribute.</p>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"return_token_type_ids"},{anchor:"transformers.PreTrainedTokenizerBase.__call__.return_attention_mask",description:`<strong>return_attention_mask</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether to return the attention mask. If left to the default, will return the attention mask according
to the specific tokenizer&#x2019;s default, defined by the <code>return_outputs</code> attribute.</p>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"return_attention_mask"},{anchor:"transformers.PreTrainedTokenizerBase.__call__.return_overflowing_tokens",description:`<strong>return_overflowing_tokens</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to return overflowing token sequences. If a pair of sequences of input ids (or a batch
of pairs) is provided with <code>truncation_strategy = longest_first</code> or <code>True</code>, an error is raised instead
of returning overflowing tokens.`,name:"return_overflowing_tokens"},{anchor:"transformers.PreTrainedTokenizerBase.__call__.return_special_tokens_mask",description:`<strong>return_special_tokens_mask</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to return special tokens mask information.`,name:"return_special_tokens_mask"},{anchor:"transformers.PreTrainedTokenizerBase.__call__.return_offsets_mapping",description:`<strong>return_offsets_mapping</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to return <code>(char_start, char_end)</code> for each token.</p>
<p>This is only available on fast tokenizers inheriting from <a href="/docs/transformers/v4.16.2/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast">PreTrainedTokenizerFast</a>, if using
Python&#x2019;s tokenizer, this method will raise <code>NotImplementedError</code>.`,name:"return_offsets_mapping"},{anchor:"transformers.PreTrainedTokenizerBase.__call__.return_length",description:`<strong>return_length</strong>  (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to return the lengths of the encoded inputs.`,name:"return_length"},{anchor:"transformers.PreTrainedTokenizerBase.__call__.verbose",description:`<strong>verbose</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to print more information and warnings.
**kwargs &#x2014; passed to the <code>self.tokenize()</code> method`,name:"verbose"}],returnDescription:`
<p>A <a
  href="/docs/transformers/v4.16.2/en/main_classes/tokenizer#transformers.BatchEncoding"
>BatchEncoding</a> with the following fields:</p>
<ul>
<li>
<p><strong>input_ids</strong> \u2014 List of token ids to be fed to a model.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a></p>
</li>
<li>
<p><strong>token_type_ids</strong> \u2014 List of token type ids to be fed to a model (when <code>return_token_type_ids=True</code> or
if <em>\u201Ctoken_type_ids\u201D</em> is in <code>self.model_input_names</code>).</p>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a></p>
</li>
<li>
<p><strong>attention_mask</strong> \u2014 List of indices specifying which tokens should be attended to by the model (when
<code>return_attention_mask=True</code> or if <em>\u201Cattention_mask\u201D</em> is in <code>self.model_input_names</code>).</p>
<p><a href="../glossary#attention-mask">What are attention masks?</a></p>
</li>
<li>
<p><strong>overflowing_tokens</strong> \u2014 List of overflowing tokens sequences (when a <code>max_length</code> is specified and
<code>return_overflowing_tokens=True</code>).</p>
</li>
<li>
<p><strong>num_truncated_tokens</strong> \u2014 Number of tokens truncated (when a <code>max_length</code> is specified and
<code>return_overflowing_tokens=True</code>).</p>
</li>
<li>
<p><strong>special_tokens_mask</strong> \u2014 List of 0s and 1s, with 1 specifying added special tokens and 0 specifying
regular sequence tokens (when <code>add_special_tokens=True</code> and <code>return_special_tokens_mask=True</code>).</p>
</li>
<li>
<p><strong>length</strong> \u2014 The length of the inputs (when <code>return_length=True</code>)</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/v4.16.2/en/main_classes/tokenizer#transformers.BatchEncoding"
>BatchEncoding</a></p>
`}}),O=new Qe({props:{name:"batch_decode",anchor:"transformers.PreTrainedTokenizerBase.batch_decode",parameters:[{name:"sequences",val:": typing.Union[typing.List[int], typing.List[typing.List[int]], ForwardRef('np.ndarray'), ForwardRef('torch.Tensor'), ForwardRef('tf.Tensor')]"},{name:"skip_special_tokens",val:": bool = False"},{name:"clean_up_tokenization_spaces",val:": bool = True"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.16.2/src/transformers/tokenization_utils_base.py#L3230",parametersDescription:[{anchor:"transformers.PreTrainedTokenizerBase.batch_decode.sequences",description:`<strong>sequences</strong> (<code>Union[List[int], List[List[int]], np.ndarray, torch.Tensor, tf.Tensor]</code>) &#x2014;
List of tokenized input ids. Can be obtained using the <code>__call__</code> method.`,name:"sequences"},{anchor:"transformers.PreTrainedTokenizerBase.batch_decode.skip_special_tokens",description:`<strong>skip_special_tokens</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to remove special tokens in the decoding.`,name:"skip_special_tokens"},{anchor:"transformers.PreTrainedTokenizerBase.batch_decode.clean_up_tokenization_spaces",description:`<strong>clean_up_tokenization_spaces</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to clean up the tokenization spaces.`,name:"clean_up_tokenization_spaces"},{anchor:"transformers.PreTrainedTokenizerBase.batch_decode.kwargs",description:`<strong>kwargs</strong> (additional keyword arguments, <em>optional</em>) &#x2014;
Will be passed to the underlying model specific decode method.`,name:"kwargs"}],returnDescription:`
<p>The list of decoded sentences.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),M=new Qe({props:{name:"decode",anchor:"transformers.PreTrainedTokenizerBase.decode",parameters:[{name:"token_ids",val:": typing.Union[int, typing.List[int], ForwardRef('np.ndarray'), ForwardRef('torch.Tensor'), ForwardRef('tf.Tensor')]"},{name:"skip_special_tokens",val:": bool = False"},{name:"clean_up_tokenization_spaces",val:": bool = True"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.16.2/src/transformers/tokenization_utils_base.py#L3263",parametersDescription:[{anchor:"transformers.PreTrainedTokenizerBase.decode.token_ids",description:`<strong>token_ids</strong> (<code>Union[int, List[int], np.ndarray, torch.Tensor, tf.Tensor]</code>) &#x2014;
List of tokenized input ids. Can be obtained using the <code>__call__</code> method.`,name:"token_ids"},{anchor:"transformers.PreTrainedTokenizerBase.decode.skip_special_tokens",description:`<strong>skip_special_tokens</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to remove special tokens in the decoding.`,name:"skip_special_tokens"},{anchor:"transformers.PreTrainedTokenizerBase.decode.clean_up_tokenization_spaces",description:`<strong>clean_up_tokenization_spaces</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to clean up the tokenization spaces.`,name:"clean_up_tokenization_spaces"},{anchor:"transformers.PreTrainedTokenizerBase.decode.kwargs",description:`<strong>kwargs</strong> (additional keyword arguments, <em>optional</em>) &#x2014;
Will be passed to the underlying model specific decode method.`,name:"kwargs"}],returnDescription:`
<p>The decoded sentence.</p>
`,returnType:`
<p><code>str</code></p>
`}}),{c(){v=n("meta"),K=l(),_=n("h1"),g=n("a"),ae=n("span"),X($.$$.fragment),Je=l(),se=n("span"),Ge=s("Wav2Vec2Phoneme"),ye=l(),b=n("h2"),y=n("a"),ie=n("span"),X(V.$$.fragment),Ke=l(),le=n("span"),Ye=s("Overview"),ze=l(),z=n("p"),eo=s("The Wav2Vec2Phoneme model was proposed in "),L=n("a"),oo=s(`Simple and Effective Zero-shot Cross-lingual Phoneme Recognition (Xu et al.,
2021`),to=s(" by Qiantong Xu, Alexei Baevski, Michael Auli."),Pe=l(),Y=n("p"),no=s("The abstract from the paper is the following:"),xe=l(),ee=n("p"),ce=n("em"),ro=s(`Recent progress in self-training, self-supervised pretraining and unsupervised learning enabled well performing speech
recognition systems without any labeled data. However, in many cases there is labeled data available for related
languages which is not utilized by these methods. This paper extends previous work on zero-shot cross-lingual transfer
learning by fine-tuning a multilingually pretrained wav2vec 2.0 model to transcribe unseen languages. This is done by
mapping phonemes of the training languages to the target language using articulatory features. Experiments show that
this simple method significantly outperforms prior work which introduced task-specific architectures and used only part
of a monolingually pretrained model.`),qe=l(),oe=n("p"),ao=s("Tips:"),We=l(),u=n("ul"),de=n("li"),so=s("Wav2Vec2Phoneme uses the exact same architecture as Wav2Vec2"),io=l(),pe=n("li"),lo=s("Wav2Vec2Phoneme is a speech model that accepts a float array corresponding to the raw waveform of the speech signal."),co=l(),B=n("li"),po=s(`Wav2Vec2Phoneme model was trained using connectionist temporal classification (CTC) so the model output has to be
decoded using `),te=n("a"),ho=s("Wav2Vec2PhonemeCTCTokenizer"),mo=s("."),uo=l(),he=n("li"),fo=s(`Wav2Vec2Phoneme can be fine-tuned on multiple language at once and decode unseen languages in a single forward pass
to a sequence of phonemes`),_o=l(),me=n("li"),go=s(`By default the model outputs a sequence of phonemes. In order to transform the phonemes to a sequence of words one
should make use of a dictionary and language model.`),Ee=l(),P=n("p"),vo=s("Relevant checkpoints can be found under "),I=n("a"),ko=s("https://huggingface.co/models?other=phoneme-recognition"),To=s("."),Ce=l(),F=n("p"),bo=s("This model was contributed by "),A=n("a"),wo=s("patrickvonplaten"),$e=l(),x=n("p"),yo=s("The original code can be found "),N=n("a"),zo=s("here"),Po=s("."),Ve=l(),q=n("p"),xo=s("Wav2Vec2Phoneme\u2019s architecture is based on the Wav2Vec2 model, so one can refer to "),ue=n("code"),qo=s("Wav2Vec2"),Wo=s("\u2019s documentation page except for the tokenizer."),Le=l(),w=n("h2"),W=n("a"),fe=n("span"),X(D.$$.fragment),Eo=l(),_e=n("span"),Co=s("Wav2Vec2PhonemeCTCTokenizer"),Be=l(),m=n("div"),X(S.$$.fragment),$o=l(),ge=n("p"),Vo=s("Constructs a Wav2Vec2PhonemeCTC tokenizer."),Lo=l(),R=n("p"),Bo=s("This tokenizer inherits from "),ne=n("a"),Io=s("PreTrainedTokenizer"),Fo=s(` which contains some of the main methods. Users should refer to
the superclass for more information regarding such methods.`),Ao=l(),E=n("div"),X(U.$$.fragment),No=l(),ve=n("p"),Do=s(`Main method to tokenize and prepare for the model one or several sequence(s) or one or several pair(s) of
sequences.`),So=l(),C=n("div"),X(O.$$.fragment),Ro=l(),ke=n("p"),Uo=s("Convert a list of lists of token ids into a list of strings by calling decode."),Oo=l(),k=n("div"),X(M.$$.fragment),Mo=l(),Te=n("p"),Ho=s(`Converts a sequence of ids in a string, using the tokenizer and vocabulary with options to remove special
tokens and clean up tokenization spaces.`),Xo=l(),H=n("p"),jo=s("Similar to doing "),be=n("code"),Qo=s("self.convert_tokens_to_string(self.convert_ids_to_tokens(token_ids))"),Zo=s("."),Jo=l(),we=n("div"),this.h()},l(e){const d=$t('[data-svelte="svelte-1phssyn"]',document.head);v=r(d,"META",{name:!0,content:!0}),d.forEach(t),K=c(e),_=r(e,"H1",{class:!0});var Fe=a(_);g=r(Fe,"A",{id:!0,class:!0,href:!0});var Yo=a(g);ae=r(Yo,"SPAN",{});var et=a(ae);j($.$$.fragment,et),et.forEach(t),Yo.forEach(t),Je=c(Fe),se=r(Fe,"SPAN",{});var ot=a(se);Ge=i(ot,"Wav2Vec2Phoneme"),ot.forEach(t),Fe.forEach(t),ye=c(e),b=r(e,"H2",{class:!0});var Ae=a(b);y=r(Ae,"A",{id:!0,class:!0,href:!0});var tt=a(y);ie=r(tt,"SPAN",{});var nt=a(ie);j(V.$$.fragment,nt),nt.forEach(t),tt.forEach(t),Ke=c(Ae),le=r(Ae,"SPAN",{});var rt=a(le);Ye=i(rt,"Overview"),rt.forEach(t),Ae.forEach(t),ze=c(e),z=r(e,"P",{});var Ne=a(z);eo=i(Ne,"The Wav2Vec2Phoneme model was proposed in "),L=r(Ne,"A",{href:!0,rel:!0});var at=a(L);oo=i(at,`Simple and Effective Zero-shot Cross-lingual Phoneme Recognition (Xu et al.,
2021`),at.forEach(t),to=i(Ne," by Qiantong Xu, Alexei Baevski, Michael Auli."),Ne.forEach(t),Pe=c(e),Y=r(e,"P",{});var st=a(Y);no=i(st,"The abstract from the paper is the following:"),st.forEach(t),xe=c(e),ee=r(e,"P",{});var it=a(ee);ce=r(it,"EM",{});var lt=a(ce);ro=i(lt,`Recent progress in self-training, self-supervised pretraining and unsupervised learning enabled well performing speech
recognition systems without any labeled data. However, in many cases there is labeled data available for related
languages which is not utilized by these methods. This paper extends previous work on zero-shot cross-lingual transfer
learning by fine-tuning a multilingually pretrained wav2vec 2.0 model to transcribe unseen languages. This is done by
mapping phonemes of the training languages to the target language using articulatory features. Experiments show that
this simple method significantly outperforms prior work which introduced task-specific architectures and used only part
of a monolingually pretrained model.`),lt.forEach(t),it.forEach(t),qe=c(e),oe=r(e,"P",{});var ct=a(oe);ao=i(ct,"Tips:"),ct.forEach(t),We=c(e),u=r(e,"UL",{});var T=a(u);de=r(T,"LI",{});var dt=a(de);so=i(dt,"Wav2Vec2Phoneme uses the exact same architecture as Wav2Vec2"),dt.forEach(t),io=c(T),pe=r(T,"LI",{});var pt=a(pe);lo=i(pt,"Wav2Vec2Phoneme is a speech model that accepts a float array corresponding to the raw waveform of the speech signal."),pt.forEach(t),co=c(T),B=r(T,"LI",{});var De=a(B);po=i(De,`Wav2Vec2Phoneme model was trained using connectionist temporal classification (CTC) so the model output has to be
decoded using `),te=r(De,"A",{href:!0});var ht=a(te);ho=i(ht,"Wav2Vec2PhonemeCTCTokenizer"),ht.forEach(t),mo=i(De,"."),De.forEach(t),uo=c(T),he=r(T,"LI",{});var mt=a(he);fo=i(mt,`Wav2Vec2Phoneme can be fine-tuned on multiple language at once and decode unseen languages in a single forward pass
to a sequence of phonemes`),mt.forEach(t),_o=c(T),me=r(T,"LI",{});var ut=a(me);go=i(ut,`By default the model outputs a sequence of phonemes. In order to transform the phonemes to a sequence of words one
should make use of a dictionary and language model.`),ut.forEach(t),T.forEach(t),Ee=c(e),P=r(e,"P",{});var Se=a(P);vo=i(Se,"Relevant checkpoints can be found under "),I=r(Se,"A",{href:!0,rel:!0});var ft=a(I);ko=i(ft,"https://huggingface.co/models?other=phoneme-recognition"),ft.forEach(t),To=i(Se,"."),Se.forEach(t),Ce=c(e),F=r(e,"P",{});var Go=a(F);bo=i(Go,"This model was contributed by "),A=r(Go,"A",{href:!0,rel:!0});var _t=a(A);wo=i(_t,"patrickvonplaten"),_t.forEach(t),Go.forEach(t),$e=c(e),x=r(e,"P",{});var Re=a(x);yo=i(Re,"The original code can be found "),N=r(Re,"A",{href:!0,rel:!0});var gt=a(N);zo=i(gt,"here"),gt.forEach(t),Po=i(Re,"."),Re.forEach(t),Ve=c(e),q=r(e,"P",{});var Ue=a(q);xo=i(Ue,"Wav2Vec2Phoneme\u2019s architecture is based on the Wav2Vec2 model, so one can refer to "),ue=r(Ue,"CODE",{});var vt=a(ue);qo=i(vt,"Wav2Vec2"),vt.forEach(t),Wo=i(Ue,"\u2019s documentation page except for the tokenizer."),Ue.forEach(t),Le=c(e),w=r(e,"H2",{class:!0});var Oe=a(w);W=r(Oe,"A",{id:!0,class:!0,href:!0});var kt=a(W);fe=r(kt,"SPAN",{});var Tt=a(fe);j(D.$$.fragment,Tt),Tt.forEach(t),kt.forEach(t),Eo=c(Oe),_e=r(Oe,"SPAN",{});var bt=a(_e);Co=i(bt,"Wav2Vec2PhonemeCTCTokenizer"),bt.forEach(t),Oe.forEach(t),Be=c(e),m=r(e,"DIV",{class:!0});var f=a(m);j(S.$$.fragment,f),$o=c(f),ge=r(f,"P",{});var wt=a(ge);Vo=i(wt,"Constructs a Wav2Vec2PhonemeCTC tokenizer."),wt.forEach(t),Lo=c(f),R=r(f,"P",{});var Me=a(R);Bo=i(Me,"This tokenizer inherits from "),ne=r(Me,"A",{href:!0});var yt=a(ne);Io=i(yt,"PreTrainedTokenizer"),yt.forEach(t),Fo=i(Me,` which contains some of the main methods. Users should refer to
the superclass for more information regarding such methods.`),Me.forEach(t),Ao=c(f),E=r(f,"DIV",{class:!0});var He=a(E);j(U.$$.fragment,He),No=c(He),ve=r(He,"P",{});var zt=a(ve);Do=i(zt,`Main method to tokenize and prepare for the model one or several sequence(s) or one or several pair(s) of
sequences.`),zt.forEach(t),He.forEach(t),So=c(f),C=r(f,"DIV",{class:!0});var Xe=a(C);j(O.$$.fragment,Xe),Ro=c(Xe),ke=r(Xe,"P",{});var Pt=a(ke);Uo=i(Pt,"Convert a list of lists of token ids into a list of strings by calling decode."),Pt.forEach(t),Xe.forEach(t),Oo=c(f),k=r(f,"DIV",{class:!0});var re=a(k);j(M.$$.fragment,re),Mo=c(re),Te=r(re,"P",{});var xt=a(Te);Ho=i(xt,`Converts a sequence of ids in a string, using the tokenizer and vocabulary with options to remove special
tokens and clean up tokenization spaces.`),xt.forEach(t),Xo=c(re),H=r(re,"P",{});var je=a(H);jo=i(je,"Similar to doing "),be=r(je,"CODE",{});var qt=a(be);Qo=i(qt,"self.convert_tokens_to_string(self.convert_ids_to_tokens(token_ids))"),qt.forEach(t),Zo=i(je,"."),je.forEach(t),re.forEach(t),Jo=c(f),we=r(f,"DIV",{class:!0}),a(we).forEach(t),f.forEach(t),this.h()},h(){p(v,"name","hf:doc:metadata"),p(v,"content",JSON.stringify(Bt)),p(g,"id","wav2vec2phoneme"),p(g,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(g,"href","#wav2vec2phoneme"),p(_,"class","relative group"),p(y,"id","overview"),p(y,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(y,"href","#overview"),p(b,"class","relative group"),p(L,"href","https://arxiv.org/abs/2109.11680"),p(L,"rel","nofollow"),p(te,"href","/docs/transformers/v4.16.2/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer"),p(I,"href","https://huggingface.co/models?other=phoneme-recognition"),p(I,"rel","nofollow"),p(A,"href","https://huggingface.co/patrickvonplaten"),p(A,"rel","nofollow"),p(N,"href","https://github.com/pytorch/fairseq/tree/master/fairseq/models/wav2vec"),p(N,"rel","nofollow"),p(W,"id","transformers.Wav2Vec2PhonemeCTCTokenizer"),p(W,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(W,"href","#transformers.Wav2Vec2PhonemeCTCTokenizer"),p(w,"class","relative group"),p(ne,"href","/docs/transformers/v4.16.2/en/main_classes/tokenizer#transformers.PreTrainedTokenizer"),p(E,"class","docstring"),p(C,"class","docstring"),p(k,"class","docstring"),p(we,"class","docstring"),p(m,"class","docstring")},m(e,d){o(document.head,v),h(e,K,d),h(e,_,d),o(_,g),o(g,ae),Q($,ae,null),o(_,Je),o(_,se),o(se,Ge),h(e,ye,d),h(e,b,d),o(b,y),o(y,ie),Q(V,ie,null),o(b,Ke),o(b,le),o(le,Ye),h(e,ze,d),h(e,z,d),o(z,eo),o(z,L),o(L,oo),o(z,to),h(e,Pe,d),h(e,Y,d),o(Y,no),h(e,xe,d),h(e,ee,d),o(ee,ce),o(ce,ro),h(e,qe,d),h(e,oe,d),o(oe,ao),h(e,We,d),h(e,u,d),o(u,de),o(de,so),o(u,io),o(u,pe),o(pe,lo),o(u,co),o(u,B),o(B,po),o(B,te),o(te,ho),o(B,mo),o(u,uo),o(u,he),o(he,fo),o(u,_o),o(u,me),o(me,go),h(e,Ee,d),h(e,P,d),o(P,vo),o(P,I),o(I,ko),o(P,To),h(e,Ce,d),h(e,F,d),o(F,bo),o(F,A),o(A,wo),h(e,$e,d),h(e,x,d),o(x,yo),o(x,N),o(N,zo),o(x,Po),h(e,Ve,d),h(e,q,d),o(q,xo),o(q,ue),o(ue,qo),o(q,Wo),h(e,Le,d),h(e,w,d),o(w,W),o(W,fe),Q(D,fe,null),o(w,Eo),o(w,_e),o(_e,Co),h(e,Be,d),h(e,m,d),Q(S,m,null),o(m,$o),o(m,ge),o(ge,Vo),o(m,Lo),o(m,R),o(R,Bo),o(R,ne),o(ne,Io),o(R,Fo),o(m,Ao),o(m,E),Q(U,E,null),o(E,No),o(E,ve),o(ve,Do),o(m,So),o(m,C),Q(O,C,null),o(C,Ro),o(C,ke),o(ke,Uo),o(m,Oo),o(m,k),Q(M,k,null),o(k,Mo),o(k,Te),o(Te,Ho),o(k,Xo),o(k,H),o(H,jo),o(H,be),o(be,Qo),o(H,Zo),o(m,Jo),o(m,we),Ie=!0},p:Vt,i(e){Ie||(Z($.$$.fragment,e),Z(V.$$.fragment,e),Z(D.$$.fragment,e),Z(S.$$.fragment,e),Z(U.$$.fragment,e),Z(O.$$.fragment,e),Z(M.$$.fragment,e),Ie=!0)},o(e){J($.$$.fragment,e),J(V.$$.fragment,e),J(D.$$.fragment,e),J(S.$$.fragment,e),J(U.$$.fragment,e),J(O.$$.fragment,e),J(M.$$.fragment,e),Ie=!1},d(e){t(v),e&&t(K),e&&t(_),G($),e&&t(ye),e&&t(b),G(V),e&&t(ze),e&&t(z),e&&t(Pe),e&&t(Y),e&&t(xe),e&&t(ee),e&&t(qe),e&&t(oe),e&&t(We),e&&t(u),e&&t(Ee),e&&t(P),e&&t(Ce),e&&t(F),e&&t($e),e&&t(x),e&&t(Ve),e&&t(q),e&&t(Le),e&&t(w),G(D),e&&t(Be),e&&t(m),G(S),G(U),G(O),G(M)}}}const Bt={local:"wav2vec2phoneme",sections:[{local:"overview",title:"Overview"},{local:"transformers.Wav2Vec2PhonemeCTCTokenizer",title:"Wav2Vec2PhonemeCTCTokenizer"}],title:"Wav2Vec2Phoneme"};function It(Ze,v,K){let{fw:_}=v;return Ze.$$set=g=>{"fw"in g&&K(0,_=g.fw)},[_]}class Dt extends Wt{constructor(v){super();Et(this,v,It,Lt,Ct,{fw:0})}}export{Dt as default,Bt as metadata};
