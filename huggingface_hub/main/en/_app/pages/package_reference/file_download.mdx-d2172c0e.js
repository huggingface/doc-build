import{S as to,i as ao,s as ro,e as n,k as u,w as ee,t as l,M as io,c as t,d as o,m as p,a,x as oe,h as d,b as y,F as e,g as k,y as ne,q as te,o as ae,B as re,v as so}from"../../chunks/vendor-d3924577.js";import{T as ke}from"../../chunks/Tip-4377bed8.js";import{D as Ne}from"../../chunks/Docstring-6e765b82.js";import{C as lo}from"../../chunks/CodeBlock-ff545b14.js";import{I as co}from"../../chunks/IconCopyLink-f94c3d80.js";function ho(Y){let h,S,E,s,f,g,$,A,j,b,x,N,F,w,i,m,L,R,_,v,T,I,z,G;return{c(){h=n("p"),S=l("Raises the following errors:"),E=u(),s=n("ul"),f=n("li"),g=n("a"),$=n("code"),A=l("EnvironmentError"),j=l(`
if `),b=n("code"),x=l("use_auth_token=True"),N=l(" and the token cannot be found."),F=u(),w=n("li"),i=n("a"),m=n("code"),L=l("OSError"),R=l(`
if ETag cannot be determined.`),_=u(),v=n("li"),T=n("a"),I=n("code"),z=l("ValueError"),G=l(`
if some parameter value is invalid`),this.h()},l(c){h=t(c,"P",{});var D=a(h);S=d(D,"Raises the following errors:"),D.forEach(o),E=p(c),s=t(c,"UL",{});var O=a(s);f=t(O,"LI",{});var P=a(f);g=t(P,"A",{href:!0,rel:!0});var K=a(g);$=t(K,"CODE",{});var Q=a($);A=d(Q,"EnvironmentError"),Q.forEach(o),K.forEach(o),j=d(P,`
if `),b=t(P,"CODE",{});var V=a(b);x=d(V,"use_auth_token=True"),V.forEach(o),N=d(P," and the token cannot be found."),P.forEach(o),F=p(O),w=t(O,"LI",{});var H=a(w);i=t(H,"A",{href:!0,rel:!0});var q=a(i);m=t(q,"CODE",{});var W=a(m);L=d(W,"OSError"),W.forEach(o),q.forEach(o),R=d(H,`
if ETag cannot be determined.`),H.forEach(o),_=p(O),v=t(O,"LI",{});var M=a(v);T=t(M,"A",{href:!0,rel:!0});var J=a(T);I=t(J,"CODE",{});var X=a(I);z=d(X,"ValueError"),X.forEach(o),J.forEach(o),G=d(M,`
if some parameter value is invalid`),M.forEach(o),O.forEach(o),this.h()},h(){y(g,"href","https://docs.python.org/3/library/exceptions.html#EnvironmentError"),y(g,"rel","nofollow"),y(i,"href","https://docs.python.org/3/library/exceptions.html#OSError"),y(i,"rel","nofollow"),y(T,"href","https://docs.python.org/3/library/exceptions.html#ValueError"),y(T,"rel","nofollow")},m(c,D){k(c,h,D),e(h,S),k(c,E,D),k(c,s,D),e(s,f),e(f,g),e(g,$),e($,A),e(f,j),e(f,b),e(b,x),e(f,N),e(s,F),e(s,w),e(w,i),e(i,m),e(m,L),e(w,R),e(s,_),e(s,v),e(v,T),e(T,I),e(I,z),e(v,G)},d(c){c&&o(h),c&&o(E),c&&o(s)}}}function fo(Y){let h,S,E,s,f,g,$,A,j,b,x,N,F,w,i,m,L,R,_,v,T,I,z,G;return{c(){h=n("p"),S=l("Raises the following errors:"),E=u(),s=n("ul"),f=n("li"),g=n("a"),$=n("code"),A=l("EnvironmentError"),j=l(`
if `),b=n("code"),x=l("use_auth_token=True"),N=l(" and the token cannot be found."),F=u(),w=n("li"),i=n("a"),m=n("code"),L=l("OSError"),R=l(` if
ETag cannot be determined.`),_=u(),v=n("li"),T=n("a"),I=n("code"),z=l("ValueError"),G=l(`
if some parameter value is invalid`),this.h()},l(c){h=t(c,"P",{});var D=a(h);S=d(D,"Raises the following errors:"),D.forEach(o),E=p(c),s=t(c,"UL",{});var O=a(s);f=t(O,"LI",{});var P=a(f);g=t(P,"A",{href:!0,rel:!0});var K=a(g);$=t(K,"CODE",{});var Q=a($);A=d(Q,"EnvironmentError"),Q.forEach(o),K.forEach(o),j=d(P,`
if `),b=t(P,"CODE",{});var V=a(b);x=d(V,"use_auth_token=True"),V.forEach(o),N=d(P," and the token cannot be found."),P.forEach(o),F=p(O),w=t(O,"LI",{});var H=a(w);i=t(H,"A",{href:!0,rel:!0});var q=a(i);m=t(q,"CODE",{});var W=a(m);L=d(W,"OSError"),W.forEach(o),q.forEach(o),R=d(H,` if
ETag cannot be determined.`),H.forEach(o),_=p(O),v=t(O,"LI",{});var M=a(v);T=t(M,"A",{href:!0,rel:!0});var J=a(T);I=t(J,"CODE",{});var X=a(I);z=d(X,"ValueError"),X.forEach(o),J.forEach(o),G=d(M,`
if some parameter value is invalid`),M.forEach(o),O.forEach(o),this.h()},h(){y(g,"href","https://docs.python.org/3/library/exceptions.html#EnvironmentError"),y(g,"rel","nofollow"),y(i,"href","https://docs.python.org/3/library/exceptions.html#OSError"),y(i,"rel","nofollow"),y(T,"href","https://docs.python.org/3/library/exceptions.html#ValueError"),y(T,"rel","nofollow")},m(c,D){k(c,h,D),e(h,S),k(c,E,D),k(c,s,D),e(s,f),e(f,g),e(g,$),e($,A),e(f,j),e(f,b),e(b,x),e(f,N),e(s,F),e(s,w),e(w,i),e(i,m),e(m,L),e(w,R),e(s,_),e(s,v),e(v,T),e(T,I),e(I,z),e(v,G)},d(c){c&&o(h),c&&o(E),c&&o(s)}}}function go(Y){let h,S,E,s,f,g,$,A,j,b,x,N,F,w,i,m,L,R,_,v,T,I,z,G;return{c(){h=n("p"),S=l("Raises the following errors:"),E=u(),s=n("ul"),f=n("li"),g=n("a"),$=n("code"),A=l("EnvironmentError"),j=l(`
if `),b=n("code"),x=l("use_auth_token=True"),N=l(" and the token cannot be found."),F=u(),w=n("li"),i=n("a"),m=n("code"),L=l("OSError"),R=l(`
if ETag cannot be determined.`),_=u(),v=n("li"),T=n("a"),I=n("code"),z=l("ValueError"),G=l(`
if some parameter value is invalid`),this.h()},l(c){h=t(c,"P",{});var D=a(h);S=d(D,"Raises the following errors:"),D.forEach(o),E=p(c),s=t(c,"UL",{});var O=a(s);f=t(O,"LI",{});var P=a(f);g=t(P,"A",{href:!0,rel:!0});var K=a(g);$=t(K,"CODE",{});var Q=a($);A=d(Q,"EnvironmentError"),Q.forEach(o),K.forEach(o),j=d(P,`
if `),b=t(P,"CODE",{});var V=a(b);x=d(V,"use_auth_token=True"),V.forEach(o),N=d(P," and the token cannot be found."),P.forEach(o),F=p(O),w=t(O,"LI",{});var H=a(w);i=t(H,"A",{href:!0,rel:!0});var q=a(i);m=t(q,"CODE",{});var W=a(m);L=d(W,"OSError"),W.forEach(o),q.forEach(o),R=d(H,`
if ETag cannot be determined.`),H.forEach(o),_=p(O),v=t(O,"LI",{});var M=a(v);T=t(M,"A",{href:!0,rel:!0});var J=a(T);I=t(J,"CODE",{});var X=a(I);z=d(X,"ValueError"),X.forEach(o),J.forEach(o),G=d(M,`
if some parameter value is invalid`),M.forEach(o),O.forEach(o),this.h()},h(){y(g,"href","https://docs.python.org/3/library/exceptions.html#EnvironmentError"),y(g,"rel","nofollow"),y(i,"href","https://docs.python.org/3/library/exceptions.html#OSError"),y(i,"rel","nofollow"),y(T,"href","https://docs.python.org/3/library/exceptions.html#ValueError"),y(T,"rel","nofollow")},m(c,D){k(c,h,D),e(h,S),k(c,E,D),k(c,s,D),e(s,f),e(f,g),e(g,$),e($,A),e(f,j),e(f,b),e(b,x),e(f,N),e(s,F),e(s,w),e(w,i),e(i,m),e(m,L),e(w,R),e(s,_),e(s,v),e(v,T),e(T,I),e(I,z),e(v,G)},d(c){c&&o(h),c&&o(E),c&&o(s)}}}function uo(Y){let h,S,E,s,f,g,$,A,j,b,x,N,F,w;return{c(){h=n("p"),S=l("Notes:"),E=u(),s=n("p"),f=l(`Cloudfront is replicated over the globe so downloads are way faster for
the end user (and it also lowers our bandwidth costs).`),g=u(),$=n("p"),A=l(`Cloudfront aggressively caches files by default (default TTL is 24
hours), however this is not an issue here because we implement a
git-based versioning system on huggingface.co, which means that we store
the files on S3/Cloudfront in a content-addressable way (i.e., the file
name is its hash). Using content-addressable filenames means cache can\u2019t
ever be stale.`),j=u(),b=n("p"),x=l(`In terms of client-side caching from this library, we base our caching
on the objects\u2019 entity tag (`),N=n("code"),F=l("ETag"),w=l(`), which is an identifier of a
specific version of a resource [1]_. An object\u2019s ETag is: its git-sha1
if stored in git, or its sha256 if stored in git-lfs.`)},l(i){h=t(i,"P",{});var m=a(h);S=d(m,"Notes:"),m.forEach(o),E=p(i),s=t(i,"P",{});var L=a(s);f=d(L,`Cloudfront is replicated over the globe so downloads are way faster for
the end user (and it also lowers our bandwidth costs).`),L.forEach(o),g=p(i),$=t(i,"P",{});var R=a($);A=d(R,`Cloudfront aggressively caches files by default (default TTL is 24
hours), however this is not an issue here because we implement a
git-based versioning system on huggingface.co, which means that we store
the files on S3/Cloudfront in a content-addressable way (i.e., the file
name is its hash). Using content-addressable filenames means cache can\u2019t
ever be stale.`),R.forEach(o),j=p(i),b=t(i,"P",{});var _=a(b);x=d(_,`In terms of client-side caching from this library, we base our caching
on the objects\u2019 entity tag (`),N=t(_,"CODE",{});var v=a(N);F=d(v,"ETag"),v.forEach(o),w=d(_,`), which is an identifier of a
specific version of a resource [1]_. An object\u2019s ETag is: its git-sha1
if stored in git, or its sha256 if stored in git-lfs.`),_.forEach(o)},m(i,m){k(i,h,m),e(h,S),k(i,E,m),k(i,s,m),e(s,f),k(i,g,m),k(i,$,m),e($,A),k(i,j,m),k(i,b,m),e(b,x),e(b,N),e(N,F),e(b,w)},d(i){i&&o(h),i&&o(E),i&&o(s),i&&o(g),i&&o($),i&&o(j),i&&o(b)}}}function po(Y){let h,S,E,s,f,g,$,A,j,b,x,N,F,w,i,m,L,R,_,v,T,I,z,G,c,D,O,P,K,Q,V,H,q,W,M,J,X,De,pe,Oe,Le,ie,xe,C,de,Ie,me,Pe,qe,_e,Ue,Ae,be,Ce,Se,ce,je,se,Fe,ve,Re,Ve,we,ge,He,he,We,Te;return g=new co({}),N=new Ne({props:{name:"huggingface_hub.hf_hub_download",anchor:"huggingface_hub.hf_hub_download",parameters:[{name:"repo_id",val:": str"},{name:"filename",val:": str"},{name:"subfolder",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"force_download",val:": typing.Optional[bool] = False"},{name:"force_filename",val:": typing.Optional[str] = None"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.hf_hub_download.repo_id",description:`<strong>repo_id</strong> (<code>str</code>) &#x2014;
A user or an organization name and a repo name separated by a <code>/</code>.`,name:"repo_id"},{anchor:"huggingface_hub.hf_hub_download.filename",description:`<strong>filename</strong> (<code>str</code>) &#x2014;
The name of the file in the repo.`,name:"filename"},{anchor:"huggingface_hub.hf_hub_download.subfolder",description:`<strong>subfolder</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional value corresponding to a folder inside the model repo.`,name:"subfolder"},{anchor:"huggingface_hub.hf_hub_download.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Set to <code>&quot;dataset&quot;</code> or <code>&quot;space&quot;</code> if uploading to a dataset or space,
<code>None</code> or <code>&quot;model&quot;</code> if uploading to a model. Default is <code>None</code>.`,name:"repo_type"},{anchor:"huggingface_hub.hf_hub_download.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"},{anchor:"huggingface_hub.hf_hub_download.library_name",description:`<strong>library_name</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.hf_hub_download.library_version",description:`<strong>library_version</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.hf_hub_download.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <code>Path</code>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.hf_hub_download.user_agent",description:`<strong>user_agent</strong> (<code>dict</code>, <code>str</code>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.hf_hub_download.force_download",description:`<strong>force_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the file should be downloaded even if it already exists in
the local cache.`,name:"force_download"},{anchor:"huggingface_hub.hf_hub_download.force_filename",description:`<strong>force_filename</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Use this name instead of a generated file name.`,name:"force_filename"},{anchor:"huggingface_hub.hf_hub_download.proxies",description:`<strong>proxies</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<code>requests.request</code>.`,name:"proxies"},{anchor:"huggingface_hub.hf_hub_download.etag_timeout",description:`<strong>etag_timeout</strong> (<code>float</code>, <em>optional</em>, defaults to <code>10</code>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <code>requests.request</code>.`,name:"etag_timeout"},{anchor:"huggingface_hub.hf_hub_download.resume_download",description:`<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, resume a previously interrupted download.`,name:"resume_download"},{anchor:"huggingface_hub.hf_hub_download.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code>, <code>bool</code>, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <code>True</code>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"use_auth_token"},{anchor:"huggingface_hub.hf_hub_download.local_files_only",description:`<strong>local_files_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/file_download.py#L648",returnDescription:`
<p>Local path (string) of file or if networking is off, last version of
file cached on disk.</p>
`}}),L=new ke({props:{$$slots:{default:[ho]},$$scope:{ctx:Y}}}),v=new Ne({props:{name:"huggingface_hub.snapshot_download",anchor:"huggingface_hub.snapshot_download",parameters:[{name:"repo_id",val:": str"},{name:"revision",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"},{name:"allow_regex",val:": typing.Union[typing.List[str], str, NoneType] = None"},{name:"ignore_regex",val:": typing.Union[typing.List[str], str, NoneType] = None"}],parametersDescription:[{anchor:"huggingface_hub.snapshot_download.repo_id",description:`<strong>repo_id</strong> (<code>str</code>) &#x2014;
A user or an organization name and a repo name separated by a <code>/</code>.`,name:"repo_id"},{anchor:"huggingface_hub.snapshot_download.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"},{anchor:"huggingface_hub.snapshot_download.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <code>Path</code>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.snapshot_download.library_name",description:`<strong>library_name</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.snapshot_download.library_version",description:`<strong>library_version</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.snapshot_download.user_agent",description:`<strong>user_agent</strong> (<code>str</code>, <code>dict</code>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.snapshot_download.proxies",description:`<strong>proxies</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<code>requests.request</code>.`,name:"proxies"},{anchor:"huggingface_hub.snapshot_download.etag_timeout",description:`<strong>etag_timeout</strong> (<code>float</code>, <em>optional</em>, defaults to <code>10</code>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <code>requests.request</code>.`,name:"etag_timeout"},{anchor:"huggingface_hub.snapshot_download.resume_download",description:"<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False) -- If </code>True`, resume a previously interrupted download.",name:"resume_download"},{anchor:"huggingface_hub.snapshot_download.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code>, <code>bool</code>, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <code>True</code>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"use_auth_token"},{anchor:"huggingface_hub.snapshot_download.local_files_only",description:`<strong>local_files_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"},{anchor:"huggingface_hub.snapshot_download.allow_regex",description:`<strong>allow_regex</strong> (<code>list of str</code>, <code>str</code>, <em>optional</em>) &#x2014;
If provided, only files matching this regex are downloaded.`,name:"allow_regex"},{anchor:"huggingface_hub.snapshot_download.ignore_regex",description:`<strong>ignore_regex</strong> (<code>list of str</code>, <code>str</code>, <em>optional</em>) &#x2014;
If provided, files matching this regex are not downloaded.`,name:"ignore_regex"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/snapshot_download.py#L22",returnDescription:`
<p>Local folder path (string) of repo snapshot</p>
`}}),V=new ke({props:{$$slots:{default:[fo]},$$scope:{ctx:Y}}}),W=new Ne({props:{name:"huggingface_hub.cached_download",anchor:"huggingface_hub.cached_download",parameters:[{name:"url",val:": str"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"force_download",val:": typing.Optional[bool] = False"},{name:"force_filename",val:": typing.Optional[str] = None"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.cached_download.url",description:`<strong>url</strong> (<code>str</code>) &#x2014;
The path to the file to be downloaded.`,name:"url"},{anchor:"huggingface_hub.cached_download.library_name",description:`<strong>library_name</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.cached_download.library_version",description:`<strong>library_version</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.cached_download.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <code>Path</code>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.cached_download.user_agent",description:`<strong>user_agent</strong> (<code>dict</code>, <code>str</code>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.cached_download.force_download",description:`<strong>force_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the file should be downloaded even if it already exists in
the local cache.`,name:"force_download"},{anchor:"huggingface_hub.cached_download.force_filename",description:`<strong>force_filename</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Use this name instead of a generated file name.`,name:"force_filename"},{anchor:"huggingface_hub.cached_download.proxies",description:`<strong>proxies</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<code>requests.request</code>.`,name:"proxies"},{anchor:"huggingface_hub.cached_download.etag_timeout",description:`<strong>etag_timeout</strong> (<code>float</code>, <em>optional</em> defaults to <code>10</code>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <code>requests.request</code>.`,name:"etag_timeout"},{anchor:"huggingface_hub.cached_download.resume_download",description:`<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, resume a previously interrupted download.`,name:"resume_download"},{anchor:"huggingface_hub.cached_download.use_auth_token",description:`<strong>use_auth_token</strong> (<code>bool</code>, <code>str</code>, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <code>True</code>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"use_auth_token"},{anchor:"huggingface_hub.cached_download.local_files_only",description:`<strong>local_files_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/file_download.py#L402",returnDescription:`
<p>Local path (string) of file or if networking is off, last version of
file cached on disk.</p>
`}}),ie=new ke({props:{$$slots:{default:[go]},$$scope:{ctx:Y}}}),de=new Ne({props:{name:"huggingface_hub.hf_hub_url",anchor:"huggingface_hub.hf_hub_url",parameters:[{name:"repo_id",val:": str"},{name:"filename",val:": str"},{name:"subfolder",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.hf_hub_url.repo_id",description:`<strong>repo_id</strong> (<code>str</code>) &#x2014;
A namespace (user or an organization) name and a repo name separated
by a <code>/</code>.`,name:"repo_id"},{anchor:"huggingface_hub.hf_hub_url.filename",description:`<strong>filename</strong> (<code>str</code>) &#x2014;
The name of the file in the repo.`,name:"filename"},{anchor:"huggingface_hub.hf_hub_url.subfolder",description:`<strong>subfolder</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional value corresponding to a folder inside the repo.`,name:"subfolder"},{anchor:"huggingface_hub.hf_hub_url.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Set to <code>&quot;dataset&quot;</code> or <code>&quot;space&quot;</code> if uploading to a dataset or space,
<code>None</code> or <code>&quot;model&quot;</code> if uploading to a model. Default is <code>None</code>.`,name:"repo_type"},{anchor:"huggingface_hub.hf_hub_url.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/file_download.py#L109"}}),ce=new lo({props:{code:`from huggingface_hub import hf_hub_url

hf_hub_url(
    repo_id="julien-c/EsperBERTo-small", filename="pytorch_model.bin"
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> huggingface_hub <span class="hljs-keyword">import</span> hf_hub_url

<span class="hljs-meta">&gt;&gt;&gt; </span>hf_hub_url(
<span class="hljs-meta">... </span>    repo_id=<span class="hljs-string">&quot;julien-c/EsperBERTo-small&quot;</span>, filename=<span class="hljs-string">&quot;pytorch_model.bin&quot;</span>
<span class="hljs-meta">... </span>)
<span class="hljs-string">&#x27;https://huggingface.co/julien-c/EsperBERTo-small/resolve/main/pytorch_model.bin&#x27;</span>`}}),se=new ke({props:{$$slots:{default:[uo]},$$scope:{ctx:Y}}}),{c(){h=n("meta"),S=u(),E=n("h1"),s=n("a"),f=n("span"),ee(g.$$.fragment),$=u(),A=n("span"),j=l("Downloading files"),b=u(),x=n("div"),ee(N.$$.fragment),F=u(),w=n("p"),i=l("Download a given file if it\u2019s not already present in the local cache."),m=u(),ee(L.$$.fragment),R=u(),_=n("div"),ee(v.$$.fragment),T=u(),I=n("p"),z=l("Download all files of a repo."),G=u(),c=n("p"),D=l(`Downloads a whole snapshot of a repo\u2019s files at the specified revision. This
is useful when you want all files from a repo, because you don\u2019t know which
ones you will need a priori. All files are nested inside a folder in order
to keep their actual filename relative to that folder.`),O=u(),P=n("p"),K=l(`An alternative would be to just clone a repo but this would require that the
user always has git and git-lfs installed, and properly configured.`),Q=u(),ee(V.$$.fragment),H=u(),q=n("div"),ee(W.$$.fragment),M=u(),J=n("p"),X=l(`Download from a given URL and cache it if it\u2019s not already present in the
local cache.`),De=u(),pe=n("p"),Oe=l(`Given a URL, this function looks for the corresponding file in the local
cache. If it\u2019s not there, download it. Then return the path to the cached
file.`),Le=u(),ee(ie.$$.fragment),xe=u(),C=n("div"),ee(de.$$.fragment),Ie=u(),me=n("p"),Pe=l("Construct the URL of a file from the given information."),qe=u(),_e=n("p"),Ue=l(`The resolved address can either be a huggingface.co-hosted url, or a link to
Cloudfront (a Content Delivery Network, or CDN) for large files which are
more than a few MBs.`),Ae=u(),be=n("p"),Ce=l("Example:"),Se=u(),ee(ce.$$.fragment),je=u(),ee(se.$$.fragment),Fe=u(),ve=n("p"),Re=l("References:"),Ve=u(),we=n("ul"),ge=n("li"),He=l("[1] "),he=n("a"),We=l("https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),this.h()},l(r){const U=io('[data-svelte="svelte-1phssyn"]',document.head);h=t(U,"META",{name:!0,content:!0}),U.forEach(o),S=p(r),E=t(r,"H1",{class:!0});var fe=a(E);s=t(fe,"A",{id:!0,class:!0,href:!0});var ye=a(s);f=t(ye,"SPAN",{});var Ee=a(f);oe(g.$$.fragment,Ee),Ee.forEach(o),ye.forEach(o),$=p(fe),A=t(fe,"SPAN",{});var $e=a(A);j=d($e,"Downloading files"),$e.forEach(o),fe.forEach(o),b=p(r),x=t(r,"DIV",{class:!0});var ue=a(x);oe(N.$$.fragment,ue),F=p(ue),w=t(ue,"P",{});var ze=a(w);i=d(ze,"Download a given file if it\u2019s not already present in the local cache."),ze.forEach(o),m=p(ue),oe(L.$$.fragment,ue),ue.forEach(o),R=p(r),_=t(r,"DIV",{class:!0});var Z=a(_);oe(v.$$.fragment,Z),T=p(Z),I=t(Z,"P",{});var Ge=a(I);z=d(Ge,"Download all files of a repo."),Ge.forEach(o),G=p(Z),c=t(Z,"P",{});var Me=a(c);D=d(Me,`Downloads a whole snapshot of a repo\u2019s files at the specified revision. This
is useful when you want all files from a repo, because you don\u2019t know which
ones you will need a priori. All files are nested inside a folder in order
to keep their actual filename relative to that folder.`),Me.forEach(o),O=p(Z),P=t(Z,"P",{});var Je=a(P);K=d(Je,`An alternative would be to just clone a repo but this would require that the
user always has git and git-lfs installed, and properly configured.`),Je.forEach(o),Q=p(Z),oe(V.$$.fragment,Z),Z.forEach(o),H=p(r),q=t(r,"DIV",{class:!0});var le=a(q);oe(W.$$.fragment,le),M=p(le),J=t(le,"P",{});var Ke=a(J);X=d(Ke,`Download from a given URL and cache it if it\u2019s not already present in the
local cache.`),Ke.forEach(o),De=p(le),pe=t(le,"P",{});var Qe=a(pe);Oe=d(Qe,`Given a URL, this function looks for the corresponding file in the local
cache. If it\u2019s not there, download it. Then return the path to the cached
file.`),Qe.forEach(o),Le=p(le),oe(ie.$$.fragment,le),le.forEach(o),xe=p(r),C=t(r,"DIV",{class:!0});var B=a(C);oe(de.$$.fragment,B),Ie=p(B),me=t(B,"P",{});var Xe=a(me);Pe=d(Xe,"Construct the URL of a file from the given information."),Xe.forEach(o),qe=p(B),_e=t(B,"P",{});var Ye=a(_e);Ue=d(Ye,`The resolved address can either be a huggingface.co-hosted url, or a link to
Cloudfront (a Content Delivery Network, or CDN) for large files which are
more than a few MBs.`),Ye.forEach(o),Ae=p(B),be=t(B,"P",{});var Ze=a(be);Ce=d(Ze,"Example:"),Ze.forEach(o),Se=p(B),oe(ce.$$.fragment,B),je=p(B),oe(se.$$.fragment,B),Fe=p(B),ve=t(B,"P",{});var eo=a(ve);Re=d(eo,"References:"),eo.forEach(o),Ve=p(B),we=t(B,"UL",{});var oo=a(we);ge=t(oo,"LI",{});var Be=a(ge);He=d(Be,"[1] "),he=t(Be,"A",{href:!0,rel:!0});var no=a(he);We=d(no,"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),no.forEach(o),Be.forEach(o),oo.forEach(o),B.forEach(o),this.h()},h(){y(h,"name","hf:doc:metadata"),y(h,"content",JSON.stringify(mo)),y(s,"id","huggingface_hub.hf_hub_download"),y(s,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(s,"href","#huggingface_hub.hf_hub_download"),y(E,"class","relative group"),y(x,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(_,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),y(he,"href","https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),y(he,"rel","nofollow"),y(C,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(r,U){e(document.head,h),k(r,S,U),k(r,E,U),e(E,s),e(s,f),ne(g,f,null),e(E,$),e(E,A),e(A,j),k(r,b,U),k(r,x,U),ne(N,x,null),e(x,F),e(x,w),e(w,i),e(x,m),ne(L,x,null),k(r,R,U),k(r,_,U),ne(v,_,null),e(_,T),e(_,I),e(I,z),e(_,G),e(_,c),e(c,D),e(_,O),e(_,P),e(P,K),e(_,Q),ne(V,_,null),k(r,H,U),k(r,q,U),ne(W,q,null),e(q,M),e(q,J),e(J,X),e(q,De),e(q,pe),e(pe,Oe),e(q,Le),ne(ie,q,null),k(r,xe,U),k(r,C,U),ne(de,C,null),e(C,Ie),e(C,me),e(me,Pe),e(C,qe),e(C,_e),e(_e,Ue),e(C,Ae),e(C,be),e(be,Ce),e(C,Se),ne(ce,C,null),e(C,je),ne(se,C,null),e(C,Fe),e(C,ve),e(ve,Re),e(C,Ve),e(C,we),e(we,ge),e(ge,He),e(ge,he),e(he,We),Te=!0},p(r,[U]){const fe={};U&2&&(fe.$$scope={dirty:U,ctx:r}),L.$set(fe);const ye={};U&2&&(ye.$$scope={dirty:U,ctx:r}),V.$set(ye);const Ee={};U&2&&(Ee.$$scope={dirty:U,ctx:r}),ie.$set(Ee);const $e={};U&2&&($e.$$scope={dirty:U,ctx:r}),se.$set($e)},i(r){Te||(te(g.$$.fragment,r),te(N.$$.fragment,r),te(L.$$.fragment,r),te(v.$$.fragment,r),te(V.$$.fragment,r),te(W.$$.fragment,r),te(ie.$$.fragment,r),te(de.$$.fragment,r),te(ce.$$.fragment,r),te(se.$$.fragment,r),Te=!0)},o(r){ae(g.$$.fragment,r),ae(N.$$.fragment,r),ae(L.$$.fragment,r),ae(v.$$.fragment,r),ae(V.$$.fragment,r),ae(W.$$.fragment,r),ae(ie.$$.fragment,r),ae(de.$$.fragment,r),ae(ce.$$.fragment,r),ae(se.$$.fragment,r),Te=!1},d(r){o(h),r&&o(S),r&&o(E),re(g),r&&o(b),r&&o(x),re(N),re(L),r&&o(R),r&&o(_),re(v),re(V),r&&o(H),r&&o(q),re(W),re(ie),r&&o(xe),r&&o(C),re(de),re(ce),re(se)}}}const mo={local:"huggingface_hub.hf_hub_download",title:"Downloading files"};function _o(Y){return so(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class $o extends to{constructor(h){super();ao(this,h,_o,po,ro,{})}}export{$o as default,mo as metadata};
