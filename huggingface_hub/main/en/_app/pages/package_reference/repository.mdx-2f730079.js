import{S as lg,i as cg,s as gg,e as r,k as l,w as d,t as i,M as hg,c as n,d as o,m as c,a,x as u,h as s,b as p,F as e,g as $,y as m,L as pg,q as f,o as _,B as b,v as dg}from"../../chunks/vendor-d3924577.js";import{D as v}from"../../chunks/Docstring-6e765b82.js";import{C as ug}from"../../chunks/CodeBlock-ff545b14.js";import{I as Rn}from"../../chunks/IconCopyLink-f94c3d80.js";function mg(El){let V,kr,A,oe,Wt,Ve,Tn,Bt,Pn,Er,k,In,Gt,On,Ln,zt,Cn,Fn,Jt,Nn,jn,xr,re,Hn,Kt,Vn,An,Dr,S,ne,Qt,Ae,Sn,Xt,qn,Rr,g,Se,Un,Yt,Mn,Wn,Zt,Bn,Gn,E,qe,zn,eo,Jn,Kn,q,Qn,to,Xn,Yn,oo,Zn,ea,ta,x,ro,oa,ra,no,na,aa,ao,ia,sa,io,la,ca,ga,ae,Ue,ha,so,pa,da,D,Me,ua,lo,ma,fa,co,_a,ba,go,ya,va,ie,We,$a,ho,wa,ka,se,Be,Ea,po,xa,Da,le,Ge,Ra,U,Ta,uo,Pa,Ia,mo,Oa,La,Ca,C,ze,Fa,fo,Na,ja,_o,Ha,Va,R,Je,Aa,M,Sa,bo,qa,Ua,yo,Ma,Wa,Ba,vo,Ga,za,Ke,Ja,ce,Qe,Ka,$o,Qa,Xa,F,Xe,Ya,wo,Za,ei,I,ti,ko,oi,ri,Eo,ni,ai,xo,ii,si,li,N,Ye,ci,Do,gi,hi,W,pi,Ro,di,ui,To,mi,fi,_i,ge,Ze,bi,Po,yi,vi,he,et,$i,Io,wi,ki,pe,tt,Ei,Ot,xi,Oo,Di,Ri,de,ot,Ti,Lo,Pi,Ii,ue,rt,Oi,Co,Li,Ci,me,nt,Fi,Fo,Ni,ji,j,at,Hi,No,Vi,Ai,B,Si,jo,qi,Ui,Ho,Mi,Wi,Bi,fe,it,Gi,Vo,zi,Ji,_e,st,Ki,Ao,Qi,Xi,be,lt,Yi,So,Zi,es,ye,ct,ts,qo,os,rs,H,gt,ns,Uo,as,is,O,ss,Mo,ls,cs,Wo,gs,hs,Bo,ps,ds,us,ve,ht,ms,Go,fs,_s,$e,pt,bs,zo,ys,vs,we,dt,$s,Jo,ws,ks,ke,ut,Es,Ko,xs,Ds,Ee,mt,Rs,Qo,Ts,Tr,G,xe,Xo,ft,Ps,Yo,Is,Pr,z,_t,Os,Zo,Ls,Ir,J,bt,Cs,er,Fs,Or,K,yt,Ns,tr,js,Lr,Q,vt,Hs,or,Vs,Cr,X,$t,As,rr,Ss,Fr,Y,wt,qs,nr,Us,Nr,L,kt,Ms,ar,Ws,Bs,ir,Gs,jr,Z,De,sr,Et,zs,lr,Js,Hr,Re,Ks,cr,Qs,Xs,Vr,T,gr,hr,Ys,Zs,pr,dr,el,tl,ur,mr,ol,rl,xt,nl,fr,al,il,Ar,Lt,sl,Sr,w,Dt,ll,_r,cl,gl,br,hl,pl,Te,Rt,dl,yr,ul,ml,Pe,Tt,fl,vr,_l,bl,Ie,Pt,yl,$r,vl,qr,ee,It,$l,wr,wl,Ur;return Ve=new Rn({}),Ae=new Rn({}),Se=new v({props:{name:"class huggingface_hub.Repository",anchor:"huggingface_hub.Repository",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L407"}}),qe=new v({props:{name:"__init__",anchor:"huggingface_hub.Repository.__init__",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.__init__.local_dir",description:`<strong>local_dir</strong> (<code>str</code>) &#x2014;
path (e.g. <code>&apos;my_trained_model/&apos;</code>) to the local directory, where
the <code>Repository</code> will be initalized.`,name:"local_dir"},{anchor:"huggingface_hub.Repository.__init__.clone_from",description:`<strong>clone_from</strong> (<code>str</code>, <em>optional</em>) &#x2014;
repository url (e.g.
<code>&apos;https://huggingface.co/philschmid/playground-tests&apos;</code>).`,name:"clone_from"},{anchor:"huggingface_hub.Repository.__init__.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
To set when creating a repo: et to &#x201C;dataset&#x201D; or &#x201C;space&#x201D; if
creating a dataset or space, default is model.`,name:"repo_type"},{anchor:"huggingface_hub.Repository.__init__.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code> or <code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
huggingface_token can be extract from <code>HfApi().login(username, password)</code> and is used to authenticate against the hub (useful
from Google Colab for instance).`,name:"use_auth_token"},{anchor:"huggingface_hub.Repository.__init__.git_user",description:`<strong>git_user</strong> (<code>str</code>, <em>optional</em>) &#x2014;
will override the <code>git config user.name</code> for committing and
pushing files to the hub.`,name:"git_user"},{anchor:"huggingface_hub.Repository.__init__.git_email",description:`<strong>git_email</strong> (<code>str</code>, <em>optional</em>) &#x2014;
will override the <code>git config user.email</code> for committing and
pushing files to the hub.`,name:"git_email"},{anchor:"huggingface_hub.Repository.__init__.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Revision to checkout after initializing the repository. If the
revision doesn&#x2019;t exist, a branch will be created with that
revision name from the default branch&#x2019;s current HEAD.`,name:"revision"},{anchor:"huggingface_hub.Repository.__init__.private",description:`<strong>private</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
whether the repository is private or not.`,name:"private"},{anchor:"huggingface_hub.Repository.__init__.skip_lfs_files",description:`<strong>skip_lfs_files</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
whether to skip git-LFS files or not.`,name:"skip_lfs_files"},{anchor:"huggingface_hub.Repository.__init__.client",description:`<strong>client</strong> (<code>HfApi</code>, <em>optional</em>) &#x2014;
Instance of HfApi to use when calling the HF Hub API. A new
instance will be created if this is left to <code>None</code>.`,name:"client"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L418"}}),Ue=new v({props:{name:"current_branch",anchor:"huggingface_hub.Repository.current_branch",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L527",returnDescription:`
<p>Current checked out branch.</p>
`,returnType:`
<p><code>str</code></p>
`}}),Me=new v({props:{name:"add_tag",anchor:"huggingface_hub.Repository.add_tag",parameters:[{name:"tag_name",val:": str"},{name:"message",val:": str = None"},{name:"remote",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.add_tag.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The name of the tag to be added.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.add_tag.message",description:`<strong>message</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The message that accompanies the tag. The tag will turn into an
annotated tag if a message is passed.`,name:"message"},{anchor:"huggingface_hub.Repository.add_tag.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The remote on which to add the tag.`,name:"remote"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1274"}}),We=new v({props:{name:"auto_track_binary_files",anchor:"huggingface_hub.Repository.auto_track_binary_files",parameters:[{name:"pattern",val:": typing.Optional[str] = '.'"}],parametersDescription:[{anchor:"huggingface_hub.Repository.auto_track_binary_files.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to track files that are binary.`,name:"pattern"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L886",returnDescription:`
<p>List of filenames that are now tracked due to being
binary files</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),Be=new v({props:{name:"auto_track_large_files",anchor:"huggingface_hub.Repository.auto_track_large_files",parameters:[{name:"pattern",val:": typing.Optional[str] = '.'"}],parametersDescription:[{anchor:"huggingface_hub.Repository.auto_track_large_files.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to track files that are above 10MBs.`,name:"pattern"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L929",returnDescription:`
<p>List of filenames that are now tracked due to their
size.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),Ge=new v({props:{name:"check_git_versions",anchor:"huggingface_hub.Repository.check_git_versions",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L544"}}),ze=new v({props:{name:"clone_from",anchor:"huggingface_hub.Repository.clone_from",parameters:[{name:"repo_url",val:": str"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.clone_from.repo_url",description:`<strong>repo_url</strong> (<code>str</code>) &#x2014;
The URL from which to clone the repository`,name:"repo_url"},{anchor:"huggingface_hub.Repository.clone_from.use_auth_token",description:`<strong>use_auth_token</strong> (<code>Union[str, bool]</code>, <em>optional</em>) &#x2014;
Whether to use the authentication token. It can be:<ul>
<li>a string which is the token itself</li>
<li><code>False</code>, which would not use the authentication token</li>
<li><code>True</code>, which would fetch the authentication token from the
local folder and use it (you should be logged in for this to
work).</li>
<li><code>None</code>, which would retrieve the value of
<code>self.huggingface_token</code>.</li>
</ul>`,name:"use_auth_token"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L572"}}),Je=new v({props:{name:"commit",anchor:"huggingface_hub.Repository.commit",parameters:[{name:"commit_message",val:": str"},{name:"branch",val:": typing.Optional[str] = None"},{name:"track_large_files",val:": typing.Optional[bool] = True"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.commit.commit_message",description:`<strong>commit_message</strong> (<code>str</code>) &#x2014;
Message to use for the commit.`,name:"commit_message"},{anchor:"huggingface_hub.Repository.commit.branch",description:`<strong>branch</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The branch on which the commit will appear. This branch will be
checked-out before any operation.`,name:"branch"},{anchor:"huggingface_hub.Repository.commit.track_large_files",description:`<strong>track_large_files</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to automatically track large files or not. Will do so by
default.`,name:"track_large_files"},{anchor:"huggingface_hub.Repository.commit.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the <code>git push</code> has
finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.commit.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1362"}}),Ke=new ug({props:{code:`with Repository(
    "text-files",
    clone_from="<user>/text-files",
    use_auth_token=True,
).commit("My first file :)"):
    with open("file.txt", "w+") as f:
        f.write(json.dumps({"hey": 8}))

import torch

model = torch.nn.Transformer()
with Repository(
    "torch-model",
    clone_from="<user>/torch-model",
    use_auth_token=True,
).commit("My cool model :)"):
    torch.save(model.state_dict(), "model.pt")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> Repository(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;text-files&quot;</span>,
<span class="hljs-meta">... </span>    clone_from=<span class="hljs-string">&quot;&lt;user&gt;/text-files&quot;</span>,
<span class="hljs-meta">... </span>    use_auth_token=<span class="hljs-literal">True</span>,
<span class="hljs-meta">&gt;&gt;&gt; </span>).commit(<span class="hljs-string">&quot;My first file :)&quot;</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>) <span class="hljs-keyword">as</span> f:
<span class="hljs-meta">... </span>        f.write(json.dumps({<span class="hljs-string">&quot;hey&quot;</span>: <span class="hljs-number">8</span>}))

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>model = torch.nn.Transformer()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> Repository(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;torch-model&quot;</span>,
<span class="hljs-meta">... </span>    clone_from=<span class="hljs-string">&quot;&lt;user&gt;/torch-model&quot;</span>,
<span class="hljs-meta">... </span>    use_auth_token=<span class="hljs-literal">True</span>,
<span class="hljs-meta">&gt;&gt;&gt; </span>).commit(<span class="hljs-string">&quot;My cool model :)&quot;</span>):
<span class="hljs-meta">... </span>    torch.save(model.state_dict(), <span class="hljs-string">&quot;model.pt&quot;</span>)`}}),Qe=new v({props:{name:"delete_tag",anchor:"huggingface_hub.Repository.delete_tag",parameters:[{name:"tag_name",val:": str"},{name:"remote",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.delete_tag.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The tag name to delete.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.delete_tag.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The remote on which to delete the tag.`,name:"remote"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1233",returnDescription:`
<p><code>True</code> if deleted, <code>False</code> if the tag didn\u2019t exist.
If remote is not passed, will just be updated locally</p>
`,returnType:`
<p><code>bool</code></p>
`}}),Xe=new v({props:{name:"git_add",anchor:"huggingface_hub.Repository.git_add",parameters:[{name:"pattern",val:": typing.Optional[str] = '.'"},{name:"auto_lfs_track",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_add.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to add files to staging.`,name:"pattern"},{anchor:"huggingface_hub.Repository.git_add.auto_lfs_track",description:`<strong>auto_lfs_track</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically track large and binary files with
git-lfs. Any file over 10MB in size, or in binary format, will
be automatically tracked.`,name:"auto_lfs_track"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1017"}}),Ye=new v({props:{name:"git_checkout",anchor:"huggingface_hub.Repository.git_checkout",parameters:[{name:"revision",val:": str"},{name:"create_branch_ok",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_checkout.revision",description:`<strong>revision</strong> (<code>str</code>) &#x2014;
The revision to checkout.`,name:"revision"},{anchor:"huggingface_hub.Repository.git_checkout.create_branch_ok",description:`<strong>create_branch_ok</strong> (<code>str</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether creating a branch named with the <code>revision</code> passed at
the current checked-out reference if <code>revision</code> isn&#x2019;t an
existing revision is allowed.`,name:"create_branch_ok"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1165"}}),Ze=new v({props:{name:"git_commit",anchor:"huggingface_hub.Repository.git_commit",parameters:[{name:"commit_message",val:": str = 'commit files to HF hub'"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_commit.commit_message",description:`<strong>commit_message</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201C;commit files to HF hub&#x201D;) &#x2014;
The message attributed to the commit.`,name:"commit_message"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1052"}}),et=new v({props:{name:"git_config_username_and_email",anchor:"huggingface_hub.Repository.git_config_username_and_email",parameters:[{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_config_username_and_email.git_user",description:`<strong>git_user</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The username to register through <code>git</code>.`,name:"git_user"},{anchor:"huggingface_hub.Repository.git_config_username_and_email.git_email",description:`<strong>git_email</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The email to register through <code>git</code>.`,name:"git_email"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L711"}}),tt=new v({props:{name:"git_credential_helper_store",anchor:"huggingface_hub.Repository.git_credential_helper_store",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L736"}}),ot=new v({props:{name:"git_head_commit_url",anchor:"huggingface_hub.Repository.git_head_commit_url",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L775",returnDescription:`
<p>The URL to the current checked-out commit.</p>
`,returnType:`
<p><code>str</code></p>
`}}),rt=new v({props:{name:"git_head_hash",anchor:"huggingface_hub.Repository.git_head_hash",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L745",returnDescription:`
<p>The current checked out commit SHA.</p>
`,returnType:`
<p><code>str</code></p>
`}}),nt=new v({props:{name:"git_pull",anchor:"huggingface_hub.Repository.git_pull",parameters:[{name:"rebase",val:": typing.Optional[bool] = False"},{name:"lfs",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_pull.rebase",description:`<strong>rebase</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to rebase the current branch on top of the upstream
branch after fetching.`,name:"rebase"},{anchor:"huggingface_hub.Repository.git_pull.lfs",description:`<strong>lfs</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to fetch the LFS files too. This option only changes the
behavior when a repository was cloned without fetching the LFS
files; calling <code>repo.git_pull(lfs=True)</code> will then fetch the LFS
file from the remote repository.`,name:"lfs"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L990"}}),at=new v({props:{name:"git_push",anchor:"huggingface_hub.Repository.git_push",parameters:[{name:"upstream",val:": typing.Optional[str] = None"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_push.upstream",description:`<strong>upstream</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Upstream to which this should push. If not specified, will push
to the lastly defined upstream or to the default one (<code>origin main</code>).`,name:"upstream"},{anchor:"huggingface_hub.Repository.git_push.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the push has
finished. Setting this to <code>False</code> will return an
<code>CommandInProgress</code> object which has an <code>is_done</code> property. This
property will be set to <code>True</code> when the push is finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.git_push.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1071"}}),it=new v({props:{name:"git_remote_url",anchor:"huggingface_hub.Repository.git_remote_url",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L758",returnDescription:`
<p>The URL of the <code>origin</code> remote.</p>
`,returnType:`
<p><code>str</code></p>
`}}),st=new v({props:{name:"is_repo_clean",anchor:"huggingface_hub.Repository.is_repo_clean",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1310",returnDescription:`
<p><code>True</code> if the git status is clean, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),lt=new v({props:{name:"lfs_enable_largefiles",anchor:"huggingface_hub.Repository.lfs_enable_largefiles",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L872"}}),ct=new v({props:{name:"lfs_prune",anchor:"huggingface_hub.Repository.lfs_prune",parameters:[{name:"recent",val:" = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_prune.recent",description:`<strong>recent</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to prune files even if they were referenced by recent
commits. See the following
<a href="https://github.com/git-lfs/git-lfs/blob/f3d43f0428a84fc4f1e5405b76b5a73ec2437e65/docs/man/git-lfs-prune.1.ronn#recent-files" rel="nofollow">link</a>
for more information.`,name:"recent"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L966"}}),gt=new v({props:{name:"lfs_track",anchor:"huggingface_hub.Repository.lfs_track",parameters:[{name:"patterns",val:": typing.Union[str, typing.List[str]]"},{name:"filename",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_track.patterns",description:`<strong>patterns</strong> (<code>Union[str, List[str]]</code>) &#x2014;
The pattern, or list of patterns, to track with git-lfs.`,name:"patterns"},{anchor:"huggingface_hub.Repository.lfs_track.filename",description:`<strong>filename</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to use the patterns as literal filenames.`,name:"filename"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L830"}}),ht=new v({props:{name:"lfs_untrack",anchor:"huggingface_hub.Repository.lfs_untrack",parameters:[{name:"patterns",val:": typing.Union[str, typing.List[str]]"}],parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_untrack.patterns",description:`<strong>patterns</strong> (<code>Union[str, List[str]]</code>) &#x2014;
The pattern, or list of patterns, to untrack with git-lfs.`,name:"patterns"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L856"}}),pt=new v({props:{name:"list_deleted_files",anchor:"huggingface_hub.Repository.list_deleted_files",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L789",returnDescription:`
<p>A list of files that have been deleted in the working
directory or index.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),dt=new v({props:{name:"push_to_hub",anchor:"huggingface_hub.Repository.push_to_hub",parameters:[{name:"commit_message",val:": typing.Optional[str] = 'commit files to HF hub'"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"clean_ok",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.push_to_hub.commit_message",description:`<strong>commit_message</strong> (<code>str</code>) &#x2014;
Message to use for the commit.`,name:"commit_message"},{anchor:"huggingface_hub.Repository.push_to_hub.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the <code>git push</code> has
finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.push_to_hub.clean_ok",description:`<strong>clean_ok</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
If True, this function will return None if the repo is
untouched. Default behavior is to fail because the git command
fails.`,name:"clean_ok"},{anchor:"huggingface_hub.Repository.push_to_hub.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1326"}}),ut=new v({props:{name:"tag_exists",anchor:"huggingface_hub.Repository.tag_exists",parameters:[{name:"tag_name",val:": str"},{name:"remote",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.tag_exists.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The name of the tag to check.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.tag_exists.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Whether to check if the tag exists on a remote. This parameter
should be the identifier of the remote.`,name:"remote"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1199",returnDescription:`
<p>Whether the tag exists.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),mt=new v({props:{name:"wait_for_commands",anchor:"huggingface_hub.Repository.wait_for_commands",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1494"}}),ft=new Rn({}),_t=new v({props:{name:"huggingface_hub.repository.is_git_repo",anchor:"huggingface_hub.repository.is_git_repo",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_git_repo.folder",description:`<strong>folder</strong> (<code>str</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L103",returnDescription:`
<p><code>True</code> if the repository is part of a repository, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),bt=new v({props:{name:"huggingface_hub.repository.is_local_clone",anchor:"huggingface_hub.repository.is_local_clone",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"},{name:"remote_url",val:": str"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_local_clone.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"},{anchor:"huggingface_hub.repository.is_local_clone.remote_url",description:`<strong>remote_url</strong> (<code>str</code>) &#x2014;
The url of a git repository.`,name:"remote_url"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L122",returnDescription:`
<p><code>True</code> if the repository is a local clone of the remote
repository specified, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),yt=new v({props:{name:"huggingface_hub.repository.is_tracked_with_lfs",anchor:"huggingface_hub.repository.is_tracked_with_lfs",parameters:[{name:"filename",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_tracked_with_lfs.filename",description:`<strong>filename</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The filename to check.`,name:"filename"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L147",returnDescription:`
<p><code>True</code> if the file passed is tracked with git-lfs, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),vt=new v({props:{name:"huggingface_hub.repository.is_git_ignored",anchor:"huggingface_hub.repository.is_git_ignored",parameters:[{name:"filename",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_git_ignored.filename",description:`<strong>filename</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The filename to check.`,name:"filename"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L184",returnDescription:`
<p><code>True</code> if the file passed is ignored by <code>git</code>, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),$t=new v({props:{name:"huggingface_hub.repository.files_to_be_staged",anchor:"huggingface_hub.repository.files_to_be_staged",parameters:[{name:"pattern",val:": str"},{name:"folder",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.files_to_be_staged.pattern",description:`<strong>pattern</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The pattern of filenames to check. Put <code>.</code> to get all files.`,name:"pattern"},{anchor:"huggingface_hub.repository.files_to_be_staged.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L234",returnDescription:`
<p>List of files that are to be staged.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),wt=new v({props:{name:"huggingface_hub.repository.is_tracked_upstream",anchor:"huggingface_hub.repository.is_tracked_upstream",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_tracked_upstream.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L259",returnDescription:`
<p><code>True</code> if the current checked-out branch is tracked upstream,
<code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),kt=new v({props:{name:"huggingface_hub.repository.commits_to_push",anchor:"huggingface_hub.repository.commits_to_push",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"},{name:"upstream",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.repository.commits_to_push.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"},{anchor:"huggingface_hub.repository.commits_to_push.upstream",description:"<strong>upstream</strong> (<code>str</code>, <em>optional</em>) &#x2014;",name:"upstream"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L283",returnDescription:`
<p>Number of commits that would be pushed upstream were a <code>git push</code> to proceed.</p>
`,returnType:`
<p><code>int</code></p>
`}}),Et=new Rn({}),Dt=new v({props:{name:"class huggingface_hub.Repository",anchor:"huggingface_hub.Repository",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L407"}}),Rt=new v({props:{name:"commands_failed",anchor:"huggingface_hub.Repository.commands_failed",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1480"}}),Tt=new v({props:{name:"commands_in_progress",anchor:"huggingface_hub.Repository.commands_in_progress",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1487"}}),Pt=new v({props:{name:"wait_for_commands",anchor:"huggingface_hub.Repository.wait_for_commands",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1494"}}),It=new v({props:{name:"class huggingface_hub.repository.CommandInProgress",anchor:"huggingface_hub.repository.CommandInProgress",parameters:[{name:"title",val:": str"},{name:"is_done_method",val:": typing.Callable"},{name:"status_method",val:": typing.Callable"},{name:"process",val:": Popen"},{name:"post_method",val:": typing.Optional[typing.Callable] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L26"}}),{c(){V=r("meta"),kr=l(),A=r("h1"),oe=r("a"),Wt=r("span"),d(Ve.$$.fragment),Tn=l(),Bt=r("span"),Pn=i("Managing local and online repositories"),Er=l(),k=r("p"),In=i("The "),Gt=r("code"),On=i("Repository"),Ln=i(" class is a helper class that wraps "),zt=r("code"),Cn=i("git"),Fn=i(" and "),Jt=r("code"),Nn=i("git-lfs"),jn=i(` commands. It provides tooling adapted
for managing repositories which can be very large.`),xr=l(),re=r("p"),Hn=i("It is the recommended tool as soon as any "),Kt=r("code"),Vn=i("git"),An=i(` operation is involved, or when collaboration will be a point
of focus with the repository itself.`),Dr=l(),S=r("h2"),ne=r("a"),Qt=r("span"),d(Ae.$$.fragment),Sn=l(),Xt=r("span"),qn=i("The Repository class"),Rr=l(),g=r("div"),d(Se.$$.fragment),Un=l(),Yt=r("p"),Mn=i("Helper class to wrap the git and git-lfs commands."),Wn=l(),Zt=r("p"),Bn=i(`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),Gn=l(),E=r("div"),d(qe.$$.fragment),zn=l(),eo=r("p"),Jn=i("Instantiate a local clone of a git repo."),Kn=l(),q=r("p"),Qn=i("If specifying a "),to=r("code"),Xn=i("clone_from"),Yn=i(`, it will clone an existing remote
repository, for instance one that was previously created using
`),oo=r("code"),Zn=i("HfApi().create_repo(repo_id=repo_name)"),ea=i("."),ta=l(),x=r("p"),ro=r("code"),oa=i("Repository"),ra=i(` uses the local git credentials by default, but if required,
the `),no=r("code"),na=i("huggingface_token"),aa=i(" as well as the git "),ao=r("code"),ia=i("user"),sa=i(" and the "),io=r("code"),la=i("email"),ca=i(` can be
explicitly specified.`),ga=l(),ae=r("div"),d(Ue.$$.fragment),ha=l(),so=r("p"),pa=i("Returns the current checked out branch."),da=l(),D=r("div"),d(Me.$$.fragment),ua=l(),lo=r("p"),ma=i("Add a tag at the current head and push it"),fa=l(),co=r("p"),_a=i("If remote is None, will just be updated locally"),ba=l(),go=r("p"),ya=i(`If no message is provided, the tag will be lightweight. if a message is
provided, the tag will be annotated.`),va=l(),ie=r("div"),d(We.$$.fragment),$a=l(),ho=r("p"),wa=i("Automatically track binary files with git-lfs."),ka=l(),se=r("div"),d(Be.$$.fragment),Ea=l(),po=r("p"),xa=i(`Automatically track large files (files that weigh more than 10MBs) with
git-lfs.`),Da=l(),le=r("div"),d(Ge.$$.fragment),Ra=l(),U=r("p"),Ta=i("Checks that "),uo=r("code"),Pa=i("git"),Ia=i(" and "),mo=r("code"),Oa=i("git-lfs"),La=i(" can be run."),Ca=l(),C=r("div"),d(ze.$$.fragment),Fa=l(),fo=r("p"),Na=i(`Clone from a remote. If the folder already exists, will try to clone the
repository within it.`),ja=l(),_o=r("p"),Ha=i(`If this folder is a git repository with linked history, will try to
update the repository.`),Va=l(),R=r("div"),d(Je.$$.fragment),Aa=l(),M=r("p"),Sa=i(`Context manager utility to handle committing to a repository. This
automatically tracks large files (>10Mb) with git-lfs. Set the
`),bo=r("code"),qa=i("track_large_files"),Ua=i(" argument to "),yo=r("code"),Ma=i("False"),Wa=i(` if you wish to ignore that
behavior.`),Ba=l(),vo=r("p"),Ga=i("Examples:"),za=l(),d(Ke.$$.fragment),Ja=l(),ce=r("div"),d(Qe.$$.fragment),Ka=l(),$o=r("p"),Qa=i("Delete a tag, both local and remote, if it exists"),Xa=l(),F=r("div"),d(Xe.$$.fragment),Ya=l(),wo=r("p"),Za=i("git add"),ei=l(),I=r("p"),ti=i("Setting the "),ko=r("code"),oi=i("auto_lfs_track"),ri=i(" parameter to "),Eo=r("code"),ni=i("True"),ai=i(` will automatically
track files that are larger than 10MB with `),xo=r("code"),ii=i("git-lfs"),si=i("."),li=l(),N=r("div"),d(Ye.$$.fragment),ci=l(),Do=r("p"),gi=i("git checkout a given revision"),hi=l(),W=r("p"),pi=i("Specifying "),Ro=r("code"),di=i("create_branch_ok"),ui=i(" to "),To=r("code"),mi=i("True"),fi=i(` will create the branch to the
given revision if that revision doesn\u2019t exist.`),_i=l(),ge=r("div"),d(Ze.$$.fragment),bi=l(),Po=r("p"),yi=i("git commit"),vi=l(),he=r("div"),d(et.$$.fragment),$i=l(),Io=r("p"),wi=i("Sets git username and email (only in the current repo)."),ki=l(),pe=r("div"),d(tt.$$.fragment),Ei=l(),Ot=r("p"),xi=i("Sets the git credential helper to "),Oo=r("code"),Di=i("store"),Ri=l(),de=r("div"),d(ot.$$.fragment),Ti=l(),Lo=r("p"),Pi=i(`Get URL to last commit on HEAD. We assume it\u2019s been pushed, and the url
scheme is the same one as for GitHub or HuggingFace.`),Ii=l(),ue=r("div"),d(rt.$$.fragment),Oi=l(),Co=r("p"),Li=i("Get commit sha on top of HEAD."),Ci=l(),me=r("div"),d(nt.$$.fragment),Fi=l(),Fo=r("p"),Ni=i("git pull"),ji=l(),j=r("div"),d(at.$$.fragment),Hi=l(),No=r("p"),Vi=i("git push"),Ai=l(),B=r("p"),Si=i("If used without setting "),jo=r("code"),qi=i("blocking"),Ui=i(`, will return url to commit on remote
repo. If used with `),Ho=r("code"),Mi=i("blocking=True"),Wi=i(`, will return a tuple containing the
url to commit and the command object to follow for information about the
process.`),Bi=l(),fe=r("div"),d(it.$$.fragment),Gi=l(),Vo=r("p"),zi=i("Get URL to origin remote."),Ji=l(),_e=r("div"),d(st.$$.fragment),Ki=l(),Ao=r("p"),Qi=i("Return whether or not the git status is clean or not"),Xi=l(),be=r("div"),d(lt.$$.fragment),Yi=l(),So=r("p"),Zi=i("HF-specific. This enables upload support of files >5GB."),es=l(),ye=r("div"),d(ct.$$.fragment),ts=l(),qo=r("p"),os=i("git lfs prune"),rs=l(),H=r("div"),d(gt.$$.fragment),ns=l(),Uo=r("p"),as=i("Tell git-lfs to track files according to a pattern."),is=l(),O=r("p"),ss=i("Setting the "),Mo=r("code"),ls=i("filename"),cs=i(" argument to "),Wo=r("code"),gs=i("True"),hs=i(` will treat the arguments as
literal filenames, not as patterns. Any special glob characters in the
filename will be escaped when writing to the `),Bo=r("code"),ps=i(".gitattributes"),ds=i(" file."),us=l(),ve=r("div"),d(ht.$$.fragment),ms=l(),Go=r("p"),fs=i("Tell git-lfs to untrack those files."),_s=l(),$e=r("div"),d(pt.$$.fragment),bs=l(),zo=r("p"),ys=i(`Returns a list of the files that are deleted in the working directory or
index.`),vs=l(),we=r("div"),d(dt.$$.fragment),$s=l(),Jo=r("p"),ws=i(`Helper to add, commit, and push files to remote repository on the
HuggingFace Hub. Will automatically track large files (>10MB).`),ks=l(),ke=r("div"),d(ut.$$.fragment),Es=l(),Ko=r("p"),xs=i("Check if a tag exists or not."),Ds=l(),Ee=r("div"),d(mt.$$.fragment),Rs=l(),Qo=r("p"),Ts=i(`Blocking method: blocks all subsequent execution until all commands have
been processed.`),Tr=l(),G=r("h2"),xe=r("a"),Xo=r("span"),d(ft.$$.fragment),Ps=l(),Yo=r("span"),Is=i("Helper methods"),Pr=l(),z=r("div"),d(_t.$$.fragment),Os=l(),Zo=r("p"),Ls=i("Check if the folder is the root or part of a git repository"),Ir=l(),J=r("div"),d(bt.$$.fragment),Cs=l(),er=r("p"),Fs=i("Check if the folder is a local clone of the remote_url"),Or=l(),K=r("div"),d(yt.$$.fragment),Ns=l(),tr=r("p"),js=i("Check if the file passed is tracked with git-lfs."),Lr=l(),Q=r("div"),d(vt.$$.fragment),Hs=l(),or=r("p"),Vs=i("Check if file is git-ignored. Supports nested .gitignore files."),Cr=l(),X=r("div"),d($t.$$.fragment),As=l(),rr=r("p"),Ss=i("Returns a list of filenames that are to be staged."),Fr=l(),Y=r("div"),d(wt.$$.fragment),qs=l(),nr=r("p"),Us=i("Check if the current checked-out branch is tracked upstream."),Nr=l(),L=r("div"),d(kt.$$.fragment),Ms=l(),ar=r("p"),Ws=i("Check the number of commits that would be pushed upstream"),Bs=l(),ir=r("p"),Gs=i(`The name of the upstream repository with which the comparison should be
made.`),jr=l(),Z=r("h2"),De=r("a"),sr=r("span"),d(Et.$$.fragment),zs=l(),lr=r("span"),Js=i("Following asynchronous commands"),Hr=l(),Re=r("p"),Ks=i("The "),cr=r("code"),Qs=i("Repository"),Xs=i(" utility offers several methods which can be launched asynchronously:"),Vr=l(),T=r("ul"),gr=r("li"),hr=r("code"),Ys=i("git_push"),Zs=l(),pr=r("li"),dr=r("code"),el=i("git_pull"),tl=l(),ur=r("li"),mr=r("code"),ol=i("push_to_hub"),rl=l(),xt=r("li"),nl=i("The "),fr=r("code"),al=i("commit"),il=i(" context manager"),Ar=l(),Lt=r("p"),sl=i("See below for utilities to manage such asynchronous methods."),Sr=l(),w=r("div"),d(Dt.$$.fragment),ll=l(),_r=r("p"),cl=i("Helper class to wrap the git and git-lfs commands."),gl=l(),br=r("p"),hl=i(`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),pl=l(),Te=r("div"),d(Rt.$$.fragment),dl=l(),yr=r("p"),ul=i("Returns the asynchronous commands that failed."),ml=l(),Pe=r("div"),d(Tt.$$.fragment),fl=l(),vr=r("p"),_l=i("Returns the asynchronous commands that are currently in progress."),bl=l(),Ie=r("div"),d(Pt.$$.fragment),yl=l(),$r=r("p"),vl=i(`Blocking method: blocks all subsequent execution until all commands have
been processed.`),qr=l(),ee=r("div"),d(It.$$.fragment),$l=l(),wr=r("p"),wl=i("Utility to follow commands launched asynchronously."),this.h()},l(t){const y=hg('[data-svelte="svelte-1phssyn"]',document.head);V=n(y,"META",{name:!0,content:!0}),y.forEach(o),kr=c(t),A=n(t,"H1",{class:!0});var Mr=a(A);oe=n(Mr,"A",{id:!0,class:!0,href:!0});var xl=a(oe);Wt=n(xl,"SPAN",{});var Dl=a(Wt);u(Ve.$$.fragment,Dl),Dl.forEach(o),xl.forEach(o),Tn=c(Mr),Bt=n(Mr,"SPAN",{});var Rl=a(Bt);Pn=s(Rl,"Managing local and online repositories"),Rl.forEach(o),Mr.forEach(o),Er=c(t),k=n(t,"P",{});var Oe=a(k);In=s(Oe,"The "),Gt=n(Oe,"CODE",{});var Tl=a(Gt);On=s(Tl,"Repository"),Tl.forEach(o),Ln=s(Oe," class is a helper class that wraps "),zt=n(Oe,"CODE",{});var Pl=a(zt);Cn=s(Pl,"git"),Pl.forEach(o),Fn=s(Oe," and "),Jt=n(Oe,"CODE",{});var Il=a(Jt);Nn=s(Il,"git-lfs"),Il.forEach(o),jn=s(Oe,` commands. It provides tooling adapted
for managing repositories which can be very large.`),Oe.forEach(o),xr=c(t),re=n(t,"P",{});var Wr=a(re);Hn=s(Wr,"It is the recommended tool as soon as any "),Kt=n(Wr,"CODE",{});var Ol=a(Kt);Vn=s(Ol,"git"),Ol.forEach(o),An=s(Wr,` operation is involved, or when collaboration will be a point
of focus with the repository itself.`),Wr.forEach(o),Dr=c(t),S=n(t,"H2",{class:!0});var Br=a(S);ne=n(Br,"A",{id:!0,class:!0,href:!0});var Ll=a(ne);Qt=n(Ll,"SPAN",{});var Cl=a(Qt);u(Ae.$$.fragment,Cl),Cl.forEach(o),Ll.forEach(o),Sn=c(Br),Xt=n(Br,"SPAN",{});var Fl=a(Xt);qn=s(Fl,"The Repository class"),Fl.forEach(o),Br.forEach(o),Rr=c(t),g=n(t,"DIV",{class:!0});var h=a(g);u(Se.$$.fragment,h),Un=c(h),Yt=n(h,"P",{});var Nl=a(Yt);Mn=s(Nl,"Helper class to wrap the git and git-lfs commands."),Nl.forEach(o),Wn=c(h),Zt=n(h,"P",{});var jl=a(Zt);Bn=s(jl,`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),jl.forEach(o),Gn=c(h),E=n(h,"DIV",{class:!0});var Le=a(E);u(qe.$$.fragment,Le),zn=c(Le),eo=n(Le,"P",{});var Hl=a(eo);Jn=s(Hl,"Instantiate a local clone of a git repo."),Hl.forEach(o),Kn=c(Le),q=n(Le,"P",{});var Ct=a(q);Qn=s(Ct,"If specifying a "),to=n(Ct,"CODE",{});var Vl=a(to);Xn=s(Vl,"clone_from"),Vl.forEach(o),Yn=s(Ct,`, it will clone an existing remote
repository, for instance one that was previously created using
`),oo=n(Ct,"CODE",{});var Al=a(oo);Zn=s(Al,"HfApi().create_repo(repo_id=repo_name)"),Al.forEach(o),ea=s(Ct,"."),Ct.forEach(o),ta=c(Le),x=n(Le,"P",{});var te=a(x);ro=n(te,"CODE",{});var Sl=a(ro);oa=s(Sl,"Repository"),Sl.forEach(o),ra=s(te,` uses the local git credentials by default, but if required,
the `),no=n(te,"CODE",{});var ql=a(no);na=s(ql,"huggingface_token"),ql.forEach(o),aa=s(te," as well as the git "),ao=n(te,"CODE",{});var Ul=a(ao);ia=s(Ul,"user"),Ul.forEach(o),sa=s(te," and the "),io=n(te,"CODE",{});var Ml=a(io);la=s(Ml,"email"),Ml.forEach(o),ca=s(te,` can be
explicitly specified.`),te.forEach(o),Le.forEach(o),ga=c(h),ae=n(h,"DIV",{class:!0});var Gr=a(ae);u(Ue.$$.fragment,Gr),ha=c(Gr),so=n(Gr,"P",{});var Wl=a(so);pa=s(Wl,"Returns the current checked out branch."),Wl.forEach(o),Gr.forEach(o),da=c(h),D=n(h,"DIV",{class:!0});var Ce=a(D);u(Me.$$.fragment,Ce),ua=c(Ce),lo=n(Ce,"P",{});var Bl=a(lo);ma=s(Bl,"Add a tag at the current head and push it"),Bl.forEach(o),fa=c(Ce),co=n(Ce,"P",{});var Gl=a(co);_a=s(Gl,"If remote is None, will just be updated locally"),Gl.forEach(o),ba=c(Ce),go=n(Ce,"P",{});var zl=a(go);ya=s(zl,`If no message is provided, the tag will be lightweight. if a message is
provided, the tag will be annotated.`),zl.forEach(o),Ce.forEach(o),va=c(h),ie=n(h,"DIV",{class:!0});var zr=a(ie);u(We.$$.fragment,zr),$a=c(zr),ho=n(zr,"P",{});var Jl=a(ho);wa=s(Jl,"Automatically track binary files with git-lfs."),Jl.forEach(o),zr.forEach(o),ka=c(h),se=n(h,"DIV",{class:!0});var Jr=a(se);u(Be.$$.fragment,Jr),Ea=c(Jr),po=n(Jr,"P",{});var Kl=a(po);xa=s(Kl,`Automatically track large files (files that weigh more than 10MBs) with
git-lfs.`),Kl.forEach(o),Jr.forEach(o),Da=c(h),le=n(h,"DIV",{class:!0});var Kr=a(le);u(Ge.$$.fragment,Kr),Ra=c(Kr),U=n(Kr,"P",{});var Ft=a(U);Ta=s(Ft,"Checks that "),uo=n(Ft,"CODE",{});var Ql=a(uo);Pa=s(Ql,"git"),Ql.forEach(o),Ia=s(Ft," and "),mo=n(Ft,"CODE",{});var Xl=a(mo);Oa=s(Xl,"git-lfs"),Xl.forEach(o),La=s(Ft," can be run."),Ft.forEach(o),Kr.forEach(o),Ca=c(h),C=n(h,"DIV",{class:!0});var Nt=a(C);u(ze.$$.fragment,Nt),Fa=c(Nt),fo=n(Nt,"P",{});var Yl=a(fo);Na=s(Yl,`Clone from a remote. If the folder already exists, will try to clone the
repository within it.`),Yl.forEach(o),ja=c(Nt),_o=n(Nt,"P",{});var Zl=a(_o);Ha=s(Zl,`If this folder is a git repository with linked history, will try to
update the repository.`),Zl.forEach(o),Nt.forEach(o),Va=c(h),R=n(h,"DIV",{class:!0});var Fe=a(R);u(Je.$$.fragment,Fe),Aa=c(Fe),M=n(Fe,"P",{});var jt=a(M);Sa=s(jt,`Context manager utility to handle committing to a repository. This
automatically tracks large files (>10Mb) with git-lfs. Set the
`),bo=n(jt,"CODE",{});var ec=a(bo);qa=s(ec,"track_large_files"),ec.forEach(o),Ua=s(jt," argument to "),yo=n(jt,"CODE",{});var tc=a(yo);Ma=s(tc,"False"),tc.forEach(o),Wa=s(jt,` if you wish to ignore that
behavior.`),jt.forEach(o),Ba=c(Fe),vo=n(Fe,"P",{});var oc=a(vo);Ga=s(oc,"Examples:"),oc.forEach(o),za=c(Fe),u(Ke.$$.fragment,Fe),Fe.forEach(o),Ja=c(h),ce=n(h,"DIV",{class:!0});var Qr=a(ce);u(Qe.$$.fragment,Qr),Ka=c(Qr),$o=n(Qr,"P",{});var rc=a($o);Qa=s(rc,"Delete a tag, both local and remote, if it exists"),rc.forEach(o),Qr.forEach(o),Xa=c(h),F=n(h,"DIV",{class:!0});var Ht=a(F);u(Xe.$$.fragment,Ht),Ya=c(Ht),wo=n(Ht,"P",{});var nc=a(wo);Za=s(nc,"git add"),nc.forEach(o),ei=c(Ht),I=n(Ht,"P",{});var Ne=a(I);ti=s(Ne,"Setting the "),ko=n(Ne,"CODE",{});var ac=a(ko);oi=s(ac,"auto_lfs_track"),ac.forEach(o),ri=s(Ne," parameter to "),Eo=n(Ne,"CODE",{});var ic=a(Eo);ni=s(ic,"True"),ic.forEach(o),ai=s(Ne,` will automatically
track files that are larger than 10MB with `),xo=n(Ne,"CODE",{});var sc=a(xo);ii=s(sc,"git-lfs"),sc.forEach(o),si=s(Ne,"."),Ne.forEach(o),Ht.forEach(o),li=c(h),N=n(h,"DIV",{class:!0});var Vt=a(N);u(Ye.$$.fragment,Vt),ci=c(Vt),Do=n(Vt,"P",{});var lc=a(Do);gi=s(lc,"git checkout a given revision"),lc.forEach(o),hi=c(Vt),W=n(Vt,"P",{});var At=a(W);pi=s(At,"Specifying "),Ro=n(At,"CODE",{});var cc=a(Ro);di=s(cc,"create_branch_ok"),cc.forEach(o),ui=s(At," to "),To=n(At,"CODE",{});var gc=a(To);mi=s(gc,"True"),gc.forEach(o),fi=s(At,` will create the branch to the
given revision if that revision doesn\u2019t exist.`),At.forEach(o),Vt.forEach(o),_i=c(h),ge=n(h,"DIV",{class:!0});var Xr=a(ge);u(Ze.$$.fragment,Xr),bi=c(Xr),Po=n(Xr,"P",{});var hc=a(Po);yi=s(hc,"git commit"),hc.forEach(o),Xr.forEach(o),vi=c(h),he=n(h,"DIV",{class:!0});var Yr=a(he);u(et.$$.fragment,Yr),$i=c(Yr),Io=n(Yr,"P",{});var pc=a(Io);wi=s(pc,"Sets git username and email (only in the current repo)."),pc.forEach(o),Yr.forEach(o),ki=c(h),pe=n(h,"DIV",{class:!0});var Zr=a(pe);u(tt.$$.fragment,Zr),Ei=c(Zr),Ot=n(Zr,"P",{});var kl=a(Ot);xi=s(kl,"Sets the git credential helper to "),Oo=n(kl,"CODE",{});var dc=a(Oo);Di=s(dc,"store"),dc.forEach(o),kl.forEach(o),Zr.forEach(o),Ri=c(h),de=n(h,"DIV",{class:!0});var en=a(de);u(ot.$$.fragment,en),Ti=c(en),Lo=n(en,"P",{});var uc=a(Lo);Pi=s(uc,`Get URL to last commit on HEAD. We assume it\u2019s been pushed, and the url
scheme is the same one as for GitHub or HuggingFace.`),uc.forEach(o),en.forEach(o),Ii=c(h),ue=n(h,"DIV",{class:!0});var tn=a(ue);u(rt.$$.fragment,tn),Oi=c(tn),Co=n(tn,"P",{});var mc=a(Co);Li=s(mc,"Get commit sha on top of HEAD."),mc.forEach(o),tn.forEach(o),Ci=c(h),me=n(h,"DIV",{class:!0});var on=a(me);u(nt.$$.fragment,on),Fi=c(on),Fo=n(on,"P",{});var fc=a(Fo);Ni=s(fc,"git pull"),fc.forEach(o),on.forEach(o),ji=c(h),j=n(h,"DIV",{class:!0});var St=a(j);u(at.$$.fragment,St),Hi=c(St),No=n(St,"P",{});var _c=a(No);Vi=s(_c,"git push"),_c.forEach(o),Ai=c(St),B=n(St,"P",{});var qt=a(B);Si=s(qt,"If used without setting "),jo=n(qt,"CODE",{});var bc=a(jo);qi=s(bc,"blocking"),bc.forEach(o),Ui=s(qt,`, will return url to commit on remote
repo. If used with `),Ho=n(qt,"CODE",{});var yc=a(Ho);Mi=s(yc,"blocking=True"),yc.forEach(o),Wi=s(qt,`, will return a tuple containing the
url to commit and the command object to follow for information about the
process.`),qt.forEach(o),St.forEach(o),Bi=c(h),fe=n(h,"DIV",{class:!0});var rn=a(fe);u(it.$$.fragment,rn),Gi=c(rn),Vo=n(rn,"P",{});var vc=a(Vo);zi=s(vc,"Get URL to origin remote."),vc.forEach(o),rn.forEach(o),Ji=c(h),_e=n(h,"DIV",{class:!0});var nn=a(_e);u(st.$$.fragment,nn),Ki=c(nn),Ao=n(nn,"P",{});var $c=a(Ao);Qi=s($c,"Return whether or not the git status is clean or not"),$c.forEach(o),nn.forEach(o),Xi=c(h),be=n(h,"DIV",{class:!0});var an=a(be);u(lt.$$.fragment,an),Yi=c(an),So=n(an,"P",{});var wc=a(So);Zi=s(wc,"HF-specific. This enables upload support of files >5GB."),wc.forEach(o),an.forEach(o),es=c(h),ye=n(h,"DIV",{class:!0});var sn=a(ye);u(ct.$$.fragment,sn),ts=c(sn),qo=n(sn,"P",{});var kc=a(qo);os=s(kc,"git lfs prune"),kc.forEach(o),sn.forEach(o),rs=c(h),H=n(h,"DIV",{class:!0});var Ut=a(H);u(gt.$$.fragment,Ut),ns=c(Ut),Uo=n(Ut,"P",{});var Ec=a(Uo);as=s(Ec,"Tell git-lfs to track files according to a pattern."),Ec.forEach(o),is=c(Ut),O=n(Ut,"P",{});var je=a(O);ss=s(je,"Setting the "),Mo=n(je,"CODE",{});var xc=a(Mo);ls=s(xc,"filename"),xc.forEach(o),cs=s(je," argument to "),Wo=n(je,"CODE",{});var Dc=a(Wo);gs=s(Dc,"True"),Dc.forEach(o),hs=s(je,` will treat the arguments as
literal filenames, not as patterns. Any special glob characters in the
filename will be escaped when writing to the `),Bo=n(je,"CODE",{});var Rc=a(Bo);ps=s(Rc,".gitattributes"),Rc.forEach(o),ds=s(je," file."),je.forEach(o),Ut.forEach(o),us=c(h),ve=n(h,"DIV",{class:!0});var ln=a(ve);u(ht.$$.fragment,ln),ms=c(ln),Go=n(ln,"P",{});var Tc=a(Go);fs=s(Tc,"Tell git-lfs to untrack those files."),Tc.forEach(o),ln.forEach(o),_s=c(h),$e=n(h,"DIV",{class:!0});var cn=a($e);u(pt.$$.fragment,cn),bs=c(cn),zo=n(cn,"P",{});var Pc=a(zo);ys=s(Pc,`Returns a list of the files that are deleted in the working directory or
index.`),Pc.forEach(o),cn.forEach(o),vs=c(h),we=n(h,"DIV",{class:!0});var gn=a(we);u(dt.$$.fragment,gn),$s=c(gn),Jo=n(gn,"P",{});var Ic=a(Jo);ws=s(Ic,`Helper to add, commit, and push files to remote repository on the
HuggingFace Hub. Will automatically track large files (>10MB).`),Ic.forEach(o),gn.forEach(o),ks=c(h),ke=n(h,"DIV",{class:!0});var hn=a(ke);u(ut.$$.fragment,hn),Es=c(hn),Ko=n(hn,"P",{});var Oc=a(Ko);xs=s(Oc,"Check if a tag exists or not."),Oc.forEach(o),hn.forEach(o),Ds=c(h),Ee=n(h,"DIV",{class:!0});var pn=a(Ee);u(mt.$$.fragment,pn),Rs=c(pn),Qo=n(pn,"P",{});var Lc=a(Qo);Ts=s(Lc,`Blocking method: blocks all subsequent execution until all commands have
been processed.`),Lc.forEach(o),pn.forEach(o),h.forEach(o),Tr=c(t),G=n(t,"H2",{class:!0});var dn=a(G);xe=n(dn,"A",{id:!0,class:!0,href:!0});var Cc=a(xe);Xo=n(Cc,"SPAN",{});var Fc=a(Xo);u(ft.$$.fragment,Fc),Fc.forEach(o),Cc.forEach(o),Ps=c(dn),Yo=n(dn,"SPAN",{});var Nc=a(Yo);Is=s(Nc,"Helper methods"),Nc.forEach(o),dn.forEach(o),Pr=c(t),z=n(t,"DIV",{class:!0});var un=a(z);u(_t.$$.fragment,un),Os=c(un),Zo=n(un,"P",{});var jc=a(Zo);Ls=s(jc,"Check if the folder is the root or part of a git repository"),jc.forEach(o),un.forEach(o),Ir=c(t),J=n(t,"DIV",{class:!0});var mn=a(J);u(bt.$$.fragment,mn),Cs=c(mn),er=n(mn,"P",{});var Hc=a(er);Fs=s(Hc,"Check if the folder is a local clone of the remote_url"),Hc.forEach(o),mn.forEach(o),Or=c(t),K=n(t,"DIV",{class:!0});var fn=a(K);u(yt.$$.fragment,fn),Ns=c(fn),tr=n(fn,"P",{});var Vc=a(tr);js=s(Vc,"Check if the file passed is tracked with git-lfs."),Vc.forEach(o),fn.forEach(o),Lr=c(t),Q=n(t,"DIV",{class:!0});var _n=a(Q);u(vt.$$.fragment,_n),Hs=c(_n),or=n(_n,"P",{});var Ac=a(or);Vs=s(Ac,"Check if file is git-ignored. Supports nested .gitignore files."),Ac.forEach(o),_n.forEach(o),Cr=c(t),X=n(t,"DIV",{class:!0});var bn=a(X);u($t.$$.fragment,bn),As=c(bn),rr=n(bn,"P",{});var Sc=a(rr);Ss=s(Sc,"Returns a list of filenames that are to be staged."),Sc.forEach(o),bn.forEach(o),Fr=c(t),Y=n(t,"DIV",{class:!0});var yn=a(Y);u(wt.$$.fragment,yn),qs=c(yn),nr=n(yn,"P",{});var qc=a(nr);Us=s(qc,"Check if the current checked-out branch is tracked upstream."),qc.forEach(o),yn.forEach(o),Nr=c(t),L=n(t,"DIV",{class:!0});var Mt=a(L);u(kt.$$.fragment,Mt),Ms=c(Mt),ar=n(Mt,"P",{});var Uc=a(ar);Ws=s(Uc,"Check the number of commits that would be pushed upstream"),Uc.forEach(o),Bs=c(Mt),ir=n(Mt,"P",{});var Mc=a(ir);Gs=s(Mc,`The name of the upstream repository with which the comparison should be
made.`),Mc.forEach(o),Mt.forEach(o),jr=c(t),Z=n(t,"H2",{class:!0});var vn=a(Z);De=n(vn,"A",{id:!0,class:!0,href:!0});var Wc=a(De);sr=n(Wc,"SPAN",{});var Bc=a(sr);u(Et.$$.fragment,Bc),Bc.forEach(o),Wc.forEach(o),zs=c(vn),lr=n(vn,"SPAN",{});var Gc=a(lr);Js=s(Gc,"Following asynchronous commands"),Gc.forEach(o),vn.forEach(o),Hr=c(t),Re=n(t,"P",{});var $n=a(Re);Ks=s($n,"The "),cr=n($n,"CODE",{});var zc=a(cr);Qs=s(zc,"Repository"),zc.forEach(o),Xs=s($n," utility offers several methods which can be launched asynchronously:"),$n.forEach(o),Vr=c(t),T=n(t,"UL",{});var He=a(T);gr=n(He,"LI",{});var Jc=a(gr);hr=n(Jc,"CODE",{});var Kc=a(hr);Ys=s(Kc,"git_push"),Kc.forEach(o),Jc.forEach(o),Zs=c(He),pr=n(He,"LI",{});var Qc=a(pr);dr=n(Qc,"CODE",{});var Xc=a(dr);el=s(Xc,"git_pull"),Xc.forEach(o),Qc.forEach(o),tl=c(He),ur=n(He,"LI",{});var Yc=a(ur);mr=n(Yc,"CODE",{});var Zc=a(mr);ol=s(Zc,"push_to_hub"),Zc.forEach(o),Yc.forEach(o),rl=c(He),xt=n(He,"LI",{});var wn=a(xt);nl=s(wn,"The "),fr=n(wn,"CODE",{});var eg=a(fr);al=s(eg,"commit"),eg.forEach(o),il=s(wn," context manager"),wn.forEach(o),He.forEach(o),Ar=c(t),Lt=n(t,"P",{});var tg=a(Lt);sl=s(tg,"See below for utilities to manage such asynchronous methods."),tg.forEach(o),Sr=c(t),w=n(t,"DIV",{class:!0});var P=a(w);u(Dt.$$.fragment,P),ll=c(P),_r=n(P,"P",{});var og=a(_r);cl=s(og,"Helper class to wrap the git and git-lfs commands."),og.forEach(o),gl=c(P),br=n(P,"P",{});var rg=a(br);hl=s(rg,`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),rg.forEach(o),pl=c(P),Te=n(P,"DIV",{class:!0});var kn=a(Te);u(Rt.$$.fragment,kn),dl=c(kn),yr=n(kn,"P",{});var ng=a(yr);ul=s(ng,"Returns the asynchronous commands that failed."),ng.forEach(o),kn.forEach(o),ml=c(P),Pe=n(P,"DIV",{class:!0});var En=a(Pe);u(Tt.$$.fragment,En),fl=c(En),vr=n(En,"P",{});var ag=a(vr);_l=s(ag,"Returns the asynchronous commands that are currently in progress."),ag.forEach(o),En.forEach(o),bl=c(P),Ie=n(P,"DIV",{class:!0});var xn=a(Ie);u(Pt.$$.fragment,xn),yl=c(xn),$r=n(xn,"P",{});var ig=a($r);vl=s(ig,`Blocking method: blocks all subsequent execution until all commands have
been processed.`),ig.forEach(o),xn.forEach(o),P.forEach(o),qr=c(t),ee=n(t,"DIV",{class:!0});var Dn=a(ee);u(It.$$.fragment,Dn),$l=c(Dn),wr=n(Dn,"P",{});var sg=a(wr);wl=s(sg,"Utility to follow commands launched asynchronously."),sg.forEach(o),Dn.forEach(o),this.h()},h(){p(V,"name","hf:doc:metadata"),p(V,"content",JSON.stringify(fg)),p(oe,"id","managing-local-and-online-repositories"),p(oe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(oe,"href","#managing-local-and-online-repositories"),p(A,"class","relative group"),p(ne,"id","huggingface_hub.Repository"),p(ne,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(ne,"href","#huggingface_hub.Repository"),p(S,"class","relative group"),p(E,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ae,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(D,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ie,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(se,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(le,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(C,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(R,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ce,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(F,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(N,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ge,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(he,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(de,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ue,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(me,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(j,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(fe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(_e,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(be,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ye,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(H,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ve,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p($e,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(we,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ke,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(g,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(xe,"id","huggingface_hub.repository.is_git_repo"),p(xe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(xe,"href","#huggingface_hub.repository.is_git_repo"),p(G,"class","relative group"),p(z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(J,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(K,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(X,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Y,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(L,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(De,"id","huggingface_hub.Repository"),p(De,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(De,"href","#huggingface_hub.Repository"),p(Z,"class","relative group"),p(Te,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Ie,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(w,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,y){e(document.head,V),$(t,kr,y),$(t,A,y),e(A,oe),e(oe,Wt),m(Ve,Wt,null),e(A,Tn),e(A,Bt),e(Bt,Pn),$(t,Er,y),$(t,k,y),e(k,In),e(k,Gt),e(Gt,On),e(k,Ln),e(k,zt),e(zt,Cn),e(k,Fn),e(k,Jt),e(Jt,Nn),e(k,jn),$(t,xr,y),$(t,re,y),e(re,Hn),e(re,Kt),e(Kt,Vn),e(re,An),$(t,Dr,y),$(t,S,y),e(S,ne),e(ne,Qt),m(Ae,Qt,null),e(S,Sn),e(S,Xt),e(Xt,qn),$(t,Rr,y),$(t,g,y),m(Se,g,null),e(g,Un),e(g,Yt),e(Yt,Mn),e(g,Wn),e(g,Zt),e(Zt,Bn),e(g,Gn),e(g,E),m(qe,E,null),e(E,zn),e(E,eo),e(eo,Jn),e(E,Kn),e(E,q),e(q,Qn),e(q,to),e(to,Xn),e(q,Yn),e(q,oo),e(oo,Zn),e(q,ea),e(E,ta),e(E,x),e(x,ro),e(ro,oa),e(x,ra),e(x,no),e(no,na),e(x,aa),e(x,ao),e(ao,ia),e(x,sa),e(x,io),e(io,la),e(x,ca),e(g,ga),e(g,ae),m(Ue,ae,null),e(ae,ha),e(ae,so),e(so,pa),e(g,da),e(g,D),m(Me,D,null),e(D,ua),e(D,lo),e(lo,ma),e(D,fa),e(D,co),e(co,_a),e(D,ba),e(D,go),e(go,ya),e(g,va),e(g,ie),m(We,ie,null),e(ie,$a),e(ie,ho),e(ho,wa),e(g,ka),e(g,se),m(Be,se,null),e(se,Ea),e(se,po),e(po,xa),e(g,Da),e(g,le),m(Ge,le,null),e(le,Ra),e(le,U),e(U,Ta),e(U,uo),e(uo,Pa),e(U,Ia),e(U,mo),e(mo,Oa),e(U,La),e(g,Ca),e(g,C),m(ze,C,null),e(C,Fa),e(C,fo),e(fo,Na),e(C,ja),e(C,_o),e(_o,Ha),e(g,Va),e(g,R),m(Je,R,null),e(R,Aa),e(R,M),e(M,Sa),e(M,bo),e(bo,qa),e(M,Ua),e(M,yo),e(yo,Ma),e(M,Wa),e(R,Ba),e(R,vo),e(vo,Ga),e(R,za),m(Ke,R,null),e(g,Ja),e(g,ce),m(Qe,ce,null),e(ce,Ka),e(ce,$o),e($o,Qa),e(g,Xa),e(g,F),m(Xe,F,null),e(F,Ya),e(F,wo),e(wo,Za),e(F,ei),e(F,I),e(I,ti),e(I,ko),e(ko,oi),e(I,ri),e(I,Eo),e(Eo,ni),e(I,ai),e(I,xo),e(xo,ii),e(I,si),e(g,li),e(g,N),m(Ye,N,null),e(N,ci),e(N,Do),e(Do,gi),e(N,hi),e(N,W),e(W,pi),e(W,Ro),e(Ro,di),e(W,ui),e(W,To),e(To,mi),e(W,fi),e(g,_i),e(g,ge),m(Ze,ge,null),e(ge,bi),e(ge,Po),e(Po,yi),e(g,vi),e(g,he),m(et,he,null),e(he,$i),e(he,Io),e(Io,wi),e(g,ki),e(g,pe),m(tt,pe,null),e(pe,Ei),e(pe,Ot),e(Ot,xi),e(Ot,Oo),e(Oo,Di),e(g,Ri),e(g,de),m(ot,de,null),e(de,Ti),e(de,Lo),e(Lo,Pi),e(g,Ii),e(g,ue),m(rt,ue,null),e(ue,Oi),e(ue,Co),e(Co,Li),e(g,Ci),e(g,me),m(nt,me,null),e(me,Fi),e(me,Fo),e(Fo,Ni),e(g,ji),e(g,j),m(at,j,null),e(j,Hi),e(j,No),e(No,Vi),e(j,Ai),e(j,B),e(B,Si),e(B,jo),e(jo,qi),e(B,Ui),e(B,Ho),e(Ho,Mi),e(B,Wi),e(g,Bi),e(g,fe),m(it,fe,null),e(fe,Gi),e(fe,Vo),e(Vo,zi),e(g,Ji),e(g,_e),m(st,_e,null),e(_e,Ki),e(_e,Ao),e(Ao,Qi),e(g,Xi),e(g,be),m(lt,be,null),e(be,Yi),e(be,So),e(So,Zi),e(g,es),e(g,ye),m(ct,ye,null),e(ye,ts),e(ye,qo),e(qo,os),e(g,rs),e(g,H),m(gt,H,null),e(H,ns),e(H,Uo),e(Uo,as),e(H,is),e(H,O),e(O,ss),e(O,Mo),e(Mo,ls),e(O,cs),e(O,Wo),e(Wo,gs),e(O,hs),e(O,Bo),e(Bo,ps),e(O,ds),e(g,us),e(g,ve),m(ht,ve,null),e(ve,ms),e(ve,Go),e(Go,fs),e(g,_s),e(g,$e),m(pt,$e,null),e($e,bs),e($e,zo),e(zo,ys),e(g,vs),e(g,we),m(dt,we,null),e(we,$s),e(we,Jo),e(Jo,ws),e(g,ks),e(g,ke),m(ut,ke,null),e(ke,Es),e(ke,Ko),e(Ko,xs),e(g,Ds),e(g,Ee),m(mt,Ee,null),e(Ee,Rs),e(Ee,Qo),e(Qo,Ts),$(t,Tr,y),$(t,G,y),e(G,xe),e(xe,Xo),m(ft,Xo,null),e(G,Ps),e(G,Yo),e(Yo,Is),$(t,Pr,y),$(t,z,y),m(_t,z,null),e(z,Os),e(z,Zo),e(Zo,Ls),$(t,Ir,y),$(t,J,y),m(bt,J,null),e(J,Cs),e(J,er),e(er,Fs),$(t,Or,y),$(t,K,y),m(yt,K,null),e(K,Ns),e(K,tr),e(tr,js),$(t,Lr,y),$(t,Q,y),m(vt,Q,null),e(Q,Hs),e(Q,or),e(or,Vs),$(t,Cr,y),$(t,X,y),m($t,X,null),e(X,As),e(X,rr),e(rr,Ss),$(t,Fr,y),$(t,Y,y),m(wt,Y,null),e(Y,qs),e(Y,nr),e(nr,Us),$(t,Nr,y),$(t,L,y),m(kt,L,null),e(L,Ms),e(L,ar),e(ar,Ws),e(L,Bs),e(L,ir),e(ir,Gs),$(t,jr,y),$(t,Z,y),e(Z,De),e(De,sr),m(Et,sr,null),e(Z,zs),e(Z,lr),e(lr,Js),$(t,Hr,y),$(t,Re,y),e(Re,Ks),e(Re,cr),e(cr,Qs),e(Re,Xs),$(t,Vr,y),$(t,T,y),e(T,gr),e(gr,hr),e(hr,Ys),e(T,Zs),e(T,pr),e(pr,dr),e(dr,el),e(T,tl),e(T,ur),e(ur,mr),e(mr,ol),e(T,rl),e(T,xt),e(xt,nl),e(xt,fr),e(fr,al),e(xt,il),$(t,Ar,y),$(t,Lt,y),e(Lt,sl),$(t,Sr,y),$(t,w,y),m(Dt,w,null),e(w,ll),e(w,_r),e(_r,cl),e(w,gl),e(w,br),e(br,hl),e(w,pl),e(w,Te),m(Rt,Te,null),e(Te,dl),e(Te,yr),e(yr,ul),e(w,ml),e(w,Pe),m(Tt,Pe,null),e(Pe,fl),e(Pe,vr),e(vr,_l),e(w,bl),e(w,Ie),m(Pt,Ie,null),e(Ie,yl),e(Ie,$r),e($r,vl),$(t,qr,y),$(t,ee,y),m(It,ee,null),e(ee,$l),e(ee,wr),e(wr,wl),Ur=!0},p:pg,i(t){Ur||(f(Ve.$$.fragment,t),f(Ae.$$.fragment,t),f(Se.$$.fragment,t),f(qe.$$.fragment,t),f(Ue.$$.fragment,t),f(Me.$$.fragment,t),f(We.$$.fragment,t),f(Be.$$.fragment,t),f(Ge.$$.fragment,t),f(ze.$$.fragment,t),f(Je.$$.fragment,t),f(Ke.$$.fragment,t),f(Qe.$$.fragment,t),f(Xe.$$.fragment,t),f(Ye.$$.fragment,t),f(Ze.$$.fragment,t),f(et.$$.fragment,t),f(tt.$$.fragment,t),f(ot.$$.fragment,t),f(rt.$$.fragment,t),f(nt.$$.fragment,t),f(at.$$.fragment,t),f(it.$$.fragment,t),f(st.$$.fragment,t),f(lt.$$.fragment,t),f(ct.$$.fragment,t),f(gt.$$.fragment,t),f(ht.$$.fragment,t),f(pt.$$.fragment,t),f(dt.$$.fragment,t),f(ut.$$.fragment,t),f(mt.$$.fragment,t),f(ft.$$.fragment,t),f(_t.$$.fragment,t),f(bt.$$.fragment,t),f(yt.$$.fragment,t),f(vt.$$.fragment,t),f($t.$$.fragment,t),f(wt.$$.fragment,t),f(kt.$$.fragment,t),f(Et.$$.fragment,t),f(Dt.$$.fragment,t),f(Rt.$$.fragment,t),f(Tt.$$.fragment,t),f(Pt.$$.fragment,t),f(It.$$.fragment,t),Ur=!0)},o(t){_(Ve.$$.fragment,t),_(Ae.$$.fragment,t),_(Se.$$.fragment,t),_(qe.$$.fragment,t),_(Ue.$$.fragment,t),_(Me.$$.fragment,t),_(We.$$.fragment,t),_(Be.$$.fragment,t),_(Ge.$$.fragment,t),_(ze.$$.fragment,t),_(Je.$$.fragment,t),_(Ke.$$.fragment,t),_(Qe.$$.fragment,t),_(Xe.$$.fragment,t),_(Ye.$$.fragment,t),_(Ze.$$.fragment,t),_(et.$$.fragment,t),_(tt.$$.fragment,t),_(ot.$$.fragment,t),_(rt.$$.fragment,t),_(nt.$$.fragment,t),_(at.$$.fragment,t),_(it.$$.fragment,t),_(st.$$.fragment,t),_(lt.$$.fragment,t),_(ct.$$.fragment,t),_(gt.$$.fragment,t),_(ht.$$.fragment,t),_(pt.$$.fragment,t),_(dt.$$.fragment,t),_(ut.$$.fragment,t),_(mt.$$.fragment,t),_(ft.$$.fragment,t),_(_t.$$.fragment,t),_(bt.$$.fragment,t),_(yt.$$.fragment,t),_(vt.$$.fragment,t),_($t.$$.fragment,t),_(wt.$$.fragment,t),_(kt.$$.fragment,t),_(Et.$$.fragment,t),_(Dt.$$.fragment,t),_(Rt.$$.fragment,t),_(Tt.$$.fragment,t),_(Pt.$$.fragment,t),_(It.$$.fragment,t),Ur=!1},d(t){o(V),t&&o(kr),t&&o(A),b(Ve),t&&o(Er),t&&o(k),t&&o(xr),t&&o(re),t&&o(Dr),t&&o(S),b(Ae),t&&o(Rr),t&&o(g),b(Se),b(qe),b(Ue),b(Me),b(We),b(Be),b(Ge),b(ze),b(Je),b(Ke),b(Qe),b(Xe),b(Ye),b(Ze),b(et),b(tt),b(ot),b(rt),b(nt),b(at),b(it),b(st),b(lt),b(ct),b(gt),b(ht),b(pt),b(dt),b(ut),b(mt),t&&o(Tr),t&&o(G),b(ft),t&&o(Pr),t&&o(z),b(_t),t&&o(Ir),t&&o(J),b(bt),t&&o(Or),t&&o(K),b(yt),t&&o(Lr),t&&o(Q),b(vt),t&&o(Cr),t&&o(X),b($t),t&&o(Fr),t&&o(Y),b(wt),t&&o(Nr),t&&o(L),b(kt),t&&o(jr),t&&o(Z),b(Et),t&&o(Hr),t&&o(Re),t&&o(Vr),t&&o(T),t&&o(Ar),t&&o(Lt),t&&o(Sr),t&&o(w),b(Dt),b(Rt),b(Tt),b(Pt),t&&o(qr),t&&o(ee),b(It)}}}const fg={local:"managing-local-and-online-repositories",sections:[{local:"huggingface_hub.Repository",title:"The Repository class"},{local:"huggingface_hub.repository.is_git_repo",title:"Helper methods"},{local:"huggingface_hub.Repository",title:"Following asynchronous commands"}],title:"Managing local and online repositories"};function _g(El){return dg(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class wg extends lg{constructor(V){super();cg(this,V,_g,mg,gg,{})}}export{wg as default,fg as metadata};
