import{S as ng,i as ag,s as ig,e as r,k as l,w as d,t as i,M as sg,c as n,d as o,m as c,a,x as u,h as s,b as p,G as e,g as $,y as m,q as f,o as _,B as b,v as lg,L as cg}from"../../chunks/vendor-hf-doc-builder.js";import{D as v}from"../../chunks/Docstring-hf-doc-builder.js";import{C as gg}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as Tn}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{E as hg}from"../../chunks/ExampleCodeBlock-hf-doc-builder.js";function pg(xr){let E,ie,D,x,j;return x=new gg({props:{code:`with Repository(
    "text-files",
    clone_from="<user>/text-files",
    use_auth_token=True,
).commit("My first file :)"):
    with open("file.txt", "w+") as f:
        f.write(json.dumps({"hey": 8}))

import torch

model = torch.nn.Transformer()
with Repository(
    "torch-model",
    clone_from="<user>/torch-model",
    use_auth_token=True,
).commit("My cool model :)"):
    torch.save(model.state_dict(), "model.pt")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> Repository(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;text-files&quot;</span>,
<span class="hljs-meta">... </span>    clone_from=<span class="hljs-string">&quot;&lt;user&gt;/text-files&quot;</span>,
<span class="hljs-meta">... </span>    use_auth_token=<span class="hljs-literal">True</span>,
<span class="hljs-meta">&gt;&gt;&gt; </span>).commit(<span class="hljs-string">&quot;My first file :)&quot;</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>) <span class="hljs-keyword">as</span> f:
<span class="hljs-meta">... </span>        f.write(json.dumps({<span class="hljs-string">&quot;hey&quot;</span>: <span class="hljs-number">8</span>}))

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>model = torch.nn.Transformer()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> Repository(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;torch-model&quot;</span>,
<span class="hljs-meta">... </span>    clone_from=<span class="hljs-string">&quot;&lt;user&gt;/torch-model&quot;</span>,
<span class="hljs-meta">... </span>    use_auth_token=<span class="hljs-literal">True</span>,
<span class="hljs-meta">&gt;&gt;&gt; </span>).commit(<span class="hljs-string">&quot;My cool model :)&quot;</span>):
<span class="hljs-meta">... </span>    torch.save(model.state_dict(), <span class="hljs-string">&quot;model.pt&quot;</span>)`}}),{c(){E=r("p"),ie=i("Examples:"),D=l(),d(x.$$.fragment)},l(w){E=n(w,"P",{});var H=a(E);ie=s(H,"Examples:"),H.forEach(o),D=c(w),u(x.$$.fragment,w)},m(w,H){$(w,E,H),e(E,ie),$(w,D,H),m(x,w,H),j=!0},p:cg,i(w){j||(f(x.$$.fragment,w),j=!0)},o(w){_(x.$$.fragment,w),j=!1},d(w){w&&o(E),w&&o(D),b(x,w)}}}function dg(xr){let E,ie,D,x,j,w,H,Jt,Pn,Dr,R,In,Kt,On,Ln,Qt,Cn,Fn,Xt,Nn,jn,Rr,se,Hn,Yt,Vn,An,Tr,W,le,Zt,Ue,Sn,eo,qn,Pr,g,Me,Un,to,Mn,Wn,oo,Bn,Gn,T,We,zn,ro,Jn,Kn,B,Qn,no,Xn,Yn,ao,Zn,ea,ta,P,io,oa,ra,so,na,aa,lo,ia,sa,co,la,ca,ga,ce,Be,ha,go,pa,da,I,Ge,ua,ho,ma,fa,po,_a,ba,uo,ya,va,ge,ze,$a,mo,wa,ka,he,Je,Ea,fo,xa,Da,pe,Ke,Ra,G,Ta,_o,Pa,Ia,bo,Oa,La,Ca,V,Qe,Fa,yo,Na,ja,vo,Ha,Va,A,Xe,Aa,z,Sa,$o,qa,Ua,wo,Ma,Wa,Ba,de,Ga,ue,Ye,za,ko,Ja,Ka,S,Ze,Qa,Eo,Xa,Ya,C,Za,xo,ei,ti,Do,oi,ri,Ro,ni,ai,ii,q,et,si,To,li,ci,J,gi,Po,hi,pi,Io,di,ui,mi,me,tt,fi,Oo,_i,bi,fe,ot,yi,Lo,vi,$i,_e,rt,wi,Ft,ki,Co,Ei,xi,be,nt,Di,Fo,Ri,Ti,ye,at,Pi,No,Ii,Oi,ve,it,Li,jo,Ci,Fi,U,st,Ni,Ho,ji,Hi,K,Vi,Vo,Ai,Si,Ao,qi,Ui,Mi,$e,lt,Wi,So,Bi,Gi,we,ct,zi,qo,Ji,Ki,ke,gt,Qi,Uo,Xi,Yi,Ee,ht,Zi,Mo,es,ts,M,pt,os,Wo,rs,ns,F,as,Bo,is,ss,Go,ls,cs,zo,gs,hs,ps,xe,dt,ds,Jo,us,ms,De,ut,fs,Ko,_s,bs,Re,mt,ys,Qo,vs,$s,Te,ft,ws,Xo,ks,Es,Pe,_t,xs,Yo,Ds,Ir,Q,Ie,Zo,bt,Rs,er,Ts,Or,X,yt,Ps,tr,Is,Lr,Y,vt,Os,or,Ls,Cr,Z,$t,Cs,rr,Fs,Fr,ee,wt,Ns,nr,js,Nr,te,kt,Hs,ar,Vs,jr,oe,Et,As,ir,Ss,Hr,N,xt,qs,sr,Us,Ms,lr,Ws,Vr,re,Oe,cr,Dt,Bs,gr,Gs,Ar,Le,zs,hr,Js,Ks,Sr,O,pr,dr,Qs,Xs,ur,mr,Ys,Zs,fr,_r,el,tl,Rt,ol,br,rl,nl,qr,Nt,al,Ur,k,Tt,il,yr,sl,ll,vr,cl,gl,Ce,Pt,hl,$r,pl,dl,Fe,It,ul,wr,ml,fl,Ne,Ot,_l,kr,bl,Mr,ne,Lt,yl,Er,vl,Wr;return w=new Tn({}),Ue=new Tn({}),Me=new v({props:{name:"class huggingface_hub.Repository",anchor:"huggingface_hub.Repository",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L411"}}),We=new v({props:{name:"__init__",anchor:"huggingface_hub.Repository.__init__",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.__init__.local_dir",description:`<strong>local_dir</strong> (<code>str</code>) &#x2014;
path (e.g. <code>&apos;my_trained_model/&apos;</code>) to the local directory, where
the <code>Repository</code> will be initalized.`,name:"local_dir"},{anchor:"huggingface_hub.Repository.__init__.clone_from",description:`<strong>clone_from</strong> (<code>str</code>, <em>optional</em>) &#x2014;
repository url (e.g.
<code>&apos;https://huggingface.co/philschmid/playground-tests&apos;</code>).`,name:"clone_from"},{anchor:"huggingface_hub.Repository.__init__.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
To set when creating a repo: et to &#x201C;dataset&#x201D; or &#x201C;space&#x201D; if
creating a dataset or space, default is model.`,name:"repo_type"},{anchor:"huggingface_hub.Repository.__init__.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code> or <code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
huggingface_token can be extract from <code>HfApi().login(username, password)</code> and is used to authenticate against the hub (useful
from Google Colab for instance).`,name:"use_auth_token"},{anchor:"huggingface_hub.Repository.__init__.git_user",description:`<strong>git_user</strong> (<code>str</code>, <em>optional</em>) &#x2014;
will override the <code>git config user.name</code> for committing and
pushing files to the hub.`,name:"git_user"},{anchor:"huggingface_hub.Repository.__init__.git_email",description:`<strong>git_email</strong> (<code>str</code>, <em>optional</em>) &#x2014;
will override the <code>git config user.email</code> for committing and
pushing files to the hub.`,name:"git_email"},{anchor:"huggingface_hub.Repository.__init__.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Revision to checkout after initializing the repository. If the
revision doesn&#x2019;t exist, a branch will be created with that
revision name from the default branch&#x2019;s current HEAD.`,name:"revision"},{anchor:"huggingface_hub.Repository.__init__.private",description:`<strong>private</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
whether the repository is private or not.`,name:"private"},{anchor:"huggingface_hub.Repository.__init__.skip_lfs_files",description:`<strong>skip_lfs_files</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
whether to skip git-LFS files or not.`,name:"skip_lfs_files"},{anchor:"huggingface_hub.Repository.__init__.client",description:`<strong>client</strong> (<code>HfApi</code>, <em>optional</em>) &#x2014;
Instance of HfApi to use when calling the HF Hub API. A new
instance will be created if this is left to <code>None</code>.`,name:"client"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L422"}}),Be=new v({props:{name:"current_branch",anchor:"huggingface_hub.Repository.current_branch",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L532",returnDescription:`
<p>Current checked out branch.</p>
`,returnType:`
<p><code>str</code></p>
`}}),Ge=new v({props:{name:"add_tag",anchor:"huggingface_hub.Repository.add_tag",parameters:[{name:"tag_name",val:": str"},{name:"message",val:": str = None"},{name:"remote",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.add_tag.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The name of the tag to be added.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.add_tag.message",description:`<strong>message</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The message that accompanies the tag. The tag will turn into an
annotated tag if a message is passed.`,name:"message"},{anchor:"huggingface_hub.Repository.add_tag.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The remote on which to add the tag.`,name:"remote"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1302"}}),ze=new v({props:{name:"auto_track_binary_files",anchor:"huggingface_hub.Repository.auto_track_binary_files",parameters:[{name:"pattern",val:": typing.Optional[str] = '.'"}],parametersDescription:[{anchor:"huggingface_hub.Repository.auto_track_binary_files.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to track files that are binary.`,name:"pattern"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L912",returnDescription:`
<p>List of filenames that are now tracked due to being
binary files</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),Je=new v({props:{name:"auto_track_large_files",anchor:"huggingface_hub.Repository.auto_track_large_files",parameters:[{name:"pattern",val:": typing.Optional[str] = '.'"}],parametersDescription:[{anchor:"huggingface_hub.Repository.auto_track_large_files.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to track files that are above 10MBs.`,name:"pattern"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L955",returnDescription:`
<p>List of filenames that are now tracked due to their
size.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),Ke=new v({props:{name:"check_git_versions",anchor:"huggingface_hub.Repository.check_git_versions",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L549"}}),Qe=new v({props:{name:"clone_from",anchor:"huggingface_hub.Repository.clone_from",parameters:[{name:"repo_url",val:": str"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.clone_from.repo_url",description:`<strong>repo_url</strong> (<code>str</code>) &#x2014;
The URL from which to clone the repository`,name:"repo_url"},{anchor:"huggingface_hub.Repository.clone_from.use_auth_token",description:`<strong>use_auth_token</strong> (<code>Union[str, bool]</code>, <em>optional</em>) &#x2014;
Whether to use the authentication token. It can be:<ul>
<li>a string which is the token itself</li>
<li><code>False</code>, which would not use the authentication token</li>
<li><code>True</code>, which would fetch the authentication token from the
local folder and use it (you should be logged in for this to
work).</li>
<li><code>None</code>, which would retrieve the value of
<code>self.huggingface_token</code>.</li>
</ul>`,name:"use_auth_token"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L577"}}),Xe=new v({props:{name:"commit",anchor:"huggingface_hub.Repository.commit",parameters:[{name:"commit_message",val:": str"},{name:"branch",val:": typing.Optional[str] = None"},{name:"track_large_files",val:": typing.Optional[bool] = True"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.commit.commit_message",description:`<strong>commit_message</strong> (<code>str</code>) &#x2014;
Message to use for the commit.`,name:"commit_message"},{anchor:"huggingface_hub.Repository.commit.branch",description:`<strong>branch</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The branch on which the commit will appear. This branch will be
checked-out before any operation.`,name:"branch"},{anchor:"huggingface_hub.Repository.commit.track_large_files",description:`<strong>track_large_files</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to automatically track large files or not. Will do so by
default.`,name:"track_large_files"},{anchor:"huggingface_hub.Repository.commit.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the <code>git push</code> has
finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.commit.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1390"}}),de=new hg({props:{anchor:"huggingface_hub.Repository.commit.example",$$slots:{default:[pg]},$$scope:{ctx:xr}}}),Ye=new v({props:{name:"delete_tag",anchor:"huggingface_hub.Repository.delete_tag",parameters:[{name:"tag_name",val:": str"},{name:"remote",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.delete_tag.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The tag name to delete.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.delete_tag.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The remote on which to delete the tag.`,name:"remote"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1261",returnDescription:`
<p><code>True</code> if deleted, <code>False</code> if the tag didn\u2019t exist.
If remote is not passed, will just be updated locally</p>
`,returnType:`
<p><code>bool</code></p>
`}}),Ze=new v({props:{name:"git_add",anchor:"huggingface_hub.Repository.git_add",parameters:[{name:"pattern",val:": typing.Optional[str] = '.'"},{name:"auto_lfs_track",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_add.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to add files to staging.`,name:"pattern"},{anchor:"huggingface_hub.Repository.git_add.auto_lfs_track",description:`<strong>auto_lfs_track</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically track large and binary files with
git-lfs. Any file over 10MB in size, or in binary format, will
be automatically tracked.`,name:"auto_lfs_track"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1043"}}),et=new v({props:{name:"git_checkout",anchor:"huggingface_hub.Repository.git_checkout",parameters:[{name:"revision",val:": str"},{name:"create_branch_ok",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_checkout.revision",description:`<strong>revision</strong> (<code>str</code>) &#x2014;
The revision to checkout.`,name:"revision"},{anchor:"huggingface_hub.Repository.git_checkout.create_branch_ok",description:`<strong>create_branch_ok</strong> (<code>str</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether creating a branch named with the <code>revision</code> passed at
the current checked-out reference if <code>revision</code> isn&#x2019;t an
existing revision is allowed.`,name:"create_branch_ok"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1192"}}),tt=new v({props:{name:"git_commit",anchor:"huggingface_hub.Repository.git_commit",parameters:[{name:"commit_message",val:": str = 'commit files to HF hub'"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_commit.commit_message",description:`<strong>commit_message</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201C;commit files to HF hub&#x201D;) &#x2014;
The message attributed to the commit.`,name:"commit_message"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1079"}}),ot=new v({props:{name:"git_config_username_and_email",anchor:"huggingface_hub.Repository.git_config_username_and_email",parameters:[{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_config_username_and_email.git_user",description:`<strong>git_user</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The username to register through <code>git</code>.`,name:"git_user"},{anchor:"huggingface_hub.Repository.git_config_username_and_email.git_email",description:`<strong>git_email</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The email to register through <code>git</code>.`,name:"git_email"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L737"}}),rt=new v({props:{name:"git_credential_helper_store",anchor:"huggingface_hub.Repository.git_credential_helper_store",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L762"}}),nt=new v({props:{name:"git_head_commit_url",anchor:"huggingface_hub.Repository.git_head_commit_url",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L801",returnDescription:`
<p>The URL to the current checked-out commit.</p>
`,returnType:`
<p><code>str</code></p>
`}}),at=new v({props:{name:"git_head_hash",anchor:"huggingface_hub.Repository.git_head_hash",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L771",returnDescription:`
<p>The current checked out commit SHA.</p>
`,returnType:`
<p><code>str</code></p>
`}}),it=new v({props:{name:"git_pull",anchor:"huggingface_hub.Repository.git_pull",parameters:[{name:"rebase",val:": typing.Optional[bool] = False"},{name:"lfs",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_pull.rebase",description:`<strong>rebase</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to rebase the current branch on top of the upstream
branch after fetching.`,name:"rebase"},{anchor:"huggingface_hub.Repository.git_pull.lfs",description:`<strong>lfs</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to fetch the LFS files too. This option only changes the
behavior when a repository was cloned without fetching the LFS
files; calling <code>repo.git_pull(lfs=True)</code> will then fetch the LFS
file from the remote repository.`,name:"lfs"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1016"}}),st=new v({props:{name:"git_push",anchor:"huggingface_hub.Repository.git_push",parameters:[{name:"upstream",val:": typing.Optional[str] = None"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_push.upstream",description:`<strong>upstream</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Upstream to which this should push. If not specified, will push
to the lastly defined upstream or to the default one (<code>origin main</code>).`,name:"upstream"},{anchor:"huggingface_hub.Repository.git_push.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the push has
finished. Setting this to <code>False</code> will return an
<code>CommandInProgress</code> object which has an <code>is_done</code> property. This
property will be set to <code>True</code> when the push is finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.git_push.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1098"}}),lt=new v({props:{name:"git_remote_url",anchor:"huggingface_hub.Repository.git_remote_url",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L784",returnDescription:`
<p>The URL of the <code>origin</code> remote.</p>
`,returnType:`
<p><code>str</code></p>
`}}),ct=new v({props:{name:"is_repo_clean",anchor:"huggingface_hub.Repository.is_repo_clean",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1338",returnDescription:`
<p><code>True</code> if the git status is clean, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),gt=new v({props:{name:"lfs_enable_largefiles",anchor:"huggingface_hub.Repository.lfs_enable_largefiles",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L898"}}),ht=new v({props:{name:"lfs_prune",anchor:"huggingface_hub.Repository.lfs_prune",parameters:[{name:"recent",val:" = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_prune.recent",description:`<strong>recent</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to prune files even if they were referenced by recent
commits. See the following
<a href="https://github.com/git-lfs/git-lfs/blob/f3d43f0428a84fc4f1e5405b76b5a73ec2437e65/docs/man/git-lfs-prune.1.ronn#recent-files" rel="nofollow">link</a>
for more information.`,name:"recent"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L992"}}),pt=new v({props:{name:"lfs_track",anchor:"huggingface_hub.Repository.lfs_track",parameters:[{name:"patterns",val:": typing.Union[str, typing.List[str]]"},{name:"filename",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_track.patterns",description:`<strong>patterns</strong> (<code>Union[str, List[str]]</code>) &#x2014;
The pattern, or list of patterns, to track with git-lfs.`,name:"patterns"},{anchor:"huggingface_hub.Repository.lfs_track.filename",description:`<strong>filename</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to use the patterns as literal filenames.`,name:"filename"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L856"}}),dt=new v({props:{name:"lfs_untrack",anchor:"huggingface_hub.Repository.lfs_untrack",parameters:[{name:"patterns",val:": typing.Union[str, typing.List[str]]"}],parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_untrack.patterns",description:`<strong>patterns</strong> (<code>Union[str, List[str]]</code>) &#x2014;
The pattern, or list of patterns, to untrack with git-lfs.`,name:"patterns"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L882"}}),ut=new v({props:{name:"list_deleted_files",anchor:"huggingface_hub.Repository.list_deleted_files",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L815",returnDescription:`
<p>A list of files that have been deleted in the working
directory or index.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),mt=new v({props:{name:"push_to_hub",anchor:"huggingface_hub.Repository.push_to_hub",parameters:[{name:"commit_message",val:": typing.Optional[str] = 'commit files to HF hub'"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"clean_ok",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.push_to_hub.commit_message",description:`<strong>commit_message</strong> (<code>str</code>) &#x2014;
Message to use for the commit.`,name:"commit_message"},{anchor:"huggingface_hub.Repository.push_to_hub.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the <code>git push</code> has
finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.push_to_hub.clean_ok",description:`<strong>clean_ok</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
If True, this function will return None if the repo is
untouched. Default behavior is to fail because the git command
fails.`,name:"clean_ok"},{anchor:"huggingface_hub.Repository.push_to_hub.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1354"}}),ft=new v({props:{name:"tag_exists",anchor:"huggingface_hub.Repository.tag_exists",parameters:[{name:"tag_name",val:": str"},{name:"remote",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.tag_exists.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The name of the tag to check.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.tag_exists.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Whether to check if the tag exists on a remote. This parameter
should be the identifier of the remote.`,name:"remote"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1227",returnDescription:`
<p>Whether the tag exists.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),_t=new v({props:{name:"wait_for_commands",anchor:"huggingface_hub.Repository.wait_for_commands",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1525"}}),bt=new Tn({}),yt=new v({props:{name:"huggingface_hub.repository.is_git_repo",anchor:"huggingface_hub.repository.is_git_repo",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_git_repo.folder",description:`<strong>folder</strong> (<code>str</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L106",returnDescription:`
<p><code>True</code> if the repository is part of a repository, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),vt=new v({props:{name:"huggingface_hub.repository.is_local_clone",anchor:"huggingface_hub.repository.is_local_clone",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"},{name:"remote_url",val:": str"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_local_clone.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"},{anchor:"huggingface_hub.repository.is_local_clone.remote_url",description:`<strong>remote_url</strong> (<code>str</code>) &#x2014;
The url of a git repository.`,name:"remote_url"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L125",returnDescription:`
<p><code>True</code> if the repository is a local clone of the remote
repository specified, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),$t=new v({props:{name:"huggingface_hub.repository.is_tracked_with_lfs",anchor:"huggingface_hub.repository.is_tracked_with_lfs",parameters:[{name:"filename",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_tracked_with_lfs.filename",description:`<strong>filename</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The filename to check.`,name:"filename"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L150",returnDescription:`
<p><code>True</code> if the file passed is tracked with git-lfs, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),wt=new v({props:{name:"huggingface_hub.repository.is_git_ignored",anchor:"huggingface_hub.repository.is_git_ignored",parameters:[{name:"filename",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_git_ignored.filename",description:`<strong>filename</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The filename to check.`,name:"filename"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L187",returnDescription:`
<p><code>True</code> if the file passed is ignored by <code>git</code>, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),kt=new v({props:{name:"huggingface_hub.repository.files_to_be_staged",anchor:"huggingface_hub.repository.files_to_be_staged",parameters:[{name:"pattern",val:": str"},{name:"folder",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.files_to_be_staged.pattern",description:`<strong>pattern</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The pattern of filenames to check. Put <code>.</code> to get all files.`,name:"pattern"},{anchor:"huggingface_hub.repository.files_to_be_staged.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L237",returnDescription:`
<p>List of files that are to be staged.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),Et=new v({props:{name:"huggingface_hub.repository.is_tracked_upstream",anchor:"huggingface_hub.repository.is_tracked_upstream",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_tracked_upstream.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L262",returnDescription:`
<p><code>True</code> if the current checked-out branch is tracked upstream,
<code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),xt=new v({props:{name:"huggingface_hub.repository.commits_to_push",anchor:"huggingface_hub.repository.commits_to_push",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"},{name:"upstream",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.repository.commits_to_push.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"},{anchor:"huggingface_hub.repository.commits_to_push.upstream",description:"<strong>upstream</strong> (<code>str</code>, <em>optional</em>) &#x2014;",name:"upstream"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L286",returnDescription:`
<p>Number of commits that would be pushed upstream were a <code>git push</code> to proceed.</p>
`,returnType:`
<p><code>int</code></p>
`}}),Dt=new Tn({}),Tt=new v({props:{name:"class huggingface_hub.Repository",anchor:"huggingface_hub.Repository",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L411"}}),Pt=new v({props:{name:"commands_failed",anchor:"huggingface_hub.Repository.commands_failed",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1511"}}),It=new v({props:{name:"commands_in_progress",anchor:"huggingface_hub.Repository.commands_in_progress",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1518"}}),Ot=new v({props:{name:"wait_for_commands",anchor:"huggingface_hub.Repository.wait_for_commands",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1525"}}),Lt=new v({props:{name:"class huggingface_hub.repository.CommandInProgress",anchor:"huggingface_hub.repository.CommandInProgress",parameters:[{name:"title",val:": str"},{name:"is_done_method",val:": typing.Callable"},{name:"status_method",val:": typing.Callable"},{name:"process",val:": Popen"},{name:"post_method",val:": typing.Optional[typing.Callable] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L25"}}),{c(){E=r("meta"),ie=l(),D=r("h1"),x=r("a"),j=r("span"),d(w.$$.fragment),H=l(),Jt=r("span"),Pn=i("Managing local and online repositories"),Dr=l(),R=r("p"),In=i("The "),Kt=r("code"),On=i("Repository"),Ln=i(" class is a helper class that wraps "),Qt=r("code"),Cn=i("git"),Fn=i(" and "),Xt=r("code"),Nn=i("git-lfs"),jn=i(` commands. It provides tooling adapted
for managing repositories which can be very large.`),Rr=l(),se=r("p"),Hn=i("It is the recommended tool as soon as any "),Yt=r("code"),Vn=i("git"),An=i(` operation is involved, or when collaboration will be a point
of focus with the repository itself.`),Tr=l(),W=r("h2"),le=r("a"),Zt=r("span"),d(Ue.$$.fragment),Sn=l(),eo=r("span"),qn=i("The Repository class"),Pr=l(),g=r("div"),d(Me.$$.fragment),Un=l(),to=r("p"),Mn=i("Helper class to wrap the git and git-lfs commands."),Wn=l(),oo=r("p"),Bn=i(`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),Gn=l(),T=r("div"),d(We.$$.fragment),zn=l(),ro=r("p"),Jn=i("Instantiate a local clone of a git repo."),Kn=l(),B=r("p"),Qn=i("If specifying a "),no=r("code"),Xn=i("clone_from"),Yn=i(`, it will clone an existing remote
repository, for instance one that was previously created using
`),ao=r("code"),Zn=i("HfApi().create_repo(repo_id=repo_name)"),ea=i("."),ta=l(),P=r("p"),io=r("code"),oa=i("Repository"),ra=i(` uses the local git credentials by default, but if required,
the `),so=r("code"),na=i("huggingface_token"),aa=i(" as well as the git "),lo=r("code"),ia=i("user"),sa=i(" and the "),co=r("code"),la=i("email"),ca=i(` can be
explicitly specified.`),ga=l(),ce=r("div"),d(Be.$$.fragment),ha=l(),go=r("p"),pa=i("Returns the current checked out branch."),da=l(),I=r("div"),d(Ge.$$.fragment),ua=l(),ho=r("p"),ma=i("Add a tag at the current head and push it"),fa=l(),po=r("p"),_a=i("If remote is None, will just be updated locally"),ba=l(),uo=r("p"),ya=i(`If no message is provided, the tag will be lightweight. if a message is
provided, the tag will be annotated.`),va=l(),ge=r("div"),d(ze.$$.fragment),$a=l(),mo=r("p"),wa=i("Automatically track binary files with git-lfs."),ka=l(),he=r("div"),d(Je.$$.fragment),Ea=l(),fo=r("p"),xa=i(`Automatically track large files (files that weigh more than 10MBs) with
git-lfs.`),Da=l(),pe=r("div"),d(Ke.$$.fragment),Ra=l(),G=r("p"),Ta=i("Checks that "),_o=r("code"),Pa=i("git"),Ia=i(" and "),bo=r("code"),Oa=i("git-lfs"),La=i(" can be run."),Ca=l(),V=r("div"),d(Qe.$$.fragment),Fa=l(),yo=r("p"),Na=i(`Clone from a remote. If the folder already exists, will try to clone the
repository within it.`),ja=l(),vo=r("p"),Ha=i(`If this folder is a git repository with linked history, will try to
update the repository.`),Va=l(),A=r("div"),d(Xe.$$.fragment),Aa=l(),z=r("p"),Sa=i(`Context manager utility to handle committing to a repository. This
automatically tracks large files (>10Mb) with git-lfs. Set the
`),$o=r("code"),qa=i("track_large_files"),Ua=i(" argument to "),wo=r("code"),Ma=i("False"),Wa=i(` if you wish to ignore that
behavior.`),Ba=l(),d(de.$$.fragment),Ga=l(),ue=r("div"),d(Ye.$$.fragment),za=l(),ko=r("p"),Ja=i("Delete a tag, both local and remote, if it exists"),Ka=l(),S=r("div"),d(Ze.$$.fragment),Qa=l(),Eo=r("p"),Xa=i("git add"),Ya=l(),C=r("p"),Za=i("Setting the "),xo=r("code"),ei=i("auto_lfs_track"),ti=i(" parameter to "),Do=r("code"),oi=i("True"),ri=i(` will automatically
track files that are larger than 10MB with `),Ro=r("code"),ni=i("git-lfs"),ai=i("."),ii=l(),q=r("div"),d(et.$$.fragment),si=l(),To=r("p"),li=i("git checkout a given revision"),ci=l(),J=r("p"),gi=i("Specifying "),Po=r("code"),hi=i("create_branch_ok"),pi=i(" to "),Io=r("code"),di=i("True"),ui=i(` will create the branch to the
given revision if that revision doesn\u2019t exist.`),mi=l(),me=r("div"),d(tt.$$.fragment),fi=l(),Oo=r("p"),_i=i("git commit"),bi=l(),fe=r("div"),d(ot.$$.fragment),yi=l(),Lo=r("p"),vi=i("Sets git username and email (only in the current repo)."),$i=l(),_e=r("div"),d(rt.$$.fragment),wi=l(),Ft=r("p"),ki=i("Sets the git credential helper to "),Co=r("code"),Ei=i("store"),xi=l(),be=r("div"),d(nt.$$.fragment),Di=l(),Fo=r("p"),Ri=i(`Get URL to last commit on HEAD. We assume it\u2019s been pushed, and the url
scheme is the same one as for GitHub or HuggingFace.`),Ti=l(),ye=r("div"),d(at.$$.fragment),Pi=l(),No=r("p"),Ii=i("Get commit sha on top of HEAD."),Oi=l(),ve=r("div"),d(it.$$.fragment),Li=l(),jo=r("p"),Ci=i("git pull"),Fi=l(),U=r("div"),d(st.$$.fragment),Ni=l(),Ho=r("p"),ji=i("git push"),Hi=l(),K=r("p"),Vi=i("If used without setting "),Vo=r("code"),Ai=i("blocking"),Si=i(`, will return url to commit on remote
repo. If used with `),Ao=r("code"),qi=i("blocking=True"),Ui=i(`, will return a tuple containing the
url to commit and the command object to follow for information about the
process.`),Mi=l(),$e=r("div"),d(lt.$$.fragment),Wi=l(),So=r("p"),Bi=i("Get URL to origin remote."),Gi=l(),we=r("div"),d(ct.$$.fragment),zi=l(),qo=r("p"),Ji=i("Return whether or not the git status is clean or not"),Ki=l(),ke=r("div"),d(gt.$$.fragment),Qi=l(),Uo=r("p"),Xi=i("HF-specific. This enables upload support of files >5GB."),Yi=l(),Ee=r("div"),d(ht.$$.fragment),Zi=l(),Mo=r("p"),es=i("git lfs prune"),ts=l(),M=r("div"),d(pt.$$.fragment),os=l(),Wo=r("p"),rs=i("Tell git-lfs to track files according to a pattern."),ns=l(),F=r("p"),as=i("Setting the "),Bo=r("code"),is=i("filename"),ss=i(" argument to "),Go=r("code"),ls=i("True"),cs=i(` will treat the arguments as
literal filenames, not as patterns. Any special glob characters in the
filename will be escaped when writing to the `),zo=r("code"),gs=i(".gitattributes"),hs=i(" file."),ps=l(),xe=r("div"),d(dt.$$.fragment),ds=l(),Jo=r("p"),us=i("Tell git-lfs to untrack those files."),ms=l(),De=r("div"),d(ut.$$.fragment),fs=l(),Ko=r("p"),_s=i(`Returns a list of the files that are deleted in the working directory or
index.`),bs=l(),Re=r("div"),d(mt.$$.fragment),ys=l(),Qo=r("p"),vs=i(`Helper to add, commit, and push files to remote repository on the
HuggingFace Hub. Will automatically track large files (>10MB).`),$s=l(),Te=r("div"),d(ft.$$.fragment),ws=l(),Xo=r("p"),ks=i("Check if a tag exists or not."),Es=l(),Pe=r("div"),d(_t.$$.fragment),xs=l(),Yo=r("p"),Ds=i(`Blocking method: blocks all subsequent execution until all commands have
been processed.`),Ir=l(),Q=r("h2"),Ie=r("a"),Zo=r("span"),d(bt.$$.fragment),Rs=l(),er=r("span"),Ts=i("Helper methods"),Or=l(),X=r("div"),d(yt.$$.fragment),Ps=l(),tr=r("p"),Is=i("Check if the folder is the root or part of a git repository"),Lr=l(),Y=r("div"),d(vt.$$.fragment),Os=l(),or=r("p"),Ls=i("Check if the folder is a local clone of the remote_url"),Cr=l(),Z=r("div"),d($t.$$.fragment),Cs=l(),rr=r("p"),Fs=i("Check if the file passed is tracked with git-lfs."),Fr=l(),ee=r("div"),d(wt.$$.fragment),Ns=l(),nr=r("p"),js=i("Check if file is git-ignored. Supports nested .gitignore files."),Nr=l(),te=r("div"),d(kt.$$.fragment),Hs=l(),ar=r("p"),Vs=i("Returns a list of filenames that are to be staged."),jr=l(),oe=r("div"),d(Et.$$.fragment),As=l(),ir=r("p"),Ss=i("Check if the current checked-out branch is tracked upstream."),Hr=l(),N=r("div"),d(xt.$$.fragment),qs=l(),sr=r("p"),Us=i("Check the number of commits that would be pushed upstream"),Ms=l(),lr=r("p"),Ws=i(`The name of the upstream repository with which the comparison should be
made.`),Vr=l(),re=r("h2"),Oe=r("a"),cr=r("span"),d(Dt.$$.fragment),Bs=l(),gr=r("span"),Gs=i("Following asynchronous commands"),Ar=l(),Le=r("p"),zs=i("The "),hr=r("code"),Js=i("Repository"),Ks=i(" utility offers several methods which can be launched asynchronously:"),Sr=l(),O=r("ul"),pr=r("li"),dr=r("code"),Qs=i("git_push"),Xs=l(),ur=r("li"),mr=r("code"),Ys=i("git_pull"),Zs=l(),fr=r("li"),_r=r("code"),el=i("push_to_hub"),tl=l(),Rt=r("li"),ol=i("The "),br=r("code"),rl=i("commit"),nl=i(" context manager"),qr=l(),Nt=r("p"),al=i("See below for utilities to manage such asynchronous methods."),Ur=l(),k=r("div"),d(Tt.$$.fragment),il=l(),yr=r("p"),sl=i("Helper class to wrap the git and git-lfs commands."),ll=l(),vr=r("p"),cl=i(`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),gl=l(),Ce=r("div"),d(Pt.$$.fragment),hl=l(),$r=r("p"),pl=i("Returns the asynchronous commands that failed."),dl=l(),Fe=r("div"),d(It.$$.fragment),ul=l(),wr=r("p"),ml=i("Returns the asynchronous commands that are currently in progress."),fl=l(),Ne=r("div"),d(Ot.$$.fragment),_l=l(),kr=r("p"),bl=i(`Blocking method: blocks all subsequent execution until all commands have
been processed.`),Mr=l(),ne=r("div"),d(Lt.$$.fragment),yl=l(),Er=r("p"),vl=i("Utility to follow commands launched asynchronously."),this.h()},l(t){const y=sg('[data-svelte="svelte-1phssyn"]',document.head);E=n(y,"META",{name:!0,content:!0}),y.forEach(o),ie=c(t),D=n(t,"H1",{class:!0});var Ct=a(D);x=n(Ct,"A",{id:!0,class:!0,href:!0});var wl=a(x);j=n(wl,"SPAN",{});var kl=a(j);u(w.$$.fragment,kl),kl.forEach(o),wl.forEach(o),H=c(Ct),Jt=n(Ct,"SPAN",{});var El=a(Jt);Pn=s(El,"Managing local and online repositories"),El.forEach(o),Ct.forEach(o),Dr=c(t),R=n(t,"P",{});var je=a(R);In=s(je,"The "),Kt=n(je,"CODE",{});var xl=a(Kt);On=s(xl,"Repository"),xl.forEach(o),Ln=s(je," class is a helper class that wraps "),Qt=n(je,"CODE",{});var Dl=a(Qt);Cn=s(Dl,"git"),Dl.forEach(o),Fn=s(je," and "),Xt=n(je,"CODE",{});var Rl=a(Xt);Nn=s(Rl,"git-lfs"),Rl.forEach(o),jn=s(je,` commands. It provides tooling adapted
for managing repositories which can be very large.`),je.forEach(o),Rr=c(t),se=n(t,"P",{});var Br=a(se);Hn=s(Br,"It is the recommended tool as soon as any "),Yt=n(Br,"CODE",{});var Tl=a(Yt);Vn=s(Tl,"git"),Tl.forEach(o),An=s(Br,` operation is involved, or when collaboration will be a point
of focus with the repository itself.`),Br.forEach(o),Tr=c(t),W=n(t,"H2",{class:!0});var Gr=a(W);le=n(Gr,"A",{id:!0,class:!0,href:!0});var Pl=a(le);Zt=n(Pl,"SPAN",{});var Il=a(Zt);u(Ue.$$.fragment,Il),Il.forEach(o),Pl.forEach(o),Sn=c(Gr),eo=n(Gr,"SPAN",{});var Ol=a(eo);qn=s(Ol,"The Repository class"),Ol.forEach(o),Gr.forEach(o),Pr=c(t),g=n(t,"DIV",{class:!0});var h=a(g);u(Me.$$.fragment,h),Un=c(h),to=n(h,"P",{});var Ll=a(to);Mn=s(Ll,"Helper class to wrap the git and git-lfs commands."),Ll.forEach(o),Wn=c(h),oo=n(h,"P",{});var Cl=a(oo);Bn=s(Cl,`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),Cl.forEach(o),Gn=c(h),T=n(h,"DIV",{class:!0});var He=a(T);u(We.$$.fragment,He),zn=c(He),ro=n(He,"P",{});var Fl=a(ro);Jn=s(Fl,"Instantiate a local clone of a git repo."),Fl.forEach(o),Kn=c(He),B=n(He,"P",{});var jt=a(B);Qn=s(jt,"If specifying a "),no=n(jt,"CODE",{});var Nl=a(no);Xn=s(Nl,"clone_from"),Nl.forEach(o),Yn=s(jt,`, it will clone an existing remote
repository, for instance one that was previously created using
`),ao=n(jt,"CODE",{});var jl=a(ao);Zn=s(jl,"HfApi().create_repo(repo_id=repo_name)"),jl.forEach(o),ea=s(jt,"."),jt.forEach(o),ta=c(He),P=n(He,"P",{});var ae=a(P);io=n(ae,"CODE",{});var Hl=a(io);oa=s(Hl,"Repository"),Hl.forEach(o),ra=s(ae,` uses the local git credentials by default, but if required,
the `),so=n(ae,"CODE",{});var Vl=a(so);na=s(Vl,"huggingface_token"),Vl.forEach(o),aa=s(ae," as well as the git "),lo=n(ae,"CODE",{});var Al=a(lo);ia=s(Al,"user"),Al.forEach(o),sa=s(ae," and the "),co=n(ae,"CODE",{});var Sl=a(co);la=s(Sl,"email"),Sl.forEach(o),ca=s(ae,` can be
explicitly specified.`),ae.forEach(o),He.forEach(o),ga=c(h),ce=n(h,"DIV",{class:!0});var zr=a(ce);u(Be.$$.fragment,zr),ha=c(zr),go=n(zr,"P",{});var ql=a(go);pa=s(ql,"Returns the current checked out branch."),ql.forEach(o),zr.forEach(o),da=c(h),I=n(h,"DIV",{class:!0});var Ve=a(I);u(Ge.$$.fragment,Ve),ua=c(Ve),ho=n(Ve,"P",{});var Ul=a(ho);ma=s(Ul,"Add a tag at the current head and push it"),Ul.forEach(o),fa=c(Ve),po=n(Ve,"P",{});var Ml=a(po);_a=s(Ml,"If remote is None, will just be updated locally"),Ml.forEach(o),ba=c(Ve),uo=n(Ve,"P",{});var Wl=a(uo);ya=s(Wl,`If no message is provided, the tag will be lightweight. if a message is
provided, the tag will be annotated.`),Wl.forEach(o),Ve.forEach(o),va=c(h),ge=n(h,"DIV",{class:!0});var Jr=a(ge);u(ze.$$.fragment,Jr),$a=c(Jr),mo=n(Jr,"P",{});var Bl=a(mo);wa=s(Bl,"Automatically track binary files with git-lfs."),Bl.forEach(o),Jr.forEach(o),ka=c(h),he=n(h,"DIV",{class:!0});var Kr=a(he);u(Je.$$.fragment,Kr),Ea=c(Kr),fo=n(Kr,"P",{});var Gl=a(fo);xa=s(Gl,`Automatically track large files (files that weigh more than 10MBs) with
git-lfs.`),Gl.forEach(o),Kr.forEach(o),Da=c(h),pe=n(h,"DIV",{class:!0});var Qr=a(pe);u(Ke.$$.fragment,Qr),Ra=c(Qr),G=n(Qr,"P",{});var Ht=a(G);Ta=s(Ht,"Checks that "),_o=n(Ht,"CODE",{});var zl=a(_o);Pa=s(zl,"git"),zl.forEach(o),Ia=s(Ht," and "),bo=n(Ht,"CODE",{});var Jl=a(bo);Oa=s(Jl,"git-lfs"),Jl.forEach(o),La=s(Ht," can be run."),Ht.forEach(o),Qr.forEach(o),Ca=c(h),V=n(h,"DIV",{class:!0});var Vt=a(V);u(Qe.$$.fragment,Vt),Fa=c(Vt),yo=n(Vt,"P",{});var Kl=a(yo);Na=s(Kl,`Clone from a remote. If the folder already exists, will try to clone the
repository within it.`),Kl.forEach(o),ja=c(Vt),vo=n(Vt,"P",{});var Ql=a(vo);Ha=s(Ql,`If this folder is a git repository with linked history, will try to
update the repository.`),Ql.forEach(o),Vt.forEach(o),Va=c(h),A=n(h,"DIV",{class:!0});var At=a(A);u(Xe.$$.fragment,At),Aa=c(At),z=n(At,"P",{});var St=a(z);Sa=s(St,`Context manager utility to handle committing to a repository. This
automatically tracks large files (>10Mb) with git-lfs. Set the
`),$o=n(St,"CODE",{});var Xl=a($o);qa=s(Xl,"track_large_files"),Xl.forEach(o),Ua=s(St," argument to "),wo=n(St,"CODE",{});var Yl=a(wo);Ma=s(Yl,"False"),Yl.forEach(o),Wa=s(St,` if you wish to ignore that
behavior.`),St.forEach(o),Ba=c(At),u(de.$$.fragment,At),At.forEach(o),Ga=c(h),ue=n(h,"DIV",{class:!0});var Xr=a(ue);u(Ye.$$.fragment,Xr),za=c(Xr),ko=n(Xr,"P",{});var Zl=a(ko);Ja=s(Zl,"Delete a tag, both local and remote, if it exists"),Zl.forEach(o),Xr.forEach(o),Ka=c(h),S=n(h,"DIV",{class:!0});var qt=a(S);u(Ze.$$.fragment,qt),Qa=c(qt),Eo=n(qt,"P",{});var ec=a(Eo);Xa=s(ec,"git add"),ec.forEach(o),Ya=c(qt),C=n(qt,"P",{});var Ae=a(C);Za=s(Ae,"Setting the "),xo=n(Ae,"CODE",{});var tc=a(xo);ei=s(tc,"auto_lfs_track"),tc.forEach(o),ti=s(Ae," parameter to "),Do=n(Ae,"CODE",{});var oc=a(Do);oi=s(oc,"True"),oc.forEach(o),ri=s(Ae,` will automatically
track files that are larger than 10MB with `),Ro=n(Ae,"CODE",{});var rc=a(Ro);ni=s(rc,"git-lfs"),rc.forEach(o),ai=s(Ae,"."),Ae.forEach(o),qt.forEach(o),ii=c(h),q=n(h,"DIV",{class:!0});var Ut=a(q);u(et.$$.fragment,Ut),si=c(Ut),To=n(Ut,"P",{});var nc=a(To);li=s(nc,"git checkout a given revision"),nc.forEach(o),ci=c(Ut),J=n(Ut,"P",{});var Mt=a(J);gi=s(Mt,"Specifying "),Po=n(Mt,"CODE",{});var ac=a(Po);hi=s(ac,"create_branch_ok"),ac.forEach(o),pi=s(Mt," to "),Io=n(Mt,"CODE",{});var ic=a(Io);di=s(ic,"True"),ic.forEach(o),ui=s(Mt,` will create the branch to the
given revision if that revision doesn\u2019t exist.`),Mt.forEach(o),Ut.forEach(o),mi=c(h),me=n(h,"DIV",{class:!0});var Yr=a(me);u(tt.$$.fragment,Yr),fi=c(Yr),Oo=n(Yr,"P",{});var sc=a(Oo);_i=s(sc,"git commit"),sc.forEach(o),Yr.forEach(o),bi=c(h),fe=n(h,"DIV",{class:!0});var Zr=a(fe);u(ot.$$.fragment,Zr),yi=c(Zr),Lo=n(Zr,"P",{});var lc=a(Lo);vi=s(lc,"Sets git username and email (only in the current repo)."),lc.forEach(o),Zr.forEach(o),$i=c(h),_e=n(h,"DIV",{class:!0});var en=a(_e);u(rt.$$.fragment,en),wi=c(en),Ft=n(en,"P",{});var $l=a(Ft);ki=s($l,"Sets the git credential helper to "),Co=n($l,"CODE",{});var cc=a(Co);Ei=s(cc,"store"),cc.forEach(o),$l.forEach(o),en.forEach(o),xi=c(h),be=n(h,"DIV",{class:!0});var tn=a(be);u(nt.$$.fragment,tn),Di=c(tn),Fo=n(tn,"P",{});var gc=a(Fo);Ri=s(gc,`Get URL to last commit on HEAD. We assume it\u2019s been pushed, and the url
scheme is the same one as for GitHub or HuggingFace.`),gc.forEach(o),tn.forEach(o),Ti=c(h),ye=n(h,"DIV",{class:!0});var on=a(ye);u(at.$$.fragment,on),Pi=c(on),No=n(on,"P",{});var hc=a(No);Ii=s(hc,"Get commit sha on top of HEAD."),hc.forEach(o),on.forEach(o),Oi=c(h),ve=n(h,"DIV",{class:!0});var rn=a(ve);u(it.$$.fragment,rn),Li=c(rn),jo=n(rn,"P",{});var pc=a(jo);Ci=s(pc,"git pull"),pc.forEach(o),rn.forEach(o),Fi=c(h),U=n(h,"DIV",{class:!0});var Wt=a(U);u(st.$$.fragment,Wt),Ni=c(Wt),Ho=n(Wt,"P",{});var dc=a(Ho);ji=s(dc,"git push"),dc.forEach(o),Hi=c(Wt),K=n(Wt,"P",{});var Bt=a(K);Vi=s(Bt,"If used without setting "),Vo=n(Bt,"CODE",{});var uc=a(Vo);Ai=s(uc,"blocking"),uc.forEach(o),Si=s(Bt,`, will return url to commit on remote
repo. If used with `),Ao=n(Bt,"CODE",{});var mc=a(Ao);qi=s(mc,"blocking=True"),mc.forEach(o),Ui=s(Bt,`, will return a tuple containing the
url to commit and the command object to follow for information about the
process.`),Bt.forEach(o),Wt.forEach(o),Mi=c(h),$e=n(h,"DIV",{class:!0});var nn=a($e);u(lt.$$.fragment,nn),Wi=c(nn),So=n(nn,"P",{});var fc=a(So);Bi=s(fc,"Get URL to origin remote."),fc.forEach(o),nn.forEach(o),Gi=c(h),we=n(h,"DIV",{class:!0});var an=a(we);u(ct.$$.fragment,an),zi=c(an),qo=n(an,"P",{});var _c=a(qo);Ji=s(_c,"Return whether or not the git status is clean or not"),_c.forEach(o),an.forEach(o),Ki=c(h),ke=n(h,"DIV",{class:!0});var sn=a(ke);u(gt.$$.fragment,sn),Qi=c(sn),Uo=n(sn,"P",{});var bc=a(Uo);Xi=s(bc,"HF-specific. This enables upload support of files >5GB."),bc.forEach(o),sn.forEach(o),Yi=c(h),Ee=n(h,"DIV",{class:!0});var ln=a(Ee);u(ht.$$.fragment,ln),Zi=c(ln),Mo=n(ln,"P",{});var yc=a(Mo);es=s(yc,"git lfs prune"),yc.forEach(o),ln.forEach(o),ts=c(h),M=n(h,"DIV",{class:!0});var Gt=a(M);u(pt.$$.fragment,Gt),os=c(Gt),Wo=n(Gt,"P",{});var vc=a(Wo);rs=s(vc,"Tell git-lfs to track files according to a pattern."),vc.forEach(o),ns=c(Gt),F=n(Gt,"P",{});var Se=a(F);as=s(Se,"Setting the "),Bo=n(Se,"CODE",{});var $c=a(Bo);is=s($c,"filename"),$c.forEach(o),ss=s(Se," argument to "),Go=n(Se,"CODE",{});var wc=a(Go);ls=s(wc,"True"),wc.forEach(o),cs=s(Se,` will treat the arguments as
literal filenames, not as patterns. Any special glob characters in the
filename will be escaped when writing to the `),zo=n(Se,"CODE",{});var kc=a(zo);gs=s(kc,".gitattributes"),kc.forEach(o),hs=s(Se," file."),Se.forEach(o),Gt.forEach(o),ps=c(h),xe=n(h,"DIV",{class:!0});var cn=a(xe);u(dt.$$.fragment,cn),ds=c(cn),Jo=n(cn,"P",{});var Ec=a(Jo);us=s(Ec,"Tell git-lfs to untrack those files."),Ec.forEach(o),cn.forEach(o),ms=c(h),De=n(h,"DIV",{class:!0});var gn=a(De);u(ut.$$.fragment,gn),fs=c(gn),Ko=n(gn,"P",{});var xc=a(Ko);_s=s(xc,`Returns a list of the files that are deleted in the working directory or
index.`),xc.forEach(o),gn.forEach(o),bs=c(h),Re=n(h,"DIV",{class:!0});var hn=a(Re);u(mt.$$.fragment,hn),ys=c(hn),Qo=n(hn,"P",{});var Dc=a(Qo);vs=s(Dc,`Helper to add, commit, and push files to remote repository on the
HuggingFace Hub. Will automatically track large files (>10MB).`),Dc.forEach(o),hn.forEach(o),$s=c(h),Te=n(h,"DIV",{class:!0});var pn=a(Te);u(ft.$$.fragment,pn),ws=c(pn),Xo=n(pn,"P",{});var Rc=a(Xo);ks=s(Rc,"Check if a tag exists or not."),Rc.forEach(o),pn.forEach(o),Es=c(h),Pe=n(h,"DIV",{class:!0});var dn=a(Pe);u(_t.$$.fragment,dn),xs=c(dn),Yo=n(dn,"P",{});var Tc=a(Yo);Ds=s(Tc,`Blocking method: blocks all subsequent execution until all commands have
been processed.`),Tc.forEach(o),dn.forEach(o),h.forEach(o),Ir=c(t),Q=n(t,"H2",{class:!0});var un=a(Q);Ie=n(un,"A",{id:!0,class:!0,href:!0});var Pc=a(Ie);Zo=n(Pc,"SPAN",{});var Ic=a(Zo);u(bt.$$.fragment,Ic),Ic.forEach(o),Pc.forEach(o),Rs=c(un),er=n(un,"SPAN",{});var Oc=a(er);Ts=s(Oc,"Helper methods"),Oc.forEach(o),un.forEach(o),Or=c(t),X=n(t,"DIV",{class:!0});var mn=a(X);u(yt.$$.fragment,mn),Ps=c(mn),tr=n(mn,"P",{});var Lc=a(tr);Is=s(Lc,"Check if the folder is the root or part of a git repository"),Lc.forEach(o),mn.forEach(o),Lr=c(t),Y=n(t,"DIV",{class:!0});var fn=a(Y);u(vt.$$.fragment,fn),Os=c(fn),or=n(fn,"P",{});var Cc=a(or);Ls=s(Cc,"Check if the folder is a local clone of the remote_url"),Cc.forEach(o),fn.forEach(o),Cr=c(t),Z=n(t,"DIV",{class:!0});var _n=a(Z);u($t.$$.fragment,_n),Cs=c(_n),rr=n(_n,"P",{});var Fc=a(rr);Fs=s(Fc,"Check if the file passed is tracked with git-lfs."),Fc.forEach(o),_n.forEach(o),Fr=c(t),ee=n(t,"DIV",{class:!0});var bn=a(ee);u(wt.$$.fragment,bn),Ns=c(bn),nr=n(bn,"P",{});var Nc=a(nr);js=s(Nc,"Check if file is git-ignored. Supports nested .gitignore files."),Nc.forEach(o),bn.forEach(o),Nr=c(t),te=n(t,"DIV",{class:!0});var yn=a(te);u(kt.$$.fragment,yn),Hs=c(yn),ar=n(yn,"P",{});var jc=a(ar);Vs=s(jc,"Returns a list of filenames that are to be staged."),jc.forEach(o),yn.forEach(o),jr=c(t),oe=n(t,"DIV",{class:!0});var vn=a(oe);u(Et.$$.fragment,vn),As=c(vn),ir=n(vn,"P",{});var Hc=a(ir);Ss=s(Hc,"Check if the current checked-out branch is tracked upstream."),Hc.forEach(o),vn.forEach(o),Hr=c(t),N=n(t,"DIV",{class:!0});var zt=a(N);u(xt.$$.fragment,zt),qs=c(zt),sr=n(zt,"P",{});var Vc=a(sr);Us=s(Vc,"Check the number of commits that would be pushed upstream"),Vc.forEach(o),Ms=c(zt),lr=n(zt,"P",{});var Ac=a(lr);Ws=s(Ac,`The name of the upstream repository with which the comparison should be
made.`),Ac.forEach(o),zt.forEach(o),Vr=c(t),re=n(t,"H2",{class:!0});var $n=a(re);Oe=n($n,"A",{id:!0,class:!0,href:!0});var Sc=a(Oe);cr=n(Sc,"SPAN",{});var qc=a(cr);u(Dt.$$.fragment,qc),qc.forEach(o),Sc.forEach(o),Bs=c($n),gr=n($n,"SPAN",{});var Uc=a(gr);Gs=s(Uc,"Following asynchronous commands"),Uc.forEach(o),$n.forEach(o),Ar=c(t),Le=n(t,"P",{});var wn=a(Le);zs=s(wn,"The "),hr=n(wn,"CODE",{});var Mc=a(hr);Js=s(Mc,"Repository"),Mc.forEach(o),Ks=s(wn," utility offers several methods which can be launched asynchronously:"),wn.forEach(o),Sr=c(t),O=n(t,"UL",{});var qe=a(O);pr=n(qe,"LI",{});var Wc=a(pr);dr=n(Wc,"CODE",{});var Bc=a(dr);Qs=s(Bc,"git_push"),Bc.forEach(o),Wc.forEach(o),Xs=c(qe),ur=n(qe,"LI",{});var Gc=a(ur);mr=n(Gc,"CODE",{});var zc=a(mr);Ys=s(zc,"git_pull"),zc.forEach(o),Gc.forEach(o),Zs=c(qe),fr=n(qe,"LI",{});var Jc=a(fr);_r=n(Jc,"CODE",{});var Kc=a(_r);el=s(Kc,"push_to_hub"),Kc.forEach(o),Jc.forEach(o),tl=c(qe),Rt=n(qe,"LI",{});var kn=a(Rt);ol=s(kn,"The "),br=n(kn,"CODE",{});var Qc=a(br);rl=s(Qc,"commit"),Qc.forEach(o),nl=s(kn," context manager"),kn.forEach(o),qe.forEach(o),qr=c(t),Nt=n(t,"P",{});var Xc=a(Nt);al=s(Xc,"See below for utilities to manage such asynchronous methods."),Xc.forEach(o),Ur=c(t),k=n(t,"DIV",{class:!0});var L=a(k);u(Tt.$$.fragment,L),il=c(L),yr=n(L,"P",{});var Yc=a(yr);sl=s(Yc,"Helper class to wrap the git and git-lfs commands."),Yc.forEach(o),ll=c(L),vr=n(L,"P",{});var Zc=a(vr);cl=s(Zc,`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),Zc.forEach(o),gl=c(L),Ce=n(L,"DIV",{class:!0});var En=a(Ce);u(Pt.$$.fragment,En),hl=c(En),$r=n(En,"P",{});var eg=a($r);pl=s(eg,"Returns the asynchronous commands that failed."),eg.forEach(o),En.forEach(o),dl=c(L),Fe=n(L,"DIV",{class:!0});var xn=a(Fe);u(It.$$.fragment,xn),ul=c(xn),wr=n(xn,"P",{});var tg=a(wr);ml=s(tg,"Returns the asynchronous commands that are currently in progress."),tg.forEach(o),xn.forEach(o),fl=c(L),Ne=n(L,"DIV",{class:!0});var Dn=a(Ne);u(Ot.$$.fragment,Dn),_l=c(Dn),kr=n(Dn,"P",{});var og=a(kr);bl=s(og,`Blocking method: blocks all subsequent execution until all commands have
been processed.`),og.forEach(o),Dn.forEach(o),L.forEach(o),Mr=c(t),ne=n(t,"DIV",{class:!0});var Rn=a(ne);u(Lt.$$.fragment,Rn),yl=c(Rn),Er=n(Rn,"P",{});var rg=a(Er);vl=s(rg,"Utility to follow commands launched asynchronously."),rg.forEach(o),Rn.forEach(o),this.h()},h(){p(E,"name","hf:doc:metadata"),p(E,"content",JSON.stringify(ug)),p(x,"id","managing-local-and-online-repositories"),p(x,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(x,"href","#managing-local-and-online-repositories"),p(D,"class","relative group"),p(le,"id","huggingface_hub.Repository"),p(le,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(le,"href","#huggingface_hub.Repository"),p(W,"class","relative group"),p(T,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ce,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(I,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ge,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(he,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(V,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(A,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ue,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(S,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(me,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(fe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(_e,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(be,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ye,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ve,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(U,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p($e,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(we,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ke,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(M,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(xe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(De,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Re,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Te,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(g,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Ie,"id","huggingface_hub.repository.is_git_repo"),p(Ie,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Ie,"href","#huggingface_hub.repository.is_git_repo"),p(Q,"class","relative group"),p(X,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Y,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(te,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(oe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(N,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Oe,"id","huggingface_hub.Repository"),p(Oe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Oe,"href","#huggingface_hub.Repository"),p(re,"class","relative group"),p(Ce,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Fe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Ne,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(k,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ne,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,y){e(document.head,E),$(t,ie,y),$(t,D,y),e(D,x),e(x,j),m(w,j,null),e(D,H),e(D,Jt),e(Jt,Pn),$(t,Dr,y),$(t,R,y),e(R,In),e(R,Kt),e(Kt,On),e(R,Ln),e(R,Qt),e(Qt,Cn),e(R,Fn),e(R,Xt),e(Xt,Nn),e(R,jn),$(t,Rr,y),$(t,se,y),e(se,Hn),e(se,Yt),e(Yt,Vn),e(se,An),$(t,Tr,y),$(t,W,y),e(W,le),e(le,Zt),m(Ue,Zt,null),e(W,Sn),e(W,eo),e(eo,qn),$(t,Pr,y),$(t,g,y),m(Me,g,null),e(g,Un),e(g,to),e(to,Mn),e(g,Wn),e(g,oo),e(oo,Bn),e(g,Gn),e(g,T),m(We,T,null),e(T,zn),e(T,ro),e(ro,Jn),e(T,Kn),e(T,B),e(B,Qn),e(B,no),e(no,Xn),e(B,Yn),e(B,ao),e(ao,Zn),e(B,ea),e(T,ta),e(T,P),e(P,io),e(io,oa),e(P,ra),e(P,so),e(so,na),e(P,aa),e(P,lo),e(lo,ia),e(P,sa),e(P,co),e(co,la),e(P,ca),e(g,ga),e(g,ce),m(Be,ce,null),e(ce,ha),e(ce,go),e(go,pa),e(g,da),e(g,I),m(Ge,I,null),e(I,ua),e(I,ho),e(ho,ma),e(I,fa),e(I,po),e(po,_a),e(I,ba),e(I,uo),e(uo,ya),e(g,va),e(g,ge),m(ze,ge,null),e(ge,$a),e(ge,mo),e(mo,wa),e(g,ka),e(g,he),m(Je,he,null),e(he,Ea),e(he,fo),e(fo,xa),e(g,Da),e(g,pe),m(Ke,pe,null),e(pe,Ra),e(pe,G),e(G,Ta),e(G,_o),e(_o,Pa),e(G,Ia),e(G,bo),e(bo,Oa),e(G,La),e(g,Ca),e(g,V),m(Qe,V,null),e(V,Fa),e(V,yo),e(yo,Na),e(V,ja),e(V,vo),e(vo,Ha),e(g,Va),e(g,A),m(Xe,A,null),e(A,Aa),e(A,z),e(z,Sa),e(z,$o),e($o,qa),e(z,Ua),e(z,wo),e(wo,Ma),e(z,Wa),e(A,Ba),m(de,A,null),e(g,Ga),e(g,ue),m(Ye,ue,null),e(ue,za),e(ue,ko),e(ko,Ja),e(g,Ka),e(g,S),m(Ze,S,null),e(S,Qa),e(S,Eo),e(Eo,Xa),e(S,Ya),e(S,C),e(C,Za),e(C,xo),e(xo,ei),e(C,ti),e(C,Do),e(Do,oi),e(C,ri),e(C,Ro),e(Ro,ni),e(C,ai),e(g,ii),e(g,q),m(et,q,null),e(q,si),e(q,To),e(To,li),e(q,ci),e(q,J),e(J,gi),e(J,Po),e(Po,hi),e(J,pi),e(J,Io),e(Io,di),e(J,ui),e(g,mi),e(g,me),m(tt,me,null),e(me,fi),e(me,Oo),e(Oo,_i),e(g,bi),e(g,fe),m(ot,fe,null),e(fe,yi),e(fe,Lo),e(Lo,vi),e(g,$i),e(g,_e),m(rt,_e,null),e(_e,wi),e(_e,Ft),e(Ft,ki),e(Ft,Co),e(Co,Ei),e(g,xi),e(g,be),m(nt,be,null),e(be,Di),e(be,Fo),e(Fo,Ri),e(g,Ti),e(g,ye),m(at,ye,null),e(ye,Pi),e(ye,No),e(No,Ii),e(g,Oi),e(g,ve),m(it,ve,null),e(ve,Li),e(ve,jo),e(jo,Ci),e(g,Fi),e(g,U),m(st,U,null),e(U,Ni),e(U,Ho),e(Ho,ji),e(U,Hi),e(U,K),e(K,Vi),e(K,Vo),e(Vo,Ai),e(K,Si),e(K,Ao),e(Ao,qi),e(K,Ui),e(g,Mi),e(g,$e),m(lt,$e,null),e($e,Wi),e($e,So),e(So,Bi),e(g,Gi),e(g,we),m(ct,we,null),e(we,zi),e(we,qo),e(qo,Ji),e(g,Ki),e(g,ke),m(gt,ke,null),e(ke,Qi),e(ke,Uo),e(Uo,Xi),e(g,Yi),e(g,Ee),m(ht,Ee,null),e(Ee,Zi),e(Ee,Mo),e(Mo,es),e(g,ts),e(g,M),m(pt,M,null),e(M,os),e(M,Wo),e(Wo,rs),e(M,ns),e(M,F),e(F,as),e(F,Bo),e(Bo,is),e(F,ss),e(F,Go),e(Go,ls),e(F,cs),e(F,zo),e(zo,gs),e(F,hs),e(g,ps),e(g,xe),m(dt,xe,null),e(xe,ds),e(xe,Jo),e(Jo,us),e(g,ms),e(g,De),m(ut,De,null),e(De,fs),e(De,Ko),e(Ko,_s),e(g,bs),e(g,Re),m(mt,Re,null),e(Re,ys),e(Re,Qo),e(Qo,vs),e(g,$s),e(g,Te),m(ft,Te,null),e(Te,ws),e(Te,Xo),e(Xo,ks),e(g,Es),e(g,Pe),m(_t,Pe,null),e(Pe,xs),e(Pe,Yo),e(Yo,Ds),$(t,Ir,y),$(t,Q,y),e(Q,Ie),e(Ie,Zo),m(bt,Zo,null),e(Q,Rs),e(Q,er),e(er,Ts),$(t,Or,y),$(t,X,y),m(yt,X,null),e(X,Ps),e(X,tr),e(tr,Is),$(t,Lr,y),$(t,Y,y),m(vt,Y,null),e(Y,Os),e(Y,or),e(or,Ls),$(t,Cr,y),$(t,Z,y),m($t,Z,null),e(Z,Cs),e(Z,rr),e(rr,Fs),$(t,Fr,y),$(t,ee,y),m(wt,ee,null),e(ee,Ns),e(ee,nr),e(nr,js),$(t,Nr,y),$(t,te,y),m(kt,te,null),e(te,Hs),e(te,ar),e(ar,Vs),$(t,jr,y),$(t,oe,y),m(Et,oe,null),e(oe,As),e(oe,ir),e(ir,Ss),$(t,Hr,y),$(t,N,y),m(xt,N,null),e(N,qs),e(N,sr),e(sr,Us),e(N,Ms),e(N,lr),e(lr,Ws),$(t,Vr,y),$(t,re,y),e(re,Oe),e(Oe,cr),m(Dt,cr,null),e(re,Bs),e(re,gr),e(gr,Gs),$(t,Ar,y),$(t,Le,y),e(Le,zs),e(Le,hr),e(hr,Js),e(Le,Ks),$(t,Sr,y),$(t,O,y),e(O,pr),e(pr,dr),e(dr,Qs),e(O,Xs),e(O,ur),e(ur,mr),e(mr,Ys),e(O,Zs),e(O,fr),e(fr,_r),e(_r,el),e(O,tl),e(O,Rt),e(Rt,ol),e(Rt,br),e(br,rl),e(Rt,nl),$(t,qr,y),$(t,Nt,y),e(Nt,al),$(t,Ur,y),$(t,k,y),m(Tt,k,null),e(k,il),e(k,yr),e(yr,sl),e(k,ll),e(k,vr),e(vr,cl),e(k,gl),e(k,Ce),m(Pt,Ce,null),e(Ce,hl),e(Ce,$r),e($r,pl),e(k,dl),e(k,Fe),m(It,Fe,null),e(Fe,ul),e(Fe,wr),e(wr,ml),e(k,fl),e(k,Ne),m(Ot,Ne,null),e(Ne,_l),e(Ne,kr),e(kr,bl),$(t,Mr,y),$(t,ne,y),m(Lt,ne,null),e(ne,yl),e(ne,Er),e(Er,vl),Wr=!0},p(t,[y]){const Ct={};y&2&&(Ct.$$scope={dirty:y,ctx:t}),de.$set(Ct)},i(t){Wr||(f(w.$$.fragment,t),f(Ue.$$.fragment,t),f(Me.$$.fragment,t),f(We.$$.fragment,t),f(Be.$$.fragment,t),f(Ge.$$.fragment,t),f(ze.$$.fragment,t),f(Je.$$.fragment,t),f(Ke.$$.fragment,t),f(Qe.$$.fragment,t),f(Xe.$$.fragment,t),f(de.$$.fragment,t),f(Ye.$$.fragment,t),f(Ze.$$.fragment,t),f(et.$$.fragment,t),f(tt.$$.fragment,t),f(ot.$$.fragment,t),f(rt.$$.fragment,t),f(nt.$$.fragment,t),f(at.$$.fragment,t),f(it.$$.fragment,t),f(st.$$.fragment,t),f(lt.$$.fragment,t),f(ct.$$.fragment,t),f(gt.$$.fragment,t),f(ht.$$.fragment,t),f(pt.$$.fragment,t),f(dt.$$.fragment,t),f(ut.$$.fragment,t),f(mt.$$.fragment,t),f(ft.$$.fragment,t),f(_t.$$.fragment,t),f(bt.$$.fragment,t),f(yt.$$.fragment,t),f(vt.$$.fragment,t),f($t.$$.fragment,t),f(wt.$$.fragment,t),f(kt.$$.fragment,t),f(Et.$$.fragment,t),f(xt.$$.fragment,t),f(Dt.$$.fragment,t),f(Tt.$$.fragment,t),f(Pt.$$.fragment,t),f(It.$$.fragment,t),f(Ot.$$.fragment,t),f(Lt.$$.fragment,t),Wr=!0)},o(t){_(w.$$.fragment,t),_(Ue.$$.fragment,t),_(Me.$$.fragment,t),_(We.$$.fragment,t),_(Be.$$.fragment,t),_(Ge.$$.fragment,t),_(ze.$$.fragment,t),_(Je.$$.fragment,t),_(Ke.$$.fragment,t),_(Qe.$$.fragment,t),_(Xe.$$.fragment,t),_(de.$$.fragment,t),_(Ye.$$.fragment,t),_(Ze.$$.fragment,t),_(et.$$.fragment,t),_(tt.$$.fragment,t),_(ot.$$.fragment,t),_(rt.$$.fragment,t),_(nt.$$.fragment,t),_(at.$$.fragment,t),_(it.$$.fragment,t),_(st.$$.fragment,t),_(lt.$$.fragment,t),_(ct.$$.fragment,t),_(gt.$$.fragment,t),_(ht.$$.fragment,t),_(pt.$$.fragment,t),_(dt.$$.fragment,t),_(ut.$$.fragment,t),_(mt.$$.fragment,t),_(ft.$$.fragment,t),_(_t.$$.fragment,t),_(bt.$$.fragment,t),_(yt.$$.fragment,t),_(vt.$$.fragment,t),_($t.$$.fragment,t),_(wt.$$.fragment,t),_(kt.$$.fragment,t),_(Et.$$.fragment,t),_(xt.$$.fragment,t),_(Dt.$$.fragment,t),_(Tt.$$.fragment,t),_(Pt.$$.fragment,t),_(It.$$.fragment,t),_(Ot.$$.fragment,t),_(Lt.$$.fragment,t),Wr=!1},d(t){o(E),t&&o(ie),t&&o(D),b(w),t&&o(Dr),t&&o(R),t&&o(Rr),t&&o(se),t&&o(Tr),t&&o(W),b(Ue),t&&o(Pr),t&&o(g),b(Me),b(We),b(Be),b(Ge),b(ze),b(Je),b(Ke),b(Qe),b(Xe),b(de),b(Ye),b(Ze),b(et),b(tt),b(ot),b(rt),b(nt),b(at),b(it),b(st),b(lt),b(ct),b(gt),b(ht),b(pt),b(dt),b(ut),b(mt),b(ft),b(_t),t&&o(Ir),t&&o(Q),b(bt),t&&o(Or),t&&o(X),b(yt),t&&o(Lr),t&&o(Y),b(vt),t&&o(Cr),t&&o(Z),b($t),t&&o(Fr),t&&o(ee),b(wt),t&&o(Nr),t&&o(te),b(kt),t&&o(jr),t&&o(oe),b(Et),t&&o(Hr),t&&o(N),b(xt),t&&o(Vr),t&&o(re),b(Dt),t&&o(Ar),t&&o(Le),t&&o(Sr),t&&o(O),t&&o(qr),t&&o(Nt),t&&o(Ur),t&&o(k),b(Tt),b(Pt),b(It),b(Ot),t&&o(Mr),t&&o(ne),b(Lt)}}}const ug={local:"managing-local-and-online-repositories",sections:[{local:"huggingface_hub.Repository",title:"The Repository class"},{local:"huggingface_hub.repository.is_git_repo",title:"Helper methods"},{local:"huggingface_hub.Repository",title:"Following asynchronous commands"}],title:"Managing local and online repositories"};function mg(xr){return lg(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class $g extends ng{constructor(E){super();ag(this,E,mg,dg,ig,{})}}export{$g as default,ug as metadata};
