import{S as sg,i as ig,s as lg,e as r,k as l,w as d,t as s,M as cg,c as n,d as o,m as c,a,x as u,h as i,b as h,G as e,g as v,y as m,q as f,o as _,B as b,v as gg,L as hg}from"../../chunks/vendor-hf-doc-builder.js";import{T as pg}from"../../chunks/Tip-hf-doc-builder.js";import{D as $}from"../../chunks/Docstring-hf-doc-builder.js";import{C as dg}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as na}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{E as ug}from"../../chunks/ExampleCodeBlock-hf-doc-builder.js";function mg(vo){let k,A,x,E,L,w,R,G,$t,Oe,T,wt,le,ce,Et,ge,he,kt,pe,de,xt,Fe,j,ue,N,z,me,Ne,V,C,fe,J,Dt,K,H,S,g,Q,Rt,X,Tt,Pt;return{c(){k=r("p"),A=s("Raises the following error:"),x=l(),E=r("ul"),L=r("li"),w=r("p"),R=r("a"),G=r("code"),$t=s("ValueError"),Oe=s(`
if the `),T=r("code"),wt=s("token"),le=s(" cannot be identified and the "),ce=r("code"),Et=s("private"),ge=s(` keyword is set to
`),he=r("code"),kt=s("True"),pe=s(". The "),de=r("code"),xt=s("token"),Fe=s(" must be passed in order to handle private repositories."),j=l(),ue=r("li"),N=r("p"),z=r("a"),me=r("code"),Ne=s("ValueError"),V=s(`
if an organization token (starts with \u201Capi_org\u201D) is passed. Use must use
your own personal access token (see `),C=r("a"),fe=s("https://hf.co/settings/tokens"),J=s(")."),Dt=l(),K=r("li"),H=r("p"),S=r("a"),g=r("code"),Q=s("EnvironmentError"),Rt=s(`
if you are trying to clone the repository in a non-empty folder, or if the
`),X=r("code"),Tt=s("git"),Pt=s(" operations raise errors."),this.h()},l(P){k=n(P,"P",{});var te=a(k);A=i(te,"Raises the following error:"),te.forEach(o),x=c(P),E=n(P,"UL",{});var oe=a(E);L=n(oe,"LI",{});var O=a(L);w=n(O,"P",{});var D=a(w);R=n(D,"A",{href:!0,rel:!0});var $o=a(R);G=n($o,"CODE",{});var Ve=a(G);$t=i(Ve,"ValueError"),Ve.forEach(o),$o.forEach(o),Oe=i(D,`
if the `),T=n(D,"CODE",{});var wo=a(T);wt=i(wo,"token"),wo.forEach(o),le=i(D," cannot be identified and the "),ce=n(D,"CODE",{});var Eo=a(ce);Et=i(Eo,"private"),Eo.forEach(o),ge=i(D,` keyword is set to
`),he=n(D,"CODE",{});var q=a(he);kt=i(q,"True"),q.forEach(o),pe=i(D,". The "),de=n(D,"CODE",{});var ko=a(de);xt=i(ko,"token"),ko.forEach(o),Fe=i(D," must be passed in order to handle private repositories."),D.forEach(o),O.forEach(o),j=c(oe),ue=n(oe,"LI",{});var Ae=a(ue);N=n(Ae,"P",{});var _e=a(N);z=n(_e,"A",{href:!0,rel:!0});var xo=a(z);me=n(xo,"CODE",{});var je=a(me);Ne=i(je,"ValueError"),je.forEach(o),xo.forEach(o),V=i(_e,`
if an organization token (starts with \u201Capi_org\u201D) is passed. Use must use
your own personal access token (see `),C=n(_e,"A",{href:!0,rel:!0});var Do=a(C);fe=i(Do,"https://hf.co/settings/tokens"),Do.forEach(o),J=i(_e,")."),_e.forEach(o),Ae.forEach(o),Dt=c(oe),K=n(oe,"LI",{});var Ro=a(K);H=n(Ro,"P",{});var be=a(H);S=n(be,"A",{href:!0,rel:!0});var F=a(S);g=n(F,"CODE",{});var He=a(g);Q=i(He,"EnvironmentError"),He.forEach(o),F.forEach(o),Rt=i(be,`
if you are trying to clone the repository in a non-empty folder, or if the
`),X=n(be,"CODE",{});var To=a(X);Tt=i(To,"git"),To.forEach(o),Pt=i(be," operations raise errors."),be.forEach(o),Ro.forEach(o),oe.forEach(o),this.h()},h(){h(R,"href","https://docs.python.org/3/library/exceptions.html#ValueError"),h(R,"rel","nofollow"),h(z,"href","https://docs.python.org/3/library/exceptions.html#ValueError"),h(z,"rel","nofollow"),h(C,"href","https://hf.co/settings/tokens"),h(C,"rel","nofollow"),h(S,"href","https://docs.python.org/3/library/exceptions.html#EnvironmentError"),h(S,"rel","nofollow")},m(P,te){v(P,k,te),e(k,A),v(P,x,te),v(P,E,te),e(E,L),e(L,w),e(w,R),e(R,G),e(G,$t),e(w,Oe),e(w,T),e(T,wt),e(w,le),e(w,ce),e(ce,Et),e(w,ge),e(w,he),e(he,kt),e(w,pe),e(w,de),e(de,xt),e(w,Fe),e(E,j),e(E,ue),e(ue,N),e(N,z),e(z,me),e(me,Ne),e(N,V),e(N,C),e(C,fe),e(N,J),e(E,Dt),e(E,K),e(K,H),e(H,S),e(S,g),e(g,Q),e(H,Rt),e(H,X),e(X,Tt),e(H,Pt)},d(P){P&&o(k),P&&o(x),P&&o(E)}}}function fg(vo){let k,A,x,E,L;return E=new dg({props:{code:`with Repository(
    "text-files",
    clone_from="<user>/text-files",
    token=True,
).commit("My first file :)"):
    with open("file.txt", "w+") as f:
        f.write(json.dumps({"hey": 8}))

import torch

model = torch.nn.Transformer()
with Repository(
    "torch-model",
    clone_from="<user>/torch-model",
    token=True,
).commit("My cool model :)"):
    torch.save(model.state_dict(), "model.pt")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> Repository(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;text-files&quot;</span>,
<span class="hljs-meta">... </span>    clone_from=<span class="hljs-string">&quot;&lt;user&gt;/text-files&quot;</span>,
<span class="hljs-meta">... </span>    token=<span class="hljs-literal">True</span>,
<span class="hljs-meta">&gt;&gt;&gt; </span>).commit(<span class="hljs-string">&quot;My first file :)&quot;</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>) <span class="hljs-keyword">as</span> f:
<span class="hljs-meta">... </span>        f.write(json.dumps({<span class="hljs-string">&quot;hey&quot;</span>: <span class="hljs-number">8</span>}))

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>model = torch.nn.Transformer()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> Repository(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;torch-model&quot;</span>,
<span class="hljs-meta">... </span>    clone_from=<span class="hljs-string">&quot;&lt;user&gt;/torch-model&quot;</span>,
<span class="hljs-meta">... </span>    token=<span class="hljs-literal">True</span>,
<span class="hljs-meta">&gt;&gt;&gt; </span>).commit(<span class="hljs-string">&quot;My cool model :)&quot;</span>):
<span class="hljs-meta">... </span>    torch.save(model.state_dict(), <span class="hljs-string">&quot;model.pt&quot;</span>)`}}),{c(){k=r("p"),A=s("Examples:"),x=l(),d(E.$$.fragment)},l(w){k=n(w,"P",{});var R=a(k);A=i(R,"Examples:"),R.forEach(o),x=c(w),u(E.$$.fragment,w)},m(w,R){v(w,k,R),e(k,A),v(w,x,R),m(E,w,R),L=!0},p:hg,i(w){L||(f(E.$$.fragment,w),L=!0)},o(w){_(E.$$.fragment,w),L=!1},d(w){w&&o(k),w&&o(x),b(E,w)}}}function _g(vo){let k,A,x,E,L,w,R,G,$t,Oe,T,wt,le,ce,Et,ge,he,kt,pe,de,xt,Fe,j,ue,N,z,me,Ne,V,C,fe,J,Dt,K,H,S,g,Q,Rt,X,Tt,Pt,P,te,oe,O,D,$o,Ve,wo,Eo,q,ko,Ae,_e,xo,je,Do,Ro,be,F,He,To,aa,Uo,sa,ia,Mo,la,ca,Wo,ga,ha,pa,Se,It,da,Bo,ua,ma,U,Lt,fa,Go,_a,ba,zo,ya,va,Jo,$a,wa,qe,Ct,Ea,Ko,ka,xa,Ue,Ot,Da,Qo,Ra,Ta,Me,Ft,Pa,ye,Ia,Xo,La,Ca,Yo,Oa,Fa,Na,M,Nt,Va,Zo,Aa,ja,er,Ha,Sa,We,qa,re,Vt,Ua,ve,Ma,tr,Wa,Ba,or,Ga,za,Ja,Be,Ka,Ge,At,Qa,rr,Xa,Ya,ne,jt,Za,nr,es,ts,Y,os,ar,rs,ns,sr,as,ss,ir,is,ls,cs,ae,Ht,gs,lr,hs,ps,$e,ds,cr,us,ms,gr,fs,_s,bs,ze,St,ys,hr,vs,$s,Je,qt,ws,pr,Es,ks,Ke,Ut,xs,Po,Ds,dr,Rs,Ts,Qe,Mt,Ps,ur,Is,Ls,Xe,Wt,Cs,mr,Os,Fs,Ye,Bt,Ns,fr,Vs,As,se,Gt,js,_r,Hs,Ss,we,qs,br,Us,Ms,yr,Ws,Bs,Gs,Ze,zt,zs,vr,Js,Ks,et,Jt,Qs,$r,Xs,Ys,tt,Kt,Zs,wr,ei,ti,ot,Qt,oi,Er,ri,ni,ie,Xt,ai,kr,si,ii,Z,li,xr,ci,gi,Dr,hi,pi,Rr,di,ui,mi,rt,Yt,fi,Tr,_i,bi,nt,Zt,yi,Pr,vi,$i,at,eo,wi,Ir,Ei,ki,st,to,xi,Lr,Di,Ri,it,oo,Ti,Cr,Pi,sn,Ee,lt,Or,ro,Ii,Fr,Li,ln,ke,no,Ci,Nr,Oi,cn,xe,ao,Fi,Vr,Ni,gn,De,so,Vi,Ar,Ai,hn,Re,io,ji,jr,Hi,pn,Te,lo,Si,Hr,qi,dn,Pe,co,Ui,Sr,Mi,un,ee,go,Wi,qr,Bi,Gi,Ur,zi,mn,Ie,ct,Mr,ho,Ji,Wr,Ki,fn,gt,Qi,Br,Xi,Yi,_n,W,Gr,zr,Zi,el,Jr,Kr,tl,ol,Qr,Xr,rl,nl,po,al,Yr,sl,il,bn,Io,ll,yn,I,uo,cl,Zr,gl,hl,en,pl,dl,ht,mo,ul,tn,ml,fl,pt,fo,_l,on,bl,yl,dt,_o,vl,rn,$l,vn,Le,bo,wl,nn,El,$n;return w=new na({}),J=new na({}),Q=new $({props:{name:"class huggingface_hub.Repository",anchor:"huggingface_hub.Repository",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L422"}}),D=new $({props:{name:"__init__",anchor:"huggingface_hub.Repository.__init__",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.__init__.local_dir",description:`<strong>local_dir</strong> (<code>str</code>) &#x2014;
path (e.g. <code>&apos;my_trained_model/&apos;</code>) to the local directory, where
the <code>Repository</code> will be initalized.`,name:"local_dir"},{anchor:"huggingface_hub.Repository.__init__.clone_from",description:`<strong>clone_from</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Either a repository url or <code>repo_id</code>.
Example:<ul>
<li><code>&quot;https://huggingface.co/philschmid/playground-tests&quot;</code></li>
<li><code>&quot;philschmid/playground-tests&quot;</code></li>
</ul>`,name:"clone_from"},{anchor:"huggingface_hub.Repository.__init__.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
To set when cloning a repo from a repo_id. Default is model.`,name:"repo_type"},{anchor:"huggingface_hub.Repository.__init__.token",description:`<strong>token</strong> (<code>bool</code> or <code>str</code>, <em>optional</em>) &#x2014;
A valid authentication token (see <a href="https://huggingface.co/settings/token" rel="nofollow">https://huggingface.co/settings/token</a>).
If <code>None</code> or <code>True</code> and machine is logged in (through <code>huggingface-cli login</code>
or <a href="/docs/huggingface_hub/main/en/package_reference/login#huggingface_hub.login">login()</a>), token will be retrieved from the cache.
If <code>False</code>, token is not sent in the request header.`,name:"token"},{anchor:"huggingface_hub.Repository.__init__.git_user",description:`<strong>git_user</strong> (<code>str</code>, <em>optional</em>) &#x2014;
will override the <code>git config user.name</code> for committing and
pushing files to the hub.`,name:"git_user"},{anchor:"huggingface_hub.Repository.__init__.git_email",description:`<strong>git_email</strong> (<code>str</code>, <em>optional</em>) &#x2014;
will override the <code>git config user.email</code> for committing and
pushing files to the hub.`,name:"git_email"},{anchor:"huggingface_hub.Repository.__init__.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Revision to checkout after initializing the repository. If the
revision doesn&#x2019;t exist, a branch will be created with that
revision name from the default branch&#x2019;s current HEAD.`,name:"revision"},{anchor:"huggingface_hub.Repository.__init__.skip_lfs_files",description:`<strong>skip_lfs_files</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
whether to skip git-LFS files or not.`,name:"skip_lfs_files"},{anchor:"huggingface_hub.Repository.__init__.client",description:`<strong>client</strong> (<code>HfApi</code>, <em>optional</em>) &#x2014;
Instance of HfApi to use when calling the HF Hub API. A new
instance will be created if this is left to <code>None</code>.`,name:"client"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L433"}}),It=new $({props:{name:"current_branch",anchor:"huggingface_hub.Repository.current_branch",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L554",returnDescription:`
<p>Current checked out branch.</p>
`,returnType:`
<p><code>str</code></p>
`}}),Lt=new $({props:{name:"add_tag",anchor:"huggingface_hub.Repository.add_tag",parameters:[{name:"tag_name",val:": str"},{name:"message",val:": typing.Optional[str] = None"},{name:"remote",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.add_tag.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The name of the tag to be added.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.add_tag.message",description:`<strong>message</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The message that accompanies the tag. The tag will turn into an
annotated tag if a message is passed.`,name:"message"},{anchor:"huggingface_hub.Repository.add_tag.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The remote on which to add the tag.`,name:"remote"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1317"}}),Ct=new $({props:{name:"auto_track_binary_files",anchor:"huggingface_hub.Repository.auto_track_binary_files",parameters:[{name:"pattern",val:": str = '.'"}],parametersDescription:[{anchor:"huggingface_hub.Repository.auto_track_binary_files.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to track files that are binary.`,name:"pattern"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L938",returnDescription:`
<p>List of filenames that are now tracked due to being
binary files</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),Ot=new $({props:{name:"auto_track_large_files",anchor:"huggingface_hub.Repository.auto_track_large_files",parameters:[{name:"pattern",val:": str = '.'"}],parametersDescription:[{anchor:"huggingface_hub.Repository.auto_track_large_files.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to track files that are above 10MBs.`,name:"pattern"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L981",returnDescription:`
<p>List of filenames that are now tracked due to their
size.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),Ft=new $({props:{name:"check_git_versions",anchor:"huggingface_hub.Repository.check_git_versions",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L595",raiseDescription:`
<ul>
<li><code>EnvironmentError</code> \u2014 if <code>git</code> or <code>git-lfs</code> are not installed.</li>
</ul>
`,raiseType:`
<p><code>EnvironmentError</code></p>
`}}),Nt=new $({props:{name:"clone_from",anchor:"huggingface_hub.Repository.clone_from",parameters:[{name:"repo_url",val:": str"},{name:"token",val:": typing.Union[bool, str, NoneType] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.clone_from.repo_url",description:`<strong>repo_url</strong> (<code>str</code>) &#x2014;
The URL from which to clone the repository`,name:"repo_url"},{anchor:"huggingface_hub.Repository.clone_from.token",description:`<strong>token</strong> (<code>Union[str, bool]</code>, <em>optional</em>) &#x2014;
Whether to use the authentication token. It can be:<ul>
<li>a string which is the token itself</li>
<li><code>False</code>, which would not use the authentication token</li>
<li><code>True</code>, which would fetch the authentication token from the
local folder and use it (you should be logged in for this to
work).</li>
<li><code>None</code>, which would retrieve the value of
<code>self.huggingface_token</code>.</li>
</ul>`,name:"token"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L621"}}),We=new pg({props:{$$slots:{default:[mg]},$$scope:{ctx:vo}}}),Vt=new $({props:{name:"commit",anchor:"huggingface_hub.Repository.commit",parameters:[{name:"commit_message",val:": str"},{name:"branch",val:": typing.Optional[str] = None"},{name:"track_large_files",val:": bool = True"},{name:"blocking",val:": bool = True"},{name:"auto_lfs_prune",val:": bool = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.commit.commit_message",description:`<strong>commit_message</strong> (<code>str</code>) &#x2014;
Message to use for the commit.`,name:"commit_message"},{anchor:"huggingface_hub.Repository.commit.branch",description:`<strong>branch</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The branch on which the commit will appear. This branch will be
checked-out before any operation.`,name:"branch"},{anchor:"huggingface_hub.Repository.commit.track_large_files",description:`<strong>track_large_files</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to automatically track large files or not. Will do so by
default.`,name:"track_large_files"},{anchor:"huggingface_hub.Repository.commit.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the <code>git push</code> has
finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.commit.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1407"}}),Be=new ug({props:{anchor:"huggingface_hub.Repository.commit.example",$$slots:{default:[fg]},$$scope:{ctx:vo}}}),At=new $({props:{name:"delete_tag",anchor:"huggingface_hub.Repository.delete_tag",parameters:[{name:"tag_name",val:": str"},{name:"remote",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.delete_tag.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The tag name to delete.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.delete_tag.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The remote on which to delete the tag.`,name:"remote"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1276",returnDescription:`
<p><code>True</code> if deleted, <code>False</code> if the tag didn\u2019t exist.
If remote is not passed, will just be updated locally</p>
`,returnType:`
<p><code>bool</code></p>
`}}),jt=new $({props:{name:"git_add",anchor:"huggingface_hub.Repository.git_add",parameters:[{name:"pattern",val:": str = '.'"},{name:"auto_lfs_track",val:": bool = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_add.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to add files to staging.`,name:"pattern"},{anchor:"huggingface_hub.Repository.git_add.auto_lfs_track",description:`<strong>auto_lfs_track</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically track large and binary files with
git-lfs. Any file over 10MB in size, or in binary format, will
be automatically tracked.`,name:"auto_lfs_track"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1062"}}),Ht=new $({props:{name:"git_checkout",anchor:"huggingface_hub.Repository.git_checkout",parameters:[{name:"revision",val:": str"},{name:"create_branch_ok",val:": bool = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_checkout.revision",description:`<strong>revision</strong> (<code>str</code>) &#x2014;
The revision to checkout.`,name:"revision"},{anchor:"huggingface_hub.Repository.git_checkout.create_branch_ok",description:`<strong>create_branch_ok</strong> (<code>str</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether creating a branch named with the <code>revision</code> passed at
the current checked-out reference if <code>revision</code> isn&#x2019;t an
existing revision is allowed.`,name:"create_branch_ok"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1209"}}),St=new $({props:{name:"git_commit",anchor:"huggingface_hub.Repository.git_commit",parameters:[{name:"commit_message",val:": str = 'commit files to HF hub'"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_commit.commit_message",description:`<strong>commit_message</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201C;commit files to HF hub&#x201D;) &#x2014;
The message attributed to the commit.`,name:"commit_message"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1096"}}),qt=new $({props:{name:"git_config_username_and_email",anchor:"huggingface_hub.Repository.git_config_username_and_email",parameters:[{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_config_username_and_email.git_user",description:`<strong>git_user</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The username to register through <code>git</code>.`,name:"git_user"},{anchor:"huggingface_hub.Repository.git_config_username_and_email.git_email",description:`<strong>git_email</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The email to register through <code>git</code>.`,name:"git_email"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L768"}}),Ut=new $({props:{name:"git_credential_helper_store",anchor:"huggingface_hub.Repository.git_credential_helper_store",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L793"}}),Mt=new $({props:{name:"git_head_commit_url",anchor:"huggingface_hub.Repository.git_head_commit_url",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L830",returnDescription:`
<p>The URL to the current checked-out commit.</p>
`,returnType:`
<p><code>str</code></p>
`}}),Wt=new $({props:{name:"git_head_hash",anchor:"huggingface_hub.Repository.git_head_hash",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L802",returnDescription:`
<p>The current checked out commit SHA.</p>
`,returnType:`
<p><code>str</code></p>
`}}),Bt=new $({props:{name:"git_pull",anchor:"huggingface_hub.Repository.git_pull",parameters:[{name:"rebase",val:": bool = False"},{name:"lfs",val:": bool = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_pull.rebase",description:`<strong>rebase</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to rebase the current branch on top of the upstream
branch after fetching.`,name:"rebase"},{anchor:"huggingface_hub.Repository.git_pull.lfs",description:`<strong>lfs</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to fetch the LFS files too. This option only changes the
behavior when a repository was cloned without fetching the LFS
files; calling <code>repo.git_pull(lfs=True)</code> will then fetch the LFS
file from the remote repository.`,name:"lfs"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1038"}}),Gt=new $({props:{name:"git_push",anchor:"huggingface_hub.Repository.git_push",parameters:[{name:"upstream",val:": typing.Optional[str] = None"},{name:"blocking",val:": bool = True"},{name:"auto_lfs_prune",val:": bool = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_push.upstream",description:`<strong>upstream</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Upstream to which this should push. If not specified, will push
to the lastly defined upstream or to the default one (<code>origin main</code>).`,name:"upstream"},{anchor:"huggingface_hub.Repository.git_push.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the push has
finished. Setting this to <code>False</code> will return an
<code>CommandInProgress</code> object which has an <code>is_done</code> property. This
property will be set to <code>True</code> when the push is finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.git_push.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1115"}}),zt=new $({props:{name:"git_remote_url",anchor:"huggingface_hub.Repository.git_remote_url",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L815",returnDescription:`
<p>The URL of the <code>origin</code> remote.</p>
`,returnType:`
<p><code>str</code></p>
`}}),Jt=new $({props:{name:"is_repo_clean",anchor:"huggingface_hub.Repository.is_repo_clean",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1355",returnDescription:`
<p><code>True</code> if the git status is clean, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),Kt=new $({props:{name:"lfs_enable_largefiles",anchor:"huggingface_hub.Repository.lfs_enable_largefiles",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L924"}}),Qt=new $({props:{name:"lfs_prune",anchor:"huggingface_hub.Repository.lfs_prune",parameters:[{name:"recent",val:" = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_prune.recent",description:`<strong>recent</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to prune files even if they were referenced by recent
commits. See the following
<a href="https://github.com/git-lfs/git-lfs/blob/f3d43f0428a84fc4f1e5405b76b5a73ec2437e65/docs/man/git-lfs-prune.1.ronn#recent-files" rel="nofollow">link</a>
for more information.`,name:"recent"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1018"}}),Xt=new $({props:{name:"lfs_track",anchor:"huggingface_hub.Repository.lfs_track",parameters:[{name:"patterns",val:": typing.Union[str, typing.List[str]]"},{name:"filename",val:": bool = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_track.patterns",description:`<strong>patterns</strong> (<code>Union[str, List[str]]</code>) &#x2014;
The pattern, or list of patterns, to track with git-lfs.`,name:"patterns"},{anchor:"huggingface_hub.Repository.lfs_track.filename",description:`<strong>filename</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to use the patterns as literal filenames.`,name:"filename"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L883"}}),Yt=new $({props:{name:"lfs_untrack",anchor:"huggingface_hub.Repository.lfs_untrack",parameters:[{name:"patterns",val:": typing.Union[str, typing.List[str]]"}],parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_untrack.patterns",description:`<strong>patterns</strong> (<code>Union[str, List[str]]</code>) &#x2014;
The pattern, or list of patterns, to untrack with git-lfs.`,name:"patterns"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L908"}}),Zt=new $({props:{name:"list_deleted_files",anchor:"huggingface_hub.Repository.list_deleted_files",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L844",returnDescription:`
<p>A list of files that have been deleted in the working
directory or index.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),eo=new $({props:{name:"push_to_hub",anchor:"huggingface_hub.Repository.push_to_hub",parameters:[{name:"commit_message",val:": str = 'commit files to HF hub'"},{name:"blocking",val:": bool = True"},{name:"clean_ok",val:": bool = True"},{name:"auto_lfs_prune",val:": bool = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.push_to_hub.commit_message",description:`<strong>commit_message</strong> (<code>str</code>) &#x2014;
Message to use for the commit.`,name:"commit_message"},{anchor:"huggingface_hub.Repository.push_to_hub.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the <code>git push</code> has
finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.push_to_hub.clean_ok",description:`<strong>clean_ok</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
If True, this function will return None if the repo is
untouched. Default behavior is to fail because the git command
fails.`,name:"clean_ok"},{anchor:"huggingface_hub.Repository.push_to_hub.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1371"}}),to=new $({props:{name:"tag_exists",anchor:"huggingface_hub.Repository.tag_exists",parameters:[{name:"tag_name",val:": str"},{name:"remote",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.tag_exists.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The name of the tag to check.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.tag_exists.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Whether to check if the tag exists on a remote. This parameter
should be the identifier of the remote.`,name:"remote"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1244",returnDescription:`
<p>Whether the tag exists.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),oo=new $({props:{name:"wait_for_commands",anchor:"huggingface_hub.Repository.wait_for_commands",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1543"}}),ro=new na({}),no=new $({props:{name:"huggingface_hub.repository.is_git_repo",anchor:"huggingface_hub.repository.is_git_repo",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_git_repo.folder",description:`<strong>folder</strong> (<code>str</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L109",returnDescription:`
<p><code>True</code> if the repository is part of a repository, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),ao=new $({props:{name:"huggingface_hub.repository.is_local_clone",anchor:"huggingface_hub.repository.is_local_clone",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"},{name:"remote_url",val:": str"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_local_clone.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"},{anchor:"huggingface_hub.repository.is_local_clone.remote_url",description:`<strong>remote_url</strong> (<code>str</code>) &#x2014;
The url of a git repository.`,name:"remote_url"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L128",returnDescription:`
<p><code>True</code> if the repository is a local clone of the remote
repository specified, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),so=new $({props:{name:"huggingface_hub.repository.is_tracked_with_lfs",anchor:"huggingface_hub.repository.is_tracked_with_lfs",parameters:[{name:"filename",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_tracked_with_lfs.filename",description:`<strong>filename</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The filename to check.`,name:"filename"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L153",returnDescription:`
<p><code>True</code> if the file passed is tracked with git-lfs, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),io=new $({props:{name:"huggingface_hub.repository.is_git_ignored",anchor:"huggingface_hub.repository.is_git_ignored",parameters:[{name:"filename",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_git_ignored.filename",description:`<strong>filename</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The filename to check.`,name:"filename"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L190",returnDescription:`
<p><code>True</code> if the file passed is ignored by <code>git</code>, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),lo=new $({props:{name:"huggingface_hub.repository.files_to_be_staged",anchor:"huggingface_hub.repository.files_to_be_staged",parameters:[{name:"pattern",val:": str = '.'"},{name:"folder",val:": typing.Union[str, pathlib.Path, NoneType] = None"}],parametersDescription:[{anchor:"huggingface_hub.repository.files_to_be_staged.pattern",description:`<strong>pattern</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The pattern of filenames to check. Put <code>.</code> to get all files.`,name:"pattern"},{anchor:"huggingface_hub.repository.files_to_be_staged.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L240",returnDescription:`
<p>List of files that are to be staged.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),co=new $({props:{name:"huggingface_hub.repository.is_tracked_upstream",anchor:"huggingface_hub.repository.is_tracked_upstream",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_tracked_upstream.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L267",returnDescription:`
<p><code>True</code> if the current checked-out branch is tracked upstream,
<code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),go=new $({props:{name:"huggingface_hub.repository.commits_to_push",anchor:"huggingface_hub.repository.commits_to_push",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"},{name:"upstream",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.repository.commits_to_push.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"},{anchor:"huggingface_hub.repository.commits_to_push.upstream",description:"<strong>upstream</strong> (<code>str</code>, <em>optional</em>) &#x2014;",name:"upstream"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L289",returnDescription:`
<p>Number of commits that would be pushed upstream were a <code>git push</code> to proceed.</p>
`,returnType:`
<p><code>int</code></p>
`}}),ho=new na({}),uo=new $({props:{name:"class huggingface_hub.Repository",anchor:"huggingface_hub.Repository",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L422"}}),mo=new $({props:{name:"commands_failed",anchor:"huggingface_hub.Repository.commands_failed",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1529"}}),fo=new $({props:{name:"commands_in_progress",anchor:"huggingface_hub.Repository.commands_in_progress",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1536"}}),_o=new $({props:{name:"wait_for_commands",anchor:"huggingface_hub.Repository.wait_for_commands",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L1543"}}),bo=new $({props:{name:"class huggingface_hub.repository.CommandInProgress",anchor:"huggingface_hub.repository.CommandInProgress",parameters:[{name:"title",val:": str"},{name:"is_done_method",val:": typing.Callable"},{name:"status_method",val:": typing.Callable"},{name:"process",val:": Popen"},{name:"post_method",val:": typing.Optional[typing.Callable] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/repository.py#L26"}}),{c(){k=r("meta"),A=l(),x=r("h1"),E=r("a"),L=r("span"),d(w.$$.fragment),R=l(),G=r("span"),$t=s("Managing local and online repositories"),Oe=l(),T=r("p"),wt=s("The "),le=r("code"),ce=s("Repository"),Et=s(" class is a helper class that wraps "),ge=r("code"),he=s("git"),kt=s(" and "),pe=r("code"),de=s("git-lfs"),xt=s(` commands. It provides tooling adapted
for managing repositories which can be very large.`),Fe=l(),j=r("p"),ue=s("It is the recommended tool as soon as any "),N=r("code"),z=s("git"),me=s(` operation is involved, or when collaboration will be a point
of focus with the repository itself.`),Ne=l(),V=r("h2"),C=r("a"),fe=r("span"),d(J.$$.fragment),Dt=l(),K=r("span"),H=s("The Repository class"),S=l(),g=r("div"),d(Q.$$.fragment),Rt=l(),X=r("p"),Tt=s("Helper class to wrap the git and git-lfs commands."),Pt=l(),P=r("p"),te=s(`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),oe=l(),O=r("div"),d(D.$$.fragment),$o=l(),Ve=r("p"),wo=s("Instantiate a local clone of a git repo."),Eo=l(),q=r("p"),ko=s("If specifying a "),Ae=r("code"),_e=s("clone_from"),xo=s(`, it will clone an existing remote
repository, for instance one that was previously created using
`),je=r("code"),Do=s("HfApi().create_repo(repo_id=repo_name)"),Ro=s("."),be=l(),F=r("p"),He=r("code"),To=s("Repository"),aa=s(` uses the local git credentials by default, but if required,
the `),Uo=r("code"),sa=s("huggingface_token"),ia=s(" as well as the git "),Mo=r("code"),la=s("user"),ca=s(" and the "),Wo=r("code"),ga=s("email"),ha=s(` can be
explicitly specified.`),pa=l(),Se=r("div"),d(It.$$.fragment),da=l(),Bo=r("p"),ua=s("Returns the current checked out branch."),ma=l(),U=r("div"),d(Lt.$$.fragment),fa=l(),Go=r("p"),_a=s("Add a tag at the current head and push it"),ba=l(),zo=r("p"),ya=s("If remote is None, will just be updated locally"),va=l(),Jo=r("p"),$a=s(`If no message is provided, the tag will be lightweight. if a message is
provided, the tag will be annotated.`),wa=l(),qe=r("div"),d(Ct.$$.fragment),Ea=l(),Ko=r("p"),ka=s("Automatically track binary files with git-lfs."),xa=l(),Ue=r("div"),d(Ot.$$.fragment),Da=l(),Qo=r("p"),Ra=s(`Automatically track large files (files that weigh more than 10MBs) with
git-lfs.`),Ta=l(),Me=r("div"),d(Ft.$$.fragment),Pa=l(),ye=r("p"),Ia=s("Checks that "),Xo=r("code"),La=s("git"),Ca=s(" and "),Yo=r("code"),Oa=s("git-lfs"),Fa=s(" can be run."),Na=l(),M=r("div"),d(Nt.$$.fragment),Va=l(),Zo=r("p"),Aa=s(`Clone from a remote. If the folder already exists, will try to clone the
repository within it.`),ja=l(),er=r("p"),Ha=s(`If this folder is a git repository with linked history, will try to
update the repository.`),Sa=l(),d(We.$$.fragment),qa=l(),re=r("div"),d(Vt.$$.fragment),Ua=l(),ve=r("p"),Ma=s(`Context manager utility to handle committing to a repository. This
automatically tracks large files (>10Mb) with git-lfs. Set the
`),tr=r("code"),Wa=s("track_large_files"),Ba=s(" argument to "),or=r("code"),Ga=s("False"),za=s(` if you wish to ignore that
behavior.`),Ja=l(),d(Be.$$.fragment),Ka=l(),Ge=r("div"),d(At.$$.fragment),Qa=l(),rr=r("p"),Xa=s("Delete a tag, both local and remote, if it exists"),Ya=l(),ne=r("div"),d(jt.$$.fragment),Za=l(),nr=r("p"),es=s("git add"),ts=l(),Y=r("p"),os=s("Setting the "),ar=r("code"),rs=s("auto_lfs_track"),ns=s(" parameter to "),sr=r("code"),as=s("True"),ss=s(` will automatically
track files that are larger than 10MB with `),ir=r("code"),is=s("git-lfs"),ls=s("."),cs=l(),ae=r("div"),d(Ht.$$.fragment),gs=l(),lr=r("p"),hs=s("git checkout a given revision"),ps=l(),$e=r("p"),ds=s("Specifying "),cr=r("code"),us=s("create_branch_ok"),ms=s(" to "),gr=r("code"),fs=s("True"),_s=s(` will create the branch to the
given revision if that revision doesn\u2019t exist.`),bs=l(),ze=r("div"),d(St.$$.fragment),ys=l(),hr=r("p"),vs=s("git commit"),$s=l(),Je=r("div"),d(qt.$$.fragment),ws=l(),pr=r("p"),Es=s("Sets git username and email (only in the current repo)."),ks=l(),Ke=r("div"),d(Ut.$$.fragment),xs=l(),Po=r("p"),Ds=s("Sets the git credential helper to "),dr=r("code"),Rs=s("store"),Ts=l(),Qe=r("div"),d(Mt.$$.fragment),Ps=l(),ur=r("p"),Is=s(`Get URL to last commit on HEAD. We assume it\u2019s been pushed, and the url
scheme is the same one as for GitHub or HuggingFace.`),Ls=l(),Xe=r("div"),d(Wt.$$.fragment),Cs=l(),mr=r("p"),Os=s("Get commit sha on top of HEAD."),Fs=l(),Ye=r("div"),d(Bt.$$.fragment),Ns=l(),fr=r("p"),Vs=s("git pull"),As=l(),se=r("div"),d(Gt.$$.fragment),js=l(),_r=r("p"),Hs=s("git push"),Ss=l(),we=r("p"),qs=s("If used without setting "),br=r("code"),Us=s("blocking"),Ms=s(`, will return url to commit on remote
repo. If used with `),yr=r("code"),Ws=s("blocking=True"),Bs=s(`, will return a tuple containing the
url to commit and the command object to follow for information about the
process.`),Gs=l(),Ze=r("div"),d(zt.$$.fragment),zs=l(),vr=r("p"),Js=s("Get URL to origin remote."),Ks=l(),et=r("div"),d(Jt.$$.fragment),Qs=l(),$r=r("p"),Xs=s("Return whether or not the git status is clean or not"),Ys=l(),tt=r("div"),d(Kt.$$.fragment),Zs=l(),wr=r("p"),ei=s("HF-specific. This enables upload support of files >5GB."),ti=l(),ot=r("div"),d(Qt.$$.fragment),oi=l(),Er=r("p"),ri=s("git lfs prune"),ni=l(),ie=r("div"),d(Xt.$$.fragment),ai=l(),kr=r("p"),si=s("Tell git-lfs to track files according to a pattern."),ii=l(),Z=r("p"),li=s("Setting the "),xr=r("code"),ci=s("filename"),gi=s(" argument to "),Dr=r("code"),hi=s("True"),pi=s(` will treat the arguments as
literal filenames, not as patterns. Any special glob characters in the
filename will be escaped when writing to the `),Rr=r("code"),di=s(".gitattributes"),ui=s(" file."),mi=l(),rt=r("div"),d(Yt.$$.fragment),fi=l(),Tr=r("p"),_i=s("Tell git-lfs to untrack those files."),bi=l(),nt=r("div"),d(Zt.$$.fragment),yi=l(),Pr=r("p"),vi=s(`Returns a list of the files that are deleted in the working directory or
index.`),$i=l(),at=r("div"),d(eo.$$.fragment),wi=l(),Ir=r("p"),Ei=s(`Helper to add, commit, and push files to remote repository on the
HuggingFace Hub. Will automatically track large files (>10MB).`),ki=l(),st=r("div"),d(to.$$.fragment),xi=l(),Lr=r("p"),Di=s("Check if a tag exists or not."),Ri=l(),it=r("div"),d(oo.$$.fragment),Ti=l(),Cr=r("p"),Pi=s(`Blocking method: blocks all subsequent execution until all commands have
been processed.`),sn=l(),Ee=r("h2"),lt=r("a"),Or=r("span"),d(ro.$$.fragment),Ii=l(),Fr=r("span"),Li=s("Helper methods"),ln=l(),ke=r("div"),d(no.$$.fragment),Ci=l(),Nr=r("p"),Oi=s("Check if the folder is the root or part of a git repository"),cn=l(),xe=r("div"),d(ao.$$.fragment),Fi=l(),Vr=r("p"),Ni=s("Check if the folder is a local clone of the remote_url"),gn=l(),De=r("div"),d(so.$$.fragment),Vi=l(),Ar=r("p"),Ai=s("Check if the file passed is tracked with git-lfs."),hn=l(),Re=r("div"),d(io.$$.fragment),ji=l(),jr=r("p"),Hi=s("Check if file is git-ignored. Supports nested .gitignore files."),pn=l(),Te=r("div"),d(lo.$$.fragment),Si=l(),Hr=r("p"),qi=s("Returns a list of filenames that are to be staged."),dn=l(),Pe=r("div"),d(co.$$.fragment),Ui=l(),Sr=r("p"),Mi=s("Check if the current checked-out branch is tracked upstream."),un=l(),ee=r("div"),d(go.$$.fragment),Wi=l(),qr=r("p"),Bi=s("Check the number of commits that would be pushed upstream"),Gi=l(),Ur=r("p"),zi=s(`The name of the upstream repository with which the comparison should be
made.`),mn=l(),Ie=r("h2"),ct=r("a"),Mr=r("span"),d(ho.$$.fragment),Ji=l(),Wr=r("span"),Ki=s("Following asynchronous commands"),fn=l(),gt=r("p"),Qi=s("The "),Br=r("code"),Xi=s("Repository"),Yi=s(" utility offers several methods which can be launched asynchronously:"),_n=l(),W=r("ul"),Gr=r("li"),zr=r("code"),Zi=s("git_push"),el=l(),Jr=r("li"),Kr=r("code"),tl=s("git_pull"),ol=l(),Qr=r("li"),Xr=r("code"),rl=s("push_to_hub"),nl=l(),po=r("li"),al=s("The "),Yr=r("code"),sl=s("commit"),il=s(" context manager"),bn=l(),Io=r("p"),ll=s("See below for utilities to manage such asynchronous methods."),yn=l(),I=r("div"),d(uo.$$.fragment),cl=l(),Zr=r("p"),gl=s("Helper class to wrap the git and git-lfs commands."),hl=l(),en=r("p"),pl=s(`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),dl=l(),ht=r("div"),d(mo.$$.fragment),ul=l(),tn=r("p"),ml=s("Returns the asynchronous commands that failed."),fl=l(),pt=r("div"),d(fo.$$.fragment),_l=l(),on=r("p"),bl=s("Returns the asynchronous commands that are currently in progress."),yl=l(),dt=r("div"),d(_o.$$.fragment),vl=l(),rn=r("p"),$l=s(`Blocking method: blocks all subsequent execution until all commands have
been processed.`),vn=l(),Le=r("div"),d(bo.$$.fragment),wl=l(),nn=r("p"),El=s("Utility to follow commands launched asynchronously."),this.h()},l(t){const y=cg('[data-svelte="svelte-1phssyn"]',document.head);k=n(y,"META",{name:!0,content:!0}),y.forEach(o),A=c(t),x=n(t,"H1",{class:!0});var yo=a(x);E=n(yo,"A",{id:!0,class:!0,href:!0});var an=a(E);L=n(an,"SPAN",{});var xl=a(L);u(w.$$.fragment,xl),xl.forEach(o),an.forEach(o),R=c(yo),G=n(yo,"SPAN",{});var Dl=a(G);$t=i(Dl,"Managing local and online repositories"),Dl.forEach(o),yo.forEach(o),Oe=c(t),T=n(t,"P",{});var ut=a(T);wt=i(ut,"The "),le=n(ut,"CODE",{});var Rl=a(le);ce=i(Rl,"Repository"),Rl.forEach(o),Et=i(ut," class is a helper class that wraps "),ge=n(ut,"CODE",{});var Tl=a(ge);he=i(Tl,"git"),Tl.forEach(o),kt=i(ut," and "),pe=n(ut,"CODE",{});var Pl=a(pe);de=i(Pl,"git-lfs"),Pl.forEach(o),xt=i(ut,` commands. It provides tooling adapted
for managing repositories which can be very large.`),ut.forEach(o),Fe=c(t),j=n(t,"P",{});var wn=a(j);ue=i(wn,"It is the recommended tool as soon as any "),N=n(wn,"CODE",{});var Il=a(N);z=i(Il,"git"),Il.forEach(o),me=i(wn,` operation is involved, or when collaboration will be a point
of focus with the repository itself.`),wn.forEach(o),Ne=c(t),V=n(t,"H2",{class:!0});var En=a(V);C=n(En,"A",{id:!0,class:!0,href:!0});var Ll=a(C);fe=n(Ll,"SPAN",{});var Cl=a(fe);u(J.$$.fragment,Cl),Cl.forEach(o),Ll.forEach(o),Dt=c(En),K=n(En,"SPAN",{});var Ol=a(K);H=i(Ol,"The Repository class"),Ol.forEach(o),En.forEach(o),S=c(t),g=n(t,"DIV",{class:!0});var p=a(g);u(Q.$$.fragment,p),Rt=c(p),X=n(p,"P",{});var Fl=a(X);Tt=i(Fl,"Helper class to wrap the git and git-lfs commands."),Fl.forEach(o),Pt=c(p),P=n(p,"P",{});var Nl=a(P);te=i(Nl,`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),Nl.forEach(o),oe=c(p),O=n(p,"DIV",{class:!0});var mt=a(O);u(D.$$.fragment,mt),$o=c(mt),Ve=n(mt,"P",{});var Vl=a(Ve);wo=i(Vl,"Instantiate a local clone of a git repo."),Vl.forEach(o),Eo=c(mt),q=n(mt,"P",{});var Lo=a(q);ko=i(Lo,"If specifying a "),Ae=n(Lo,"CODE",{});var Al=a(Ae);_e=i(Al,"clone_from"),Al.forEach(o),xo=i(Lo,`, it will clone an existing remote
repository, for instance one that was previously created using
`),je=n(Lo,"CODE",{});var jl=a(je);Do=i(jl,"HfApi().create_repo(repo_id=repo_name)"),jl.forEach(o),Ro=i(Lo,"."),Lo.forEach(o),be=c(mt),F=n(mt,"P",{});var Ce=a(F);He=n(Ce,"CODE",{});var Hl=a(He);To=i(Hl,"Repository"),Hl.forEach(o),aa=i(Ce,` uses the local git credentials by default, but if required,
the `),Uo=n(Ce,"CODE",{});var Sl=a(Uo);sa=i(Sl,"huggingface_token"),Sl.forEach(o),ia=i(Ce," as well as the git "),Mo=n(Ce,"CODE",{});var ql=a(Mo);la=i(ql,"user"),ql.forEach(o),ca=i(Ce," and the "),Wo=n(Ce,"CODE",{});var Ul=a(Wo);ga=i(Ul,"email"),Ul.forEach(o),ha=i(Ce,` can be
explicitly specified.`),Ce.forEach(o),mt.forEach(o),pa=c(p),Se=n(p,"DIV",{class:!0});var kn=a(Se);u(It.$$.fragment,kn),da=c(kn),Bo=n(kn,"P",{});var Ml=a(Bo);ua=i(Ml,"Returns the current checked out branch."),Ml.forEach(o),kn.forEach(o),ma=c(p),U=n(p,"DIV",{class:!0});var ft=a(U);u(Lt.$$.fragment,ft),fa=c(ft),Go=n(ft,"P",{});var Wl=a(Go);_a=i(Wl,"Add a tag at the current head and push it"),Wl.forEach(o),ba=c(ft),zo=n(ft,"P",{});var Bl=a(zo);ya=i(Bl,"If remote is None, will just be updated locally"),Bl.forEach(o),va=c(ft),Jo=n(ft,"P",{});var Gl=a(Jo);$a=i(Gl,`If no message is provided, the tag will be lightweight. if a message is
provided, the tag will be annotated.`),Gl.forEach(o),ft.forEach(o),wa=c(p),qe=n(p,"DIV",{class:!0});var xn=a(qe);u(Ct.$$.fragment,xn),Ea=c(xn),Ko=n(xn,"P",{});var zl=a(Ko);ka=i(zl,"Automatically track binary files with git-lfs."),zl.forEach(o),xn.forEach(o),xa=c(p),Ue=n(p,"DIV",{class:!0});var Dn=a(Ue);u(Ot.$$.fragment,Dn),Da=c(Dn),Qo=n(Dn,"P",{});var Jl=a(Qo);Ra=i(Jl,`Automatically track large files (files that weigh more than 10MBs) with
git-lfs.`),Jl.forEach(o),Dn.forEach(o),Ta=c(p),Me=n(p,"DIV",{class:!0});var Rn=a(Me);u(Ft.$$.fragment,Rn),Pa=c(Rn),ye=n(Rn,"P",{});var Co=a(ye);Ia=i(Co,"Checks that "),Xo=n(Co,"CODE",{});var Kl=a(Xo);La=i(Kl,"git"),Kl.forEach(o),Ca=i(Co," and "),Yo=n(Co,"CODE",{});var Ql=a(Yo);Oa=i(Ql,"git-lfs"),Ql.forEach(o),Fa=i(Co," can be run."),Co.forEach(o),Rn.forEach(o),Na=c(p),M=n(p,"DIV",{class:!0});var _t=a(M);u(Nt.$$.fragment,_t),Va=c(_t),Zo=n(_t,"P",{});var Xl=a(Zo);Aa=i(Xl,`Clone from a remote. If the folder already exists, will try to clone the
repository within it.`),Xl.forEach(o),ja=c(_t),er=n(_t,"P",{});var Yl=a(er);Ha=i(Yl,`If this folder is a git repository with linked history, will try to
update the repository.`),Yl.forEach(o),Sa=c(_t),u(We.$$.fragment,_t),_t.forEach(o),qa=c(p),re=n(p,"DIV",{class:!0});var Oo=a(re);u(Vt.$$.fragment,Oo),Ua=c(Oo),ve=n(Oo,"P",{});var Fo=a(ve);Ma=i(Fo,`Context manager utility to handle committing to a repository. This
automatically tracks large files (>10Mb) with git-lfs. Set the
`),tr=n(Fo,"CODE",{});var Zl=a(tr);Wa=i(Zl,"track_large_files"),Zl.forEach(o),Ba=i(Fo," argument to "),or=n(Fo,"CODE",{});var ec=a(or);Ga=i(ec,"False"),ec.forEach(o),za=i(Fo,` if you wish to ignore that
behavior.`),Fo.forEach(o),Ja=c(Oo),u(Be.$$.fragment,Oo),Oo.forEach(o),Ka=c(p),Ge=n(p,"DIV",{class:!0});var Tn=a(Ge);u(At.$$.fragment,Tn),Qa=c(Tn),rr=n(Tn,"P",{});var tc=a(rr);Xa=i(tc,"Delete a tag, both local and remote, if it exists"),tc.forEach(o),Tn.forEach(o),Ya=c(p),ne=n(p,"DIV",{class:!0});var No=a(ne);u(jt.$$.fragment,No),Za=c(No),nr=n(No,"P",{});var oc=a(nr);es=i(oc,"git add"),oc.forEach(o),ts=c(No),Y=n(No,"P",{});var bt=a(Y);os=i(bt,"Setting the "),ar=n(bt,"CODE",{});var rc=a(ar);rs=i(rc,"auto_lfs_track"),rc.forEach(o),ns=i(bt," parameter to "),sr=n(bt,"CODE",{});var nc=a(sr);as=i(nc,"True"),nc.forEach(o),ss=i(bt,` will automatically
track files that are larger than 10MB with `),ir=n(bt,"CODE",{});var ac=a(ir);is=i(ac,"git-lfs"),ac.forEach(o),ls=i(bt,"."),bt.forEach(o),No.forEach(o),cs=c(p),ae=n(p,"DIV",{class:!0});var Vo=a(ae);u(Ht.$$.fragment,Vo),gs=c(Vo),lr=n(Vo,"P",{});var sc=a(lr);hs=i(sc,"git checkout a given revision"),sc.forEach(o),ps=c(Vo),$e=n(Vo,"P",{});var Ao=a($e);ds=i(Ao,"Specifying "),cr=n(Ao,"CODE",{});var ic=a(cr);us=i(ic,"create_branch_ok"),ic.forEach(o),ms=i(Ao," to "),gr=n(Ao,"CODE",{});var lc=a(gr);fs=i(lc,"True"),lc.forEach(o),_s=i(Ao,` will create the branch to the
given revision if that revision doesn\u2019t exist.`),Ao.forEach(o),Vo.forEach(o),bs=c(p),ze=n(p,"DIV",{class:!0});var Pn=a(ze);u(St.$$.fragment,Pn),ys=c(Pn),hr=n(Pn,"P",{});var cc=a(hr);vs=i(cc,"git commit"),cc.forEach(o),Pn.forEach(o),$s=c(p),Je=n(p,"DIV",{class:!0});var In=a(Je);u(qt.$$.fragment,In),ws=c(In),pr=n(In,"P",{});var gc=a(pr);Es=i(gc,"Sets git username and email (only in the current repo)."),gc.forEach(o),In.forEach(o),ks=c(p),Ke=n(p,"DIV",{class:!0});var Ln=a(Ke);u(Ut.$$.fragment,Ln),xs=c(Ln),Po=n(Ln,"P",{});var kl=a(Po);Ds=i(kl,"Sets the git credential helper to "),dr=n(kl,"CODE",{});var hc=a(dr);Rs=i(hc,"store"),hc.forEach(o),kl.forEach(o),Ln.forEach(o),Ts=c(p),Qe=n(p,"DIV",{class:!0});var Cn=a(Qe);u(Mt.$$.fragment,Cn),Ps=c(Cn),ur=n(Cn,"P",{});var pc=a(ur);Is=i(pc,`Get URL to last commit on HEAD. We assume it\u2019s been pushed, and the url
scheme is the same one as for GitHub or HuggingFace.`),pc.forEach(o),Cn.forEach(o),Ls=c(p),Xe=n(p,"DIV",{class:!0});var On=a(Xe);u(Wt.$$.fragment,On),Cs=c(On),mr=n(On,"P",{});var dc=a(mr);Os=i(dc,"Get commit sha on top of HEAD."),dc.forEach(o),On.forEach(o),Fs=c(p),Ye=n(p,"DIV",{class:!0});var Fn=a(Ye);u(Bt.$$.fragment,Fn),Ns=c(Fn),fr=n(Fn,"P",{});var uc=a(fr);Vs=i(uc,"git pull"),uc.forEach(o),Fn.forEach(o),As=c(p),se=n(p,"DIV",{class:!0});var jo=a(se);u(Gt.$$.fragment,jo),js=c(jo),_r=n(jo,"P",{});var mc=a(_r);Hs=i(mc,"git push"),mc.forEach(o),Ss=c(jo),we=n(jo,"P",{});var Ho=a(we);qs=i(Ho,"If used without setting "),br=n(Ho,"CODE",{});var fc=a(br);Us=i(fc,"blocking"),fc.forEach(o),Ms=i(Ho,`, will return url to commit on remote
repo. If used with `),yr=n(Ho,"CODE",{});var _c=a(yr);Ws=i(_c,"blocking=True"),_c.forEach(o),Bs=i(Ho,`, will return a tuple containing the
url to commit and the command object to follow for information about the
process.`),Ho.forEach(o),jo.forEach(o),Gs=c(p),Ze=n(p,"DIV",{class:!0});var Nn=a(Ze);u(zt.$$.fragment,Nn),zs=c(Nn),vr=n(Nn,"P",{});var bc=a(vr);Js=i(bc,"Get URL to origin remote."),bc.forEach(o),Nn.forEach(o),Ks=c(p),et=n(p,"DIV",{class:!0});var Vn=a(et);u(Jt.$$.fragment,Vn),Qs=c(Vn),$r=n(Vn,"P",{});var yc=a($r);Xs=i(yc,"Return whether or not the git status is clean or not"),yc.forEach(o),Vn.forEach(o),Ys=c(p),tt=n(p,"DIV",{class:!0});var An=a(tt);u(Kt.$$.fragment,An),Zs=c(An),wr=n(An,"P",{});var vc=a(wr);ei=i(vc,"HF-specific. This enables upload support of files >5GB."),vc.forEach(o),An.forEach(o),ti=c(p),ot=n(p,"DIV",{class:!0});var jn=a(ot);u(Qt.$$.fragment,jn),oi=c(jn),Er=n(jn,"P",{});var $c=a(Er);ri=i($c,"git lfs prune"),$c.forEach(o),jn.forEach(o),ni=c(p),ie=n(p,"DIV",{class:!0});var So=a(ie);u(Xt.$$.fragment,So),ai=c(So),kr=n(So,"P",{});var wc=a(kr);si=i(wc,"Tell git-lfs to track files according to a pattern."),wc.forEach(o),ii=c(So),Z=n(So,"P",{});var yt=a(Z);li=i(yt,"Setting the "),xr=n(yt,"CODE",{});var Ec=a(xr);ci=i(Ec,"filename"),Ec.forEach(o),gi=i(yt," argument to "),Dr=n(yt,"CODE",{});var kc=a(Dr);hi=i(kc,"True"),kc.forEach(o),pi=i(yt,` will treat the arguments as
literal filenames, not as patterns. Any special glob characters in the
filename will be escaped when writing to the `),Rr=n(yt,"CODE",{});var xc=a(Rr);di=i(xc,".gitattributes"),xc.forEach(o),ui=i(yt," file."),yt.forEach(o),So.forEach(o),mi=c(p),rt=n(p,"DIV",{class:!0});var Hn=a(rt);u(Yt.$$.fragment,Hn),fi=c(Hn),Tr=n(Hn,"P",{});var Dc=a(Tr);_i=i(Dc,"Tell git-lfs to untrack those files."),Dc.forEach(o),Hn.forEach(o),bi=c(p),nt=n(p,"DIV",{class:!0});var Sn=a(nt);u(Zt.$$.fragment,Sn),yi=c(Sn),Pr=n(Sn,"P",{});var Rc=a(Pr);vi=i(Rc,`Returns a list of the files that are deleted in the working directory or
index.`),Rc.forEach(o),Sn.forEach(o),$i=c(p),at=n(p,"DIV",{class:!0});var qn=a(at);u(eo.$$.fragment,qn),wi=c(qn),Ir=n(qn,"P",{});var Tc=a(Ir);Ei=i(Tc,`Helper to add, commit, and push files to remote repository on the
HuggingFace Hub. Will automatically track large files (>10MB).`),Tc.forEach(o),qn.forEach(o),ki=c(p),st=n(p,"DIV",{class:!0});var Un=a(st);u(to.$$.fragment,Un),xi=c(Un),Lr=n(Un,"P",{});var Pc=a(Lr);Di=i(Pc,"Check if a tag exists or not."),Pc.forEach(o),Un.forEach(o),Ri=c(p),it=n(p,"DIV",{class:!0});var Mn=a(it);u(oo.$$.fragment,Mn),Ti=c(Mn),Cr=n(Mn,"P",{});var Ic=a(Cr);Pi=i(Ic,`Blocking method: blocks all subsequent execution until all commands have
been processed.`),Ic.forEach(o),Mn.forEach(o),p.forEach(o),sn=c(t),Ee=n(t,"H2",{class:!0});var Wn=a(Ee);lt=n(Wn,"A",{id:!0,class:!0,href:!0});var Lc=a(lt);Or=n(Lc,"SPAN",{});var Cc=a(Or);u(ro.$$.fragment,Cc),Cc.forEach(o),Lc.forEach(o),Ii=c(Wn),Fr=n(Wn,"SPAN",{});var Oc=a(Fr);Li=i(Oc,"Helper methods"),Oc.forEach(o),Wn.forEach(o),ln=c(t),ke=n(t,"DIV",{class:!0});var Bn=a(ke);u(no.$$.fragment,Bn),Ci=c(Bn),Nr=n(Bn,"P",{});var Fc=a(Nr);Oi=i(Fc,"Check if the folder is the root or part of a git repository"),Fc.forEach(o),Bn.forEach(o),cn=c(t),xe=n(t,"DIV",{class:!0});var Gn=a(xe);u(ao.$$.fragment,Gn),Fi=c(Gn),Vr=n(Gn,"P",{});var Nc=a(Vr);Ni=i(Nc,"Check if the folder is a local clone of the remote_url"),Nc.forEach(o),Gn.forEach(o),gn=c(t),De=n(t,"DIV",{class:!0});var zn=a(De);u(so.$$.fragment,zn),Vi=c(zn),Ar=n(zn,"P",{});var Vc=a(Ar);Ai=i(Vc,"Check if the file passed is tracked with git-lfs."),Vc.forEach(o),zn.forEach(o),hn=c(t),Re=n(t,"DIV",{class:!0});var Jn=a(Re);u(io.$$.fragment,Jn),ji=c(Jn),jr=n(Jn,"P",{});var Ac=a(jr);Hi=i(Ac,"Check if file is git-ignored. Supports nested .gitignore files."),Ac.forEach(o),Jn.forEach(o),pn=c(t),Te=n(t,"DIV",{class:!0});var Kn=a(Te);u(lo.$$.fragment,Kn),Si=c(Kn),Hr=n(Kn,"P",{});var jc=a(Hr);qi=i(jc,"Returns a list of filenames that are to be staged."),jc.forEach(o),Kn.forEach(o),dn=c(t),Pe=n(t,"DIV",{class:!0});var Qn=a(Pe);u(co.$$.fragment,Qn),Ui=c(Qn),Sr=n(Qn,"P",{});var Hc=a(Sr);Mi=i(Hc,"Check if the current checked-out branch is tracked upstream."),Hc.forEach(o),Qn.forEach(o),un=c(t),ee=n(t,"DIV",{class:!0});var qo=a(ee);u(go.$$.fragment,qo),Wi=c(qo),qr=n(qo,"P",{});var Sc=a(qr);Bi=i(Sc,"Check the number of commits that would be pushed upstream"),Sc.forEach(o),Gi=c(qo),Ur=n(qo,"P",{});var qc=a(Ur);zi=i(qc,`The name of the upstream repository with which the comparison should be
made.`),qc.forEach(o),qo.forEach(o),mn=c(t),Ie=n(t,"H2",{class:!0});var Xn=a(Ie);ct=n(Xn,"A",{id:!0,class:!0,href:!0});var Uc=a(ct);Mr=n(Uc,"SPAN",{});var Mc=a(Mr);u(ho.$$.fragment,Mc),Mc.forEach(o),Uc.forEach(o),Ji=c(Xn),Wr=n(Xn,"SPAN",{});var Wc=a(Wr);Ki=i(Wc,"Following asynchronous commands"),Wc.forEach(o),Xn.forEach(o),fn=c(t),gt=n(t,"P",{});var Yn=a(gt);Qi=i(Yn,"The "),Br=n(Yn,"CODE",{});var Bc=a(Br);Xi=i(Bc,"Repository"),Bc.forEach(o),Yi=i(Yn," utility offers several methods which can be launched asynchronously:"),Yn.forEach(o),_n=c(t),W=n(t,"UL",{});var vt=a(W);Gr=n(vt,"LI",{});var Gc=a(Gr);zr=n(Gc,"CODE",{});var zc=a(zr);Zi=i(zc,"git_push"),zc.forEach(o),Gc.forEach(o),el=c(vt),Jr=n(vt,"LI",{});var Jc=a(Jr);Kr=n(Jc,"CODE",{});var Kc=a(Kr);tl=i(Kc,"git_pull"),Kc.forEach(o),Jc.forEach(o),ol=c(vt),Qr=n(vt,"LI",{});var Qc=a(Qr);Xr=n(Qc,"CODE",{});var Xc=a(Xr);rl=i(Xc,"push_to_hub"),Xc.forEach(o),Qc.forEach(o),nl=c(vt),po=n(vt,"LI",{});var Zn=a(po);al=i(Zn,"The "),Yr=n(Zn,"CODE",{});var Yc=a(Yr);sl=i(Yc,"commit"),Yc.forEach(o),il=i(Zn," context manager"),Zn.forEach(o),vt.forEach(o),bn=c(t),Io=n(t,"P",{});var Zc=a(Io);ll=i(Zc,"See below for utilities to manage such asynchronous methods."),Zc.forEach(o),yn=c(t),I=n(t,"DIV",{class:!0});var B=a(I);u(uo.$$.fragment,B),cl=c(B),Zr=n(B,"P",{});var eg=a(Zr);gl=i(eg,"Helper class to wrap the git and git-lfs commands."),eg.forEach(o),hl=c(B),en=n(B,"P",{});var tg=a(en);pl=i(tg,`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),tg.forEach(o),dl=c(B),ht=n(B,"DIV",{class:!0});var ea=a(ht);u(mo.$$.fragment,ea),ul=c(ea),tn=n(ea,"P",{});var og=a(tn);ml=i(og,"Returns the asynchronous commands that failed."),og.forEach(o),ea.forEach(o),fl=c(B),pt=n(B,"DIV",{class:!0});var ta=a(pt);u(fo.$$.fragment,ta),_l=c(ta),on=n(ta,"P",{});var rg=a(on);bl=i(rg,"Returns the asynchronous commands that are currently in progress."),rg.forEach(o),ta.forEach(o),yl=c(B),dt=n(B,"DIV",{class:!0});var oa=a(dt);u(_o.$$.fragment,oa),vl=c(oa),rn=n(oa,"P",{});var ng=a(rn);$l=i(ng,`Blocking method: blocks all subsequent execution until all commands have
been processed.`),ng.forEach(o),oa.forEach(o),B.forEach(o),vn=c(t),Le=n(t,"DIV",{class:!0});var ra=a(Le);u(bo.$$.fragment,ra),wl=c(ra),nn=n(ra,"P",{});var ag=a(nn);El=i(ag,"Utility to follow commands launched asynchronously."),ag.forEach(o),ra.forEach(o),this.h()},h(){h(k,"name","hf:doc:metadata"),h(k,"content",JSON.stringify(bg)),h(E,"id","managing-local-and-online-repositories"),h(E,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(E,"href","#managing-local-and-online-repositories"),h(x,"class","relative group"),h(C,"id","huggingface_hub.Repository"),h(C,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(C,"href","#huggingface_hub.Repository"),h(V,"class","relative group"),h(O,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Se,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(U,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(qe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Ue,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Me,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(M,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(re,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Ge,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(ne,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(ae,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(ze,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Je,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Ke,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Qe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Xe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Ye,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(se,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Ze,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(et,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(tt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(ot,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(ie,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(rt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(nt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(at,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(st,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(it,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(g,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(lt,"id","huggingface_hub.repository.is_git_repo"),h(lt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(lt,"href","#huggingface_hub.repository.is_git_repo"),h(Ee,"class","relative group"),h(ke,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(xe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(De,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Re,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Te,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(ct,"id","huggingface_hub.Repository"),h(ct,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(ct,"href","#huggingface_hub.Repository"),h(Ie,"class","relative group"),h(ht,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(pt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(dt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(I,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Le,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,y){e(document.head,k),v(t,A,y),v(t,x,y),e(x,E),e(E,L),m(w,L,null),e(x,R),e(x,G),e(G,$t),v(t,Oe,y),v(t,T,y),e(T,wt),e(T,le),e(le,ce),e(T,Et),e(T,ge),e(ge,he),e(T,kt),e(T,pe),e(pe,de),e(T,xt),v(t,Fe,y),v(t,j,y),e(j,ue),e(j,N),e(N,z),e(j,me),v(t,Ne,y),v(t,V,y),e(V,C),e(C,fe),m(J,fe,null),e(V,Dt),e(V,K),e(K,H),v(t,S,y),v(t,g,y),m(Q,g,null),e(g,Rt),e(g,X),e(X,Tt),e(g,Pt),e(g,P),e(P,te),e(g,oe),e(g,O),m(D,O,null),e(O,$o),e(O,Ve),e(Ve,wo),e(O,Eo),e(O,q),e(q,ko),e(q,Ae),e(Ae,_e),e(q,xo),e(q,je),e(je,Do),e(q,Ro),e(O,be),e(O,F),e(F,He),e(He,To),e(F,aa),e(F,Uo),e(Uo,sa),e(F,ia),e(F,Mo),e(Mo,la),e(F,ca),e(F,Wo),e(Wo,ga),e(F,ha),e(g,pa),e(g,Se),m(It,Se,null),e(Se,da),e(Se,Bo),e(Bo,ua),e(g,ma),e(g,U),m(Lt,U,null),e(U,fa),e(U,Go),e(Go,_a),e(U,ba),e(U,zo),e(zo,ya),e(U,va),e(U,Jo),e(Jo,$a),e(g,wa),e(g,qe),m(Ct,qe,null),e(qe,Ea),e(qe,Ko),e(Ko,ka),e(g,xa),e(g,Ue),m(Ot,Ue,null),e(Ue,Da),e(Ue,Qo),e(Qo,Ra),e(g,Ta),e(g,Me),m(Ft,Me,null),e(Me,Pa),e(Me,ye),e(ye,Ia),e(ye,Xo),e(Xo,La),e(ye,Ca),e(ye,Yo),e(Yo,Oa),e(ye,Fa),e(g,Na),e(g,M),m(Nt,M,null),e(M,Va),e(M,Zo),e(Zo,Aa),e(M,ja),e(M,er),e(er,Ha),e(M,Sa),m(We,M,null),e(g,qa),e(g,re),m(Vt,re,null),e(re,Ua),e(re,ve),e(ve,Ma),e(ve,tr),e(tr,Wa),e(ve,Ba),e(ve,or),e(or,Ga),e(ve,za),e(re,Ja),m(Be,re,null),e(g,Ka),e(g,Ge),m(At,Ge,null),e(Ge,Qa),e(Ge,rr),e(rr,Xa),e(g,Ya),e(g,ne),m(jt,ne,null),e(ne,Za),e(ne,nr),e(nr,es),e(ne,ts),e(ne,Y),e(Y,os),e(Y,ar),e(ar,rs),e(Y,ns),e(Y,sr),e(sr,as),e(Y,ss),e(Y,ir),e(ir,is),e(Y,ls),e(g,cs),e(g,ae),m(Ht,ae,null),e(ae,gs),e(ae,lr),e(lr,hs),e(ae,ps),e(ae,$e),e($e,ds),e($e,cr),e(cr,us),e($e,ms),e($e,gr),e(gr,fs),e($e,_s),e(g,bs),e(g,ze),m(St,ze,null),e(ze,ys),e(ze,hr),e(hr,vs),e(g,$s),e(g,Je),m(qt,Je,null),e(Je,ws),e(Je,pr),e(pr,Es),e(g,ks),e(g,Ke),m(Ut,Ke,null),e(Ke,xs),e(Ke,Po),e(Po,Ds),e(Po,dr),e(dr,Rs),e(g,Ts),e(g,Qe),m(Mt,Qe,null),e(Qe,Ps),e(Qe,ur),e(ur,Is),e(g,Ls),e(g,Xe),m(Wt,Xe,null),e(Xe,Cs),e(Xe,mr),e(mr,Os),e(g,Fs),e(g,Ye),m(Bt,Ye,null),e(Ye,Ns),e(Ye,fr),e(fr,Vs),e(g,As),e(g,se),m(Gt,se,null),e(se,js),e(se,_r),e(_r,Hs),e(se,Ss),e(se,we),e(we,qs),e(we,br),e(br,Us),e(we,Ms),e(we,yr),e(yr,Ws),e(we,Bs),e(g,Gs),e(g,Ze),m(zt,Ze,null),e(Ze,zs),e(Ze,vr),e(vr,Js),e(g,Ks),e(g,et),m(Jt,et,null),e(et,Qs),e(et,$r),e($r,Xs),e(g,Ys),e(g,tt),m(Kt,tt,null),e(tt,Zs),e(tt,wr),e(wr,ei),e(g,ti),e(g,ot),m(Qt,ot,null),e(ot,oi),e(ot,Er),e(Er,ri),e(g,ni),e(g,ie),m(Xt,ie,null),e(ie,ai),e(ie,kr),e(kr,si),e(ie,ii),e(ie,Z),e(Z,li),e(Z,xr),e(xr,ci),e(Z,gi),e(Z,Dr),e(Dr,hi),e(Z,pi),e(Z,Rr),e(Rr,di),e(Z,ui),e(g,mi),e(g,rt),m(Yt,rt,null),e(rt,fi),e(rt,Tr),e(Tr,_i),e(g,bi),e(g,nt),m(Zt,nt,null),e(nt,yi),e(nt,Pr),e(Pr,vi),e(g,$i),e(g,at),m(eo,at,null),e(at,wi),e(at,Ir),e(Ir,Ei),e(g,ki),e(g,st),m(to,st,null),e(st,xi),e(st,Lr),e(Lr,Di),e(g,Ri),e(g,it),m(oo,it,null),e(it,Ti),e(it,Cr),e(Cr,Pi),v(t,sn,y),v(t,Ee,y),e(Ee,lt),e(lt,Or),m(ro,Or,null),e(Ee,Ii),e(Ee,Fr),e(Fr,Li),v(t,ln,y),v(t,ke,y),m(no,ke,null),e(ke,Ci),e(ke,Nr),e(Nr,Oi),v(t,cn,y),v(t,xe,y),m(ao,xe,null),e(xe,Fi),e(xe,Vr),e(Vr,Ni),v(t,gn,y),v(t,De,y),m(so,De,null),e(De,Vi),e(De,Ar),e(Ar,Ai),v(t,hn,y),v(t,Re,y),m(io,Re,null),e(Re,ji),e(Re,jr),e(jr,Hi),v(t,pn,y),v(t,Te,y),m(lo,Te,null),e(Te,Si),e(Te,Hr),e(Hr,qi),v(t,dn,y),v(t,Pe,y),m(co,Pe,null),e(Pe,Ui),e(Pe,Sr),e(Sr,Mi),v(t,un,y),v(t,ee,y),m(go,ee,null),e(ee,Wi),e(ee,qr),e(qr,Bi),e(ee,Gi),e(ee,Ur),e(Ur,zi),v(t,mn,y),v(t,Ie,y),e(Ie,ct),e(ct,Mr),m(ho,Mr,null),e(Ie,Ji),e(Ie,Wr),e(Wr,Ki),v(t,fn,y),v(t,gt,y),e(gt,Qi),e(gt,Br),e(Br,Xi),e(gt,Yi),v(t,_n,y),v(t,W,y),e(W,Gr),e(Gr,zr),e(zr,Zi),e(W,el),e(W,Jr),e(Jr,Kr),e(Kr,tl),e(W,ol),e(W,Qr),e(Qr,Xr),e(Xr,rl),e(W,nl),e(W,po),e(po,al),e(po,Yr),e(Yr,sl),e(po,il),v(t,bn,y),v(t,Io,y),e(Io,ll),v(t,yn,y),v(t,I,y),m(uo,I,null),e(I,cl),e(I,Zr),e(Zr,gl),e(I,hl),e(I,en),e(en,pl),e(I,dl),e(I,ht),m(mo,ht,null),e(ht,ul),e(ht,tn),e(tn,ml),e(I,fl),e(I,pt),m(fo,pt,null),e(pt,_l),e(pt,on),e(on,bl),e(I,yl),e(I,dt),m(_o,dt,null),e(dt,vl),e(dt,rn),e(rn,$l),v(t,vn,y),v(t,Le,y),m(bo,Le,null),e(Le,wl),e(Le,nn),e(nn,El),$n=!0},p(t,[y]){const yo={};y&2&&(yo.$$scope={dirty:y,ctx:t}),We.$set(yo);const an={};y&2&&(an.$$scope={dirty:y,ctx:t}),Be.$set(an)},i(t){$n||(f(w.$$.fragment,t),f(J.$$.fragment,t),f(Q.$$.fragment,t),f(D.$$.fragment,t),f(It.$$.fragment,t),f(Lt.$$.fragment,t),f(Ct.$$.fragment,t),f(Ot.$$.fragment,t),f(Ft.$$.fragment,t),f(Nt.$$.fragment,t),f(We.$$.fragment,t),f(Vt.$$.fragment,t),f(Be.$$.fragment,t),f(At.$$.fragment,t),f(jt.$$.fragment,t),f(Ht.$$.fragment,t),f(St.$$.fragment,t),f(qt.$$.fragment,t),f(Ut.$$.fragment,t),f(Mt.$$.fragment,t),f(Wt.$$.fragment,t),f(Bt.$$.fragment,t),f(Gt.$$.fragment,t),f(zt.$$.fragment,t),f(Jt.$$.fragment,t),f(Kt.$$.fragment,t),f(Qt.$$.fragment,t),f(Xt.$$.fragment,t),f(Yt.$$.fragment,t),f(Zt.$$.fragment,t),f(eo.$$.fragment,t),f(to.$$.fragment,t),f(oo.$$.fragment,t),f(ro.$$.fragment,t),f(no.$$.fragment,t),f(ao.$$.fragment,t),f(so.$$.fragment,t),f(io.$$.fragment,t),f(lo.$$.fragment,t),f(co.$$.fragment,t),f(go.$$.fragment,t),f(ho.$$.fragment,t),f(uo.$$.fragment,t),f(mo.$$.fragment,t),f(fo.$$.fragment,t),f(_o.$$.fragment,t),f(bo.$$.fragment,t),$n=!0)},o(t){_(w.$$.fragment,t),_(J.$$.fragment,t),_(Q.$$.fragment,t),_(D.$$.fragment,t),_(It.$$.fragment,t),_(Lt.$$.fragment,t),_(Ct.$$.fragment,t),_(Ot.$$.fragment,t),_(Ft.$$.fragment,t),_(Nt.$$.fragment,t),_(We.$$.fragment,t),_(Vt.$$.fragment,t),_(Be.$$.fragment,t),_(At.$$.fragment,t),_(jt.$$.fragment,t),_(Ht.$$.fragment,t),_(St.$$.fragment,t),_(qt.$$.fragment,t),_(Ut.$$.fragment,t),_(Mt.$$.fragment,t),_(Wt.$$.fragment,t),_(Bt.$$.fragment,t),_(Gt.$$.fragment,t),_(zt.$$.fragment,t),_(Jt.$$.fragment,t),_(Kt.$$.fragment,t),_(Qt.$$.fragment,t),_(Xt.$$.fragment,t),_(Yt.$$.fragment,t),_(Zt.$$.fragment,t),_(eo.$$.fragment,t),_(to.$$.fragment,t),_(oo.$$.fragment,t),_(ro.$$.fragment,t),_(no.$$.fragment,t),_(ao.$$.fragment,t),_(so.$$.fragment,t),_(io.$$.fragment,t),_(lo.$$.fragment,t),_(co.$$.fragment,t),_(go.$$.fragment,t),_(ho.$$.fragment,t),_(uo.$$.fragment,t),_(mo.$$.fragment,t),_(fo.$$.fragment,t),_(_o.$$.fragment,t),_(bo.$$.fragment,t),$n=!1},d(t){o(k),t&&o(A),t&&o(x),b(w),t&&o(Oe),t&&o(T),t&&o(Fe),t&&o(j),t&&o(Ne),t&&o(V),b(J),t&&o(S),t&&o(g),b(Q),b(D),b(It),b(Lt),b(Ct),b(Ot),b(Ft),b(Nt),b(We),b(Vt),b(Be),b(At),b(jt),b(Ht),b(St),b(qt),b(Ut),b(Mt),b(Wt),b(Bt),b(Gt),b(zt),b(Jt),b(Kt),b(Qt),b(Xt),b(Yt),b(Zt),b(eo),b(to),b(oo),t&&o(sn),t&&o(Ee),b(ro),t&&o(ln),t&&o(ke),b(no),t&&o(cn),t&&o(xe),b(ao),t&&o(gn),t&&o(De),b(so),t&&o(hn),t&&o(Re),b(io),t&&o(pn),t&&o(Te),b(lo),t&&o(dn),t&&o(Pe),b(co),t&&o(un),t&&o(ee),b(go),t&&o(mn),t&&o(Ie),b(ho),t&&o(fn),t&&o(gt),t&&o(_n),t&&o(W),t&&o(bn),t&&o(Io),t&&o(yn),t&&o(I),b(uo),b(mo),b(fo),b(_o),t&&o(vn),t&&o(Le),b(bo)}}}const bg={local:"managing-local-and-online-repositories",sections:[{local:"huggingface_hub.Repository",title:"The Repository class"},{local:"huggingface_hub.repository.is_git_repo",title:"Helper methods"},{local:"huggingface_hub.Repository",title:"Following asynchronous commands"}],title:"Managing local and online repositories"};function yg(vo){return gg(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Dg extends sg{constructor(k){super();ig(this,k,yg,_g,lg,{})}}export{Dg as default,bg as metadata};
