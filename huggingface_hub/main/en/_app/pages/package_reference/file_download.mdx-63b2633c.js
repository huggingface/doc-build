import{S as Ze,i as eo,s as oo,e as n,k as m,w as Z,t as d,M as no,c as t,d as o,m as _,a,x as ee,h as c,b as $,F as e,g as x,y as oe,q as ne,o as te,B as ae,v as to,L as ao}from"../../chunks/vendor-a09ded63.js";import{T as Te}from"../../chunks/Tip-27a54654.js";import{D as ke}from"../../chunks/Docstring-3f63de13.js";import{C as ro}from"../../chunks/CodeBlock-879da7fe.js";import{I as io}from"../../chunks/IconCopyLink-3f5556be.js";import{E as so}from"../../chunks/ExampleCodeBlock-7aff195a.js";function lo(K){let h,D,p,i,f,s,u,A,S,w,T,N,j,E,l,b,P,F,v,y,k,q,W,z;return{c(){h=n("p"),D=d("Raises the following errors:"),p=m(),i=n("ul"),f=n("li"),s=n("a"),u=n("code"),A=d("EnvironmentError"),S=d(`
if `),w=n("code"),T=d("use_auth_token=True"),N=d(" and the token cannot be found."),j=m(),E=n("li"),l=n("a"),b=n("code"),P=d("OSError"),F=d(`
if ETag cannot be determined.`),v=m(),y=n("li"),k=n("a"),q=n("code"),W=d("ValueError"),z=d(`
if some parameter value is invalid`),this.h()},l(g){h=t(g,"P",{});var O=a(h);D=c(O,"Raises the following errors:"),O.forEach(o),p=_(g),i=t(g,"UL",{});var L=a(i);f=t(L,"LI",{});var C=a(f);s=t(C,"A",{href:!0,rel:!0});var Q=a(s);u=t(Q,"CODE",{});var X=a(u);A=c(X,"EnvironmentError"),X.forEach(o),Q.forEach(o),S=c(C,`
if `),w=t(C,"CODE",{});var V=a(w);T=c(V,"use_auth_token=True"),V.forEach(o),N=c(C," and the token cannot be found."),C.forEach(o),j=_(L),E=t(L,"LI",{});var H=a(E);l=t(H,"A",{href:!0,rel:!0});var U=a(l);b=t(U,"CODE",{});var B=a(b);P=c(B,"OSError"),B.forEach(o),U.forEach(o),F=c(H,`
if ETag cannot be determined.`),H.forEach(o),v=_(L),y=t(L,"LI",{});var G=a(y);k=t(G,"A",{href:!0,rel:!0});var M=a(k);q=t(M,"CODE",{});var Y=a(q);W=c(Y,"ValueError"),Y.forEach(o),M.forEach(o),z=c(G,`
if some parameter value is invalid`),G.forEach(o),L.forEach(o),this.h()},h(){$(s,"href","https://docs.python.org/3/library/exceptions.html#EnvironmentError"),$(s,"rel","nofollow"),$(l,"href","https://docs.python.org/3/library/exceptions.html#OSError"),$(l,"rel","nofollow"),$(k,"href","https://docs.python.org/3/library/exceptions.html#ValueError"),$(k,"rel","nofollow")},m(g,O){x(g,h,O),e(h,D),x(g,p,O),x(g,i,O),e(i,f),e(f,s),e(s,u),e(u,A),e(f,S),e(f,w),e(w,T),e(f,N),e(i,j),e(i,E),e(E,l),e(l,b),e(b,P),e(E,F),e(i,v),e(i,y),e(y,k),e(k,q),e(q,W),e(y,z)},d(g){g&&o(h),g&&o(p),g&&o(i)}}}function co(K){let h,D,p,i,f,s,u,A,S,w,T,N,j,E,l,b,P,F,v,y,k,q,W,z;return{c(){h=n("p"),D=d("Raises the following errors:"),p=m(),i=n("ul"),f=n("li"),s=n("a"),u=n("code"),A=d("EnvironmentError"),S=d(`
if `),w=n("code"),T=d("use_auth_token=True"),N=d(" and the token cannot be found."),j=m(),E=n("li"),l=n("a"),b=n("code"),P=d("OSError"),F=d(` if
ETag cannot be determined.`),v=m(),y=n("li"),k=n("a"),q=n("code"),W=d("ValueError"),z=d(`
if some parameter value is invalid`),this.h()},l(g){h=t(g,"P",{});var O=a(h);D=c(O,"Raises the following errors:"),O.forEach(o),p=_(g),i=t(g,"UL",{});var L=a(i);f=t(L,"LI",{});var C=a(f);s=t(C,"A",{href:!0,rel:!0});var Q=a(s);u=t(Q,"CODE",{});var X=a(u);A=c(X,"EnvironmentError"),X.forEach(o),Q.forEach(o),S=c(C,`
if `),w=t(C,"CODE",{});var V=a(w);T=c(V,"use_auth_token=True"),V.forEach(o),N=c(C," and the token cannot be found."),C.forEach(o),j=_(L),E=t(L,"LI",{});var H=a(E);l=t(H,"A",{href:!0,rel:!0});var U=a(l);b=t(U,"CODE",{});var B=a(b);P=c(B,"OSError"),B.forEach(o),U.forEach(o),F=c(H,` if
ETag cannot be determined.`),H.forEach(o),v=_(L),y=t(L,"LI",{});var G=a(y);k=t(G,"A",{href:!0,rel:!0});var M=a(k);q=t(M,"CODE",{});var Y=a(q);W=c(Y,"ValueError"),Y.forEach(o),M.forEach(o),z=c(G,`
if some parameter value is invalid`),G.forEach(o),L.forEach(o),this.h()},h(){$(s,"href","https://docs.python.org/3/library/exceptions.html#EnvironmentError"),$(s,"rel","nofollow"),$(l,"href","https://docs.python.org/3/library/exceptions.html#OSError"),$(l,"rel","nofollow"),$(k,"href","https://docs.python.org/3/library/exceptions.html#ValueError"),$(k,"rel","nofollow")},m(g,O){x(g,h,O),e(h,D),x(g,p,O),x(g,i,O),e(i,f),e(f,s),e(s,u),e(u,A),e(f,S),e(f,w),e(w,T),e(f,N),e(i,j),e(i,E),e(E,l),e(l,b),e(b,P),e(E,F),e(i,v),e(i,y),e(y,k),e(k,q),e(q,W),e(y,z)},d(g){g&&o(h),g&&o(p),g&&o(i)}}}function ho(K){let h,D,p,i,f,s,u,A,S,w,T,N,j,E,l,b,P,F,v,y,k,q,W,z;return{c(){h=n("p"),D=d("Raises the following errors:"),p=m(),i=n("ul"),f=n("li"),s=n("a"),u=n("code"),A=d("EnvironmentError"),S=d(`
if `),w=n("code"),T=d("use_auth_token=True"),N=d(" and the token cannot be found."),j=m(),E=n("li"),l=n("a"),b=n("code"),P=d("OSError"),F=d(`
if ETag cannot be determined.`),v=m(),y=n("li"),k=n("a"),q=n("code"),W=d("ValueError"),z=d(`
if some parameter value is invalid`),this.h()},l(g){h=t(g,"P",{});var O=a(h);D=c(O,"Raises the following errors:"),O.forEach(o),p=_(g),i=t(g,"UL",{});var L=a(i);f=t(L,"LI",{});var C=a(f);s=t(C,"A",{href:!0,rel:!0});var Q=a(s);u=t(Q,"CODE",{});var X=a(u);A=c(X,"EnvironmentError"),X.forEach(o),Q.forEach(o),S=c(C,`
if `),w=t(C,"CODE",{});var V=a(w);T=c(V,"use_auth_token=True"),V.forEach(o),N=c(C," and the token cannot be found."),C.forEach(o),j=_(L),E=t(L,"LI",{});var H=a(E);l=t(H,"A",{href:!0,rel:!0});var U=a(l);b=t(U,"CODE",{});var B=a(b);P=c(B,"OSError"),B.forEach(o),U.forEach(o),F=c(H,`
if ETag cannot be determined.`),H.forEach(o),v=_(L),y=t(L,"LI",{});var G=a(y);k=t(G,"A",{href:!0,rel:!0});var M=a(k);q=t(M,"CODE",{});var Y=a(q);W=c(Y,"ValueError"),Y.forEach(o),M.forEach(o),z=c(G,`
if some parameter value is invalid`),G.forEach(o),L.forEach(o),this.h()},h(){$(s,"href","https://docs.python.org/3/library/exceptions.html#EnvironmentError"),$(s,"rel","nofollow"),$(l,"href","https://docs.python.org/3/library/exceptions.html#OSError"),$(l,"rel","nofollow"),$(k,"href","https://docs.python.org/3/library/exceptions.html#ValueError"),$(k,"rel","nofollow")},m(g,O){x(g,h,O),e(h,D),x(g,p,O),x(g,i,O),e(i,f),e(f,s),e(s,u),e(u,A),e(f,S),e(f,w),e(w,T),e(f,N),e(i,j),e(i,E),e(E,l),e(l,b),e(b,P),e(E,F),e(i,v),e(i,y),e(y,k),e(k,q),e(q,W),e(y,z)},d(g){g&&o(h),g&&o(p),g&&o(i)}}}function fo(K){let h,D,p,i,f;return i=new ro({props:{code:`from huggingface_hub import hf_hub_url

hf_hub_url(
    repo_id="julien-c/EsperBERTo-small", filename="pytorch_model.bin"
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> huggingface_hub <span class="hljs-keyword">import</span> hf_hub_url

<span class="hljs-meta">&gt;&gt;&gt; </span>hf_hub_url(
<span class="hljs-meta">... </span>    repo_id=<span class="hljs-string">&quot;julien-c/EsperBERTo-small&quot;</span>, filename=<span class="hljs-string">&quot;pytorch_model.bin&quot;</span>
<span class="hljs-meta">... </span>)
<span class="hljs-string">&#x27;https://huggingface.co/julien-c/EsperBERTo-small/resolve/main/pytorch_model.bin&#x27;</span>`}}),{c(){h=n("p"),D=d("Example:"),p=m(),Z(i.$$.fragment)},l(s){h=t(s,"P",{});var u=a(h);D=c(u,"Example:"),u.forEach(o),p=_(s),ee(i.$$.fragment,s)},m(s,u){x(s,h,u),e(h,D),x(s,p,u),oe(i,s,u),f=!0},p:ao,i(s){f||(ne(i.$$.fragment,s),f=!0)},o(s){te(i.$$.fragment,s),f=!1},d(s){s&&o(h),s&&o(p),ae(i,s)}}}function go(K){let h,D,p,i,f,s,u,A,S,w,T,N,j,E;return{c(){h=n("p"),D=d("Notes:"),p=m(),i=n("p"),f=d(`Cloudfront is replicated over the globe so downloads are way faster for
the end user (and it also lowers our bandwidth costs).`),s=m(),u=n("p"),A=d(`Cloudfront aggressively caches files by default (default TTL is 24
hours), however this is not an issue here because we implement a
git-based versioning system on huggingface.co, which means that we store
the files on S3/Cloudfront in a content-addressable way (i.e., the file
name is its hash). Using content-addressable filenames means cache can\u2019t
ever be stale.`),S=m(),w=n("p"),T=d(`In terms of client-side caching from this library, we base our caching
on the objects\u2019 entity tag (`),N=n("code"),j=d("ETag"),E=d(`), which is an identifier of a
specific version of a resource [1]_. An object\u2019s ETag is: its git-sha1
if stored in git, or its sha256 if stored in git-lfs.`)},l(l){h=t(l,"P",{});var b=a(h);D=c(b,"Notes:"),b.forEach(o),p=_(l),i=t(l,"P",{});var P=a(i);f=c(P,`Cloudfront is replicated over the globe so downloads are way faster for
the end user (and it also lowers our bandwidth costs).`),P.forEach(o),s=_(l),u=t(l,"P",{});var F=a(u);A=c(F,`Cloudfront aggressively caches files by default (default TTL is 24
hours), however this is not an issue here because we implement a
git-based versioning system on huggingface.co, which means that we store
the files on S3/Cloudfront in a content-addressable way (i.e., the file
name is its hash). Using content-addressable filenames means cache can\u2019t
ever be stale.`),F.forEach(o),S=_(l),w=t(l,"P",{});var v=a(w);T=c(v,`In terms of client-side caching from this library, we base our caching
on the objects\u2019 entity tag (`),N=t(v,"CODE",{});var y=a(N);j=c(y,"ETag"),y.forEach(o),E=c(v,`), which is an identifier of a
specific version of a resource [1]_. An object\u2019s ETag is: its git-sha1
if stored in git, or its sha256 if stored in git-lfs.`),v.forEach(o)},m(l,b){x(l,h,b),e(h,D),x(l,p,b),x(l,i,b),e(i,f),x(l,s,b),x(l,u,b),e(u,A),x(l,S,b),x(l,w,b),e(w,T),e(w,N),e(N,j),e(w,E)},d(l){l&&o(h),l&&o(p),l&&o(i),l&&o(s),l&&o(u),l&&o(S),l&&o(w)}}}function uo(K){let h,D,p,i,f,s,u,A,S,w,T,N,j,E,l,b,P,F,v,y,k,q,W,z,g,O,L,C,Q,X,V,H,U,B,G,M,Y,Ne,pe,De,Oe,se,$e,R,he,Le,me,Ie,Pe,_e,qe,Ce,le,Ue,de,Ae,be,Se,je,ve,ue,Fe,fe,Re,xe;return s=new io({}),N=new ke({props:{name:"huggingface_hub.hf_hub_download",anchor:"huggingface_hub.hf_hub_download",parameters:[{name:"repo_id",val:": str"},{name:"filename",val:": str"},{name:"subfolder",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"force_download",val:": typing.Optional[bool] = False"},{name:"force_filename",val:": typing.Optional[str] = None"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.hf_hub_download.repo_id",description:`<strong>repo_id</strong> (<code>str</code>) &#x2014;
A user or an organization name and a repo name separated by a <code>/</code>.`,name:"repo_id"},{anchor:"huggingface_hub.hf_hub_download.filename",description:`<strong>filename</strong> (<code>str</code>) &#x2014;
The name of the file in the repo.`,name:"filename"},{anchor:"huggingface_hub.hf_hub_download.subfolder",description:`<strong>subfolder</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional value corresponding to a folder inside the model repo.`,name:"subfolder"},{anchor:"huggingface_hub.hf_hub_download.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Set to <code>&quot;dataset&quot;</code> or <code>&quot;space&quot;</code> if uploading to a dataset or space,
<code>None</code> or <code>&quot;model&quot;</code> if uploading to a model. Default is <code>None</code>.`,name:"repo_type"},{anchor:"huggingface_hub.hf_hub_download.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"},{anchor:"huggingface_hub.hf_hub_download.library_name",description:`<strong>library_name</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.hf_hub_download.library_version",description:`<strong>library_version</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.hf_hub_download.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <code>Path</code>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.hf_hub_download.user_agent",description:`<strong>user_agent</strong> (<code>dict</code>, <code>str</code>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.hf_hub_download.force_download",description:`<strong>force_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the file should be downloaded even if it already exists in
the local cache.`,name:"force_download"},{anchor:"huggingface_hub.hf_hub_download.force_filename",description:`<strong>force_filename</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Use this name instead of a generated file name.`,name:"force_filename"},{anchor:"huggingface_hub.hf_hub_download.proxies",description:`<strong>proxies</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<code>requests.request</code>.`,name:"proxies"},{anchor:"huggingface_hub.hf_hub_download.etag_timeout",description:`<strong>etag_timeout</strong> (<code>float</code>, <em>optional</em>, defaults to <code>10</code>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <code>requests.request</code>.`,name:"etag_timeout"},{anchor:"huggingface_hub.hf_hub_download.resume_download",description:`<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, resume a previously interrupted download.`,name:"resume_download"},{anchor:"huggingface_hub.hf_hub_download.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code>, <code>bool</code>, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <code>True</code>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"use_auth_token"},{anchor:"huggingface_hub.hf_hub_download.local_files_only",description:`<strong>local_files_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/file_download.py#L692",returnDescription:`
<p>Local path (string) of file or if networking is off, last version of
file cached on disk.</p>
`}}),P=new Te({props:{$$slots:{default:[lo]},$$scope:{ctx:K}}}),y=new ke({props:{name:"huggingface_hub.snapshot_download",anchor:"huggingface_hub.snapshot_download",parameters:[{name:"repo_id",val:": str"},{name:"revision",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"},{name:"allow_regex",val:": typing.Union[typing.List[str], str, NoneType] = None"},{name:"ignore_regex",val:": typing.Union[typing.List[str], str, NoneType] = None"}],parametersDescription:[{anchor:"huggingface_hub.snapshot_download.repo_id",description:`<strong>repo_id</strong> (<code>str</code>) &#x2014;
A user or an organization name and a repo name separated by a <code>/</code>.`,name:"repo_id"},{anchor:"huggingface_hub.snapshot_download.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"},{anchor:"huggingface_hub.snapshot_download.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <code>Path</code>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.snapshot_download.library_name",description:`<strong>library_name</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.snapshot_download.library_version",description:`<strong>library_version</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.snapshot_download.user_agent",description:`<strong>user_agent</strong> (<code>str</code>, <code>dict</code>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.snapshot_download.proxies",description:`<strong>proxies</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<code>requests.request</code>.`,name:"proxies"},{anchor:"huggingface_hub.snapshot_download.etag_timeout",description:`<strong>etag_timeout</strong> (<code>float</code>, <em>optional</em>, defaults to <code>10</code>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <code>requests.request</code>.`,name:"etag_timeout"},{anchor:"huggingface_hub.snapshot_download.resume_download",description:"<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False) -- If </code>True`, resume a previously interrupted download.",name:"resume_download"},{anchor:"huggingface_hub.snapshot_download.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code>, <code>bool</code>, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <code>True</code>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"use_auth_token"},{anchor:"huggingface_hub.snapshot_download.local_files_only",description:`<strong>local_files_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"},{anchor:"huggingface_hub.snapshot_download.allow_regex",description:`<strong>allow_regex</strong> (<code>list of str</code>, <code>str</code>, <em>optional</em>) &#x2014;
If provided, only files matching this regex are downloaded.`,name:"allow_regex"},{anchor:"huggingface_hub.snapshot_download.ignore_regex",description:`<strong>ignore_regex</strong> (<code>list of str</code>, <code>str</code>, <em>optional</em>) &#x2014;
If provided, files matching this regex are not downloaded.`,name:"ignore_regex"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/_snapshot_download.py#L22",returnDescription:`
<p>Local folder path (string) of repo snapshot</p>
`}}),V=new Te({props:{$$slots:{default:[co]},$$scope:{ctx:K}}}),B=new ke({props:{name:"huggingface_hub.cached_download",anchor:"huggingface_hub.cached_download",parameters:[{name:"url",val:": str"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"force_download",val:": typing.Optional[bool] = False"},{name:"force_filename",val:": typing.Optional[str] = None"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.cached_download.url",description:`<strong>url</strong> (<code>str</code>) &#x2014;
The path to the file to be downloaded.`,name:"url"},{anchor:"huggingface_hub.cached_download.library_name",description:`<strong>library_name</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.cached_download.library_version",description:`<strong>library_version</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.cached_download.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <code>Path</code>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.cached_download.user_agent",description:`<strong>user_agent</strong> (<code>dict</code>, <code>str</code>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.cached_download.force_download",description:`<strong>force_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the file should be downloaded even if it already exists in
the local cache.`,name:"force_download"},{anchor:"huggingface_hub.cached_download.force_filename",description:`<strong>force_filename</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Use this name instead of a generated file name.`,name:"force_filename"},{anchor:"huggingface_hub.cached_download.proxies",description:`<strong>proxies</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<code>requests.request</code>.`,name:"proxies"},{anchor:"huggingface_hub.cached_download.etag_timeout",description:`<strong>etag_timeout</strong> (<code>float</code>, <em>optional</em> defaults to <code>10</code>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <code>requests.request</code>.`,name:"etag_timeout"},{anchor:"huggingface_hub.cached_download.resume_download",description:`<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, resume a previously interrupted download.`,name:"resume_download"},{anchor:"huggingface_hub.cached_download.use_auth_token",description:`<strong>use_auth_token</strong> (<code>bool</code>, <code>str</code>, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <code>True</code>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"use_auth_token"},{anchor:"huggingface_hub.cached_download.local_files_only",description:`<strong>local_files_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/file_download.py#L443",returnDescription:`
<p>Local path (string) of file or if networking is off, last version of
file cached on disk.</p>
`}}),se=new Te({props:{$$slots:{default:[ho]},$$scope:{ctx:K}}}),he=new ke({props:{name:"huggingface_hub.hf_hub_url",anchor:"huggingface_hub.hf_hub_url",parameters:[{name:"repo_id",val:": str"},{name:"filename",val:": str"},{name:"subfolder",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.hf_hub_url.repo_id",description:`<strong>repo_id</strong> (<code>str</code>) &#x2014;
A namespace (user or an organization) name and a repo name separated
by a <code>/</code>.`,name:"repo_id"},{anchor:"huggingface_hub.hf_hub_url.filename",description:`<strong>filename</strong> (<code>str</code>) &#x2014;
The name of the file in the repo.`,name:"filename"},{anchor:"huggingface_hub.hf_hub_url.subfolder",description:`<strong>subfolder</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional value corresponding to a folder inside the repo.`,name:"subfolder"},{anchor:"huggingface_hub.hf_hub_url.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Set to <code>&quot;dataset&quot;</code> or <code>&quot;space&quot;</code> if uploading to a dataset or space,
<code>None</code> or <code>&quot;model&quot;</code> if uploading to a model. Default is <code>None</code>.`,name:"repo_type"},{anchor:"huggingface_hub.hf_hub_url.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"}],source:"https://github.com/huggingface/huggingface_hub/blob/main/src/huggingface_hub/file_download.py#L145"}}),le=new so({props:{anchor:"huggingface_hub.hf_hub_url.example",$$slots:{default:[fo]},$$scope:{ctx:K}}}),de=new Te({props:{$$slots:{default:[go]},$$scope:{ctx:K}}}),{c(){h=n("meta"),D=m(),p=n("h1"),i=n("a"),f=n("span"),Z(s.$$.fragment),u=m(),A=n("span"),S=d("Downloading files"),w=m(),T=n("div"),Z(N.$$.fragment),j=m(),E=n("p"),l=d("Download a given file if it\u2019s not already present in the local cache."),b=m(),Z(P.$$.fragment),F=m(),v=n("div"),Z(y.$$.fragment),k=m(),q=n("p"),W=d("Download all files of a repo."),z=m(),g=n("p"),O=d(`Downloads a whole snapshot of a repo\u2019s files at the specified revision. This
is useful when you want all files from a repo, because you don\u2019t know which
ones you will need a priori. All files are nested inside a folder in order
to keep their actual filename relative to that folder.`),L=m(),C=n("p"),Q=d(`An alternative would be to just clone a repo but this would require that the
user always has git and git-lfs installed, and properly configured.`),X=m(),Z(V.$$.fragment),H=m(),U=n("div"),Z(B.$$.fragment),G=m(),M=n("p"),Y=d(`Download from a given URL and cache it if it\u2019s not already present in the
local cache.`),Ne=m(),pe=n("p"),De=d(`Given a URL, this function looks for the corresponding file in the local
cache. If it\u2019s not there, download it. Then return the path to the cached
file.`),Oe=m(),Z(se.$$.fragment),$e=m(),R=n("div"),Z(he.$$.fragment),Le=m(),me=n("p"),Ie=d("Construct the URL of a file from the given information."),Pe=m(),_e=n("p"),qe=d(`The resolved address can either be a huggingface.co-hosted url, or a link to
Cloudfront (a Content Delivery Network, or CDN) for large files which are
more than a few MBs.`),Ce=m(),Z(le.$$.fragment),Ue=m(),Z(de.$$.fragment),Ae=m(),be=n("p"),Se=d("References:"),je=m(),ve=n("ul"),ue=n("li"),Fe=d("[1] "),fe=n("a"),Re=d("https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),this.h()},l(r){const I=no('[data-svelte="svelte-1phssyn"]',document.head);h=t(I,"META",{name:!0,content:!0}),I.forEach(o),D=_(r),p=t(r,"H1",{class:!0});var ge=a(p);i=t(ge,"A",{id:!0,class:!0,href:!0});var we=a(i);f=t(we,"SPAN",{});var ye=a(f);ee(s.$$.fragment,ye),ye.forEach(o),we.forEach(o),u=_(ge),A=t(ge,"SPAN",{});var Ee=a(A);S=c(Ee,"Downloading files"),Ee.forEach(o),ge.forEach(o),w=_(r),T=t(r,"DIV",{class:!0});var ie=a(T);ee(N.$$.fragment,ie),j=_(ie),E=t(ie,"P",{});var He=a(E);l=c(He,"Download a given file if it\u2019s not already present in the local cache."),He.forEach(o),b=_(ie),ee(P.$$.fragment,ie),ie.forEach(o),F=_(r),v=t(r,"DIV",{class:!0});var re=a(v);ee(y.$$.fragment,re),k=_(re),q=t(re,"P",{});var Be=a(q);W=c(Be,"Download all files of a repo."),Be.forEach(o),z=_(re),g=t(re,"P",{});var We=a(g);O=c(We,`Downloads a whole snapshot of a repo\u2019s files at the specified revision. This
is useful when you want all files from a repo, because you don\u2019t know which
ones you will need a priori. All files are nested inside a folder in order
to keep their actual filename relative to that folder.`),We.forEach(o),L=_(re),C=t(re,"P",{});var ze=a(C);Q=c(ze,`An alternative would be to just clone a repo but this would require that the
user always has git and git-lfs installed, and properly configured.`),ze.forEach(o),X=_(re),ee(V.$$.fragment,re),re.forEach(o),H=_(r),U=t(r,"DIV",{class:!0});var ce=a(U);ee(B.$$.fragment,ce),G=_(ce),M=t(ce,"P",{});var Ge=a(M);Y=c(Ge,`Download from a given URL and cache it if it\u2019s not already present in the
local cache.`),Ge.forEach(o),Ne=_(ce),pe=t(ce,"P",{});var Me=a(pe);De=c(Me,`Given a URL, this function looks for the corresponding file in the local
cache. If it\u2019s not there, download it. Then return the path to the cached
file.`),Me.forEach(o),Oe=_(ce),ee(se.$$.fragment,ce),ce.forEach(o),$e=_(r),R=t(r,"DIV",{class:!0});var J=a(R);ee(he.$$.fragment,J),Le=_(J),me=t(J,"P",{});var Je=a(me);Ie=c(Je,"Construct the URL of a file from the given information."),Je.forEach(o),Pe=_(J),_e=t(J,"P",{});var Ke=a(_e);qe=c(Ke,`The resolved address can either be a huggingface.co-hosted url, or a link to
Cloudfront (a Content Delivery Network, or CDN) for large files which are
more than a few MBs.`),Ke.forEach(o),Ce=_(J),ee(le.$$.fragment,J),Ue=_(J),ee(de.$$.fragment,J),Ae=_(J),be=t(J,"P",{});var Qe=a(be);Se=c(Qe,"References:"),Qe.forEach(o),je=_(J),ve=t(J,"UL",{});var Xe=a(ve);ue=t(Xe,"LI",{});var Ve=a(ue);Fe=c(Ve,"[1] "),fe=t(Ve,"A",{href:!0,rel:!0});var Ye=a(fe);Re=c(Ye,"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),Ye.forEach(o),Ve.forEach(o),Xe.forEach(o),J.forEach(o),this.h()},h(){$(h,"name","hf:doc:metadata"),$(h,"content",JSON.stringify(po)),$(i,"id","huggingface_hub.hf_hub_download"),$(i,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),$(i,"href","#huggingface_hub.hf_hub_download"),$(p,"class","relative group"),$(T,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),$(v,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),$(U,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),$(fe,"href","https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),$(fe,"rel","nofollow"),$(R,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(r,I){e(document.head,h),x(r,D,I),x(r,p,I),e(p,i),e(i,f),oe(s,f,null),e(p,u),e(p,A),e(A,S),x(r,w,I),x(r,T,I),oe(N,T,null),e(T,j),e(T,E),e(E,l),e(T,b),oe(P,T,null),x(r,F,I),x(r,v,I),oe(y,v,null),e(v,k),e(v,q),e(q,W),e(v,z),e(v,g),e(g,O),e(v,L),e(v,C),e(C,Q),e(v,X),oe(V,v,null),x(r,H,I),x(r,U,I),oe(B,U,null),e(U,G),e(U,M),e(M,Y),e(U,Ne),e(U,pe),e(pe,De),e(U,Oe),oe(se,U,null),x(r,$e,I),x(r,R,I),oe(he,R,null),e(R,Le),e(R,me),e(me,Ie),e(R,Pe),e(R,_e),e(_e,qe),e(R,Ce),oe(le,R,null),e(R,Ue),oe(de,R,null),e(R,Ae),e(R,be),e(be,Se),e(R,je),e(R,ve),e(ve,ue),e(ue,Fe),e(ue,fe),e(fe,Re),xe=!0},p(r,[I]){const ge={};I&2&&(ge.$$scope={dirty:I,ctx:r}),P.$set(ge);const we={};I&2&&(we.$$scope={dirty:I,ctx:r}),V.$set(we);const ye={};I&2&&(ye.$$scope={dirty:I,ctx:r}),se.$set(ye);const Ee={};I&2&&(Ee.$$scope={dirty:I,ctx:r}),le.$set(Ee);const ie={};I&2&&(ie.$$scope={dirty:I,ctx:r}),de.$set(ie)},i(r){xe||(ne(s.$$.fragment,r),ne(N.$$.fragment,r),ne(P.$$.fragment,r),ne(y.$$.fragment,r),ne(V.$$.fragment,r),ne(B.$$.fragment,r),ne(se.$$.fragment,r),ne(he.$$.fragment,r),ne(le.$$.fragment,r),ne(de.$$.fragment,r),xe=!0)},o(r){te(s.$$.fragment,r),te(N.$$.fragment,r),te(P.$$.fragment,r),te(y.$$.fragment,r),te(V.$$.fragment,r),te(B.$$.fragment,r),te(se.$$.fragment,r),te(he.$$.fragment,r),te(le.$$.fragment,r),te(de.$$.fragment,r),xe=!1},d(r){o(h),r&&o(D),r&&o(p),ae(s),r&&o(w),r&&o(T),ae(N),ae(P),r&&o(F),r&&o(v),ae(y),ae(V),r&&o(H),r&&o(U),ae(B),ae(se),r&&o($e),r&&o(R),ae(he),ae(le),ae(de)}}}const po={local:"huggingface_hub.hf_hub_download",title:"Downloading files"};function mo(K){return to(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class $o extends Ze{constructor(h){super();eo(this,h,mo,uo,oo,{})}}export{$o as default,po as metadata};
