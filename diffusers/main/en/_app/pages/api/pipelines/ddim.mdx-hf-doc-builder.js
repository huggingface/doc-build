import{S as Jt,i as Rt,s as jt,e as a,k as d,w as Y,t as l,M as Vt,c as o,d as i,m as c,a as r,x as K,h as p,b as n,G as t,g as f,y as Q,L as Yt,q as X,o as Z,B as ee,v as Kt}from"../../../chunks/vendor-hf-doc-builder.js";import{D as Ft}from"../../../chunks/Docstring-hf-doc-builder.js";import{I as Ne}from"../../../chunks/IconCopyLink-hf-doc-builder.js";function Qt(ut){let m,ge,g,y,te,E,qe,ie,Oe,ve,v,M,ae,T,Ce,oe,He,_e,k,x,Le,Ge,De,G,Ue,be,U,We,we,u,ze,A,Be,Fe,S,Je,Re,ye,_,P,re,N,je,ne,Ve,Me,I,se,D,le,Ye,Ke,pe,Qe,Xe,W,Ze,et,de,b,ce,q,tt,it,fe,he,at,ot,z,rt,Pe,w,$,ue,O,nt,me,st,Ie,h,C,lt,H,pt,B,dt,ct,ft,F,L,$e;return E=new Ne({}),T=new Ne({}),N=new Ne({}),O=new Ne({}),C=new Ft({props:{name:"class diffusers.DDIMPipeline",anchor:"diffusers.DDIMPipeline",parameters:[{name:"unet",val:""},{name:"scheduler",val:""}],parametersDescription:[{anchor:"diffusers.DDIMPipeline.unet",description:'<strong>unet</strong> (<a href="/docs/diffusers/main/en/api/models#diffusers.UNet2DModel">UNet2DModel</a>) &#x2014; U-Net architecture to denoise the encoded image.',name:"unet"},{anchor:"diffusers.DDIMPipeline.scheduler",description:`<strong>scheduler</strong> (<a href="/docs/diffusers/main/en/api/schedulers#diffusers.SchedulerMixin">SchedulerMixin</a>) &#x2014;
A scheduler to be used in combination with <code>unet</code> to denoise the encoded image. Can be one of
<a href="/docs/diffusers/main/en/api/schedulers#diffusers.DDPMScheduler">DDPMScheduler</a>, or <a href="/docs/diffusers/main/en/api/schedulers#diffusers.DDIMScheduler">DDIMScheduler</a>.`,name:"scheduler"}],source:"https://github.com/huggingface/diffusers/blob/main/src/diffusers/pipelines/ddim/pipeline_ddim.py#L23"}}),L=new Ft({props:{name:"__call__",anchor:"diffusers.DDIMPipeline.__call__",parameters:[{name:"batch_size",val:": int = 1"},{name:"generator",val:": typing.Optional[torch._C.Generator] = None"},{name:"eta",val:": float = 0.0"},{name:"num_inference_steps",val:": int = 50"},{name:"use_clipped_model_output",val:": typing.Optional[bool] = None"},{name:"output_type",val:": typing.Optional[str] = 'pil'"},{name:"return_dict",val:": bool = True"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"diffusers.DDIMPipeline.__call__.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
The number of images to generate.`,name:"batch_size"},{anchor:"diffusers.DDIMPipeline.__call__.generator",description:`<strong>generator</strong> (<code>torch.Generator</code>, <em>optional</em>) &#x2014;
A <a href="https://pytorch.org/docs/stable/generated/torch.Generator.html" rel="nofollow">torch generator</a> to make generation
deterministic.`,name:"generator"},{anchor:"diffusers.DDIMPipeline.__call__.eta",description:`<strong>eta</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
The eta parameter which controls the scale of the variance (0 is DDIM and 1 is one type of DDPM).`,name:"eta"},{anchor:"diffusers.DDIMPipeline.__call__.num_inference_steps",description:`<strong>num_inference_steps</strong> (<code>int</code>, <em>optional</em>, defaults to 50) &#x2014;
The number of denoising steps. More denoising steps usually lead to a higher quality image at the
expense of slower inference.`,name:"num_inference_steps"},{anchor:"diffusers.DDIMPipeline.__call__.use_clipped_model_output",description:`<strong>use_clipped_model_output</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
if <code>True</code> or <code>False</code>, see documentation for <code>DDIMScheduler.step</code>. If <code>None</code>, nothing is passed
downstream to the scheduler. So use <code>None</code> for schedulers which don&#x2019;t support this argument.`,name:"use_clipped_model_output"},{anchor:"diffusers.DDIMPipeline.__call__.output_type",description:`<strong>output_type</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;pil&quot;</code>) &#x2014;
The output format of the generate image. Choose between
<a href="https://pillow.readthedocs.io/en/stable/" rel="nofollow">PIL</a>: <code>PIL.Image.Image</code> or <code>np.array</code>.`,name:"output_type"},{anchor:"diffusers.DDIMPipeline.__call__.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to return a <a href="/docs/diffusers/main/en/api/diffusion_pipeline#diffusers.pipeline_utils.ImagePipelineOutput">ImagePipelineOutput</a> instead of a plain tuple.`,name:"return_dict"}],source:"https://github.com/huggingface/diffusers/blob/main/src/diffusers/pipelines/ddim/pipeline_ddim.py#L39",returnDescription:`
<p><code>~pipelines.utils.ImagePipelineOutput</code> if
<code>return_dict</code> is True, otherwise a \`tuple. When returning a tuple, the first element is a list with the
generated images.</p>
`,returnType:`
<p><a
  href="/docs/diffusers/main/en/api/diffusion_pipeline#diffusers.pipeline_utils.ImagePipelineOutput"
>ImagePipelineOutput</a> or <code>tuple</code></p>
`}}),{c(){m=a("meta"),ge=d(),g=a("h1"),y=a("a"),te=a("span"),Y(E.$$.fragment),qe=d(),ie=a("span"),Oe=l("DDIM"),ve=d(),v=a("h2"),M=a("a"),ae=a("span"),Y(T.$$.fragment),Ce=d(),oe=a("span"),He=l("Overview"),_e=d(),k=a("p"),x=a("a"),Le=l("Denoising Diffusion Implicit Models"),Ge=l(" (DDIM) by Jiaming Song, Chenlin Meng and Stefano Ermon."),De=d(),G=a("p"),Ue=l("The abstract of the paper is the following:"),be=d(),U=a("p"),We=l("Denoising diffusion probabilistic models (DDPMs) have achieved high quality image generation without adversarial training, yet they require simulating a Markov chain for many steps to produce a sample. To accelerate sampling, we present denoising diffusion implicit models (DDIMs), a more efficient class of iterative implicit probabilistic models with the same training procedure as DDPMs. In DDPMs, the generative process is defined as the reverse of a Markovian diffusion process. We construct a class of non-Markovian diffusion processes that lead to the same training objective, but whose reverse process can be much faster to sample from. We empirically demonstrate that DDIMs can produce high quality samples 10\xD7 to 50\xD7 faster in terms of wall-clock time compared to DDPMs, allow us to trade off computation for sample quality, and can perform semantically meaningful image interpolation directly in the latent space."),we=d(),u=a("p"),ze=l("The original codebase of this paper can be found here: "),A=a("a"),Be=l("ermongroup/ddim"),Fe=l(`.
For questions, feel free to contact the author on `),S=a("a"),Je=l("tsong.me"),Re=l("."),ye=d(),_=a("h2"),P=a("a"),re=a("span"),Y(N.$$.fragment),je=d(),ne=a("span"),Ve=l("Available Pipelines:"),Me=d(),I=a("table"),se=a("thead"),D=a("tr"),le=a("th"),Ye=l("Pipeline"),Ke=d(),pe=a("th"),Qe=l("Tasks"),Xe=d(),W=a("th"),Ze=l("Colab"),et=d(),de=a("tbody"),b=a("tr"),ce=a("td"),q=a("a"),tt=l("pipeline_ddim.py"),it=d(),fe=a("td"),he=a("em"),at=l("Unconditional Image Generation"),ot=d(),z=a("td"),rt=l("-"),Pe=d(),w=a("h2"),$=a("a"),ue=a("span"),Y(O.$$.fragment),nt=d(),me=a("span"),st=l("DDIMPipeline"),Ie=d(),h=a("div"),Y(C.$$.fragment),lt=d(),H=a("p"),pt=l("This model inherits from "),B=a("a"),dt=l("DiffusionPipeline"),ct=l(`. Check the superclass documentation for the generic methods the
library implements for all the pipelines (such as downloading or saving, running on a particular device, etc.)`),ft=d(),F=a("div"),Y(L.$$.fragment),this.h()},l(e){const s=Vt('[data-svelte="svelte-1phssyn"]',document.head);m=o(s,"META",{name:!0,content:!0}),s.forEach(i),ge=c(e),g=o(e,"H1",{class:!0});var Ee=r(g);y=o(Ee,"A",{id:!0,class:!0,href:!0});var mt=r(y);te=o(mt,"SPAN",{});var gt=r(te);K(E.$$.fragment,gt),gt.forEach(i),mt.forEach(i),qe=c(Ee),ie=o(Ee,"SPAN",{});var vt=r(ie);Oe=p(vt,"DDIM"),vt.forEach(i),Ee.forEach(i),ve=c(e),v=o(e,"H2",{class:!0});var Te=r(v);M=o(Te,"A",{id:!0,class:!0,href:!0});var _t=r(M);ae=o(_t,"SPAN",{});var Dt=r(ae);K(T.$$.fragment,Dt),Dt.forEach(i),_t.forEach(i),Ce=c(Te),oe=o(Te,"SPAN",{});var bt=r(oe);He=p(bt,"Overview"),bt.forEach(i),Te.forEach(i),_e=c(e),k=o(e,"P",{});var ht=r(k);x=o(ht,"A",{href:!0,rel:!0});var wt=r(x);Le=p(wt,"Denoising Diffusion Implicit Models"),wt.forEach(i),Ge=p(ht," (DDIM) by Jiaming Song, Chenlin Meng and Stefano Ermon."),ht.forEach(i),De=c(e),G=o(e,"P",{});var yt=r(G);Ue=p(yt,"The abstract of the paper is the following:"),yt.forEach(i),be=c(e),U=o(e,"P",{});var Mt=r(U);We=p(Mt,"Denoising diffusion probabilistic models (DDPMs) have achieved high quality image generation without adversarial training, yet they require simulating a Markov chain for many steps to produce a sample. To accelerate sampling, we present denoising diffusion implicit models (DDIMs), a more efficient class of iterative implicit probabilistic models with the same training procedure as DDPMs. In DDPMs, the generative process is defined as the reverse of a Markovian diffusion process. We construct a class of non-Markovian diffusion processes that lead to the same training objective, but whose reverse process can be much faster to sample from. We empirically demonstrate that DDIMs can produce high quality samples 10\xD7 to 50\xD7 faster in terms of wall-clock time compared to DDPMs, allow us to trade off computation for sample quality, and can perform semantically meaningful image interpolation directly in the latent space."),Mt.forEach(i),we=c(e),u=o(e,"P",{});var J=r(u);ze=p(J,"The original codebase of this paper can be found here: "),A=o(J,"A",{href:!0,rel:!0});var Pt=r(A);Be=p(Pt,"ermongroup/ddim"),Pt.forEach(i),Fe=p(J,`.
For questions, feel free to contact the author on `),S=o(J,"A",{href:!0,rel:!0});var It=r(S);Je=p(It,"tsong.me"),It.forEach(i),Re=p(J,"."),J.forEach(i),ye=c(e),_=o(e,"H2",{class:!0});var ke=r(_);P=o(ke,"A",{id:!0,class:!0,href:!0});var $t=r(P);re=o($t,"SPAN",{});var Et=r(re);K(N.$$.fragment,Et),Et.forEach(i),$t.forEach(i),je=c(ke),ne=o(ke,"SPAN",{});var Tt=r(ne);Ve=p(Tt,"Available Pipelines:"),Tt.forEach(i),ke.forEach(i),Me=c(e),I=o(e,"TABLE",{});var xe=r(I);se=o(xe,"THEAD",{});var kt=r(se);D=o(kt,"TR",{});var R=r(D);le=o(R,"TH",{});var xt=r(le);Ye=p(xt,"Pipeline"),xt.forEach(i),Ke=c(R),pe=o(R,"TH",{});var At=r(pe);Qe=p(At,"Tasks"),At.forEach(i),Xe=c(R),W=o(R,"TH",{align:!0});var St=r(W);Ze=p(St,"Colab"),St.forEach(i),R.forEach(i),kt.forEach(i),et=c(xe),de=o(xe,"TBODY",{});var Nt=r(de);b=o(Nt,"TR",{});var j=r(b);ce=o(j,"TD",{});var qt=r(ce);q=o(qt,"A",{href:!0,rel:!0});var Ot=r(q);tt=p(Ot,"pipeline_ddim.py"),Ot.forEach(i),qt.forEach(i),it=c(j),fe=o(j,"TD",{});var Ct=r(fe);he=o(Ct,"EM",{});var Ht=r(he);at=p(Ht,"Unconditional Image Generation"),Ht.forEach(i),Ct.forEach(i),ot=c(j),z=o(j,"TD",{align:!0});var Lt=r(z);rt=p(Lt,"-"),Lt.forEach(i),j.forEach(i),Nt.forEach(i),xe.forEach(i),Pe=c(e),w=o(e,"H2",{class:!0});var Ae=r(w);$=o(Ae,"A",{id:!0,class:!0,href:!0});var Gt=r($);ue=o(Gt,"SPAN",{});var Ut=r(ue);K(O.$$.fragment,Ut),Ut.forEach(i),Gt.forEach(i),nt=c(Ae),me=o(Ae,"SPAN",{});var Wt=r(me);st=p(Wt,"DDIMPipeline"),Wt.forEach(i),Ae.forEach(i),Ie=c(e),h=o(e,"DIV",{class:!0});var V=r(h);K(C.$$.fragment,V),lt=c(V),H=o(V,"P",{});var Se=r(H);pt=p(Se,"This model inherits from "),B=o(Se,"A",{href:!0});var zt=r(B);dt=p(zt,"DiffusionPipeline"),zt.forEach(i),ct=p(Se,`. Check the superclass documentation for the generic methods the
library implements for all the pipelines (such as downloading or saving, running on a particular device, etc.)`),Se.forEach(i),ft=c(V),F=o(V,"DIV",{class:!0});var Bt=r(F);K(L.$$.fragment,Bt),Bt.forEach(i),V.forEach(i),this.h()},h(){n(m,"name","hf:doc:metadata"),n(m,"content",JSON.stringify(Xt)),n(y,"id","ddim"),n(y,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),n(y,"href","#ddim"),n(g,"class","relative group"),n(M,"id","overview"),n(M,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),n(M,"href","#overview"),n(v,"class","relative group"),n(x,"href","https://arxiv.org/abs/2010.02502"),n(x,"rel","nofollow"),n(A,"href","https://github.com/ermongroup/ddim"),n(A,"rel","nofollow"),n(S,"href","https://tsong.me/"),n(S,"rel","nofollow"),n(P,"id","available-pipelines"),n(P,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),n(P,"href","#available-pipelines"),n(_,"class","relative group"),n(W,"align","center"),n(q,"href","https://github.com/huggingface/diffusers/blob/main/src/diffusers/pipelines/ddim/pipeline_ddim.py"),n(q,"rel","nofollow"),n(z,"align","center"),n($,"id","diffusers.DDIMPipeline"),n($,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),n($,"href","#diffusers.DDIMPipeline"),n(w,"class","relative group"),n(B,"href","/docs/diffusers/main/en/using-diffusers/loading#diffusers.DiffusionPipeline"),n(F,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),n(h,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(e,s){t(document.head,m),f(e,ge,s),f(e,g,s),t(g,y),t(y,te),Q(E,te,null),t(g,qe),t(g,ie),t(ie,Oe),f(e,ve,s),f(e,v,s),t(v,M),t(M,ae),Q(T,ae,null),t(v,Ce),t(v,oe),t(oe,He),f(e,_e,s),f(e,k,s),t(k,x),t(x,Le),t(k,Ge),f(e,De,s),f(e,G,s),t(G,Ue),f(e,be,s),f(e,U,s),t(U,We),f(e,we,s),f(e,u,s),t(u,ze),t(u,A),t(A,Be),t(u,Fe),t(u,S),t(S,Je),t(u,Re),f(e,ye,s),f(e,_,s),t(_,P),t(P,re),Q(N,re,null),t(_,je),t(_,ne),t(ne,Ve),f(e,Me,s),f(e,I,s),t(I,se),t(se,D),t(D,le),t(le,Ye),t(D,Ke),t(D,pe),t(pe,Qe),t(D,Xe),t(D,W),t(W,Ze),t(I,et),t(I,de),t(de,b),t(b,ce),t(ce,q),t(q,tt),t(b,it),t(b,fe),t(fe,he),t(he,at),t(b,ot),t(b,z),t(z,rt),f(e,Pe,s),f(e,w,s),t(w,$),t($,ue),Q(O,ue,null),t(w,nt),t(w,me),t(me,st),f(e,Ie,s),f(e,h,s),Q(C,h,null),t(h,lt),t(h,H),t(H,pt),t(H,B),t(B,dt),t(H,ct),t(h,ft),t(h,F),Q(L,F,null),$e=!0},p:Yt,i(e){$e||(X(E.$$.fragment,e),X(T.$$.fragment,e),X(N.$$.fragment,e),X(O.$$.fragment,e),X(C.$$.fragment,e),X(L.$$.fragment,e),$e=!0)},o(e){Z(E.$$.fragment,e),Z(T.$$.fragment,e),Z(N.$$.fragment,e),Z(O.$$.fragment,e),Z(C.$$.fragment,e),Z(L.$$.fragment,e),$e=!1},d(e){i(m),e&&i(ge),e&&i(g),ee(E),e&&i(ve),e&&i(v),ee(T),e&&i(_e),e&&i(k),e&&i(De),e&&i(G),e&&i(be),e&&i(U),e&&i(we),e&&i(u),e&&i(ye),e&&i(_),ee(N),e&&i(Me),e&&i(I),e&&i(Pe),e&&i(w),ee(O),e&&i(Ie),e&&i(h),ee(C),ee(L)}}}const Xt={local:"ddim",sections:[{local:"overview",title:"Overview"},{local:"available-pipelines",title:"Available Pipelines:"},{local:"diffusers.DDIMPipeline",title:"DDIMPipeline"}],title:"DDIM"};function Zt(ut){return Kt(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class ai extends Jt{constructor(m){super();Rt(this,m,Zt,Qt,jt,{})}}export{ai as default,Xt as metadata};
