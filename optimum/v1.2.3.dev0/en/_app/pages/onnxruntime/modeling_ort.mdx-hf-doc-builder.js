import{S as vl,i as xl,s as Tl,F as Ml,e as a,w as M,k as f,c as i,a as l,x as O,d as o,m as h,b as v,g as k,G as e,y,P as Ol,H as yl,I as jl,J as El,q as T,o as b,B as j,v as bl,Z as ql,_ as Rl,t as m,M as Fl,h as p,L as Y}from"../../chunks/vendor-hf-doc-builder.js";import{T as so}from"../../chunks/Tip-hf-doc-builder.js";import{D as L}from"../../chunks/Docstring-hf-doc-builder.js";import{C}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as ee}from"../../chunks/IconCopyLink-hf-doc-builder.js";const{window:zl}=ql;function Cl(E){let s,_,d,u,g,n,r,x,c;u=new ee({props:{classNames:"text-smd"}});const w=E[4].default,q=Ml(w,E,E[3],null);return{c(){s=a("div"),_=a("a"),d=a("span"),M(u.$$.fragment),n=f(),q&&q.c(),this.h()},l(R){s=i(R,"DIV",{class:!0});var F=l(s);_=i(F,"A",{id:!0,class:!0,href:!0});var Vt=l(_);d=i(Vt,"SPAN",{});var Jt=l(d);O(u.$$.fragment,Jt),Jt.forEach(o),Vt.forEach(o),n=h(F),q&&q.l(F),F.forEach(o),this.h()},h(){v(_,"id",E[0]),v(_,"class","header-link block pr-0.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(_,"href",g=`#${E[0]}`),v(s,"class","relative group rounded-md")},m(R,F){k(R,s,F),e(s,_),e(_,d),y(u,d,null),e(s,n),q&&q.m(s,null),E[5](s),r=!0,x||(c=Ol(zl,"hashchange",E[2]),x=!0)},p(R,[F]){(!r||F&1)&&v(_,"id",R[0]),(!r||F&1&&g!==(g=`#${R[0]}`))&&v(_,"href",g),q&&q.p&&(!r||F&8)&&yl(q,w,R,R[3],r?El(w,R[3],F,null):jl(R[3]),null)},i(R){r||(T(u.$$.fragment,R),T(q,R),r=!0)},o(R){b(u.$$.fragment,R),b(q,R),r=!1},d(R){R&&o(s),j(u),q&&q.d(R),E[5](null),x=!1,c()}}}const wl="bg-yellow-50 dark:bg-[#494a3d]";function Al(E,s,_){let{$$slots:d={},$$scope:u}=s,{anchor:g}=s,n;function r(){const{hash:c}=window.location,w=c.substring(1);n&&n.classList.remove(...wl.split(" ")),w===g&&n.classList.add(...wl.split(" "))}bl(()=>{r()});function x(c){Rl[c?"unshift":"push"](()=>{n=c,_(1,n)})}return E.$$set=c=>{"anchor"in c&&_(0,g=c.anchor),"$$scope"in c&&_(3,u=c.$$scope)},[g,n,r,u,d,x]}class U extends vl{constructor(s){super();xl(this,s,Al,Cl,Tl,{anchor:0})}}function Pl(E){let s,_,d,u,g;return{c(){s=a("p"),_=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),d=a("code"),u=m("Module"),g=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Although the recipe for forward pass needs to be defined within this function, one should call the "),d=i(r,"CODE",{});var x=l(d);u=p(x,"Module"),x.forEach(o),g=p(r,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),r.forEach(o)},m(n,r){k(n,s,r),e(s,_),e(s,d),e(d,u),e(s,g)},d(n){n&&o(s)}}}function Il(E){let s,_,d,u,g;return u=new C({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForFeatureExtraction
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/all-MiniLM-L6-v2")
model = ORTModelForFeatureExtraction.from_pretrained("optimum/all-MiniLM-L6-v2")

inputs = tokenizer("My name is Philipp and I live in Germany.", return_tensors="pt")

outputs = model(**inputs)
logits = outputs.logits
list(logits.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForFeatureExtraction
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForFeatureExtraction.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(logits.shape)`}}),{c(){s=a("p"),_=m("Example of feature extraction:"),d=f(),M(u.$$.fragment)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Example of feature extraction:"),r.forEach(o),d=h(n),O(u.$$.fragment,n)},m(n,r){k(n,s,r),e(s,_),k(n,d,r),y(u,n,r),g=!0},p:Y,i(n){g||(T(u.$$.fragment,n),g=!0)},o(n){b(u.$$.fragment,n),g=!1},d(n){n&&o(s),n&&o(d),j(u,n)}}}function Nl(E){let s,_,d,u,g,n,r,x;return r=new C({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForFeatureExtraction

tokenizer = AutoTokenizer.from_pretrained("optimum/all-MiniLM-L6-v2")
model = ORTModelForFeatureExtraction.from_pretrained("optimum/all-MiniLM-L6-v2")
onnx_extractor = pipeline("feature-extraction", model=model, tokenizer=tokenizer)

text = "My name is Philipp and I live in Germany."
pred = onnx_extractor(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForFeatureExtraction

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForFeatureExtraction.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_extractor = pipeline(<span class="hljs-string">&quot;feature-extraction&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_extractor(text)`}}),{c(){s=a("p"),_=m("Example using "),d=a("code"),u=m("transformers.pipeline"),g=m(":"),n=f(),M(r.$$.fragment)},l(c){s=i(c,"P",{});var w=l(s);_=p(w,"Example using "),d=i(w,"CODE",{});var q=l(d);u=p(q,"transformers.pipeline"),q.forEach(o),g=p(w,":"),w.forEach(o),n=h(c),O(r.$$.fragment,c)},m(c,w){k(c,s,w),e(s,_),e(s,d),e(d,u),e(s,g),k(c,n,w),y(r,c,w),x=!0},p:Y,i(c){x||(T(r.$$.fragment,c),x=!0)},o(c){b(r.$$.fragment,c),x=!1},d(c){c&&o(s),c&&o(n),j(r,c)}}}function Sl(E){let s,_,d,u,g;return{c(){s=a("p"),_=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),d=a("code"),u=m("Module"),g=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Although the recipe for forward pass needs to be defined within this function, one should call the "),d=i(r,"CODE",{});var x=l(d);u=p(x,"Module"),x.forEach(o),g=p(r,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),r.forEach(o)},m(n,r){k(n,s,r),e(s,_),e(s,d),e(d,u),e(s,g)},d(n){n&&o(s)}}}function Dl(E){let s,_,d,u,g;return u=new C({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForQuestionAnswering
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/roberta-base-squad2")
model = ORTModelForQuestionAnswering.from_pretrained("optimum/roberta-base-squad2")

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"
inputs = tokenizer(question, text, return_tensors="pt")
start_positions = torch.tensor([1])
end_positions = torch.tensor([3])

outputs = model(**inputs, start_positions=start_positions, end_positions=end_positions)
start_scores = outputs.start_logits
end_scores = outputs.end_logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForQuestionAnswering
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(question, text, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>start_positions = torch.tensor([<span class="hljs-number">1</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>end_positions = torch.tensor([<span class="hljs-number">3</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, start_positions=start_positions, end_positions=end_positions)
<span class="hljs-meta">&gt;&gt;&gt; </span>start_scores = outputs.start_logits
<span class="hljs-meta">&gt;&gt;&gt; </span>end_scores = outputs.end_logits`}}),{c(){s=a("p"),_=m("Example of question answering:"),d=f(),M(u.$$.fragment)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Example of question answering:"),r.forEach(o),d=h(n),O(u.$$.fragment,n)},m(n,r){k(n,s,r),e(s,_),k(n,d,r),y(u,n,r),g=!0},p:Y,i(n){g||(T(u.$$.fragment,n),g=!0)},o(n){b(u.$$.fragment,n),g=!1},d(n){n&&o(s),n&&o(d),j(u,n)}}}function Ll(E){let s,_,d,u,g,n,r,x;return r=new C({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForQuestionAnswering

tokenizer = AutoTokenizer.from_pretrained("optimum/roberta-base-squad2")
model = ORTModelForQuestionAnswering.from_pretrained("optimum/roberta-base-squad2")
onnx_qa = pipeline("question-answering", model=model, tokenizer=tokenizer)

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"
pred = onnx_qa(question, text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForQuestionAnswering

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_qa = pipeline(<span class="hljs-string">&quot;question-answering&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_qa(question, text)`}}),{c(){s=a("p"),_=m("Example using "),d=a("code"),u=m("transformers.pipeline"),g=m(":"),n=f(),M(r.$$.fragment)},l(c){s=i(c,"P",{});var w=l(s);_=p(w,"Example using "),d=i(w,"CODE",{});var q=l(d);u=p(q,"transformers.pipeline"),q.forEach(o),g=p(w,":"),w.forEach(o),n=h(c),O(r.$$.fragment,c)},m(c,w){k(c,s,w),e(s,_),e(s,d),e(d,u),e(s,g),k(c,n,w),y(r,c,w),x=!0},p:Y,i(c){x||(T(r.$$.fragment,c),x=!0)},o(c){b(r.$$.fragment,c),x=!1},d(c){c&&o(s),c&&o(n),j(r,c)}}}function Hl(E){let s,_,d,u,g;return{c(){s=a("p"),_=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),d=a("code"),u=m("Module"),g=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Although the recipe for forward pass needs to be defined within this function, one should call the "),d=i(r,"CODE",{});var x=l(d);u=p(x,"Module"),x.forEach(o),g=p(r,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),r.forEach(o)},m(n,r){k(n,s,r),e(s,_),e(s,d),e(d,u),e(s,g)},d(n){n&&o(s)}}}function Ql(E){let s,_,d,u,g;return u=new C({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForSequenceClassification
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")
model = ORTModelForSequenceClassification.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")

outputs = model(**inputs)
logits = outputs.logits
list(logits.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSequenceClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(logits.shape)`}}),{c(){s=a("p"),_=m("Example of single-label classification:"),d=f(),M(u.$$.fragment)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Example of single-label classification:"),r.forEach(o),d=h(n),O(u.$$.fragment,n)},m(n,r){k(n,s,r),e(s,_),k(n,d,r),y(u,n,r),g=!0},p:Y,i(n){g||(T(u.$$.fragment,n),g=!0)},o(n){b(u.$$.fragment,n),g=!1},d(n){n&&o(s),n&&o(d),j(u,n)}}}function Xl(E){let s,_,d,u,g,n,r,x;return r=new C({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForSequenceClassification

tokenizer = AutoTokenizer.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")
model = ORTModelForSequenceClassification.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")
onnx_classifier = pipeline("text-classification", model=model, tokenizer=tokenizer)

text = "Hello, my dog is cute"
pred = onnx_classifier(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_classifier = pipeline(<span class="hljs-string">&quot;text-classification&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_classifier(text)`}}),{c(){s=a("p"),_=m("Example using "),d=a("code"),u=m("transformers.pipelines"),g=m(":"),n=f(),M(r.$$.fragment)},l(c){s=i(c,"P",{});var w=l(s);_=p(w,"Example using "),d=i(w,"CODE",{});var q=l(d);u=p(q,"transformers.pipelines"),q.forEach(o),g=p(w,":"),w.forEach(o),n=h(c),O(r.$$.fragment,c)},m(c,w){k(c,s,w),e(s,_),e(s,d),e(d,u),e(s,g),k(c,n,w),y(r,c,w),x=!0},p:Y,i(c){x||(T(r.$$.fragment,c),x=!0)},o(c){b(r.$$.fragment,c),x=!1},d(c){c&&o(s),c&&o(n),j(r,c)}}}function Wl(E){let s,_,d,u,g,n,r,x;return r=new C({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForSequenceClassification

tokenizer = AutoTokenizer.from_pretrained("optimum/distilbert-base-uncased-mnli")
model = ORTModelForSequenceClassification.from_pretrained("optimum/distilbert-base-uncased-mnli")
onnx_z0 = pipeline("zero-shot-classification", model=model, tokenizer=tokenizer)

sequence_to_classify = "Who are you voting for in 2020?"
candidate_labels = ["Europe", "public health", "politics", "elections"]
pred = onnx_z0(sequence_to_classify, candidate_labels, multi_class=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-mnli&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-mnli&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_z0 = pipeline(<span class="hljs-string">&quot;zero-shot-classification&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>sequence_to_classify = <span class="hljs-string">&quot;Who are you voting for in 2020?&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>candidate_labels = [<span class="hljs-string">&quot;Europe&quot;</span>, <span class="hljs-string">&quot;public health&quot;</span>, <span class="hljs-string">&quot;politics&quot;</span>, <span class="hljs-string">&quot;elections&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_z0(sequence_to_classify, candidate_labels, multi_class=<span class="hljs-literal">True</span>)`}}),{c(){s=a("p"),_=m("Example using zero-shot-classification "),d=a("code"),u=m("transformers.pipelines"),g=m(":"),n=f(),M(r.$$.fragment)},l(c){s=i(c,"P",{});var w=l(s);_=p(w,"Example using zero-shot-classification "),d=i(w,"CODE",{});var q=l(d);u=p(q,"transformers.pipelines"),q.forEach(o),g=p(w,":"),w.forEach(o),n=h(c),O(r.$$.fragment,c)},m(c,w){k(c,s,w),e(s,_),e(s,d),e(d,u),e(s,g),k(c,n,w),y(r,c,w),x=!0},p:Y,i(c){x||(T(r.$$.fragment,c),x=!0)},o(c){b(r.$$.fragment,c),x=!1},d(c){c&&o(s),c&&o(n),j(r,c)}}}function Bl(E){let s,_,d,u,g;return{c(){s=a("p"),_=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),d=a("code"),u=m("Module"),g=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Although the recipe for forward pass needs to be defined within this function, one should call the "),d=i(r,"CODE",{});var x=l(d);u=p(x,"Module"),x.forEach(o),g=p(r,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),r.forEach(o)},m(n,r){k(n,s,r),e(s,_),e(s,d),e(d,u),e(s,g)},d(n){n&&o(s)}}}function Gl(E){let s,_,d,u,g;return u=new C({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForTokenClassification
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/bert-base-NER")
model = ORTModelForTokenClassification.from_pretrained("optimum/bert-base-NER")

inputs = tokenizer("My name is Philipp and I live in Germany.", return_tensors="pt")

outputs = model(**inputs)
logits = outputs.logits
list(logits.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForTokenClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(logits.shape)`}}),{c(){s=a("p"),_=m("Example of token classification:"),d=f(),M(u.$$.fragment)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Example of token classification:"),r.forEach(o),d=h(n),O(u.$$.fragment,n)},m(n,r){k(n,s,r),e(s,_),k(n,d,r),y(u,n,r),g=!0},p:Y,i(n){g||(T(u.$$.fragment,n),g=!0)},o(n){b(u.$$.fragment,n),g=!1},d(n){n&&o(s),n&&o(d),j(u,n)}}}function Vl(E){let s,_,d,u,g,n,r,x;return r=new C({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForTokenClassification

tokenizer = AutoTokenizer.from_pretrained("optimum/bert-base-NER")
model = ORTModelForTokenClassification.from_pretrained("optimum/bert-base-NER")
onnx_ner = pipeline("token-classification", model=model, tokenizer=tokenizer)

text = "My name is Philipp and I live in Germany."
pred = onnx_ner(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForTokenClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_ner = pipeline(<span class="hljs-string">&quot;token-classification&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_ner(text)`}}),{c(){s=a("p"),_=m("Example using "),d=a("code"),u=m("transformers.pipelines"),g=m(":"),n=f(),M(r.$$.fragment)},l(c){s=i(c,"P",{});var w=l(s);_=p(w,"Example using "),d=i(w,"CODE",{});var q=l(d);u=p(q,"transformers.pipelines"),q.forEach(o),g=p(w,":"),w.forEach(o),n=h(c),O(r.$$.fragment,c)},m(c,w){k(c,s,w),e(s,_),e(s,d),e(d,u),e(s,g),k(c,n,w),y(r,c,w),x=!0},p:Y,i(c){x||(T(r.$$.fragment,c),x=!0)},o(c){b(r.$$.fragment,c),x=!1},d(c){c&&o(s),c&&o(n),j(r,c)}}}function Jl(E){let s,_,d,u,g;return{c(){s=a("p"),_=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),d=a("code"),u=m("Module"),g=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Although the recipe for forward pass needs to be defined within this function, one should call the "),d=i(r,"CODE",{});var x=l(d);u=p(x,"Module"),x.forEach(o),g=p(r,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),r.forEach(o)},m(n,r){k(n,s,r),e(s,_),e(s,d),e(d,u),e(s,g)},d(n){n&&o(s)}}}function Ul(E){let s,_,d,u,g;return u=new C({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForCausalLM
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/gpt2")
model = ORTModelForCausalLM.from_pretrained("optimum/gpt2")

inputs = tokenizer("My name is Philipp and I live in Germany.", return_tensors="pt")

gen_tokens = model.generate(**inputs,do_sample=True,temperature=0.9, min_length=20,max_length=20)
tokenizer.batch_decode(gen_tokens)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForCausalLM
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/gpt2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForCausalLM.from_pretrained(<span class="hljs-string">&quot;optimum/gpt2&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>gen_tokens = model.generate(**inputs,do_sample=<span class="hljs-literal">True</span>,temperature=<span class="hljs-number">0.9</span>, min_length=<span class="hljs-number">20</span>,max_length=<span class="hljs-number">20</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.batch_decode(gen_tokens)`}}),{c(){s=a("p"),_=m("Example of text generation:"),d=f(),M(u.$$.fragment)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Example of text generation:"),r.forEach(o),d=h(n),O(u.$$.fragment,n)},m(n,r){k(n,s,r),e(s,_),k(n,d,r),y(u,n,r),g=!0},p:Y,i(n){g||(T(u.$$.fragment,n),g=!0)},o(n){b(u.$$.fragment,n),g=!1},d(n){n&&o(s),n&&o(d),j(u,n)}}}function Yl(E){let s,_,d,u,g,n,r,x;return r=new C({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForCausalLM

tokenizer = AutoTokenizer.from_pretrained("optimum/gpt2")
model = ORTModelForCausalLM.from_pretrained("optimum/gpt2")
onnx_gen = pipeline("text-generation", model=model, tokenizer=tokenizer)

text = "My name is Philipp and I live in Germany."
gen = onnx_gen(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForCausalLM

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/gpt2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForCausalLM.from_pretrained(<span class="hljs-string">&quot;optimum/gpt2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_gen = pipeline(<span class="hljs-string">&quot;text-generation&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>gen = onnx_gen(text)`}}),{c(){s=a("p"),_=m("Example using "),d=a("code"),u=m("transformers.pipelines"),g=m(":"),n=f(),M(r.$$.fragment)},l(c){s=i(c,"P",{});var w=l(s);_=p(w,"Example using "),d=i(w,"CODE",{});var q=l(d);u=p(q,"transformers.pipelines"),q.forEach(o),g=p(w,":"),w.forEach(o),n=h(c),O(r.$$.fragment,c)},m(c,w){k(c,s,w),e(s,_),e(s,d),e(d,u),e(s,g),k(c,n,w),y(r,c,w),x=!0},p:Y,i(c){x||(T(r.$$.fragment,c),x=!0)},o(c){b(r.$$.fragment,c),x=!1},d(c){c&&o(s),c&&o(n),j(r,c)}}}function Zl(E){let s,_,d,u,g;return{c(){s=a("p"),_=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),d=a("code"),u=m("Module"),g=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Although the recipe for forward pass needs to be defined within this function, one should call the "),d=i(r,"CODE",{});var x=l(d);u=p(x,"Module"),x.forEach(o),g=p(r,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),r.forEach(o)},m(n,r){k(n,s,r),e(s,_),e(s,d),e(d,u),e(s,g)},d(n){n&&o(s)}}}function Kl(E){let s,_,d,u,g;return u=new C({props:{code:`from transformers import AutoFeatureExtractor
from optimum.onnxruntime import ORTModelForImageClassification
import torch

tokenizer = AutoFeatureExtractor.from_pretrained("optimum/vit-base-patch16-224")
model = ORTModelForImageClassification.from_pretrained("optimum/vit-base-patch16-224")

inputs = tokenizer("My name is Philipp and I live in Germany.", return_tensors="pt")

outputs = model(**inputs)
logits = outputs.logits
list(logits.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoFeatureExtractor
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForImageClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;optimum/vit-base-patch16-224&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForImageClassification.from_pretrained(<span class="hljs-string">&quot;optimum/vit-base-patch16-224&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(logits.shape)`}}),{c(){s=a("p"),_=m("Example of feature extraction:"),d=f(),M(u.$$.fragment)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Example of feature extraction:"),r.forEach(o),d=h(n),O(u.$$.fragment,n)},m(n,r){k(n,s,r),e(s,_),k(n,d,r),y(u,n,r),g=!0},p:Y,i(n){g||(T(u.$$.fragment,n),g=!0)},o(n){b(u.$$.fragment,n),g=!1},d(n){n&&o(s),n&&o(d),j(u,n)}}}function em(E){let s,_,d,u,g,n,r,x;return r=new C({props:{code:`from transformers import AutoFeatureExtractor, pipeline
from optimum.onnxruntime import ORTModelForImageClassification

tokenizer = AutoFeatureExtractor.from_pretrained("optimum/vit-base-patch16-224")
model = ORTModelForImageClassification.from_pretrained("optimum/vit-base-patch16-224")
onnx_extractor = pipeline("feature-extraction", model=model, tokenizer=tokenizer)

text = "My name is Philipp and I live in Germany."
pred = onnx_extractor(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoFeatureExtractor, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForImageClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;optimum/vit-base-patch16-224&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForImageClassification.from_pretrained(<span class="hljs-string">&quot;optimum/vit-base-patch16-224&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_extractor = pipeline(<span class="hljs-string">&quot;feature-extraction&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_extractor(text)`}}),{c(){s=a("p"),_=m("Example using "),d=a("code"),u=m("transformers.pipeline"),g=m(":"),n=f(),M(r.$$.fragment)},l(c){s=i(c,"P",{});var w=l(s);_=p(w,"Example using "),d=i(w,"CODE",{});var q=l(d);u=p(q,"transformers.pipeline"),q.forEach(o),g=p(w,":"),w.forEach(o),n=h(c),O(r.$$.fragment,c)},m(c,w){k(c,s,w),e(s,_),e(s,d),e(d,u),e(s,g),k(c,n,w),y(r,c,w),x=!0},p:Y,i(c){x||(T(r.$$.fragment,c),x=!0)},o(c){b(r.$$.fragment,c),x=!1},d(c){c&&o(s),c&&o(n),j(r,c)}}}function tm(E){let s,_,d,u,g,n,r,x,c,w,q,R,F,Vt,Jt,bn,ue,Ee,ro,lt,ds,ao,us,Mn,H,fs,io,hs,gs,lo,_s,$s,mo,ks,ws,po,vs,xs,On,mt,yn,te,Ts,co,bs,Ms,uo,Os,ys,jn,pt,En,qe,js,Ut,Es,qs,qn,fe,Re,fo,ct,Rs,ho,Fs,Rn,Z,zs,Yt,Cs,As,dt,Ps,Is,go,Ns,Ss,Fn,ut,zn,he,Fe,_o,ft,Ds,$o,Ls,Cn,V,ht,Hs,gt,Qs,ko,Xs,Ws,Bs,ze,_t,Gs,$t,Vs,wo,Js,Us,Ys,Ce,kt,Zs,vo,Ks,An,ge,Ae,xo,wt,er,To,tr,Pn,A,vt,or,bo,nr,sr,xt,rr,Mo,ar,ir,lr,Oo,mr,pr,Q,Tt,cr,_e,dr,yo,ur,fr,jo,hr,gr,_r,Pe,$r,Ie,kr,Ne,In,$e,Se,Eo,bt,wr,qo,vr,Nn,P,Mt,xr,Ro,Tr,br,Ot,Mr,Fo,Or,yr,jr,zo,Er,qr,X,yt,Rr,ke,Fr,Co,zr,Cr,Ao,Ar,Pr,Ir,De,Nr,Le,Sr,He,Sn,we,Qe,Po,jt,Dr,Io,Lr,Dn,I,Et,Hr,No,Qr,Xr,qt,Wr,So,Br,Gr,Vr,Do,Jr,Ur,z,Rt,Yr,ve,Zr,Lo,Kr,ea,Ho,ta,oa,na,Xe,sa,We,ra,Be,aa,Ge,Ln,xe,Ve,Qo,Ft,ia,Xo,la,Hn,N,zt,ma,Wo,pa,ca,Ct,da,Bo,ua,fa,ha,Go,ga,_a,W,At,$a,Te,ka,Vo,wa,va,Jo,xa,Ta,ba,Je,Ma,Ue,Oa,Ye,Qn,be,Ze,Uo,Pt,ya,Yo,ja,Xn,S,It,Ea,Zo,qa,Ra,Nt,Fa,Ko,za,Ca,Aa,en,Pa,Ia,B,St,Na,Me,Sa,tn,Da,La,on,Ha,Qa,Xa,Ke,Wa,et,Ba,tt,Wn,Oe,ot,nn,Dt,Ga,sn,Va,Bn,D,Lt,Ja,rn,Ua,Ya,Ht,Za,an,Ka,ei,ti,ln,oi,ni,G,Qt,si,ye,ri,mn,ai,ii,pn,li,mi,pi,nt,ci,st,di,rt,Gn;return n=new ee({}),lt=new ee({}),mt=new C({props:{code:`

`,highlighted:`from transformers import AutoTokenizer, pipeline
<span class="hljs-deletion">-from transformers import AutoModelForQuestionAnswering</span>
<span class="hljs-addition">+from optimum.onnxruntime import ORTModelForQuestionAnswering</span>

<span class="hljs-deletion">-model = AutoModelForQuestionAnswering.from_pretrained(&quot;deepset/roberta-base-squad2&quot;) # pytorch checkpoint</span>
<span class="hljs-addition">+model = ORTModelForQuestionAnswering.from_pretrained(&quot;optimum/roberta-base-squad2&quot;) # onnx checkpoint</span>
tokenizer = AutoTokenizer.from_pretrained(&quot;deepset/roberta-base-squad2&quot;)

onnx_qa = pipeline(&quot;question-answering&quot;,model=model,tokenizer=tokenizer)

question = &quot;What&#x27;s my name?&quot;
context = &quot;My name is Philipp and I live in Nuremberg.&quot;
pred = onnx_qa(question, context)`}}),pt=new C({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForSequenceClassification

model = ORTModelForSequenceClassification.from_pretrained("distilbert-base-uncased-finetuned-sst-2-english",from_transformers=True)
tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased-finetuned-sst-2-english")

onnx_classifier = pipeline("text-classification",model=model,tokenizer=tokenizer)

result = onnx_classifier(text="This is a great model")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSequenceClassification

<span class="hljs-comment"># load model from hub and convert</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>,from_transformers=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)

<span class="hljs-comment"># create pipeline</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_classifier = pipeline(<span class="hljs-string">&quot;text-classification&quot;</span>,model=model,tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>result = onnx_classifier(text=<span class="hljs-string">&quot;This is a great model&quot;</span>)
[{<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;POSITIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.9998838901519775</span>}]`}}),ct=new ee({}),ut=new C({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForSequenceClassification

model = ORTModelForSequenceClassification.from_pretrained("distilbert-base-uncased-finetuned-sst-2-english",from_transformers=True)
tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased-finetuned-sst-2-english")

model.save_pretrained("a_local_path_for_convert_onnx_model")
tokenizer.save_pretrained("a_local_path_for_convert_onnx_model")

model.push_to_hub("a_local_path_for_convert_onnx_model",`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSequenceClassification

<span class="hljs-comment"># load model from hub and convert</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>,from_transformers=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)

<span class="hljs-comment"># save converted model</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model.save_pretrained(<span class="hljs-string">&quot;a_local_path_for_convert_onnx_model&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.save_pretrained(<span class="hljs-string">&quot;a_local_path_for_convert_onnx_model&quot;</span>)

<span class="hljs-comment"># push model onnx model to HF Hub</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model.push_to_hub(<span class="hljs-string">&quot;a_local_path_for_convert_onnx_model&quot;</span>,
                  repository_id=<span class="hljs-string">&quot;my-onnx-repo&quot;</span>,
                  use_auth_token=<span class="hljs-literal">True</span>
                  )`}}),ft=new ee({}),ht=new L({props:{name:"class optimum.onnxruntime.ORTModel",anchor:"optimum.onnxruntime.ORTModel",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/v1.2.3.dev0/src/optimum/onnxruntime/modeling_ort.py#L82"}}),_t=new L({props:{name:"load_model",anchor:"optimum.onnxruntime.ORTModel.load_model",parameters:[{name:"path",val:": typing.Union[str, pathlib.Path]"},{name:"provider",val:" = None"}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModel.load_model.path",description:`<strong>path</strong> (<code>str</code> or <code>Path</code>) &#x2014;
Directory from which to load the model.`,name:"path"},{anchor:"optimum.onnxruntime.ORTModel.load_model.provider(str,",description:`<strong>provider(<code>str</code>,</strong> <em>optional</em>) &#x2014;
ONNX Runtime provider to use for loading the model. Defaults to <code>CPUExecutionProvider</code>.`,name:"provider(str,"}],source:"https://github.com/huggingface/optimum/blob/v1.2.3.dev0/src/optimum/onnxruntime/modeling_ort.py#L122"}}),kt=new L({props:{name:"to",anchor:"optimum.onnxruntime.ORTModel.to",parameters:[{name:"device",val:""}],source:"https://github.com/huggingface/optimum/blob/v1.2.3.dev0/src/optimum/onnxruntime/modeling_ort.py#L110"}}),wt=new ee({}),vt=new L({props:{name:"class optimum.onnxruntime.ORTModelForFeatureExtraction",anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.config",description:`<strong>config</strong> (<code>transformers.PretrainedConfig</code>) &#x2014; <a href="https://huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig" rel="nofollow">PretrainedConfig</a> is the Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <code>from_pretrained()</code> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.model",description:'<strong>model</strong> (<code>onnxruntime.InferenceSession</code>) &#x2014; <a href="https://onnxruntime.ai/docs/api/python/api_summary.html#inferencesession" rel="nofollow">onnxruntime.InferenceSession</a> is the main class used to run a model. Check out the <a href="/docs/optimum/v1.2.3.dev0/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.load_model">load_model()</a> method for more information.',name:"model"}],source:"https://github.com/huggingface/optimum/blob/v1.2.3.dev0/src/optimum/onnxruntime/modeling_ort.py#L320"}}),Tt=new L({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}],source:"https://github.com/huggingface/optimum/blob/v1.2.3.dev0/src/optimum/onnxruntime/modeling_ort.py#L334"}}),Pe=new so({props:{$$slots:{default:[Pl]},$$scope:{ctx:E}}}),Ie=new U({props:{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward.example",$$slots:{default:[Il]},$$scope:{ctx:E}}}),Ne=new U({props:{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward.example-2",$$slots:{default:[Nl]},$$scope:{ctx:E}}}),bt=new ee({}),Mt=new L({props:{name:"class optimum.onnxruntime.ORTModelForQuestionAnswering",anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.config",description:`<strong>config</strong> (<code>transformers.PretrainedConfig</code>) &#x2014; <a href="https://huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig" rel="nofollow">PretrainedConfig</a> is the Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <code>from_pretrained()</code> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.model",description:'<strong>model</strong> (<code>onnxruntime.InferenceSession</code>) &#x2014; <a href="https://onnxruntime.ai/docs/api/python/api_summary.html#inferencesession" rel="nofollow">onnxruntime.InferenceSession</a> is the main class used to run a model. Check out the <a href="/docs/optimum/v1.2.3.dev0/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.load_model">load_model()</a> method for more information.',name:"model"}],source:"https://github.com/huggingface/optimum/blob/v1.2.3.dev0/src/optimum/onnxruntime/modeling_ort.py#L405"}}),yt=new L({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}],source:"https://github.com/huggingface/optimum/blob/v1.2.3.dev0/src/optimum/onnxruntime/modeling_ort.py#L419"}}),De=new so({props:{$$slots:{default:[Sl]},$$scope:{ctx:E}}}),Le=new U({props:{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward.example",$$slots:{default:[Dl]},$$scope:{ctx:E}}}),He=new U({props:{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward.example-2",$$slots:{default:[Ll]},$$scope:{ctx:E}}}),jt=new ee({}),Et=new L({props:{name:"class optimum.onnxruntime.ORTModelForSequenceClassification",anchor:"optimum.onnxruntime.ORTModelForSequenceClassification",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.config",description:`<strong>config</strong> (<code>transformers.PretrainedConfig</code>) &#x2014; <a href="https://huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig" rel="nofollow">PretrainedConfig</a> is the Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <code>from_pretrained()</code> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.model",description:'<strong>model</strong> (<code>onnxruntime.InferenceSession</code>) &#x2014; <a href="https://onnxruntime.ai/docs/api/python/api_summary.html#inferencesession" rel="nofollow">onnxruntime.InferenceSession</a> is the main class used to run a model. Check out the <a href="/docs/optimum/v1.2.3.dev0/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.load_model">load_model()</a> method for more information.',name:"model"}],source:"https://github.com/huggingface/optimum/blob/v1.2.3.dev0/src/optimum/onnxruntime/modeling_ort.py#L508"}}),Rt=new L({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}],source:"https://github.com/huggingface/optimum/blob/v1.2.3.dev0/src/optimum/onnxruntime/modeling_ort.py#L523"}}),Xe=new so({props:{$$slots:{default:[Hl]},$$scope:{ctx:E}}}),We=new U({props:{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.example",$$slots:{default:[Ql]},$$scope:{ctx:E}}}),Be=new U({props:{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.example-2",$$slots:{default:[Xl]},$$scope:{ctx:E}}}),Ge=new U({props:{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.example-3",$$slots:{default:[Wl]},$$scope:{ctx:E}}}),Ft=new ee({}),zt=new L({props:{name:"class optimum.onnxruntime.ORTModelForTokenClassification",anchor:"optimum.onnxruntime.ORTModelForTokenClassification",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.config",description:`<strong>config</strong> (<code>transformers.PretrainedConfig</code>) &#x2014; <a href="https://huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig" rel="nofollow">PretrainedConfig</a> is the Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <code>from_pretrained()</code> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.model",description:'<strong>model</strong> (<code>onnxruntime.InferenceSession</code>) &#x2014; <a href="https://onnxruntime.ai/docs/api/python/api_summary.html#inferencesession" rel="nofollow">onnxruntime.InferenceSession</a> is the main class used to run a model. Check out the <a href="/docs/optimum/v1.2.3.dev0/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.load_model">load_model()</a> method for more information.',name:"model"}],source:"https://github.com/huggingface/optimum/blob/v1.2.3.dev0/src/optimum/onnxruntime/modeling_ort.py#L596"}}),At=new L({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}],source:"https://github.com/huggingface/optimum/blob/v1.2.3.dev0/src/optimum/onnxruntime/modeling_ort.py#L610"}}),Je=new so({props:{$$slots:{default:[Bl]},$$scope:{ctx:E}}}),Ue=new U({props:{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward.example",$$slots:{default:[Gl]},$$scope:{ctx:E}}}),Ye=new U({props:{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward.example-2",$$slots:{default:[Vl]},$$scope:{ctx:E}}}),Pt=new ee({}),It=new L({props:{name:"class optimum.onnxruntime.ORTModelForCausalLM",anchor:"optimum.onnxruntime.ORTModelForCausalLM",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForCausalLM.config",description:`<strong>config</strong> (<code>transformers.PretrainedConfig</code>) &#x2014; <a href="https://huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig" rel="nofollow">PretrainedConfig</a> is the Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <code>from_pretrained()</code> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForCausalLM.model",description:'<strong>model</strong> (<code>onnxruntime.InferenceSession</code>) &#x2014; <a href="https://onnxruntime.ai/docs/api/python/api_summary.html#inferencesession" rel="nofollow">onnxruntime.InferenceSession</a> is the main class used to run a model. Check out the <a href="/docs/optimum/v1.2.3.dev0/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.load_model">load_model()</a> method for more information.',name:"model"}],source:"https://github.com/huggingface/optimum/blob/v1.2.3.dev0/src/optimum/onnxruntime/modeling_ort.py#L681"}}),St=new L({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForCausalLM.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForCausalLM.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForCausalLM.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForCausalLM.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}],source:"https://github.com/huggingface/optimum/blob/v1.2.3.dev0/src/optimum/onnxruntime/modeling_ort.py#L705"}}),Ke=new so({props:{$$slots:{default:[Jl]},$$scope:{ctx:E}}}),et=new U({props:{anchor:"optimum.onnxruntime.ORTModelForCausalLM.forward.example",$$slots:{default:[Ul]},$$scope:{ctx:E}}}),tt=new U({props:{anchor:"optimum.onnxruntime.ORTModelForCausalLM.forward.example-2",$$slots:{default:[Yl]},$$scope:{ctx:E}}}),Dt=new ee({}),Lt=new L({props:{name:"class optimum.onnxruntime.ORTModelForImageClassification",anchor:"optimum.onnxruntime.ORTModelForImageClassification",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForImageClassification.config",description:`<strong>config</strong> (<code>transformers.PretrainedConfig</code>) &#x2014; <a href="https://huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig" rel="nofollow">PretrainedConfig</a> is the Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <code>from_pretrained()</code> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForImageClassification.model",description:'<strong>model</strong> (<code>onnxruntime.InferenceSession</code>) &#x2014; <a href="https://onnxruntime.ai/docs/api/python/api_summary.html#inferencesession" rel="nofollow">onnxruntime.InferenceSession</a> is the main class used to run a model. Check out the <a href="/docs/optimum/v1.2.3.dev0/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModel.load_model">load_model()</a> method for more information.',name:"model"}],source:"https://github.com/huggingface/optimum/blob/v1.2.3.dev0/src/optimum/onnxruntime/modeling_ort.py#L801"}}),Qt=new L({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForImageClassification.forward",parameters:[{name:"pixel_values",val:": Tensor"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForImageClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForImageClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForImageClassification.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}],source:"https://github.com/huggingface/optimum/blob/v1.2.3.dev0/src/optimum/onnxruntime/modeling_ort.py#L815"}}),nt=new so({props:{$$slots:{default:[Zl]},$$scope:{ctx:E}}}),st=new U({props:{anchor:"optimum.onnxruntime.ORTModelForImageClassification.forward.example",$$slots:{default:[Kl]},$$scope:{ctx:E}}}),rt=new U({props:{anchor:"optimum.onnxruntime.ORTModelForImageClassification.forward.example-2",$$slots:{default:[em]},$$scope:{ctx:E}}}),{c(){s=a("meta"),_=f(),d=a("h1"),u=a("a"),g=a("span"),M(n.$$.fragment),r=f(),x=a("span"),c=m("Optimum Inference with ONNX Runtime"),w=f(),q=a("p"),R=m(`Optimum is a utility package for building and running inference with accelerated runtime like ONNX Runtime.
Optimum can be used to load optimized models from the `),F=a("a"),Vt=m("Hugging Face Hub"),Jt=m(` and create pipelines
to run accelerated inference without rewriting your APIs.`),bn=f(),ue=a("h2"),Ee=a("a"),ro=a("span"),M(lt.$$.fragment),ds=f(),ao=a("span"),us=m("Switching from Transformers to Optimum Inference"),Mn=f(),H=a("p"),fs=m("The Optimum Inference models are API compatible with Hugging Face Transformers models. This means you can just replace your "),io=a("code"),hs=m("AutoModelForXxx"),gs=m(" class with the corresponding "),lo=a("code"),_s=m("ORTModelForXxx"),$s=m(" class in "),mo=a("code"),ks=m("optimum"),ws=m(". For example, this is how you can use a question answering model in "),po=a("code"),vs=m("optimum"),xs=m(":"),On=f(),M(mt.$$.fragment),yn=f(),te=a("p"),Ts=m("Optimum Inference also includes methods to convert vanilla Transformers models to optimized ones. Simply pass "),co=a("code"),bs=m("from_transformers=True"),Ms=m(" to the "),uo=a("code"),Os=m("from_pretrained()"),ys=m(" method, and your model will be loaded and converted to ONNX on-the-fly:"),jn=f(),M(pt.$$.fragment),En=f(),qe=a("p"),js=m("You can find a complete walkhrough Optimum Inference for ONNX Runtime in this "),Ut=a("a"),Es=m("notebook"),qs=m("."),qn=f(),fe=a("h3"),Re=a("a"),fo=a("span"),M(ct.$$.fragment),Rs=f(),ho=a("span"),Fs=m("Working with the Hugging Face Model Hub"),Rn=f(),Z=a("p"),zs=m("The Optimum model classes like "),Yt=a("a"),Cs=m("ORTModelForSequenceClassification"),As=m(" are integrated with the "),dt=a("a"),Ps=m("Hugging Face Model Hub"),Is=m(`, which means you can not only
load model from the Hub, but also push your models to the Hub with `),go=a("code"),Ns=m("push_to_hub()"),Ss=m(` method. Below is an example which downloads a vanilla Transformers model
from the Hub and converts it to an optimum onnxruntime model and pushes it back into a new repository.`),Fn=f(),M(ut.$$.fragment),zn=f(),he=a("h2"),Fe=a("a"),_o=a("span"),M(ft.$$.fragment),Ds=f(),$o=a("span"),Ls=m("ORTModel"),Cn=f(),V=a("div"),M(ht.$$.fragment),Hs=f(),gt=a("p"),Qs=m(`Base ORTModel class for implementing models using ONNX Runtime. The ORTModel implements generic methods for interacting
with the Hugging Face Hub as well as exporting vanilla transformers models to ONNX using `),ko=a("code"),Xs=m("transformers.onnx"),Ws=m(` toolchain.
The ORTModel implements additionally generic methods for optimizing and quantizing Onnx models.`),Bs=f(),ze=a("div"),M(_t.$$.fragment),Gs=f(),$t=a("p"),Vs=m("Loads an ONNX Inference session with a given provider. Default provider is "),wo=a("code"),Js=m("CPUExecutionProvider"),Us=m(" to match the default behaviour in PyTorch/TensorFlow/JAX."),Ys=f(),Ce=a("div"),M(kt.$$.fragment),Zs=f(),vo=a("p"),Ks=m("Changes the ONNX Runtime provider according to the device."),An=f(),ge=a("h2"),Ae=a("a"),xo=a("span"),M(wt.$$.fragment),er=f(),To=a("span"),tr=m("ORTModelForFeatureExtraction"),Pn=f(),A=a("div"),M(vt.$$.fragment),or=f(),bo=a("p"),nr=m("Onnx Model with a MaskedLMOutput for feature-extraction tasks."),sr=f(),xt=a("p"),rr=m("This model inherits from [~"),Mo=a("code"),ar=m("onnxruntime.modeling_ort.ORTModel"),ir=m(`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),lr=f(),Oo=a("p"),mr=m("Feature Extraction model for ONNX."),pr=f(),Q=a("div"),M(Tt.$$.fragment),cr=f(),_e=a("p"),dr=m("The "),yo=a("code"),ur=m("ORTModelForFeatureExtraction"),fr=m(" forward method, overrides the "),jo=a("code"),hr=m("__call__"),gr=m(" special method."),_r=f(),M(Pe.$$.fragment),$r=f(),M(Ie.$$.fragment),kr=f(),M(Ne.$$.fragment),In=f(),$e=a("h2"),Se=a("a"),Eo=a("span"),M(bt.$$.fragment),wr=f(),qo=a("span"),vr=m("ORTModelForQuestionAnswering"),Nn=f(),P=a("div"),M(Mt.$$.fragment),xr=f(),Ro=a("p"),Tr=m("Onnx Model with a QuestionAnsweringModelOutput for extractive question-answering tasks like SQuAD."),br=f(),Ot=a("p"),Mr=m("This model inherits from [~"),Fo=a("code"),Or=m("onnxruntime.modeling_ort.ORTModel"),yr=m(`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),jr=f(),zo=a("p"),Er=m("Question Answering model for ONNX."),qr=f(),X=a("div"),M(yt.$$.fragment),Rr=f(),ke=a("p"),Fr=m("The "),Co=a("code"),zr=m("ORTModelForQuestionAnswering"),Cr=m(" forward method, overrides the "),Ao=a("code"),Ar=m("__call__"),Pr=m(" special method."),Ir=f(),M(De.$$.fragment),Nr=f(),M(Le.$$.fragment),Sr=f(),M(He.$$.fragment),Sn=f(),we=a("h2"),Qe=a("a"),Po=a("span"),M(jt.$$.fragment),Dr=f(),Io=a("span"),Lr=m("ORTModelForSequenceClassification"),Dn=f(),I=a("div"),M(Et.$$.fragment),Hr=f(),No=a("p"),Qr=m(`Onnx Model with a sequence classification/regression head on top (a linear layer on top of the
pooled output) e.g. for GLUE tasks.`),Xr=f(),qt=a("p"),Wr=m("This model inherits from [~"),So=a("code"),Br=m("onnxruntime.modeling_ort.ORTModel"),Gr=m(`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),Vr=f(),Do=a("p"),Jr=m("Sequence Classification model for ONNX."),Ur=f(),z=a("div"),M(Rt.$$.fragment),Yr=f(),ve=a("p"),Zr=m("The "),Lo=a("code"),Kr=m("ORTModelForSequenceClassification"),ea=m(" forward method, overrides the "),Ho=a("code"),ta=m("__call__"),oa=m(" special method."),na=f(),M(Xe.$$.fragment),sa=f(),M(We.$$.fragment),ra=f(),M(Be.$$.fragment),aa=f(),M(Ge.$$.fragment),Ln=f(),xe=a("h2"),Ve=a("a"),Qo=a("span"),M(Ft.$$.fragment),ia=f(),Xo=a("span"),la=m("ORTModelForTokenClassification"),Hn=f(),N=a("div"),M(zt.$$.fragment),ma=f(),Wo=a("p"),pa=m(`Onnx Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g.
for Named-Entity-Recognition (NER) tasks.`),ca=f(),Ct=a("p"),da=m("This model inherits from [~"),Bo=a("code"),ua=m("onnxruntime.modeling_ort.ORTModel"),fa=m(`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),ha=f(),Go=a("p"),ga=m("Token Classification model for ONNX."),_a=f(),W=a("div"),M(At.$$.fragment),$a=f(),Te=a("p"),ka=m("The "),Vo=a("code"),wa=m("ORTModelForTokenClassification"),va=m(" forward method, overrides the "),Jo=a("code"),xa=m("__call__"),Ta=m(" special method."),ba=f(),M(Je.$$.fragment),Ma=f(),M(Ue.$$.fragment),Oa=f(),M(Ye.$$.fragment),Qn=f(),be=a("h2"),Ze=a("a"),Uo=a("span"),M(Pt.$$.fragment),ya=f(),Yo=a("span"),ja=m("ORTModelForCausalLM"),Xn=f(),S=a("div"),M(It.$$.fragment),Ea=f(),Zo=a("p"),qa=m(`Onnx Model with a causal language modeling head on top (linear layer with weights tied to the input
embeddings).`),Ra=f(),Nt=a("p"),Fa=m("This model inherits from [~"),Ko=a("code"),za=m("onnxruntime.modeling_ort.ORTModel"),Ca=m(`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),Aa=f(),en=a("p"),Pa=m("Causal LM model for ONNX."),Ia=f(),B=a("div"),M(St.$$.fragment),Na=f(),Me=a("p"),Sa=m("The "),tn=a("code"),Da=m("ORTModelForCausalLM"),La=m(" forward method, overrides the "),on=a("code"),Ha=m("__call__"),Qa=m(" special method."),Xa=f(),M(Ke.$$.fragment),Wa=f(),M(et.$$.fragment),Ba=f(),M(tt.$$.fragment),Wn=f(),Oe=a("h2"),ot=a("a"),nn=a("span"),M(Dt.$$.fragment),Ga=f(),sn=a("span"),Va=m("ORTModelForImageClassification"),Bn=f(),D=a("div"),M(Lt.$$.fragment),Ja=f(),rn=a("p"),Ua=m("Onnx Model for image-classification tasks."),Ya=f(),Ht=a("p"),Za=m("This model inherits from [~"),an=a("code"),Ka=m("onnxruntime.modeling_ort.ORTModel"),ei=m(`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),ti=f(),ln=a("p"),oi=m("Image Classification model for ONNX."),ni=f(),G=a("div"),M(Qt.$$.fragment),si=f(),ye=a("p"),ri=m("The "),mn=a("code"),ai=m("ORTModelForImageClassification"),ii=m(" forward method, overrides the "),pn=a("code"),li=m("__call__"),mi=m(" special method."),pi=f(),M(nt.$$.fragment),ci=f(),M(st.$$.fragment),di=f(),M(rt.$$.fragment),this.h()},l(t){const $=Fl('[data-svelte="svelte-1phssyn"]',document.head);s=i($,"META",{name:!0,content:!0}),$.forEach(o),_=h(t),d=i(t,"H1",{class:!0});var Xt=l(d);u=i(Xt,"A",{id:!0,class:!0,href:!0});var cn=l(u);g=i(cn,"SPAN",{});var dn=l(g);O(n.$$.fragment,dn),dn.forEach(o),cn.forEach(o),r=h(Xt),x=i(Xt,"SPAN",{});var un=l(x);c=p(un,"Optimum Inference with ONNX Runtime"),un.forEach(o),Xt.forEach(o),w=h(t),q=i(t,"P",{});var Wt=l(q);R=p(Wt,`Optimum is a utility package for building and running inference with accelerated runtime like ONNX Runtime.
Optimum can be used to load optimized models from the `),F=i(Wt,"A",{href:!0});var fn=l(F);Vt=p(fn,"Hugging Face Hub"),fn.forEach(o),Jt=p(Wt,` and create pipelines
to run accelerated inference without rewriting your APIs.`),Wt.forEach(o),bn=h(t),ue=i(t,"H2",{class:!0});var Bt=l(ue);Ee=i(Bt,"A",{id:!0,class:!0,href:!0});var hn=l(Ee);ro=i(hn,"SPAN",{});var gn=l(ro);O(lt.$$.fragment,gn),gn.forEach(o),hn.forEach(o),ds=h(Bt),ao=i(Bt,"SPAN",{});var _n=l(ao);us=p(_n,"Switching from Transformers to Optimum Inference"),_n.forEach(o),Bt.forEach(o),Mn=h(t),H=i(t,"P",{});var J=l(H);fs=p(J,"The Optimum Inference models are API compatible with Hugging Face Transformers models. This means you can just replace your "),io=i(J,"CODE",{});var $n=l(io);hs=p($n,"AutoModelForXxx"),$n.forEach(o),gs=p(J," class with the corresponding "),lo=i(J,"CODE",{});var kn=l(lo);_s=p(kn,"ORTModelForXxx"),kn.forEach(o),$s=p(J," class in "),mo=i(J,"CODE",{});var wn=l(mo);ks=p(wn,"optimum"),wn.forEach(o),ws=p(J,". For example, this is how you can use a question answering model in "),po=i(J,"CODE",{});var vn=l(po);vs=p(vn,"optimum"),vn.forEach(o),xs=p(J,":"),J.forEach(o),On=h(t),O(mt.$$.fragment,t),yn=h(t),te=i(t,"P",{});var je=l(te);Ts=p(je,"Optimum Inference also includes methods to convert vanilla Transformers models to optimized ones. Simply pass "),co=i(je,"CODE",{});var xn=l(co);bs=p(xn,"from_transformers=True"),xn.forEach(o),Ms=p(je," to the "),uo=i(je,"CODE",{});var Tn=l(uo);Os=p(Tn,"from_pretrained()"),Tn.forEach(o),ys=p(je," method, and your model will be loaded and converted to ONNX on-the-fly:"),je.forEach(o),jn=h(t),O(pt.$$.fragment,t),En=h(t),qe=i(t,"P",{});var Gt=l(qe);js=p(Gt,"You can find a complete walkhrough Optimum Inference for ONNX Runtime in this "),Ut=i(Gt,"A",{href:!0});var ui=l(Ut);Es=p(ui,"notebook"),ui.forEach(o),qs=p(Gt,"."),Gt.forEach(o),qn=h(t),fe=i(t,"H3",{class:!0});var Vn=l(fe);Re=i(Vn,"A",{id:!0,class:!0,href:!0});var fi=l(Re);fo=i(fi,"SPAN",{});var hi=l(fo);O(ct.$$.fragment,hi),hi.forEach(o),fi.forEach(o),Rs=h(Vn),ho=i(Vn,"SPAN",{});var gi=l(ho);Fs=p(gi,"Working with the Hugging Face Model Hub"),gi.forEach(o),Vn.forEach(o),Rn=h(t),Z=i(t,"P",{});var at=l(Z);zs=p(at,"The Optimum model classes like "),Yt=i(at,"A",{href:!0});var _i=l(Yt);Cs=p(_i,"ORTModelForSequenceClassification"),_i.forEach(o),As=p(at," are integrated with the "),dt=i(at,"A",{href:!0,rel:!0});var $i=l(dt);Ps=p($i,"Hugging Face Model Hub"),$i.forEach(o),Is=p(at,`, which means you can not only
load model from the Hub, but also push your models to the Hub with `),go=i(at,"CODE",{});var ki=l(go);Ns=p(ki,"push_to_hub()"),ki.forEach(o),Ss=p(at,` method. Below is an example which downloads a vanilla Transformers model
from the Hub and converts it to an optimum onnxruntime model and pushes it back into a new repository.`),at.forEach(o),Fn=h(t),O(ut.$$.fragment,t),zn=h(t),he=i(t,"H2",{class:!0});var Jn=l(he);Fe=i(Jn,"A",{id:!0,class:!0,href:!0});var wi=l(Fe);_o=i(wi,"SPAN",{});var vi=l(_o);O(ft.$$.fragment,vi),vi.forEach(o),wi.forEach(o),Ds=h(Jn),$o=i(Jn,"SPAN",{});var xi=l($o);Ls=p(xi,"ORTModel"),xi.forEach(o),Jn.forEach(o),Cn=h(t),V=i(t,"DIV",{class:!0});var it=l(V);O(ht.$$.fragment,it),Hs=h(it),gt=i(it,"P",{});var Un=l(gt);Qs=p(Un,`Base ORTModel class for implementing models using ONNX Runtime. The ORTModel implements generic methods for interacting
with the Hugging Face Hub as well as exporting vanilla transformers models to ONNX using `),ko=i(Un,"CODE",{});var Ti=l(ko);Xs=p(Ti,"transformers.onnx"),Ti.forEach(o),Ws=p(Un,` toolchain.
The ORTModel implements additionally generic methods for optimizing and quantizing Onnx models.`),Un.forEach(o),Bs=h(it),ze=i(it,"DIV",{class:!0});var Yn=l(ze);O(_t.$$.fragment,Yn),Gs=h(Yn),$t=i(Yn,"P",{});var Zn=l($t);Vs=p(Zn,"Loads an ONNX Inference session with a given provider. Default provider is "),wo=i(Zn,"CODE",{});var bi=l(wo);Js=p(bi,"CPUExecutionProvider"),bi.forEach(o),Us=p(Zn," to match the default behaviour in PyTorch/TensorFlow/JAX."),Zn.forEach(o),Yn.forEach(o),Ys=h(it),Ce=i(it,"DIV",{class:!0});var Kn=l(Ce);O(kt.$$.fragment,Kn),Zs=h(Kn),vo=i(Kn,"P",{});var Mi=l(vo);Ks=p(Mi,"Changes the ONNX Runtime provider according to the device."),Mi.forEach(o),Kn.forEach(o),it.forEach(o),An=h(t),ge=i(t,"H2",{class:!0});var es=l(ge);Ae=i(es,"A",{id:!0,class:!0,href:!0});var Oi=l(Ae);xo=i(Oi,"SPAN",{});var yi=l(xo);O(wt.$$.fragment,yi),yi.forEach(o),Oi.forEach(o),er=h(es),To=i(es,"SPAN",{});var ji=l(To);tr=p(ji,"ORTModelForFeatureExtraction"),ji.forEach(o),es.forEach(o),Pn=h(t),A=i(t,"DIV",{class:!0});var oe=l(A);O(vt.$$.fragment,oe),or=h(oe),bo=i(oe,"P",{});var Ei=l(bo);nr=p(Ei,"Onnx Model with a MaskedLMOutput for feature-extraction tasks."),Ei.forEach(o),sr=h(oe),xt=i(oe,"P",{});var ts=l(xt);rr=p(ts,"This model inherits from [~"),Mo=i(ts,"CODE",{});var qi=l(Mo);ar=p(qi,"onnxruntime.modeling_ort.ORTModel"),qi.forEach(o),ir=p(ts,`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),ts.forEach(o),lr=h(oe),Oo=i(oe,"P",{});var Ri=l(Oo);mr=p(Ri,"Feature Extraction model for ONNX."),Ri.forEach(o),pr=h(oe),Q=i(oe,"DIV",{class:!0});var ne=l(Q);O(Tt.$$.fragment,ne),cr=h(ne),_e=i(ne,"P",{});var Zt=l(_e);dr=p(Zt,"The "),yo=i(Zt,"CODE",{});var Fi=l(yo);ur=p(Fi,"ORTModelForFeatureExtraction"),Fi.forEach(o),fr=p(Zt," forward method, overrides the "),jo=i(Zt,"CODE",{});var zi=l(jo);hr=p(zi,"__call__"),zi.forEach(o),gr=p(Zt," special method."),Zt.forEach(o),_r=h(ne),O(Pe.$$.fragment,ne),$r=h(ne),O(Ie.$$.fragment,ne),kr=h(ne),O(Ne.$$.fragment,ne),ne.forEach(o),oe.forEach(o),In=h(t),$e=i(t,"H2",{class:!0});var os=l($e);Se=i(os,"A",{id:!0,class:!0,href:!0});var Ci=l(Se);Eo=i(Ci,"SPAN",{});var Ai=l(Eo);O(bt.$$.fragment,Ai),Ai.forEach(o),Ci.forEach(o),wr=h(os),qo=i(os,"SPAN",{});var Pi=l(qo);vr=p(Pi,"ORTModelForQuestionAnswering"),Pi.forEach(o),os.forEach(o),Nn=h(t),P=i(t,"DIV",{class:!0});var se=l(P);O(Mt.$$.fragment,se),xr=h(se),Ro=i(se,"P",{});var Ii=l(Ro);Tr=p(Ii,"Onnx Model with a QuestionAnsweringModelOutput for extractive question-answering tasks like SQuAD."),Ii.forEach(o),br=h(se),Ot=i(se,"P",{});var ns=l(Ot);Mr=p(ns,"This model inherits from [~"),Fo=i(ns,"CODE",{});var Ni=l(Fo);Or=p(Ni,"onnxruntime.modeling_ort.ORTModel"),Ni.forEach(o),yr=p(ns,`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),ns.forEach(o),jr=h(se),zo=i(se,"P",{});var Si=l(zo);Er=p(Si,"Question Answering model for ONNX."),Si.forEach(o),qr=h(se),X=i(se,"DIV",{class:!0});var re=l(X);O(yt.$$.fragment,re),Rr=h(re),ke=i(re,"P",{});var Kt=l(ke);Fr=p(Kt,"The "),Co=i(Kt,"CODE",{});var Di=l(Co);zr=p(Di,"ORTModelForQuestionAnswering"),Di.forEach(o),Cr=p(Kt," forward method, overrides the "),Ao=i(Kt,"CODE",{});var Li=l(Ao);Ar=p(Li,"__call__"),Li.forEach(o),Pr=p(Kt," special method."),Kt.forEach(o),Ir=h(re),O(De.$$.fragment,re),Nr=h(re),O(Le.$$.fragment,re),Sr=h(re),O(He.$$.fragment,re),re.forEach(o),se.forEach(o),Sn=h(t),we=i(t,"H2",{class:!0});var ss=l(we);Qe=i(ss,"A",{id:!0,class:!0,href:!0});var Hi=l(Qe);Po=i(Hi,"SPAN",{});var Qi=l(Po);O(jt.$$.fragment,Qi),Qi.forEach(o),Hi.forEach(o),Dr=h(ss),Io=i(ss,"SPAN",{});var Xi=l(Io);Lr=p(Xi,"ORTModelForSequenceClassification"),Xi.forEach(o),ss.forEach(o),Dn=h(t),I=i(t,"DIV",{class:!0});var ae=l(I);O(Et.$$.fragment,ae),Hr=h(ae),No=i(ae,"P",{});var Wi=l(No);Qr=p(Wi,`Onnx Model with a sequence classification/regression head on top (a linear layer on top of the
pooled output) e.g. for GLUE tasks.`),Wi.forEach(o),Xr=h(ae),qt=i(ae,"P",{});var rs=l(qt);Wr=p(rs,"This model inherits from [~"),So=i(rs,"CODE",{});var Bi=l(So);Br=p(Bi,"onnxruntime.modeling_ort.ORTModel"),Bi.forEach(o),Gr=p(rs,`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),rs.forEach(o),Vr=h(ae),Do=i(ae,"P",{});var Gi=l(Do);Jr=p(Gi,"Sequence Classification model for ONNX."),Gi.forEach(o),Ur=h(ae),z=i(ae,"DIV",{class:!0});var K=l(z);O(Rt.$$.fragment,K),Yr=h(K),ve=i(K,"P",{});var eo=l(ve);Zr=p(eo,"The "),Lo=i(eo,"CODE",{});var Vi=l(Lo);Kr=p(Vi,"ORTModelForSequenceClassification"),Vi.forEach(o),ea=p(eo," forward method, overrides the "),Ho=i(eo,"CODE",{});var Ji=l(Ho);ta=p(Ji,"__call__"),Ji.forEach(o),oa=p(eo," special method."),eo.forEach(o),na=h(K),O(Xe.$$.fragment,K),sa=h(K),O(We.$$.fragment,K),ra=h(K),O(Be.$$.fragment,K),aa=h(K),O(Ge.$$.fragment,K),K.forEach(o),ae.forEach(o),Ln=h(t),xe=i(t,"H2",{class:!0});var as=l(xe);Ve=i(as,"A",{id:!0,class:!0,href:!0});var Ui=l(Ve);Qo=i(Ui,"SPAN",{});var Yi=l(Qo);O(Ft.$$.fragment,Yi),Yi.forEach(o),Ui.forEach(o),ia=h(as),Xo=i(as,"SPAN",{});var Zi=l(Xo);la=p(Zi,"ORTModelForTokenClassification"),Zi.forEach(o),as.forEach(o),Hn=h(t),N=i(t,"DIV",{class:!0});var ie=l(N);O(zt.$$.fragment,ie),ma=h(ie),Wo=i(ie,"P",{});var Ki=l(Wo);pa=p(Ki,`Onnx Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g.
for Named-Entity-Recognition (NER) tasks.`),Ki.forEach(o),ca=h(ie),Ct=i(ie,"P",{});var is=l(Ct);da=p(is,"This model inherits from [~"),Bo=i(is,"CODE",{});var el=l(Bo);ua=p(el,"onnxruntime.modeling_ort.ORTModel"),el.forEach(o),fa=p(is,`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),is.forEach(o),ha=h(ie),Go=i(ie,"P",{});var tl=l(Go);ga=p(tl,"Token Classification model for ONNX."),tl.forEach(o),_a=h(ie),W=i(ie,"DIV",{class:!0});var le=l(W);O(At.$$.fragment,le),$a=h(le),Te=i(le,"P",{});var to=l(Te);ka=p(to,"The "),Vo=i(to,"CODE",{});var ol=l(Vo);wa=p(ol,"ORTModelForTokenClassification"),ol.forEach(o),va=p(to," forward method, overrides the "),Jo=i(to,"CODE",{});var nl=l(Jo);xa=p(nl,"__call__"),nl.forEach(o),Ta=p(to," special method."),to.forEach(o),ba=h(le),O(Je.$$.fragment,le),Ma=h(le),O(Ue.$$.fragment,le),Oa=h(le),O(Ye.$$.fragment,le),le.forEach(o),ie.forEach(o),Qn=h(t),be=i(t,"H2",{class:!0});var ls=l(be);Ze=i(ls,"A",{id:!0,class:!0,href:!0});var sl=l(Ze);Uo=i(sl,"SPAN",{});var rl=l(Uo);O(Pt.$$.fragment,rl),rl.forEach(o),sl.forEach(o),ya=h(ls),Yo=i(ls,"SPAN",{});var al=l(Yo);ja=p(al,"ORTModelForCausalLM"),al.forEach(o),ls.forEach(o),Xn=h(t),S=i(t,"DIV",{class:!0});var me=l(S);O(It.$$.fragment,me),Ea=h(me),Zo=i(me,"P",{});var il=l(Zo);qa=p(il,`Onnx Model with a causal language modeling head on top (linear layer with weights tied to the input
embeddings).`),il.forEach(o),Ra=h(me),Nt=i(me,"P",{});var ms=l(Nt);Fa=p(ms,"This model inherits from [~"),Ko=i(ms,"CODE",{});var ll=l(Ko);za=p(ll,"onnxruntime.modeling_ort.ORTModel"),ll.forEach(o),Ca=p(ms,`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),ms.forEach(o),Aa=h(me),en=i(me,"P",{});var ml=l(en);Pa=p(ml,"Causal LM model for ONNX."),ml.forEach(o),Ia=h(me),B=i(me,"DIV",{class:!0});var pe=l(B);O(St.$$.fragment,pe),Na=h(pe),Me=i(pe,"P",{});var oo=l(Me);Sa=p(oo,"The "),tn=i(oo,"CODE",{});var pl=l(tn);Da=p(pl,"ORTModelForCausalLM"),pl.forEach(o),La=p(oo," forward method, overrides the "),on=i(oo,"CODE",{});var cl=l(on);Ha=p(cl,"__call__"),cl.forEach(o),Qa=p(oo," special method."),oo.forEach(o),Xa=h(pe),O(Ke.$$.fragment,pe),Wa=h(pe),O(et.$$.fragment,pe),Ba=h(pe),O(tt.$$.fragment,pe),pe.forEach(o),me.forEach(o),Wn=h(t),Oe=i(t,"H2",{class:!0});var ps=l(Oe);ot=i(ps,"A",{id:!0,class:!0,href:!0});var dl=l(ot);nn=i(dl,"SPAN",{});var ul=l(nn);O(Dt.$$.fragment,ul),ul.forEach(o),dl.forEach(o),Ga=h(ps),sn=i(ps,"SPAN",{});var fl=l(sn);Va=p(fl,"ORTModelForImageClassification"),fl.forEach(o),ps.forEach(o),Bn=h(t),D=i(t,"DIV",{class:!0});var ce=l(D);O(Lt.$$.fragment,ce),Ja=h(ce),rn=i(ce,"P",{});var hl=l(rn);Ua=p(hl,"Onnx Model for image-classification tasks."),hl.forEach(o),Ya=h(ce),Ht=i(ce,"P",{});var cs=l(Ht);Za=p(cs,"This model inherits from [~"),an=i(cs,"CODE",{});var gl=l(an);Ka=p(gl,"onnxruntime.modeling_ort.ORTModel"),gl.forEach(o),ei=p(cs,`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),cs.forEach(o),ti=h(ce),ln=i(ce,"P",{});var _l=l(ln);oi=p(_l,"Image Classification model for ONNX."),_l.forEach(o),ni=h(ce),G=i(ce,"DIV",{class:!0});var de=l(G);O(Qt.$$.fragment,de),si=h(de),ye=i(de,"P",{});var no=l(ye);ri=p(no,"The "),mn=i(no,"CODE",{});var $l=l(mn);ai=p($l,"ORTModelForImageClassification"),$l.forEach(o),ii=p(no," forward method, overrides the "),pn=i(no,"CODE",{});var kl=l(pn);li=p(kl,"__call__"),kl.forEach(o),mi=p(no," special method."),no.forEach(o),pi=h(de),O(nt.$$.fragment,de),ci=h(de),O(st.$$.fragment,de),di=h(de),O(rt.$$.fragment,de),de.forEach(o),ce.forEach(o),this.h()},h(){v(s,"name","hf:doc:metadata"),v(s,"content",JSON.stringify(om)),v(u,"id","optimum-inference-with-onnx-runtime"),v(u,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(u,"href","#optimum-inference-with-onnx-runtime"),v(d,"class","relative group"),v(F,"href","hf.co/models"),v(Ee,"id","switching-from-transformers-to-optimum-inference"),v(Ee,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(Ee,"href","#switching-from-transformers-to-optimum-inference"),v(ue,"class","relative group"),v(Ut,"href","todo:add-link"),v(Re,"id","working-with-the-hugging-face-model-hub"),v(Re,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(Re,"href","#working-with-the-hugging-face-model-hub"),v(fe,"class","relative group"),v(Yt,"href","/docs/optimum/v1.2.3.dev0/en/onnxruntime/modeling_ort#optimum.onnxruntime.ORTModelForSequenceClassification"),v(dt,"href","https://hf.co/models"),v(dt,"rel","nofollow"),v(Fe,"id","optimum.onnxruntime.ORTModel"),v(Fe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(Fe,"href","#optimum.onnxruntime.ORTModel"),v(he,"class","relative group"),v(ze,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),v(Ce,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),v(V,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),v(Ae,"id","optimum.onnxruntime.ORTModelForFeatureExtraction"),v(Ae,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(Ae,"href","#optimum.onnxruntime.ORTModelForFeatureExtraction"),v(ge,"class","relative group"),v(Q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),v(A,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),v(Se,"id","optimum.onnxruntime.ORTModelForQuestionAnswering"),v(Se,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(Se,"href","#optimum.onnxruntime.ORTModelForQuestionAnswering"),v($e,"class","relative group"),v(X,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),v(P,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),v(Qe,"id","optimum.onnxruntime.ORTModelForSequenceClassification"),v(Qe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(Qe,"href","#optimum.onnxruntime.ORTModelForSequenceClassification"),v(we,"class","relative group"),v(z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),v(I,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),v(Ve,"id","optimum.onnxruntime.ORTModelForTokenClassification"),v(Ve,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(Ve,"href","#optimum.onnxruntime.ORTModelForTokenClassification"),v(xe,"class","relative group"),v(W,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),v(N,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),v(Ze,"id","optimum.onnxruntime.ORTModelForCausalLM"),v(Ze,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(Ze,"href","#optimum.onnxruntime.ORTModelForCausalLM"),v(be,"class","relative group"),v(B,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),v(S,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),v(ot,"id","optimum.onnxruntime.ORTModelForImageClassification"),v(ot,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(ot,"href","#optimum.onnxruntime.ORTModelForImageClassification"),v(Oe,"class","relative group"),v(G,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),v(D,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,$){e(document.head,s),k(t,_,$),k(t,d,$),e(d,u),e(u,g),y(n,g,null),e(d,r),e(d,x),e(x,c),k(t,w,$),k(t,q,$),e(q,R),e(q,F),e(F,Vt),e(q,Jt),k(t,bn,$),k(t,ue,$),e(ue,Ee),e(Ee,ro),y(lt,ro,null),e(ue,ds),e(ue,ao),e(ao,us),k(t,Mn,$),k(t,H,$),e(H,fs),e(H,io),e(io,hs),e(H,gs),e(H,lo),e(lo,_s),e(H,$s),e(H,mo),e(mo,ks),e(H,ws),e(H,po),e(po,vs),e(H,xs),k(t,On,$),y(mt,t,$),k(t,yn,$),k(t,te,$),e(te,Ts),e(te,co),e(co,bs),e(te,Ms),e(te,uo),e(uo,Os),e(te,ys),k(t,jn,$),y(pt,t,$),k(t,En,$),k(t,qe,$),e(qe,js),e(qe,Ut),e(Ut,Es),e(qe,qs),k(t,qn,$),k(t,fe,$),e(fe,Re),e(Re,fo),y(ct,fo,null),e(fe,Rs),e(fe,ho),e(ho,Fs),k(t,Rn,$),k(t,Z,$),e(Z,zs),e(Z,Yt),e(Yt,Cs),e(Z,As),e(Z,dt),e(dt,Ps),e(Z,Is),e(Z,go),e(go,Ns),e(Z,Ss),k(t,Fn,$),y(ut,t,$),k(t,zn,$),k(t,he,$),e(he,Fe),e(Fe,_o),y(ft,_o,null),e(he,Ds),e(he,$o),e($o,Ls),k(t,Cn,$),k(t,V,$),y(ht,V,null),e(V,Hs),e(V,gt),e(gt,Qs),e(gt,ko),e(ko,Xs),e(gt,Ws),e(V,Bs),e(V,ze),y(_t,ze,null),e(ze,Gs),e(ze,$t),e($t,Vs),e($t,wo),e(wo,Js),e($t,Us),e(V,Ys),e(V,Ce),y(kt,Ce,null),e(Ce,Zs),e(Ce,vo),e(vo,Ks),k(t,An,$),k(t,ge,$),e(ge,Ae),e(Ae,xo),y(wt,xo,null),e(ge,er),e(ge,To),e(To,tr),k(t,Pn,$),k(t,A,$),y(vt,A,null),e(A,or),e(A,bo),e(bo,nr),e(A,sr),e(A,xt),e(xt,rr),e(xt,Mo),e(Mo,ar),e(xt,ir),e(A,lr),e(A,Oo),e(Oo,mr),e(A,pr),e(A,Q),y(Tt,Q,null),e(Q,cr),e(Q,_e),e(_e,dr),e(_e,yo),e(yo,ur),e(_e,fr),e(_e,jo),e(jo,hr),e(_e,gr),e(Q,_r),y(Pe,Q,null),e(Q,$r),y(Ie,Q,null),e(Q,kr),y(Ne,Q,null),k(t,In,$),k(t,$e,$),e($e,Se),e(Se,Eo),y(bt,Eo,null),e($e,wr),e($e,qo),e(qo,vr),k(t,Nn,$),k(t,P,$),y(Mt,P,null),e(P,xr),e(P,Ro),e(Ro,Tr),e(P,br),e(P,Ot),e(Ot,Mr),e(Ot,Fo),e(Fo,Or),e(Ot,yr),e(P,jr),e(P,zo),e(zo,Er),e(P,qr),e(P,X),y(yt,X,null),e(X,Rr),e(X,ke),e(ke,Fr),e(ke,Co),e(Co,zr),e(ke,Cr),e(ke,Ao),e(Ao,Ar),e(ke,Pr),e(X,Ir),y(De,X,null),e(X,Nr),y(Le,X,null),e(X,Sr),y(He,X,null),k(t,Sn,$),k(t,we,$),e(we,Qe),e(Qe,Po),y(jt,Po,null),e(we,Dr),e(we,Io),e(Io,Lr),k(t,Dn,$),k(t,I,$),y(Et,I,null),e(I,Hr),e(I,No),e(No,Qr),e(I,Xr),e(I,qt),e(qt,Wr),e(qt,So),e(So,Br),e(qt,Gr),e(I,Vr),e(I,Do),e(Do,Jr),e(I,Ur),e(I,z),y(Rt,z,null),e(z,Yr),e(z,ve),e(ve,Zr),e(ve,Lo),e(Lo,Kr),e(ve,ea),e(ve,Ho),e(Ho,ta),e(ve,oa),e(z,na),y(Xe,z,null),e(z,sa),y(We,z,null),e(z,ra),y(Be,z,null),e(z,aa),y(Ge,z,null),k(t,Ln,$),k(t,xe,$),e(xe,Ve),e(Ve,Qo),y(Ft,Qo,null),e(xe,ia),e(xe,Xo),e(Xo,la),k(t,Hn,$),k(t,N,$),y(zt,N,null),e(N,ma),e(N,Wo),e(Wo,pa),e(N,ca),e(N,Ct),e(Ct,da),e(Ct,Bo),e(Bo,ua),e(Ct,fa),e(N,ha),e(N,Go),e(Go,ga),e(N,_a),e(N,W),y(At,W,null),e(W,$a),e(W,Te),e(Te,ka),e(Te,Vo),e(Vo,wa),e(Te,va),e(Te,Jo),e(Jo,xa),e(Te,Ta),e(W,ba),y(Je,W,null),e(W,Ma),y(Ue,W,null),e(W,Oa),y(Ye,W,null),k(t,Qn,$),k(t,be,$),e(be,Ze),e(Ze,Uo),y(Pt,Uo,null),e(be,ya),e(be,Yo),e(Yo,ja),k(t,Xn,$),k(t,S,$),y(It,S,null),e(S,Ea),e(S,Zo),e(Zo,qa),e(S,Ra),e(S,Nt),e(Nt,Fa),e(Nt,Ko),e(Ko,za),e(Nt,Ca),e(S,Aa),e(S,en),e(en,Pa),e(S,Ia),e(S,B),y(St,B,null),e(B,Na),e(B,Me),e(Me,Sa),e(Me,tn),e(tn,Da),e(Me,La),e(Me,on),e(on,Ha),e(Me,Qa),e(B,Xa),y(Ke,B,null),e(B,Wa),y(et,B,null),e(B,Ba),y(tt,B,null),k(t,Wn,$),k(t,Oe,$),e(Oe,ot),e(ot,nn),y(Dt,nn,null),e(Oe,Ga),e(Oe,sn),e(sn,Va),k(t,Bn,$),k(t,D,$),y(Lt,D,null),e(D,Ja),e(D,rn),e(rn,Ua),e(D,Ya),e(D,Ht),e(Ht,Za),e(Ht,an),e(an,Ka),e(Ht,ei),e(D,ti),e(D,ln),e(ln,oi),e(D,ni),e(D,G),y(Qt,G,null),e(G,si),e(G,ye),e(ye,ri),e(ye,mn),e(mn,ai),e(ye,ii),e(ye,pn),e(pn,li),e(ye,mi),e(G,pi),y(nt,G,null),e(G,ci),y(st,G,null),e(G,di),y(rt,G,null),Gn=!0},p(t,[$]){const Xt={};$&2&&(Xt.$$scope={dirty:$,ctx:t}),Pe.$set(Xt);const cn={};$&2&&(cn.$$scope={dirty:$,ctx:t}),Ie.$set(cn);const dn={};$&2&&(dn.$$scope={dirty:$,ctx:t}),Ne.$set(dn);const un={};$&2&&(un.$$scope={dirty:$,ctx:t}),De.$set(un);const Wt={};$&2&&(Wt.$$scope={dirty:$,ctx:t}),Le.$set(Wt);const fn={};$&2&&(fn.$$scope={dirty:$,ctx:t}),He.$set(fn);const Bt={};$&2&&(Bt.$$scope={dirty:$,ctx:t}),Xe.$set(Bt);const hn={};$&2&&(hn.$$scope={dirty:$,ctx:t}),We.$set(hn);const gn={};$&2&&(gn.$$scope={dirty:$,ctx:t}),Be.$set(gn);const _n={};$&2&&(_n.$$scope={dirty:$,ctx:t}),Ge.$set(_n);const J={};$&2&&(J.$$scope={dirty:$,ctx:t}),Je.$set(J);const $n={};$&2&&($n.$$scope={dirty:$,ctx:t}),Ue.$set($n);const kn={};$&2&&(kn.$$scope={dirty:$,ctx:t}),Ye.$set(kn);const wn={};$&2&&(wn.$$scope={dirty:$,ctx:t}),Ke.$set(wn);const vn={};$&2&&(vn.$$scope={dirty:$,ctx:t}),et.$set(vn);const je={};$&2&&(je.$$scope={dirty:$,ctx:t}),tt.$set(je);const xn={};$&2&&(xn.$$scope={dirty:$,ctx:t}),nt.$set(xn);const Tn={};$&2&&(Tn.$$scope={dirty:$,ctx:t}),st.$set(Tn);const Gt={};$&2&&(Gt.$$scope={dirty:$,ctx:t}),rt.$set(Gt)},i(t){Gn||(T(n.$$.fragment,t),T(lt.$$.fragment,t),T(mt.$$.fragment,t),T(pt.$$.fragment,t),T(ct.$$.fragment,t),T(ut.$$.fragment,t),T(ft.$$.fragment,t),T(ht.$$.fragment,t),T(_t.$$.fragment,t),T(kt.$$.fragment,t),T(wt.$$.fragment,t),T(vt.$$.fragment,t),T(Tt.$$.fragment,t),T(Pe.$$.fragment,t),T(Ie.$$.fragment,t),T(Ne.$$.fragment,t),T(bt.$$.fragment,t),T(Mt.$$.fragment,t),T(yt.$$.fragment,t),T(De.$$.fragment,t),T(Le.$$.fragment,t),T(He.$$.fragment,t),T(jt.$$.fragment,t),T(Et.$$.fragment,t),T(Rt.$$.fragment,t),T(Xe.$$.fragment,t),T(We.$$.fragment,t),T(Be.$$.fragment,t),T(Ge.$$.fragment,t),T(Ft.$$.fragment,t),T(zt.$$.fragment,t),T(At.$$.fragment,t),T(Je.$$.fragment,t),T(Ue.$$.fragment,t),T(Ye.$$.fragment,t),T(Pt.$$.fragment,t),T(It.$$.fragment,t),T(St.$$.fragment,t),T(Ke.$$.fragment,t),T(et.$$.fragment,t),T(tt.$$.fragment,t),T(Dt.$$.fragment,t),T(Lt.$$.fragment,t),T(Qt.$$.fragment,t),T(nt.$$.fragment,t),T(st.$$.fragment,t),T(rt.$$.fragment,t),Gn=!0)},o(t){b(n.$$.fragment,t),b(lt.$$.fragment,t),b(mt.$$.fragment,t),b(pt.$$.fragment,t),b(ct.$$.fragment,t),b(ut.$$.fragment,t),b(ft.$$.fragment,t),b(ht.$$.fragment,t),b(_t.$$.fragment,t),b(kt.$$.fragment,t),b(wt.$$.fragment,t),b(vt.$$.fragment,t),b(Tt.$$.fragment,t),b(Pe.$$.fragment,t),b(Ie.$$.fragment,t),b(Ne.$$.fragment,t),b(bt.$$.fragment,t),b(Mt.$$.fragment,t),b(yt.$$.fragment,t),b(De.$$.fragment,t),b(Le.$$.fragment,t),b(He.$$.fragment,t),b(jt.$$.fragment,t),b(Et.$$.fragment,t),b(Rt.$$.fragment,t),b(Xe.$$.fragment,t),b(We.$$.fragment,t),b(Be.$$.fragment,t),b(Ge.$$.fragment,t),b(Ft.$$.fragment,t),b(zt.$$.fragment,t),b(At.$$.fragment,t),b(Je.$$.fragment,t),b(Ue.$$.fragment,t),b(Ye.$$.fragment,t),b(Pt.$$.fragment,t),b(It.$$.fragment,t),b(St.$$.fragment,t),b(Ke.$$.fragment,t),b(et.$$.fragment,t),b(tt.$$.fragment,t),b(Dt.$$.fragment,t),b(Lt.$$.fragment,t),b(Qt.$$.fragment,t),b(nt.$$.fragment,t),b(st.$$.fragment,t),b(rt.$$.fragment,t),Gn=!1},d(t){o(s),t&&o(_),t&&o(d),j(n),t&&o(w),t&&o(q),t&&o(bn),t&&o(ue),j(lt),t&&o(Mn),t&&o(H),t&&o(On),j(mt,t),t&&o(yn),t&&o(te),t&&o(jn),j(pt,t),t&&o(En),t&&o(qe),t&&o(qn),t&&o(fe),j(ct),t&&o(Rn),t&&o(Z),t&&o(Fn),j(ut,t),t&&o(zn),t&&o(he),j(ft),t&&o(Cn),t&&o(V),j(ht),j(_t),j(kt),t&&o(An),t&&o(ge),j(wt),t&&o(Pn),t&&o(A),j(vt),j(Tt),j(Pe),j(Ie),j(Ne),t&&o(In),t&&o($e),j(bt),t&&o(Nn),t&&o(P),j(Mt),j(yt),j(De),j(Le),j(He),t&&o(Sn),t&&o(we),j(jt),t&&o(Dn),t&&o(I),j(Et),j(Rt),j(Xe),j(We),j(Be),j(Ge),t&&o(Ln),t&&o(xe),j(Ft),t&&o(Hn),t&&o(N),j(zt),j(At),j(Je),j(Ue),j(Ye),t&&o(Qn),t&&o(be),j(Pt),t&&o(Xn),t&&o(S),j(It),j(St),j(Ke),j(et),j(tt),t&&o(Wn),t&&o(Oe),j(Dt),t&&o(Bn),t&&o(D),j(Lt),j(Qt),j(nt),j(st),j(rt)}}}const om={local:"optimum-inference-with-onnx-runtime",sections:[{local:"switching-from-transformers-to-optimum-inference",sections:[{local:"working-with-the-hugging-face-model-hub",title:"Working with the Hugging Face Model Hub"}],title:"Switching from Transformers to Optimum Inference"},{local:"optimum.onnxruntime.ORTModel",title:"ORTModel"},{local:"optimum.onnxruntime.ORTModelForFeatureExtraction",title:"ORTModelForFeatureExtraction"},{local:"optimum.onnxruntime.ORTModelForQuestionAnswering",title:"ORTModelForQuestionAnswering"},{local:"optimum.onnxruntime.ORTModelForSequenceClassification",title:"ORTModelForSequenceClassification"},{local:"optimum.onnxruntime.ORTModelForTokenClassification",title:"ORTModelForTokenClassification"},{local:"optimum.onnxruntime.ORTModelForCausalLM",title:"ORTModelForCausalLM"},{local:"optimum.onnxruntime.ORTModelForImageClassification",title:"ORTModelForImageClassification"}],title:"Optimum Inference with ONNX Runtime"};function nm(E){return bl(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class mm extends vl{constructor(s){super();xl(this,s,nm,tm,Tl,{})}}export{mm as default,om as metadata};
