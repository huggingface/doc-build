import{S as Nl,i as Ll,s as Ql,e as a,k as f,w as k,t as m,M as Wl,c as i,d as o,m as g,a as l,x,h as p,b as q,G as e,g as O,y as w,q as b,o as T,B as M,v as Xl,L}from"../../../chunks/vendor-hf-doc-builder.js";import{T as lo}from"../../../chunks/Tip-hf-doc-builder.js";import{D as j}from"../../../chunks/Docstring-hf-doc-builder.js";import{C as Q}from"../../../chunks/CodeBlock-hf-doc-builder.js";import{I as Te}from"../../../chunks/IconCopyLink-hf-doc-builder.js";import{E as N}from"../../../chunks/ExampleCodeBlock-hf-doc-builder.js";function Bl(E){let s,_,d,u,h;return{c(){s=a("p"),_=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),d=a("code"),u=m("Module"),h=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Although the recipe for forward pass needs to be defined within this function, one should call the "),d=i(r,"CODE",{});var y=l(d);u=p(y,"Module"),y.forEach(o),h=p(r,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),r.forEach(o)},m(n,r){O(n,s,r),e(s,_),e(s,d),e(d,u),e(s,h)},d(n){n&&o(s)}}}function Hl(E){let s,_,d,u,h;return u=new Q({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForFeatureExtraction
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/all-MiniLM-L6-v2")
model = ORTModelForFeatureExtraction.from_pretrained("optimum/all-MiniLM-L6-v2")

inputs = tokenizer("My name is Philipp and I live in Germany.", return_tensors="pt")

outputs = model(**inputs)
logits = outputs.logits
list(logits.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForFeatureExtraction
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForFeatureExtraction.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(logits.shape)`}}),{c(){s=a("p"),_=m("Example of feature extraction:"),d=f(),k(u.$$.fragment)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Example of feature extraction:"),r.forEach(o),d=g(n),x(u.$$.fragment,n)},m(n,r){O(n,s,r),e(s,_),O(n,d,r),w(u,n,r),h=!0},p:L,i(n){h||(b(u.$$.fragment,n),h=!0)},o(n){T(u.$$.fragment,n),h=!1},d(n){n&&o(s),n&&o(d),M(u,n)}}}function Vl(E){let s,_,d,u,h,n,r,y;return r=new Q({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForFeatureExtraction

tokenizer = AutoTokenizer.from_pretrained("optimum/all-MiniLM-L6-v2")
model = ORTModelForFeatureExtraction.from_pretrained("optimum/all-MiniLM-L6-v2")
onnx_extractor = pipeline("feature-extraction", model=model, tokenizer=tokenizer)

text = "My name is Philipp and I live in Germany."
pred = onnx_extractor(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForFeatureExtraction

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForFeatureExtraction.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_extractor = pipeline(<span class="hljs-string">&quot;feature-extraction&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_extractor(text)`}}),{c(){s=a("p"),_=m("Example using "),d=a("code"),u=m("transformers.pipeline"),h=m(":"),n=f(),k(r.$$.fragment)},l(c){s=i(c,"P",{});var v=l(s);_=p(v,"Example using "),d=i(v,"CODE",{});var R=l(d);u=p(R,"transformers.pipeline"),R.forEach(o),h=p(v,":"),v.forEach(o),n=g(c),x(r.$$.fragment,c)},m(c,v){O(c,s,v),e(s,_),e(s,d),e(d,u),e(s,h),O(c,n,v),w(r,c,v),y=!0},p:L,i(c){y||(b(r.$$.fragment,c),y=!0)},o(c){T(r.$$.fragment,c),y=!1},d(c){c&&o(s),c&&o(n),M(r,c)}}}function Ul(E){let s,_,d,u,h;return{c(){s=a("p"),_=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),d=a("code"),u=m("Module"),h=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Although the recipe for forward pass needs to be defined within this function, one should call the "),d=i(r,"CODE",{});var y=l(d);u=p(y,"Module"),y.forEach(o),h=p(r,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),r.forEach(o)},m(n,r){O(n,s,r),e(s,_),e(s,d),e(d,u),e(s,h)},d(n){n&&o(s)}}}function Gl(E){let s,_,d,u,h;return u=new Q({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForQuestionAnswering
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/roberta-base-squad2")
model = ORTModelForQuestionAnswering.from_pretrained("optimum/roberta-base-squad2")

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"
inputs = tokenizer(question, text, return_tensors="pt")
start_positions = torch.tensor([1])
end_positions = torch.tensor([3])

outputs = model(**inputs, start_positions=start_positions, end_positions=end_positions)
start_scores = outputs.start_logits
end_scores = outputs.end_logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForQuestionAnswering
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(question, text, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>start_positions = torch.tensor([<span class="hljs-number">1</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>end_positions = torch.tensor([<span class="hljs-number">3</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, start_positions=start_positions, end_positions=end_positions)
<span class="hljs-meta">&gt;&gt;&gt; </span>start_scores = outputs.start_logits
<span class="hljs-meta">&gt;&gt;&gt; </span>end_scores = outputs.end_logits`}}),{c(){s=a("p"),_=m("Example of question answering:"),d=f(),k(u.$$.fragment)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Example of question answering:"),r.forEach(o),d=g(n),x(u.$$.fragment,n)},m(n,r){O(n,s,r),e(s,_),O(n,d,r),w(u,n,r),h=!0},p:L,i(n){h||(b(u.$$.fragment,n),h=!0)},o(n){T(u.$$.fragment,n),h=!1},d(n){n&&o(s),n&&o(d),M(u,n)}}}function Jl(E){let s,_,d,u,h,n,r,y;return r=new Q({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForQuestionAnswering

tokenizer = AutoTokenizer.from_pretrained("optimum/roberta-base-squad2")
model = ORTModelForQuestionAnswering.from_pretrained("optimum/roberta-base-squad2")
onnx_qa = pipeline("question-answering", model=model, tokenizer=tokenizer)

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"
pred = onnx_qa(question, text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForQuestionAnswering

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_qa = pipeline(<span class="hljs-string">&quot;question-answering&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_qa(question, text)`}}),{c(){s=a("p"),_=m("Example using "),d=a("code"),u=m("transformers.pipeline"),h=m(":"),n=f(),k(r.$$.fragment)},l(c){s=i(c,"P",{});var v=l(s);_=p(v,"Example using "),d=i(v,"CODE",{});var R=l(d);u=p(R,"transformers.pipeline"),R.forEach(o),h=p(v,":"),v.forEach(o),n=g(c),x(r.$$.fragment,c)},m(c,v){O(c,s,v),e(s,_),e(s,d),e(d,u),e(s,h),O(c,n,v),w(r,c,v),y=!0},p:L,i(c){y||(b(r.$$.fragment,c),y=!0)},o(c){T(r.$$.fragment,c),y=!1},d(c){c&&o(s),c&&o(n),M(r,c)}}}function Yl(E){let s,_,d,u,h;return{c(){s=a("p"),_=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),d=a("code"),u=m("Module"),h=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Although the recipe for forward pass needs to be defined within this function, one should call the "),d=i(r,"CODE",{});var y=l(d);u=p(y,"Module"),y.forEach(o),h=p(r,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),r.forEach(o)},m(n,r){O(n,s,r),e(s,_),e(s,d),e(d,u),e(s,h)},d(n){n&&o(s)}}}function Kl(E){let s,_,d,u,h;return u=new Q({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForSequenceClassification
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")
model = ORTModelForSequenceClassification.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")

outputs = model(**inputs)
logits = outputs.logits
list(logits.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSequenceClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(logits.shape)`}}),{c(){s=a("p"),_=m("Example of single-label classification:"),d=f(),k(u.$$.fragment)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Example of single-label classification:"),r.forEach(o),d=g(n),x(u.$$.fragment,n)},m(n,r){O(n,s,r),e(s,_),O(n,d,r),w(u,n,r),h=!0},p:L,i(n){h||(b(u.$$.fragment,n),h=!0)},o(n){T(u.$$.fragment,n),h=!1},d(n){n&&o(s),n&&o(d),M(u,n)}}}function Zl(E){let s,_,d,u,h,n,r,y;return r=new Q({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForSequenceClassification

tokenizer = AutoTokenizer.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")
model = ORTModelForSequenceClassification.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")
onnx_classifier = pipeline("text-classification", model=model, tokenizer=tokenizer)

text = "Hello, my dog is cute"
pred = onnx_classifier(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_classifier = pipeline(<span class="hljs-string">&quot;text-classification&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_classifier(text)`}}),{c(){s=a("p"),_=m("Example using "),d=a("code"),u=m("transformers.pipelines"),h=m(":"),n=f(),k(r.$$.fragment)},l(c){s=i(c,"P",{});var v=l(s);_=p(v,"Example using "),d=i(v,"CODE",{});var R=l(d);u=p(R,"transformers.pipelines"),R.forEach(o),h=p(v,":"),v.forEach(o),n=g(c),x(r.$$.fragment,c)},m(c,v){O(c,s,v),e(s,_),e(s,d),e(d,u),e(s,h),O(c,n,v),w(r,c,v),y=!0},p:L,i(c){y||(b(r.$$.fragment,c),y=!0)},o(c){T(r.$$.fragment,c),y=!1},d(c){c&&o(s),c&&o(n),M(r,c)}}}function em(E){let s,_,d,u,h,n,r,y;return r=new Q({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForSequenceClassification

tokenizer = AutoTokenizer.from_pretrained("optimum/distilbert-base-uncased-mnli")
model = ORTModelForSequenceClassification.from_pretrained("optimum/distilbert-base-uncased-mnli")
onnx_z0 = pipeline("zero-shot-classification", model=model, tokenizer=tokenizer)

sequence_to_classify = "Who are you voting for in 2020?"
candidate_labels = ["Europe", "public health", "politics", "elections"]
pred = onnx_z0(sequence_to_classify, candidate_labels, multi_class=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-mnli&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-mnli&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_z0 = pipeline(<span class="hljs-string">&quot;zero-shot-classification&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>sequence_to_classify = <span class="hljs-string">&quot;Who are you voting for in 2020?&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>candidate_labels = [<span class="hljs-string">&quot;Europe&quot;</span>, <span class="hljs-string">&quot;public health&quot;</span>, <span class="hljs-string">&quot;politics&quot;</span>, <span class="hljs-string">&quot;elections&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_z0(sequence_to_classify, candidate_labels, multi_class=<span class="hljs-literal">True</span>)`}}),{c(){s=a("p"),_=m("Example using zero-shot-classification "),d=a("code"),u=m("transformers.pipelines"),h=m(":"),n=f(),k(r.$$.fragment)},l(c){s=i(c,"P",{});var v=l(s);_=p(v,"Example using zero-shot-classification "),d=i(v,"CODE",{});var R=l(d);u=p(R,"transformers.pipelines"),R.forEach(o),h=p(v,":"),v.forEach(o),n=g(c),x(r.$$.fragment,c)},m(c,v){O(c,s,v),e(s,_),e(s,d),e(d,u),e(s,h),O(c,n,v),w(r,c,v),y=!0},p:L,i(c){y||(b(r.$$.fragment,c),y=!0)},o(c){T(r.$$.fragment,c),y=!1},d(c){c&&o(s),c&&o(n),M(r,c)}}}function tm(E){let s,_,d,u,h;return{c(){s=a("p"),_=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),d=a("code"),u=m("Module"),h=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Although the recipe for forward pass needs to be defined within this function, one should call the "),d=i(r,"CODE",{});var y=l(d);u=p(y,"Module"),y.forEach(o),h=p(r,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),r.forEach(o)},m(n,r){O(n,s,r),e(s,_),e(s,d),e(d,u),e(s,h)},d(n){n&&o(s)}}}function om(E){let s,_,d,u,h;return u=new Q({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForTokenClassification
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/bert-base-NER")
model = ORTModelForTokenClassification.from_pretrained("optimum/bert-base-NER")

inputs = tokenizer("My name is Philipp and I live in Germany.", return_tensors="pt")

outputs = model(**inputs)
logits = outputs.logits
list(logits.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForTokenClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(logits.shape)`}}),{c(){s=a("p"),_=m("Example of token classification:"),d=f(),k(u.$$.fragment)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Example of token classification:"),r.forEach(o),d=g(n),x(u.$$.fragment,n)},m(n,r){O(n,s,r),e(s,_),O(n,d,r),w(u,n,r),h=!0},p:L,i(n){h||(b(u.$$.fragment,n),h=!0)},o(n){T(u.$$.fragment,n),h=!1},d(n){n&&o(s),n&&o(d),M(u,n)}}}function nm(E){let s,_,d,u,h,n,r,y;return r=new Q({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForTokenClassification

tokenizer = AutoTokenizer.from_pretrained("optimum/bert-base-NER")
model = ORTModelForTokenClassification.from_pretrained("optimum/bert-base-NER")
onnx_ner = pipeline("token-classification", model=model, tokenizer=tokenizer)

text = "My name is Philipp and I live in Germany."
pred = onnx_ner(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForTokenClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_ner = pipeline(<span class="hljs-string">&quot;token-classification&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_ner(text)`}}),{c(){s=a("p"),_=m("Example using "),d=a("code"),u=m("transformers.pipelines"),h=m(":"),n=f(),k(r.$$.fragment)},l(c){s=i(c,"P",{});var v=l(s);_=p(v,"Example using "),d=i(v,"CODE",{});var R=l(d);u=p(R,"transformers.pipelines"),R.forEach(o),h=p(v,":"),v.forEach(o),n=g(c),x(r.$$.fragment,c)},m(c,v){O(c,s,v),e(s,_),e(s,d),e(d,u),e(s,h),O(c,n,v),w(r,c,v),y=!0},p:L,i(c){y||(b(r.$$.fragment,c),y=!0)},o(c){T(r.$$.fragment,c),y=!1},d(c){c&&o(s),c&&o(n),M(r,c)}}}function sm(E){let s,_,d,u,h;return{c(){s=a("p"),_=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),d=a("code"),u=m("Module"),h=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Although the recipe for forward pass needs to be defined within this function, one should call the "),d=i(r,"CODE",{});var y=l(d);u=p(y,"Module"),y.forEach(o),h=p(r,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),r.forEach(o)},m(n,r){O(n,s,r),e(s,_),e(s,d),e(d,u),e(s,h)},d(n){n&&o(s)}}}function rm(E){let s,_,d,u,h;return u=new Q({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForCausalLM
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/gpt2")
model = ORTModelForCausalLM.from_pretrained("optimum/gpt2")

inputs = tokenizer("My name is Philipp and I live in Germany.", return_tensors="pt")

gen_tokens = model.generate(**inputs,do_sample=True,temperature=0.9, min_length=20,max_length=20)
tokenizer.batch_decode(gen_tokens)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForCausalLM
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/gpt2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForCausalLM.from_pretrained(<span class="hljs-string">&quot;optimum/gpt2&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>gen_tokens = model.generate(**inputs,do_sample=<span class="hljs-literal">True</span>,temperature=<span class="hljs-number">0.9</span>, min_length=<span class="hljs-number">20</span>,max_length=<span class="hljs-number">20</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.batch_decode(gen_tokens)`}}),{c(){s=a("p"),_=m("Example of text generation:"),d=f(),k(u.$$.fragment)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Example of text generation:"),r.forEach(o),d=g(n),x(u.$$.fragment,n)},m(n,r){O(n,s,r),e(s,_),O(n,d,r),w(u,n,r),h=!0},p:L,i(n){h||(b(u.$$.fragment,n),h=!0)},o(n){T(u.$$.fragment,n),h=!1},d(n){n&&o(s),n&&o(d),M(u,n)}}}function am(E){let s,_,d,u,h,n,r,y;return r=new Q({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForCausalLM

tokenizer = AutoTokenizer.from_pretrained("optimum/gpt2")
model = ORTModelForCausalLM.from_pretrained("optimum/gpt2")
onnx_gen = pipeline("text-generation", model=model, tokenizer=tokenizer)

text = "My name is Philipp and I live in Germany."
gen = onnx_gen(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForCausalLM

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/gpt2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForCausalLM.from_pretrained(<span class="hljs-string">&quot;optimum/gpt2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_gen = pipeline(<span class="hljs-string">&quot;text-generation&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;My name is Philipp and I live in Germany.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>gen = onnx_gen(text)`}}),{c(){s=a("p"),_=m("Example using "),d=a("code"),u=m("transformers.pipelines"),h=m(":"),n=f(),k(r.$$.fragment)},l(c){s=i(c,"P",{});var v=l(s);_=p(v,"Example using "),d=i(v,"CODE",{});var R=l(d);u=p(R,"transformers.pipelines"),R.forEach(o),h=p(v,":"),v.forEach(o),n=g(c),x(r.$$.fragment,c)},m(c,v){O(c,s,v),e(s,_),e(s,d),e(d,u),e(s,h),O(c,n,v),w(r,c,v),y=!0},p:L,i(c){y||(b(r.$$.fragment,c),y=!0)},o(c){T(r.$$.fragment,c),y=!1},d(c){c&&o(s),c&&o(n),M(r,c)}}}function im(E){let s,_,d,u,h;return{c(){s=a("p"),_=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),d=a("code"),u=m("Module"),h=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Although the recipe for forward pass needs to be defined within this function, one should call the "),d=i(r,"CODE",{});var y=l(d);u=p(y,"Module"),y.forEach(o),h=p(r,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),r.forEach(o)},m(n,r){O(n,s,r),e(s,_),e(s,d),e(d,u),e(s,h)},d(n){n&&o(s)}}}function lm(E){let s,_,d,u,h;return u=new Q({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForSeq2SeqLM

tokenizer = AutoTokenizer.from_pretrained("optimum/t5-small")
model = ORTModelForSeq2SeqLM.from_pretrained("optimum/t5-small")

inputs = tokenizer("My name is Eustache and I like to", return_tensors="pt")

gen_tokens = model.generate(**inputs)
outputs = tokenizer.batch_decode(gen_tokens)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSeq2SeqLM

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/t5-small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSeq2SeqLM.from_pretrained(<span class="hljs-string">&quot;optimum/t5-small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;My name is Eustache and I like to&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>gen_tokens = model.generate(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = tokenizer.batch_decode(gen_tokens)`}}),{c(){s=a("p"),_=m("Example of text generation:"),d=f(),k(u.$$.fragment)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Example of text generation:"),r.forEach(o),d=g(n),x(u.$$.fragment,n)},m(n,r){O(n,s,r),e(s,_),O(n,d,r),w(u,n,r),h=!0},p:L,i(n){h||(b(u.$$.fragment,n),h=!0)},o(n){T(u.$$.fragment,n),h=!1},d(n){n&&o(s),n&&o(d),M(u,n)}}}function mm(E){let s,_,d,u,h,n,r,y;return r=new Q({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForSeq2SeqLM

tokenizer = AutoTokenizer.from_pretrained("optimum/t5-small")
model = ORTModelForSeq2SeqLM.from_pretrained("optimum/t5-small")
onnx_translation = pipeline("translation_en_to_de", model=model, tokenizer=tokenizer)

text = "My name is Eustache."
pred = onnx_translation(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSeq2SeqLM

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/t5-small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSeq2SeqLM.from_pretrained(<span class="hljs-string">&quot;optimum/t5-small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_translation = pipeline(<span class="hljs-string">&quot;translation_en_to_de&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;My name is Eustache.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_translation(text)`}}),{c(){s=a("p"),_=m("Example using "),d=a("code"),u=m("transformers.pipeline"),h=m(":"),n=f(),k(r.$$.fragment)},l(c){s=i(c,"P",{});var v=l(s);_=p(v,"Example using "),d=i(v,"CODE",{});var R=l(d);u=p(R,"transformers.pipeline"),R.forEach(o),h=p(v,":"),v.forEach(o),n=g(c),x(r.$$.fragment,c)},m(c,v){O(c,s,v),e(s,_),e(s,d),e(d,u),e(s,h),O(c,n,v),w(r,c,v),y=!0},p:L,i(c){y||(b(r.$$.fragment,c),y=!0)},o(c){T(r.$$.fragment,c),y=!1},d(c){c&&o(s),c&&o(n),M(r,c)}}}function pm(E){let s,_,d,u,h;return{c(){s=a("p"),_=m("Although the recipe for forward pass needs to be defined within this function, one should call the "),d=a("code"),u=m("Module"),h=m(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Although the recipe for forward pass needs to be defined within this function, one should call the "),d=i(r,"CODE",{});var y=l(d);u=p(y,"Module"),y.forEach(o),h=p(r,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),r.forEach(o)},m(n,r){O(n,s,r),e(s,_),e(s,d),e(d,u),e(s,h)},d(n){n&&o(s)}}}function dm(E){let s,_,d,u,h;return u=new Q({props:{code:`import requests
from PIL import Image
from optimum.onnxruntime import ORTModelForImageClassification
from transformers import AutoFeatureExtractor

url = "http://images.cocodataset.org/val2017/000000039769.jpg"
image = Image.open(requests.get(url, stream=True).raw)

preprocessor = AutoFeatureExtractor.from_pretrained("optimum/vit-base-patch16-224")
model = ORTModelForImageClassification.from_pretrained("optimum/vit-base-patch16-224")

inputs = preprocessor(images=image, return_tensors="pt")

outputs = model(**inputs)
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> requests
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForImageClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoFeatureExtractor

<span class="hljs-meta">&gt;&gt;&gt; </span>url = <span class="hljs-string">&quot;http://images.cocodataset.org/val2017/000000039769.jpg&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>image = Image.<span class="hljs-built_in">open</span>(requests.get(url, stream=<span class="hljs-literal">True</span>).raw)

<span class="hljs-meta">&gt;&gt;&gt; </span>preprocessor = AutoFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;optimum/vit-base-patch16-224&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForImageClassification.from_pretrained(<span class="hljs-string">&quot;optimum/vit-base-patch16-224&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = preprocessor(images=image, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),{c(){s=a("p"),_=m("Example of image classification:"),d=f(),k(u.$$.fragment)},l(n){s=i(n,"P",{});var r=l(s);_=p(r,"Example of image classification:"),r.forEach(o),d=g(n),x(u.$$.fragment,n)},m(n,r){O(n,s,r),e(s,_),O(n,d,r),w(u,n,r),h=!0},p:L,i(n){h||(b(u.$$.fragment,n),h=!0)},o(n){T(u.$$.fragment,n),h=!1},d(n){n&&o(s),n&&o(d),M(u,n)}}}function cm(E){let s,_,d,u,h,n,r,y;return r=new Q({props:{code:`import requests
from PIL import Image
from transformers import AutoFeatureExtractor, pipeline
from optimum.onnxruntime import ORTModelForImageClassification

preprocessor = AutoFeatureExtractor.from_pretrained("optimum/vit-base-patch16-224")
model = ORTModelForImageClassification.from_pretrained("optimum/vit-base-patch16-224")
onnx_image_classifier = pipeline("image-classification", model=model, feature_extractor=preprocessor)

url = "http://images.cocodataset.org/val2017/000000039769.jpg"
pred = onnx_image_classifier(url)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> requests
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoFeatureExtractor, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForImageClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>preprocessor = AutoFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;optimum/vit-base-patch16-224&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForImageClassification.from_pretrained(<span class="hljs-string">&quot;optimum/vit-base-patch16-224&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_image_classifier = pipeline(<span class="hljs-string">&quot;image-classification&quot;</span>, model=model, feature_extractor=preprocessor)

<span class="hljs-meta">&gt;&gt;&gt; </span>url = <span class="hljs-string">&quot;http://images.cocodataset.org/val2017/000000039769.jpg&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_image_classifier(url)`}}),{c(){s=a("p"),_=m("Example using "),d=a("code"),u=m("transformers.pipeline"),h=m(":"),n=f(),k(r.$$.fragment)},l(c){s=i(c,"P",{});var v=l(s);_=p(v,"Example using "),d=i(v,"CODE",{});var R=l(d);u=p(R,"transformers.pipeline"),R.forEach(o),h=p(v,":"),v.forEach(o),n=g(c),x(r.$$.fragment,c)},m(c,v){O(c,s,v),e(s,_),e(s,d),e(d,u),e(s,h),O(c,n,v),w(r,c,v),y=!0},p:L,i(c){y||(b(r.$$.fragment,c),y=!0)},o(c){T(r.$$.fragment,c),y=!1},d(c){c&&o(s),c&&o(n),M(r,c)}}}function um(E){let s,_,d,u,h,n,r,y,c,v,R,Me,$o,dt,xs,vo,ws,In,D,ct,bs,ut,Ts,ko,Ms,Os,ys,Oe,ft,qs,xo,Es,Rs,ye,gt,js,ht,Fs,wo,zs,Cs,Ps,qe,_t,As,bo,Ss,Dn,pe,Ee,To,$t,Is,Mo,Ds,Nn,z,vt,Ns,Oo,Ls,Qs,kt,Ws,yo,Xs,Bs,Hs,qo,Vs,Us,W,xt,Gs,de,Js,Eo,Ys,Ks,Ro,Zs,er,tr,Re,or,je,nr,Fe,sr,ze,wt,rr,bt,ar,jo,ir,lr,Ln,ce,Ce,Fo,Tt,mr,zo,pr,Qn,C,Mt,dr,Co,cr,ur,Ot,fr,Po,gr,hr,_r,Ao,$r,vr,X,yt,kr,ue,xr,So,wr,br,Io,Tr,Mr,Or,Pe,yr,Ae,qr,Se,Er,Ie,qt,Rr,Do,jr,Wn,fe,De,No,Et,Fr,Lo,zr,Xn,P,Rt,Cr,Qo,Pr,Ar,jt,Sr,Wo,Ir,Dr,Nr,Xo,Lr,Qr,I,Ft,Wr,ge,Xr,Bo,Br,Hr,Ho,Vr,Ur,Gr,Ne,Jr,Le,Yr,Qe,Kr,We,Zr,Xe,zt,ea,Vo,ta,Bn,he,Be,Uo,Ct,oa,Go,na,Hn,A,Pt,sa,Jo,ra,aa,At,ia,Yo,la,ma,pa,Ko,da,ca,B,St,ua,_e,fa,Zo,ga,ha,en,_a,$a,va,He,ka,Ve,xa,Ue,wa,Ge,It,ba,tn,Ta,Vn,$e,Je,on,Dt,Ma,nn,Oa,Un,F,Nt,ya,sn,qa,Ea,Lt,Ra,rn,ja,Fa,za,an,Ca,Pa,H,Qt,Aa,ve,Sa,ln,Ia,Da,mn,Na,La,Qa,Ye,Wa,Ke,Xa,Ze,Ba,et,Wt,Ha,Xt,Va,pn,Ua,Ga,Ja,tt,Bt,Ya,dn,Ka,Gn,ke,ot,cn,Ht,Za,un,ei,Jn,ne,Vt,ti,fn,oi,ni,V,Ut,si,xe,ri,gn,ai,ii,hn,li,mi,pi,nt,di,st,ci,rt,Yn,we,at,_n,Gt,ui,$n,fi,Kn,S,Jt,gi,vn,hi,_i,Yt,$i,kn,vi,ki,xi,xn,wi,bi,U,Kt,Ti,be,Mi,wn,Oi,yi,bn,qi,Ei,Ri,it,ji,lt,Fi,mt,zi,pt,Zt,Ci,Tn,Pi,Zn;return n=new Te({}),dt=new Te({}),ct=new j({props:{name:"class optimum.onnxruntime.ORTModel",anchor:"optimum.onnxruntime.ORTModel",parameters:[{name:"model",val:": InferenceSession = None"},{name:"config",val:": PretrainedConfig = None"},{name:"use_io_binding",val:": bool = True"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L109"}}),ft=new j({props:{name:"from_pretrained",anchor:"optimum.onnxruntime.ORTModel.from_pretrained",parameters:[{name:"model_id",val:": typing.Union[str, pathlib.Path]"},{name:"from_transformers",val:": bool = False"},{name:"force_download",val:": bool = False"},{name:"use_auth_token",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Optional[str] = None"},{name:"subfolder",val:": typing.Optional[str] = ''"},{name:"provider",val:": typing.Optional[str] = 'CPUExecutionProvider'"},{name:"session_options",val:": typing.Optional[onnxruntime.capi.onnxruntime_pybind11_state.SessionOptions] = None"},{name:"provider_options",val:": typing.Optional[typing.Dict] = None"},{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModel.from_pretrained.model_id",description:`<strong>model_id</strong> (<code>Union[str, Path]</code>) &#x2014;
Can be either:</p>
<ul>
<li>A string, the <em>model id</em> of a pretrained model hosted inside a model repo on huggingface.co.
Valid model ids can be located at the root-level, like <code>bert-base-uncased</code>, or namespaced under a
user or organization name, like <code>dbmdz/bert-base-german-cased</code>.</li>
<li>A path to a <em>directory</em> containing a model saved using <code>~OptimizedModel.save_pretrained</code>,
e.g., <code>./my_model_directory/</code>.</li>
</ul>`,name:"model_id"},{anchor:"optimum.onnxruntime.ORTModel.from_pretrained.from_transformers",description:`<strong>from_transformers</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Defines whether the provided <code>model_id</code> contains a vanilla Transformers checkpoint.`,name:"from_transformers"},{anchor:"optimum.onnxruntime.ORTModel.from_pretrained.force_download",description:`<strong>force_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to force the (re-)download of the model weights and configuration files, overriding the
cached versions if they exist.`,name:"force_download"},{anchor:"optimum.onnxruntime.ORTModel.from_pretrained.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
The token to use as HTTP bearer authorization for remote files. If <code>True</code>, will use the token generated
when running <code>transformers-cli login</code> (stored in <code>~/.huggingface</code>).`,name:"use_auth_token"},{anchor:"optimum.onnxruntime.ORTModel.from_pretrained.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
Path to a directory in which a downloaded pretrained model configuration should be cached if the
standard cache should not be used.`,name:"cache_dir"},{anchor:"optimum.onnxruntime.ORTModel.from_pretrained.local_files_only(bool,",description:`<strong>local_files_only(<code>bool</code>,</strong> <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to only look at local files (i.e., do not try to download the model).`,name:"local_files_only(bool,"},{anchor:"optimum.onnxruntime.ORTModel.from_pretrained.subfolder",description:`<strong>subfolder</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;&quot;</code>) &#x2014;
In case the relevant files are located inside a subfolder of the model repo either locally or on huggingface.co, you can
specify the folder name here.`,name:"subfolder"},{anchor:"optimum.onnxruntime.ORTModel.from_pretrained.provider",description:`<strong>provider</strong> (<code>str</code>, <em>optional</em>) &#x2014;
ONNX Runtime providers to use for loading the model. See <a href="https://onnxruntime.ai/docs/execution-providers/" rel="nofollow">https://onnxruntime.ai/docs/execution-providers/</a> for
possible providers. Defaults to <code>CPUExecutionProvider</code>.`,name:"provider"},{anchor:"optimum.onnxruntime.ORTModel.from_pretrained.session_options",description:`<strong>session_options</strong> (<code>onnxruntime.SessionOptions</code>, <em>optional</em>), &#x2014;
ONNX Runtime session options to use for loading the model. Defaults to <code>None</code>.`,name:"session_options"},{anchor:"optimum.onnxruntime.ORTModel.from_pretrained.provider_options",description:`<strong>provider_options</strong> (<code>Dict</code>, <strong>optional</strong>) &#x2014;
Provider option dictionaries corresponding to the provider used. See available options
for each provider: <a href="https://onnxruntime.ai/docs/api/c/group___global.html" rel="nofollow">https://onnxruntime.ai/docs/api/c/group___global.html</a> . Defaults to <code>None</code>.`,name:"provider_options"}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L240",returnDescription:`
<p>The loaded ORTModel model.</p>
`,returnType:`
<p><code>ORTModel</code></p>
`}}),gt=new j({props:{name:"load_model",anchor:"optimum.onnxruntime.ORTModel.load_model",parameters:[{name:"path",val:": typing.Union[str, pathlib.Path]"},{name:"provider",val:": typing.Optional[str] = 'CPUExecutionProvider'"},{name:"session_options",val:": typing.Optional[onnxruntime.capi.onnxruntime_pybind11_state.SessionOptions] = None"},{name:"provider_options",val:": typing.Optional[typing.Dict] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModel.load_model.path",description:`<strong>path</strong> (<code>str</code> or <code>Path</code>) &#x2014;
Path of the ONNX model.`,name:"path"},{anchor:"optimum.onnxruntime.ORTModel.load_model.provider",description:`<strong>provider</strong> (<code>str</code>, <em>optional</em>) &#x2014;
ONNX Runtime provider to use for loading the model. See <a href="https://onnxruntime.ai/docs/execution-providers/" rel="nofollow">https://onnxruntime.ai/docs/execution-providers/</a>
for possible providers. Defaults to <code>CPUExecutionProvider</code>.`,name:"provider"},{anchor:"optimum.onnxruntime.ORTModel.load_model.session_options",description:`<strong>session_options</strong> (<code>onnxruntime.SessionOptions</code>, <em>optional</em>) &#x2014;
ONNX Runtime session options to use for loading the model. Defaults to <code>None</code>.`,name:"session_options"},{anchor:"optimum.onnxruntime.ORTModel.load_model.provider_options",description:`<strong>provider_options</strong> (<code>Dict</code>, <strong>optional</strong>) &#x2014;
Provider option dictionary corresponding to the provider used. See available options
for each provider: <a href="https://onnxruntime.ai/docs/api/c/group___global.html" rel="nofollow">https://onnxruntime.ai/docs/api/c/group___global.html</a> . Defaults to <code>None</code>.`,name:"provider_options"}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L181"}}),_t=new j({props:{name:"to",anchor:"optimum.onnxruntime.ORTModel.to",parameters:[{name:"device",val:": typing.Union[torch.device, str, int]"}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModel.to.device",description:`<strong>device</strong> (<code>torch.device</code> or <code>str</code> or <code>int</code>) &#x2014;
Device ordinal for CPU/GPU supports. Setting this to -1 will leverage CPU, a positive will run
the model on the associated CUDA device id. You can pass native <code>torch.device</code> or a <code>str</code> too.`,name:"device"}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L157",returnDescription:`
<p>the model placed on the requested device.</p>
`,returnType:`
<p><code>ORTModel</code></p>
`}}),$t=new Te({}),vt=new j({props:{name:"class optimum.onnxruntime.ORTModelForFeatureExtraction",anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"use_io_binding",val:" = True"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.config",description:`<strong>config</strong> (<code>transformers.PretrainedConfig</code>) &#x2014; <a href="https://huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig" rel="nofollow">PretrainedConfig</a> is the Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/optimum/main/en/onnxruntime/package_reference/modeling_ort#optimum.onnxruntime.ORTModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.model",description:'<strong>model</strong> (<code>onnxruntime.InferenceSession</code>) &#x2014; <a href="https://onnxruntime.ai/docs/api/python/api_summary.html#inferencesession" rel="nofollow">onnxruntime.InferenceSession</a> is the main class used to run a model. Check out the <a href="/docs/optimum/main/en/onnxruntime/package_reference/modeling_ort#optimum.onnxruntime.ORTModel.load_model">load_model()</a> method for more information.',name:"model"},{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.use_io_binding",description:"<strong>use_io_binding</strong> (<code>bool</code>, <em>optional</em>) &#x2014; Whether to use IOBinding during inference to avoid memory copy between the host and devices. Defaults to <code>True</code> if the device is CUDA, otherwise defaults to <code>False</code>.",name:"use_io_binding"}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L459"}}),xt=new j({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L541"}}),Re=new lo({props:{$$slots:{default:[Bl]},$$scope:{ctx:E}}}),je=new N({props:{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward.example",$$slots:{default:[Hl]},$$scope:{ctx:E}}}),Fe=new N({props:{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward.example-2",$$slots:{default:[Vl]},$$scope:{ctx:E}}}),wt=new j({props:{name:"prepare_output_buffer",anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.prepare_output_buffer",parameters:[{name:"batch_size",val:""},{name:"sequence_length",val:""},{name:"hidden_size",val:""}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L474"}}),Tt=new Te({}),Mt=new j({props:{name:"class optimum.onnxruntime.ORTModelForQuestionAnswering",anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"use_io_binding",val:" = True"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.config",description:`<strong>config</strong> (<code>transformers.PretrainedConfig</code>) &#x2014; <a href="https://huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig" rel="nofollow">PretrainedConfig</a> is the Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/optimum/main/en/onnxruntime/package_reference/modeling_ort#optimum.onnxruntime.ORTModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.model",description:'<strong>model</strong> (<code>onnxruntime.InferenceSession</code>) &#x2014; <a href="https://onnxruntime.ai/docs/api/python/api_summary.html#inferencesession" rel="nofollow">onnxruntime.InferenceSession</a> is the main class used to run a model. Check out the <a href="/docs/optimum/main/en/onnxruntime/package_reference/modeling_ort#optimum.onnxruntime.ORTModel.load_model">load_model()</a> method for more information.',name:"model"},{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.use_io_binding",description:"<strong>use_io_binding</strong> (<code>bool</code>, <em>optional</em>) &#x2014; Whether to use IOBinding during inference to avoid memory copy between the host and devices. Defaults to <code>True</code> if the device is CUDA, otherwise defaults to <code>False</code>.",name:"use_io_binding"}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L629"}}),yt=new j({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L720"}}),Pe=new lo({props:{$$slots:{default:[Ul]},$$scope:{ctx:E}}}),Ae=new N({props:{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward.example",$$slots:{default:[Gl]},$$scope:{ctx:E}}}),Se=new N({props:{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward.example-2",$$slots:{default:[Jl]},$$scope:{ctx:E}}}),qt=new j({props:{name:"prepare_logits_buffer",anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.prepare_logits_buffer",parameters:[{name:"batch_size",val:""},{name:"sequence_length",val:""}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L644"}}),Et=new Te({}),Rt=new j({props:{name:"class optimum.onnxruntime.ORTModelForSequenceClassification",anchor:"optimum.onnxruntime.ORTModelForSequenceClassification",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"use_io_binding",val:" = True"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.config",description:`<strong>config</strong> (<code>transformers.PretrainedConfig</code>) &#x2014; <a href="https://huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig" rel="nofollow">PretrainedConfig</a> is the Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/optimum/main/en/onnxruntime/package_reference/modeling_ort#optimum.onnxruntime.ORTModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.model",description:'<strong>model</strong> (<code>onnxruntime.InferenceSession</code>) &#x2014; <a href="https://onnxruntime.ai/docs/api/python/api_summary.html#inferencesession" rel="nofollow">onnxruntime.InferenceSession</a> is the main class used to run a model. Check out the <a href="/docs/optimum/main/en/onnxruntime/package_reference/modeling_ort#optimum.onnxruntime.ORTModel.load_model">load_model()</a> method for more information.',name:"model"},{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.use_io_binding",description:"<strong>use_io_binding</strong> (<code>bool</code>, <em>optional</em>) &#x2014; Whether to use IOBinding during inference to avoid memory copy between the host and devices. Defaults to <code>True</code> if the device is CUDA, otherwise defaults to <code>False</code>.",name:"use_io_binding"}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L828"}}),Ft=new j({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L910"}}),Ne=new lo({props:{$$slots:{default:[Yl]},$$scope:{ctx:E}}}),Le=new N({props:{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.example",$$slots:{default:[Kl]},$$scope:{ctx:E}}}),Qe=new N({props:{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.example-2",$$slots:{default:[Zl]},$$scope:{ctx:E}}}),We=new N({props:{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.example-3",$$slots:{default:[em]},$$scope:{ctx:E}}}),zt=new j({props:{name:"prepare_logits_buffer",anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.prepare_logits_buffer",parameters:[{name:"batch_size",val:""},{name:"num_labels",val:""}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L844"}}),Ct=new Te({}),Pt=new j({props:{name:"class optimum.onnxruntime.ORTModelForTokenClassification",anchor:"optimum.onnxruntime.ORTModelForTokenClassification",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"use_io_binding",val:" = True"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.config",description:`<strong>config</strong> (<code>transformers.PretrainedConfig</code>) &#x2014; <a href="https://huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig" rel="nofollow">PretrainedConfig</a> is the Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/optimum/main/en/onnxruntime/package_reference/modeling_ort#optimum.onnxruntime.ORTModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.model",description:'<strong>model</strong> (<code>onnxruntime.InferenceSession</code>) &#x2014; <a href="https://onnxruntime.ai/docs/api/python/api_summary.html#inferencesession" rel="nofollow">onnxruntime.InferenceSession</a> is the main class used to run a model. Check out the <a href="/docs/optimum/main/en/onnxruntime/package_reference/modeling_ort#optimum.onnxruntime.ORTModel.load_model">load_model()</a> method for more information.',name:"model"},{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.use_io_binding",description:"<strong>use_io_binding</strong> (<code>bool</code>, <em>optional</em>) &#x2014; Whether to use IOBinding during inference to avoid memory copy between the host and devices. Defaults to <code>True</code> if the device is CUDA, otherwise defaults to <code>False</code>.",name:"use_io_binding"}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L998"}}),St=new j({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L1080"}}),He=new lo({props:{$$slots:{default:[tm]},$$scope:{ctx:E}}}),Ve=new N({props:{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward.example",$$slots:{default:[om]},$$scope:{ctx:E}}}),Ue=new N({props:{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward.example-2",$$slots:{default:[nm]},$$scope:{ctx:E}}}),It=new j({props:{name:"prepare_logits_buffer",anchor:"optimum.onnxruntime.ORTModelForTokenClassification.prepare_logits_buffer",parameters:[{name:"batch_size",val:""},{name:"sequence_length",val:""},{name:"num_labels",val:""}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L1013"}}),Dt=new Te({}),Nt=new j({props:{name:"class optimum.onnxruntime.ORTModelForCausalLM",anchor:"optimum.onnxruntime.ORTModelForCausalLM",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"use_io_binding",val:" = True"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForCausalLM.config",description:`<strong>config</strong> (<code>transformers.PretrainedConfig</code>) &#x2014; <a href="https://huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig" rel="nofollow">PretrainedConfig</a> is the Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/optimum/main/en/onnxruntime/package_reference/modeling_ort#optimum.onnxruntime.ORTModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForCausalLM.model",description:'<strong>model</strong> (<code>onnxruntime.InferenceSession</code>) &#x2014; <a href="https://onnxruntime.ai/docs/api/python/api_summary.html#inferencesession" rel="nofollow">onnxruntime.InferenceSession</a> is the main class used to run a model. Check out the <a href="/docs/optimum/main/en/onnxruntime/package_reference/modeling_ort#optimum.onnxruntime.ORTModel.load_model">load_model()</a> method for more information.',name:"model"},{anchor:"optimum.onnxruntime.ORTModelForCausalLM.use_io_binding",description:"<strong>use_io_binding</strong> (<code>bool</code>, <em>optional</em>) &#x2014; Whether to use IOBinding during inference to avoid memory copy between the host and devices. Defaults to <code>True</code> if the device is CUDA, otherwise defaults to <code>False</code>.",name:"use_io_binding"}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L1326"}}),Qt=new j({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForCausalLM.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForCausalLM.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForCausalLM.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForCausalLM.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L1404"}}),Ye=new lo({props:{$$slots:{default:[sm]},$$scope:{ctx:E}}}),Ke=new N({props:{anchor:"optimum.onnxruntime.ORTModelForCausalLM.forward.example",$$slots:{default:[rm]},$$scope:{ctx:E}}}),Ze=new N({props:{anchor:"optimum.onnxruntime.ORTModelForCausalLM.forward.example-2",$$slots:{default:[am]},$$scope:{ctx:E}}}),Wt=new j({props:{name:"prepare_inputs_for_generation",anchor:"optimum.onnxruntime.ORTModelForCausalLM.prepare_inputs_for_generation",parameters:[{name:"input_ids",val:": LongTensor"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L1342"}}),Bt=new j({props:{name:"prepare_logits_buffer",anchor:"optimum.onnxruntime.ORTModelForCausalLM.prepare_logits_buffer",parameters:[{name:"batch_size",val:""},{name:"sequence_length",val:""}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L1351"}}),Ht=new Te({}),Vt=new j({props:{name:"class optimum.onnxruntime.ORTModelForSeq2SeqLM",anchor:"optimum.onnxruntime.ORTModelForSeq2SeqLM",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_seq2seq.py#L963"}}),Ut=new j({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForSeq2SeqLM.forward",parameters:[{name:"input_ids",val:": LongTensor = None"},{name:"attention_mask",val:": typing.Optional[torch.FloatTensor] = None"},{name:"decoder_input_ids",val:": typing.Optional[torch.LongTensor] = None"},{name:"encoder_outputs",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.Tensor]]] = None"},{name:"past_key_values",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.Tensor]]] = None"},{name:"labels",val:": typing.Optional[torch.LongTensor] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForSeq2SeqLM.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code>) &#x2014;
Indices of input sequence tokens in the vocabulary of shape <code>(batch_size, encoder_sequence_length)</code>.`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForSeq2SeqLM.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.LongTensor</code>) &#x2014;
Mask to avoid performing attention on padding token indices, of shape
<code>(batch_size, encoder_sequence_length)</code>. Mask values selected in <code>[0, 1]</code>.`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForSeq2SeqLM.forward.decoder_input_ids",description:`<strong>decoder_input_ids</strong> (<code>torch.LongTensor</code>) &#x2014;
Indices of decoder input sequence tokens in the vocabulary of shape <code>(batch_size, decoder_sequence_length)</code>.`,name:"decoder_input_ids"},{anchor:"optimum.onnxruntime.ORTModelForSeq2SeqLM.forward.encoder_outputs",description:`<strong>encoder_outputs</strong> (<code>torch.FloatTensor</code>) &#x2014;
The encoder <code>last_hidden_state</code> of shape <code>(batch_size, encoder_sequence_length, hidden_size)</code>.`,name:"encoder_outputs"},{anchor:"optimum.onnxruntime.ORTModelForSeq2SeqLM.forward.past_key_values",description:`<strong>past_key_values</strong> (<code>tuple(tuple(torch.FloatTensor), *optional*)</code> &#x2014;
Contains the precomputed key and value hidden states of the attention blocks used to speed up decoding.
The tuple is of length <code>config.n_layers</code> with each tuple having 2 tensors of shape
<code>(batch_size, num_heads, decoder_sequence_length, embed_size_per_head)</code> and 2 additional tensors of shape
<code>(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)</code>.`,name:"past_key_values"}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_seq2seq.py#L972"}}),nt=new lo({props:{$$slots:{default:[im]},$$scope:{ctx:E}}}),st=new N({props:{anchor:"optimum.onnxruntime.ORTModelForSeq2SeqLM.forward.example",$$slots:{default:[lm]},$$scope:{ctx:E}}}),rt=new N({props:{anchor:"optimum.onnxruntime.ORTModelForSeq2SeqLM.forward.example-2",$$slots:{default:[mm]},$$scope:{ctx:E}}}),Gt=new Te({}),Jt=new j({props:{name:"class optimum.onnxruntime.ORTModelForImageClassification",anchor:"optimum.onnxruntime.ORTModelForImageClassification",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"use_io_binding",val:" = True"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForImageClassification.config",description:`<strong>config</strong> (<code>transformers.PretrainedConfig</code>) &#x2014; <a href="https://huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig" rel="nofollow">PretrainedConfig</a> is the Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/optimum/main/en/onnxruntime/package_reference/modeling_ort#optimum.onnxruntime.ORTModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForImageClassification.model",description:'<strong>model</strong> (<code>onnxruntime.InferenceSession</code>) &#x2014; <a href="https://onnxruntime.ai/docs/api/python/api_summary.html#inferencesession" rel="nofollow">onnxruntime.InferenceSession</a> is the main class used to run a model. Check out the <a href="/docs/optimum/main/en/onnxruntime/package_reference/modeling_ort#optimum.onnxruntime.ORTModel.load_model">load_model()</a> method for more information.',name:"model"},{anchor:"optimum.onnxruntime.ORTModelForImageClassification.use_io_binding",description:"<strong>use_io_binding</strong> (<code>bool</code>, <em>optional</em>) &#x2014; Whether to use IOBinding during inference to avoid memory copy between the host and devices. Defaults to <code>True</code> if the device is CUDA, otherwise defaults to <code>False</code>.",name:"use_io_binding"}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L1511"}}),Kt=new j({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForImageClassification.forward",parameters:[{name:"pixel_values",val:": Tensor"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForImageClassification.forward.pixel_values",description:`<strong>pixel_values</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values corresponding to the images in the current batch.
Pixel values can be obtained from encoded images using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autofeatureextractor" rel="nofollow"><code>AutoFeatureExtractor</code></a>.`,name:"pixel_values"}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L1567"}}),it=new lo({props:{$$slots:{default:[pm]},$$scope:{ctx:E}}}),lt=new N({props:{anchor:"optimum.onnxruntime.ORTModelForImageClassification.forward.example",$$slots:{default:[dm]},$$scope:{ctx:E}}}),mt=new N({props:{anchor:"optimum.onnxruntime.ORTModelForImageClassification.forward.example-2",$$slots:{default:[cm]},$$scope:{ctx:E}}}),Zt=new j({props:{name:"prepare_logits_buffer",anchor:"optimum.onnxruntime.ORTModelForImageClassification.prepare_logits_buffer",parameters:[{name:"batch_size",val:""}],source:"https://github.com/huggingface/optimum/blob/main/optimum/onnxruntime/modeling_ort.py#L1526"}}),{c(){s=a("meta"),_=f(),d=a("h1"),u=a("a"),h=a("span"),k(n.$$.fragment),r=f(),y=a("span"),c=m("Models"),v=f(),R=a("h2"),Me=a("a"),$o=a("span"),k(dt.$$.fragment),xs=f(),vo=a("span"),ws=m("ORTModel"),In=f(),D=a("div"),k(ct.$$.fragment),bs=f(),ut=a("p"),Ts=m(`Base ORTModel class for implementing models using ONNX Runtime. The ORTModel implements generic methods for interacting
with the Hugging Face Hub as well as exporting vanilla transformers models to ONNX using `),ko=a("code"),Ms=m("transformers.onnx"),Os=m(` toolchain.
The ORTModel implements additionally generic methods for optimizing and quantizing Onnx models.`),ys=f(),Oe=a("div"),k(ft.$$.fragment),qs=f(),xo=a("p"),Es=m("Instantiate a pretrained model from a pre-trained model configuration."),Rs=f(),ye=a("div"),k(gt.$$.fragment),js=f(),ht=a("p"),Fs=m("Loads an ONNX Inference session with a given provider. Default provider is "),wo=a("code"),zs=m("CPUExecutionProvider"),Cs=m(" to match the default behaviour in PyTorch/TensorFlow/JAX."),Ps=f(),qe=a("div"),k(_t.$$.fragment),As=f(),bo=a("p"),Ss=m("Changes the ONNX Runtime provider according to the device."),Dn=f(),pe=a("h2"),Ee=a("a"),To=a("span"),k($t.$$.fragment),Is=f(),Mo=a("span"),Ds=m("ORTModelForFeatureExtraction"),Nn=f(),z=a("div"),k(vt.$$.fragment),Ns=f(),Oo=a("p"),Ls=m("Onnx Model with a MaskedLMOutput for feature-extraction tasks."),Qs=f(),kt=a("p"),Ws=m("This model inherits from [~"),yo=a("code"),Xs=m("onnxruntime.modeling_ort.ORTModel"),Bs=m(`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),Hs=f(),qo=a("p"),Vs=m("Feature Extraction model for ONNX."),Us=f(),W=a("div"),k(xt.$$.fragment),Gs=f(),de=a("p"),Js=m("The "),Eo=a("code"),Ys=m("ORTModelForFeatureExtraction"),Ks=m(" forward method, overrides the "),Ro=a("code"),Zs=m("__call__"),er=m(" special method."),tr=f(),k(Re.$$.fragment),or=f(),k(je.$$.fragment),nr=f(),k(Fe.$$.fragment),sr=f(),ze=a("div"),k(wt.$$.fragment),rr=f(),bt=a("p"),ar=m("Prepare the buffer of output("),jo=a("code"),ir=m("last_hidden_state"),lr=m(") with a 1D tensor on shape: (batch_size, sequence_length, hidden_size)."),Ln=f(),ce=a("h2"),Ce=a("a"),Fo=a("span"),k(Tt.$$.fragment),mr=f(),zo=a("span"),pr=m("ORTModelForQuestionAnswering"),Qn=f(),C=a("div"),k(Mt.$$.fragment),dr=f(),Co=a("p"),cr=m("Onnx Model with a QuestionAnsweringModelOutput for extractive question-answering tasks like SQuAD."),ur=f(),Ot=a("p"),fr=m("This model inherits from [~"),Po=a("code"),gr=m("onnxruntime.modeling_ort.ORTModel"),hr=m(`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),_r=f(),Ao=a("p"),$r=m("Question Answering model for ONNX."),vr=f(),X=a("div"),k(yt.$$.fragment),kr=f(),ue=a("p"),xr=m("The "),So=a("code"),wr=m("ORTModelForQuestionAnswering"),br=m(" forward method, overrides the "),Io=a("code"),Tr=m("__call__"),Mr=m(" special method."),Or=f(),k(Pe.$$.fragment),yr=f(),k(Ae.$$.fragment),qr=f(),k(Se.$$.fragment),Er=f(),Ie=a("div"),k(qt.$$.fragment),Rr=f(),Do=a("p"),jr=m("Prepare the buffer of logits with a 1D tensor on shape: (batch_size, sequence_length)."),Wn=f(),fe=a("h2"),De=a("a"),No=a("span"),k(Et.$$.fragment),Fr=f(),Lo=a("span"),zr=m("ORTModelForSequenceClassification"),Xn=f(),P=a("div"),k(Rt.$$.fragment),Cr=f(),Qo=a("p"),Pr=m(`Onnx Model with a sequence classification/regression head on top (a linear layer on top of the
pooled output) e.g. for GLUE tasks.`),Ar=f(),jt=a("p"),Sr=m("This model inherits from [~"),Wo=a("code"),Ir=m("onnxruntime.modeling_ort.ORTModel"),Dr=m(`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),Nr=f(),Xo=a("p"),Lr=m("Sequence Classification model for ONNX."),Qr=f(),I=a("div"),k(Ft.$$.fragment),Wr=f(),ge=a("p"),Xr=m("The "),Bo=a("code"),Br=m("ORTModelForSequenceClassification"),Hr=m(" forward method, overrides the "),Ho=a("code"),Vr=m("__call__"),Ur=m(" special method."),Gr=f(),k(Ne.$$.fragment),Jr=f(),k(Le.$$.fragment),Yr=f(),k(Qe.$$.fragment),Kr=f(),k(We.$$.fragment),Zr=f(),Xe=a("div"),k(zt.$$.fragment),ea=f(),Vo=a("p"),ta=m("Prepare the buffer of logits with a 1D tensor on shape: (batch_size, config.num_labels)."),Bn=f(),he=a("h2"),Be=a("a"),Uo=a("span"),k(Ct.$$.fragment),oa=f(),Go=a("span"),na=m("ORTModelForTokenClassification"),Hn=f(),A=a("div"),k(Pt.$$.fragment),sa=f(),Jo=a("p"),ra=m(`Onnx Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g.
for Named-Entity-Recognition (NER) tasks.`),aa=f(),At=a("p"),ia=m("This model inherits from [~"),Yo=a("code"),la=m("onnxruntime.modeling_ort.ORTModel"),ma=m(`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),pa=f(),Ko=a("p"),da=m("Token Classification model for ONNX."),ca=f(),B=a("div"),k(St.$$.fragment),ua=f(),_e=a("p"),fa=m("The "),Zo=a("code"),ga=m("ORTModelForTokenClassification"),ha=m(" forward method, overrides the "),en=a("code"),_a=m("__call__"),$a=m(" special method."),va=f(),k(He.$$.fragment),ka=f(),k(Ve.$$.fragment),xa=f(),k(Ue.$$.fragment),wa=f(),Ge=a("div"),k(It.$$.fragment),ba=f(),tn=a("p"),Ta=m("Prepare the buffer of logits with a 1D tensor on shape: (batch_size, sequence_length, config.num_labels)."),Vn=f(),$e=a("h2"),Je=a("a"),on=a("span"),k(Dt.$$.fragment),Ma=f(),nn=a("span"),Oa=m("ORTModelForCausalLM"),Un=f(),F=a("div"),k(Nt.$$.fragment),ya=f(),sn=a("p"),qa=m(`Onnx Model with a causal language modeling head on top (linear layer with weights tied to the input
embeddings).`),Ea=f(),Lt=a("p"),Ra=m("This model inherits from [~"),rn=a("code"),ja=m("onnxruntime.modeling_ort.ORTModel"),Fa=m(`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),za=f(),an=a("p"),Ca=m("Causal LM model for ONNX."),Pa=f(),H=a("div"),k(Qt.$$.fragment),Aa=f(),ve=a("p"),Sa=m("The "),ln=a("code"),Ia=m("ORTModelForCausalLM"),Da=m(" forward method, overrides the "),mn=a("code"),Na=m("__call__"),La=m(" special method."),Qa=f(),k(Ye.$$.fragment),Wa=f(),k(Ke.$$.fragment),Xa=f(),k(Ze.$$.fragment),Ba=f(),et=a("div"),k(Wt.$$.fragment),Ha=f(),Xt=a("p"),Va=m("Implement in subclasses of "),pn=a("code"),Ua=m("PreTrainedModel"),Ga=m(" for custom behavior to prepare inputs in the generate method."),Ja=f(),tt=a("div"),k(Bt.$$.fragment),Ya=f(),dn=a("p"),Ka=m("Prepare the buffer of logits with a 1D tensor on shape: (batch_size, sequence_length, config.vocab_size)."),Gn=f(),ke=a("h2"),ot=a("a"),cn=a("span"),k(Ht.$$.fragment),Za=f(),un=a("span"),ei=m("ORTModelForSeq2SeqLM"),Jn=f(),ne=a("div"),k(Vt.$$.fragment),ti=f(),fn=a("p"),oi=m("Sequence-to-sequence model with a language modeling head for ONNX Runtime inference."),ni=f(),V=a("div"),k(Ut.$$.fragment),si=f(),xe=a("p"),ri=m("The "),gn=a("code"),ai=m("ORTModelForSeq2SeqLM"),ii=m(" forward method, overrides the "),hn=a("code"),li=m("__call__"),mi=m(" special method."),pi=f(),k(nt.$$.fragment),di=f(),k(st.$$.fragment),ci=f(),k(rt.$$.fragment),Yn=f(),we=a("h2"),at=a("a"),_n=a("span"),k(Gt.$$.fragment),ui=f(),$n=a("span"),fi=m("ORTModelForImageClassification"),Kn=f(),S=a("div"),k(Jt.$$.fragment),gi=f(),vn=a("p"),hi=m("Onnx Model for image-classification tasks."),_i=f(),Yt=a("p"),$i=m("This model inherits from [~"),kn=a("code"),vi=m("onnxruntime.modeling_ort.ORTModel"),ki=m(`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),xi=f(),xn=a("p"),wi=m("Image Classification model for ONNX."),bi=f(),U=a("div"),k(Kt.$$.fragment),Ti=f(),be=a("p"),Mi=m("The "),wn=a("code"),Oi=m("ORTModelForImageClassification"),yi=m(" forward method, overrides the "),bn=a("code"),qi=m("__call__"),Ei=m(" special method."),Ri=f(),k(it.$$.fragment),ji=f(),k(lt.$$.fragment),Fi=f(),k(mt.$$.fragment),zi=f(),pt=a("div"),k(Zt.$$.fragment),Ci=f(),Tn=a("p"),Pi=m("Prepare the buffer of logits with a 1D tensor on shape: (batch_size, config.num_labels)."),this.h()},l(t){const $=Wl('[data-svelte="svelte-1phssyn"]',document.head);s=i($,"META",{name:!0,content:!0}),$.forEach(o),_=g(t),d=i(t,"H1",{class:!0});var eo=l(d);u=i(eo,"A",{id:!0,class:!0,href:!0});var Mn=l(u);h=i(Mn,"SPAN",{});var On=l(h);x(n.$$.fragment,On),On.forEach(o),Mn.forEach(o),r=g(eo),y=i(eo,"SPAN",{});var yn=l(y);c=p(yn,"Models"),yn.forEach(o),eo.forEach(o),v=g(t),R=i(t,"H2",{class:!0});var to=l(R);Me=i(to,"A",{id:!0,class:!0,href:!0});var qn=l(Me);$o=i(qn,"SPAN",{});var En=l($o);x(dt.$$.fragment,En),En.forEach(o),qn.forEach(o),xs=g(to),vo=i(to,"SPAN",{});var Rn=l(vo);ws=p(Rn,"ORTModel"),Rn.forEach(o),to.forEach(o),In=g(t),D=i(t,"DIV",{class:!0});var J=l(D);x(ct.$$.fragment,J),bs=g(J),ut=i(J,"P",{});var oo=l(ut);Ts=p(oo,`Base ORTModel class for implementing models using ONNX Runtime. The ORTModel implements generic methods for interacting
with the Hugging Face Hub as well as exporting vanilla transformers models to ONNX using `),ko=i(oo,"CODE",{});var jn=l(ko);Ms=p(jn,"transformers.onnx"),jn.forEach(o),Os=p(oo,` toolchain.
The ORTModel implements additionally generic methods for optimizing and quantizing Onnx models.`),oo.forEach(o),ys=g(J),Oe=i(J,"DIV",{class:!0});var no=l(Oe);x(ft.$$.fragment,no),qs=g(no),xo=i(no,"P",{});var Fn=l(xo);Es=p(Fn,"Instantiate a pretrained model from a pre-trained model configuration."),Fn.forEach(o),no.forEach(o),Rs=g(J),ye=i(J,"DIV",{class:!0});var so=l(ye);x(gt.$$.fragment,so),js=g(so),ht=i(so,"P",{});var ro=l(ht);Fs=p(ro,"Loads an ONNX Inference session with a given provider. Default provider is "),wo=i(ro,"CODE",{});var zn=l(wo);zs=p(zn,"CPUExecutionProvider"),zn.forEach(o),Cs=p(ro," to match the default behaviour in PyTorch/TensorFlow/JAX."),ro.forEach(o),so.forEach(o),Ps=g(J),qe=i(J,"DIV",{class:!0});var ao=l(qe);x(_t.$$.fragment,ao),As=g(ao),bo=i(ao,"P",{});var Cn=l(bo);Ss=p(Cn,"Changes the ONNX Runtime provider according to the device."),Cn.forEach(o),ao.forEach(o),J.forEach(o),Dn=g(t),pe=i(t,"H2",{class:!0});var io=l(pe);Ee=i(io,"A",{id:!0,class:!0,href:!0});var Pn=l(Ee);To=i(Pn,"SPAN",{});var An=l(To);x($t.$$.fragment,An),An.forEach(o),Pn.forEach(o),Is=g(io),Mo=i(io,"SPAN",{});var Sn=l(Mo);Ds=p(Sn,"ORTModelForFeatureExtraction"),Sn.forEach(o),io.forEach(o),Nn=g(t),z=i(t,"DIV",{class:!0});var Y=l(z);x(vt.$$.fragment,Y),Ns=g(Y),Oo=i(Y,"P",{});var Ai=l(Oo);Ls=p(Ai,"Onnx Model with a MaskedLMOutput for feature-extraction tasks."),Ai.forEach(o),Qs=g(Y),kt=i(Y,"P",{});var es=l(kt);Ws=p(es,"This model inherits from [~"),yo=i(es,"CODE",{});var Si=l(yo);Xs=p(Si,"onnxruntime.modeling_ort.ORTModel"),Si.forEach(o),Bs=p(es,`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),es.forEach(o),Hs=g(Y),qo=i(Y,"P",{});var Ii=l(qo);Vs=p(Ii,"Feature Extraction model for ONNX."),Ii.forEach(o),Us=g(Y),W=i(Y,"DIV",{class:!0});var se=l(W);x(xt.$$.fragment,se),Gs=g(se),de=i(se,"P",{});var mo=l(de);Js=p(mo,"The "),Eo=i(mo,"CODE",{});var Di=l(Eo);Ys=p(Di,"ORTModelForFeatureExtraction"),Di.forEach(o),Ks=p(mo," forward method, overrides the "),Ro=i(mo,"CODE",{});var Ni=l(Ro);Zs=p(Ni,"__call__"),Ni.forEach(o),er=p(mo," special method."),mo.forEach(o),tr=g(se),x(Re.$$.fragment,se),or=g(se),x(je.$$.fragment,se),nr=g(se),x(Fe.$$.fragment,se),se.forEach(o),sr=g(Y),ze=i(Y,"DIV",{class:!0});var ts=l(ze);x(wt.$$.fragment,ts),rr=g(ts),bt=i(ts,"P",{});var os=l(bt);ar=p(os,"Prepare the buffer of output("),jo=i(os,"CODE",{});var Li=l(jo);ir=p(Li,"last_hidden_state"),Li.forEach(o),lr=p(os,") with a 1D tensor on shape: (batch_size, sequence_length, hidden_size)."),os.forEach(o),ts.forEach(o),Y.forEach(o),Ln=g(t),ce=i(t,"H2",{class:!0});var ns=l(ce);Ce=i(ns,"A",{id:!0,class:!0,href:!0});var Qi=l(Ce);Fo=i(Qi,"SPAN",{});var Wi=l(Fo);x(Tt.$$.fragment,Wi),Wi.forEach(o),Qi.forEach(o),mr=g(ns),zo=i(ns,"SPAN",{});var Xi=l(zo);pr=p(Xi,"ORTModelForQuestionAnswering"),Xi.forEach(o),ns.forEach(o),Qn=g(t),C=i(t,"DIV",{class:!0});var K=l(C);x(Mt.$$.fragment,K),dr=g(K),Co=i(K,"P",{});var Bi=l(Co);cr=p(Bi,"Onnx Model with a QuestionAnsweringModelOutput for extractive question-answering tasks like SQuAD."),Bi.forEach(o),ur=g(K),Ot=i(K,"P",{});var ss=l(Ot);fr=p(ss,"This model inherits from [~"),Po=i(ss,"CODE",{});var Hi=l(Po);gr=p(Hi,"onnxruntime.modeling_ort.ORTModel"),Hi.forEach(o),hr=p(ss,`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),ss.forEach(o),_r=g(K),Ao=i(K,"P",{});var Vi=l(Ao);$r=p(Vi,"Question Answering model for ONNX."),Vi.forEach(o),vr=g(K),X=i(K,"DIV",{class:!0});var re=l(X);x(yt.$$.fragment,re),kr=g(re),ue=i(re,"P",{});var po=l(ue);xr=p(po,"The "),So=i(po,"CODE",{});var Ui=l(So);wr=p(Ui,"ORTModelForQuestionAnswering"),Ui.forEach(o),br=p(po," forward method, overrides the "),Io=i(po,"CODE",{});var Gi=l(Io);Tr=p(Gi,"__call__"),Gi.forEach(o),Mr=p(po," special method."),po.forEach(o),Or=g(re),x(Pe.$$.fragment,re),yr=g(re),x(Ae.$$.fragment,re),qr=g(re),x(Se.$$.fragment,re),re.forEach(o),Er=g(K),Ie=i(K,"DIV",{class:!0});var rs=l(Ie);x(qt.$$.fragment,rs),Rr=g(rs),Do=i(rs,"P",{});var Ji=l(Do);jr=p(Ji,"Prepare the buffer of logits with a 1D tensor on shape: (batch_size, sequence_length)."),Ji.forEach(o),rs.forEach(o),K.forEach(o),Wn=g(t),fe=i(t,"H2",{class:!0});var as=l(fe);De=i(as,"A",{id:!0,class:!0,href:!0});var Yi=l(De);No=i(Yi,"SPAN",{});var Ki=l(No);x(Et.$$.fragment,Ki),Ki.forEach(o),Yi.forEach(o),Fr=g(as),Lo=i(as,"SPAN",{});var Zi=l(Lo);zr=p(Zi,"ORTModelForSequenceClassification"),Zi.forEach(o),as.forEach(o),Xn=g(t),P=i(t,"DIV",{class:!0});var Z=l(P);x(Rt.$$.fragment,Z),Cr=g(Z),Qo=i(Z,"P",{});var el=l(Qo);Pr=p(el,`Onnx Model with a sequence classification/regression head on top (a linear layer on top of the
pooled output) e.g. for GLUE tasks.`),el.forEach(o),Ar=g(Z),jt=i(Z,"P",{});var is=l(jt);Sr=p(is,"This model inherits from [~"),Wo=i(is,"CODE",{});var tl=l(Wo);Ir=p(tl,"onnxruntime.modeling_ort.ORTModel"),tl.forEach(o),Dr=p(is,`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),is.forEach(o),Nr=g(Z),Xo=i(Z,"P",{});var ol=l(Xo);Lr=p(ol,"Sequence Classification model for ONNX."),ol.forEach(o),Qr=g(Z),I=i(Z,"DIV",{class:!0});var ee=l(I);x(Ft.$$.fragment,ee),Wr=g(ee),ge=i(ee,"P",{});var co=l(ge);Xr=p(co,"The "),Bo=i(co,"CODE",{});var nl=l(Bo);Br=p(nl,"ORTModelForSequenceClassification"),nl.forEach(o),Hr=p(co," forward method, overrides the "),Ho=i(co,"CODE",{});var sl=l(Ho);Vr=p(sl,"__call__"),sl.forEach(o),Ur=p(co," special method."),co.forEach(o),Gr=g(ee),x(Ne.$$.fragment,ee),Jr=g(ee),x(Le.$$.fragment,ee),Yr=g(ee),x(Qe.$$.fragment,ee),Kr=g(ee),x(We.$$.fragment,ee),ee.forEach(o),Zr=g(Z),Xe=i(Z,"DIV",{class:!0});var ls=l(Xe);x(zt.$$.fragment,ls),ea=g(ls),Vo=i(ls,"P",{});var rl=l(Vo);ta=p(rl,"Prepare the buffer of logits with a 1D tensor on shape: (batch_size, config.num_labels)."),rl.forEach(o),ls.forEach(o),Z.forEach(o),Bn=g(t),he=i(t,"H2",{class:!0});var ms=l(he);Be=i(ms,"A",{id:!0,class:!0,href:!0});var al=l(Be);Uo=i(al,"SPAN",{});var il=l(Uo);x(Ct.$$.fragment,il),il.forEach(o),al.forEach(o),oa=g(ms),Go=i(ms,"SPAN",{});var ll=l(Go);na=p(ll,"ORTModelForTokenClassification"),ll.forEach(o),ms.forEach(o),Hn=g(t),A=i(t,"DIV",{class:!0});var te=l(A);x(Pt.$$.fragment,te),sa=g(te),Jo=i(te,"P",{});var ml=l(Jo);ra=p(ml,`Onnx Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g.
for Named-Entity-Recognition (NER) tasks.`),ml.forEach(o),aa=g(te),At=i(te,"P",{});var ps=l(At);ia=p(ps,"This model inherits from [~"),Yo=i(ps,"CODE",{});var pl=l(Yo);la=p(pl,"onnxruntime.modeling_ort.ORTModel"),pl.forEach(o),ma=p(ps,`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),ps.forEach(o),pa=g(te),Ko=i(te,"P",{});var dl=l(Ko);da=p(dl,"Token Classification model for ONNX."),dl.forEach(o),ca=g(te),B=i(te,"DIV",{class:!0});var ae=l(B);x(St.$$.fragment,ae),ua=g(ae),_e=i(ae,"P",{});var uo=l(_e);fa=p(uo,"The "),Zo=i(uo,"CODE",{});var cl=l(Zo);ga=p(cl,"ORTModelForTokenClassification"),cl.forEach(o),ha=p(uo," forward method, overrides the "),en=i(uo,"CODE",{});var ul=l(en);_a=p(ul,"__call__"),ul.forEach(o),$a=p(uo," special method."),uo.forEach(o),va=g(ae),x(He.$$.fragment,ae),ka=g(ae),x(Ve.$$.fragment,ae),xa=g(ae),x(Ue.$$.fragment,ae),ae.forEach(o),wa=g(te),Ge=i(te,"DIV",{class:!0});var ds=l(Ge);x(It.$$.fragment,ds),ba=g(ds),tn=i(ds,"P",{});var fl=l(tn);Ta=p(fl,"Prepare the buffer of logits with a 1D tensor on shape: (batch_size, sequence_length, config.num_labels)."),fl.forEach(o),ds.forEach(o),te.forEach(o),Vn=g(t),$e=i(t,"H2",{class:!0});var cs=l($e);Je=i(cs,"A",{id:!0,class:!0,href:!0});var gl=l(Je);on=i(gl,"SPAN",{});var hl=l(on);x(Dt.$$.fragment,hl),hl.forEach(o),gl.forEach(o),Ma=g(cs),nn=i(cs,"SPAN",{});var _l=l(nn);Oa=p(_l,"ORTModelForCausalLM"),_l.forEach(o),cs.forEach(o),Un=g(t),F=i(t,"DIV",{class:!0});var G=l(F);x(Nt.$$.fragment,G),ya=g(G),sn=i(G,"P",{});var $l=l(sn);qa=p($l,`Onnx Model with a causal language modeling head on top (linear layer with weights tied to the input
embeddings).`),$l.forEach(o),Ea=g(G),Lt=i(G,"P",{});var us=l(Lt);Ra=p(us,"This model inherits from [~"),rn=i(us,"CODE",{});var vl=l(rn);ja=p(vl,"onnxruntime.modeling_ort.ORTModel"),vl.forEach(o),Fa=p(us,`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),us.forEach(o),za=g(G),an=i(G,"P",{});var kl=l(an);Ca=p(kl,"Causal LM model for ONNX."),kl.forEach(o),Pa=g(G),H=i(G,"DIV",{class:!0});var ie=l(H);x(Qt.$$.fragment,ie),Aa=g(ie),ve=i(ie,"P",{});var fo=l(ve);Sa=p(fo,"The "),ln=i(fo,"CODE",{});var xl=l(ln);Ia=p(xl,"ORTModelForCausalLM"),xl.forEach(o),Da=p(fo," forward method, overrides the "),mn=i(fo,"CODE",{});var wl=l(mn);Na=p(wl,"__call__"),wl.forEach(o),La=p(fo," special method."),fo.forEach(o),Qa=g(ie),x(Ye.$$.fragment,ie),Wa=g(ie),x(Ke.$$.fragment,ie),Xa=g(ie),x(Ze.$$.fragment,ie),ie.forEach(o),Ba=g(G),et=i(G,"DIV",{class:!0});var fs=l(et);x(Wt.$$.fragment,fs),Ha=g(fs),Xt=i(fs,"P",{});var gs=l(Xt);Va=p(gs,"Implement in subclasses of "),pn=i(gs,"CODE",{});var bl=l(pn);Ua=p(bl,"PreTrainedModel"),bl.forEach(o),Ga=p(gs," for custom behavior to prepare inputs in the generate method."),gs.forEach(o),fs.forEach(o),Ja=g(G),tt=i(G,"DIV",{class:!0});var hs=l(tt);x(Bt.$$.fragment,hs),Ya=g(hs),dn=i(hs,"P",{});var Tl=l(dn);Ka=p(Tl,"Prepare the buffer of logits with a 1D tensor on shape: (batch_size, sequence_length, config.vocab_size)."),Tl.forEach(o),hs.forEach(o),G.forEach(o),Gn=g(t),ke=i(t,"H2",{class:!0});var _s=l(ke);ot=i(_s,"A",{id:!0,class:!0,href:!0});var Ml=l(ot);cn=i(Ml,"SPAN",{});var Ol=l(cn);x(Ht.$$.fragment,Ol),Ol.forEach(o),Ml.forEach(o),Za=g(_s),un=i(_s,"SPAN",{});var yl=l(un);ei=p(yl,"ORTModelForSeq2SeqLM"),yl.forEach(o),_s.forEach(o),Jn=g(t),ne=i(t,"DIV",{class:!0});var go=l(ne);x(Vt.$$.fragment,go),ti=g(go),fn=i(go,"P",{});var ql=l(fn);oi=p(ql,"Sequence-to-sequence model with a language modeling head for ONNX Runtime inference."),ql.forEach(o),ni=g(go),V=i(go,"DIV",{class:!0});var le=l(V);x(Ut.$$.fragment,le),si=g(le),xe=i(le,"P",{});var ho=l(xe);ri=p(ho,"The "),gn=i(ho,"CODE",{});var El=l(gn);ai=p(El,"ORTModelForSeq2SeqLM"),El.forEach(o),ii=p(ho," forward method, overrides the "),hn=i(ho,"CODE",{});var Rl=l(hn);li=p(Rl,"__call__"),Rl.forEach(o),mi=p(ho," special method."),ho.forEach(o),pi=g(le),x(nt.$$.fragment,le),di=g(le),x(st.$$.fragment,le),ci=g(le),x(rt.$$.fragment,le),le.forEach(o),go.forEach(o),Yn=g(t),we=i(t,"H2",{class:!0});var $s=l(we);at=i($s,"A",{id:!0,class:!0,href:!0});var jl=l(at);_n=i(jl,"SPAN",{});var Fl=l(_n);x(Gt.$$.fragment,Fl),Fl.forEach(o),jl.forEach(o),ui=g($s),$n=i($s,"SPAN",{});var zl=l($n);fi=p(zl,"ORTModelForImageClassification"),zl.forEach(o),$s.forEach(o),Kn=g(t),S=i(t,"DIV",{class:!0});var oe=l(S);x(Jt.$$.fragment,oe),gi=g(oe),vn=i(oe,"P",{});var Cl=l(vn);hi=p(Cl,"Onnx Model for image-classification tasks."),Cl.forEach(o),_i=g(oe),Yt=i(oe,"P",{});var vs=l(Yt);$i=p(vs,"This model inherits from [~"),kn=i(vs,"CODE",{});var Pl=l(kn);vi=p(Pl,"onnxruntime.modeling_ort.ORTModel"),Pl.forEach(o),ki=p(vs,`]. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),vs.forEach(o),xi=g(oe),xn=i(oe,"P",{});var Al=l(xn);wi=p(Al,"Image Classification model for ONNX."),Al.forEach(o),bi=g(oe),U=i(oe,"DIV",{class:!0});var me=l(U);x(Kt.$$.fragment,me),Ti=g(me),be=i(me,"P",{});var _o=l(be);Mi=p(_o,"The "),wn=i(_o,"CODE",{});var Sl=l(wn);Oi=p(Sl,"ORTModelForImageClassification"),Sl.forEach(o),yi=p(_o," forward method, overrides the "),bn=i(_o,"CODE",{});var Il=l(bn);qi=p(Il,"__call__"),Il.forEach(o),Ei=p(_o," special method."),_o.forEach(o),Ri=g(me),x(it.$$.fragment,me),ji=g(me),x(lt.$$.fragment,me),Fi=g(me),x(mt.$$.fragment,me),me.forEach(o),zi=g(oe),pt=i(oe,"DIV",{class:!0});var ks=l(pt);x(Zt.$$.fragment,ks),Ci=g(ks),Tn=i(ks,"P",{});var Dl=l(Tn);Pi=p(Dl,"Prepare the buffer of logits with a 1D tensor on shape: (batch_size, config.num_labels)."),Dl.forEach(o),ks.forEach(o),oe.forEach(o),this.h()},h(){q(s,"name","hf:doc:metadata"),q(s,"content",JSON.stringify(fm)),q(u,"id","models"),q(u,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),q(u,"href","#models"),q(d,"class","relative group"),q(Me,"id","optimum.onnxruntime.ORTModel"),q(Me,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),q(Me,"href","#optimum.onnxruntime.ORTModel"),q(R,"class","relative group"),q(Oe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(ye,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(qe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(D,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(Ee,"id","optimum.onnxruntime.ORTModelForFeatureExtraction"),q(Ee,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),q(Ee,"href","#optimum.onnxruntime.ORTModelForFeatureExtraction"),q(pe,"class","relative group"),q(W,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(ze,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(Ce,"id","optimum.onnxruntime.ORTModelForQuestionAnswering"),q(Ce,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),q(Ce,"href","#optimum.onnxruntime.ORTModelForQuestionAnswering"),q(ce,"class","relative group"),q(X,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(Ie,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(C,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(De,"id","optimum.onnxruntime.ORTModelForSequenceClassification"),q(De,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),q(De,"href","#optimum.onnxruntime.ORTModelForSequenceClassification"),q(fe,"class","relative group"),q(I,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(Xe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(P,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(Be,"id","optimum.onnxruntime.ORTModelForTokenClassification"),q(Be,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),q(Be,"href","#optimum.onnxruntime.ORTModelForTokenClassification"),q(he,"class","relative group"),q(B,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(Ge,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(A,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(Je,"id","optimum.onnxruntime.ORTModelForCausalLM"),q(Je,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),q(Je,"href","#optimum.onnxruntime.ORTModelForCausalLM"),q($e,"class","relative group"),q(H,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(et,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(tt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(F,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(ot,"id","optimum.onnxruntime.ORTModelForSeq2SeqLM"),q(ot,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),q(ot,"href","#optimum.onnxruntime.ORTModelForSeq2SeqLM"),q(ke,"class","relative group"),q(V,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(ne,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(at,"id","optimum.onnxruntime.ORTModelForImageClassification"),q(at,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),q(at,"href","#optimum.onnxruntime.ORTModelForImageClassification"),q(we,"class","relative group"),q(U,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(pt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),q(S,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,$){e(document.head,s),O(t,_,$),O(t,d,$),e(d,u),e(u,h),w(n,h,null),e(d,r),e(d,y),e(y,c),O(t,v,$),O(t,R,$),e(R,Me),e(Me,$o),w(dt,$o,null),e(R,xs),e(R,vo),e(vo,ws),O(t,In,$),O(t,D,$),w(ct,D,null),e(D,bs),e(D,ut),e(ut,Ts),e(ut,ko),e(ko,Ms),e(ut,Os),e(D,ys),e(D,Oe),w(ft,Oe,null),e(Oe,qs),e(Oe,xo),e(xo,Es),e(D,Rs),e(D,ye),w(gt,ye,null),e(ye,js),e(ye,ht),e(ht,Fs),e(ht,wo),e(wo,zs),e(ht,Cs),e(D,Ps),e(D,qe),w(_t,qe,null),e(qe,As),e(qe,bo),e(bo,Ss),O(t,Dn,$),O(t,pe,$),e(pe,Ee),e(Ee,To),w($t,To,null),e(pe,Is),e(pe,Mo),e(Mo,Ds),O(t,Nn,$),O(t,z,$),w(vt,z,null),e(z,Ns),e(z,Oo),e(Oo,Ls),e(z,Qs),e(z,kt),e(kt,Ws),e(kt,yo),e(yo,Xs),e(kt,Bs),e(z,Hs),e(z,qo),e(qo,Vs),e(z,Us),e(z,W),w(xt,W,null),e(W,Gs),e(W,de),e(de,Js),e(de,Eo),e(Eo,Ys),e(de,Ks),e(de,Ro),e(Ro,Zs),e(de,er),e(W,tr),w(Re,W,null),e(W,or),w(je,W,null),e(W,nr),w(Fe,W,null),e(z,sr),e(z,ze),w(wt,ze,null),e(ze,rr),e(ze,bt),e(bt,ar),e(bt,jo),e(jo,ir),e(bt,lr),O(t,Ln,$),O(t,ce,$),e(ce,Ce),e(Ce,Fo),w(Tt,Fo,null),e(ce,mr),e(ce,zo),e(zo,pr),O(t,Qn,$),O(t,C,$),w(Mt,C,null),e(C,dr),e(C,Co),e(Co,cr),e(C,ur),e(C,Ot),e(Ot,fr),e(Ot,Po),e(Po,gr),e(Ot,hr),e(C,_r),e(C,Ao),e(Ao,$r),e(C,vr),e(C,X),w(yt,X,null),e(X,kr),e(X,ue),e(ue,xr),e(ue,So),e(So,wr),e(ue,br),e(ue,Io),e(Io,Tr),e(ue,Mr),e(X,Or),w(Pe,X,null),e(X,yr),w(Ae,X,null),e(X,qr),w(Se,X,null),e(C,Er),e(C,Ie),w(qt,Ie,null),e(Ie,Rr),e(Ie,Do),e(Do,jr),O(t,Wn,$),O(t,fe,$),e(fe,De),e(De,No),w(Et,No,null),e(fe,Fr),e(fe,Lo),e(Lo,zr),O(t,Xn,$),O(t,P,$),w(Rt,P,null),e(P,Cr),e(P,Qo),e(Qo,Pr),e(P,Ar),e(P,jt),e(jt,Sr),e(jt,Wo),e(Wo,Ir),e(jt,Dr),e(P,Nr),e(P,Xo),e(Xo,Lr),e(P,Qr),e(P,I),w(Ft,I,null),e(I,Wr),e(I,ge),e(ge,Xr),e(ge,Bo),e(Bo,Br),e(ge,Hr),e(ge,Ho),e(Ho,Vr),e(ge,Ur),e(I,Gr),w(Ne,I,null),e(I,Jr),w(Le,I,null),e(I,Yr),w(Qe,I,null),e(I,Kr),w(We,I,null),e(P,Zr),e(P,Xe),w(zt,Xe,null),e(Xe,ea),e(Xe,Vo),e(Vo,ta),O(t,Bn,$),O(t,he,$),e(he,Be),e(Be,Uo),w(Ct,Uo,null),e(he,oa),e(he,Go),e(Go,na),O(t,Hn,$),O(t,A,$),w(Pt,A,null),e(A,sa),e(A,Jo),e(Jo,ra),e(A,aa),e(A,At),e(At,ia),e(At,Yo),e(Yo,la),e(At,ma),e(A,pa),e(A,Ko),e(Ko,da),e(A,ca),e(A,B),w(St,B,null),e(B,ua),e(B,_e),e(_e,fa),e(_e,Zo),e(Zo,ga),e(_e,ha),e(_e,en),e(en,_a),e(_e,$a),e(B,va),w(He,B,null),e(B,ka),w(Ve,B,null),e(B,xa),w(Ue,B,null),e(A,wa),e(A,Ge),w(It,Ge,null),e(Ge,ba),e(Ge,tn),e(tn,Ta),O(t,Vn,$),O(t,$e,$),e($e,Je),e(Je,on),w(Dt,on,null),e($e,Ma),e($e,nn),e(nn,Oa),O(t,Un,$),O(t,F,$),w(Nt,F,null),e(F,ya),e(F,sn),e(sn,qa),e(F,Ea),e(F,Lt),e(Lt,Ra),e(Lt,rn),e(rn,ja),e(Lt,Fa),e(F,za),e(F,an),e(an,Ca),e(F,Pa),e(F,H),w(Qt,H,null),e(H,Aa),e(H,ve),e(ve,Sa),e(ve,ln),e(ln,Ia),e(ve,Da),e(ve,mn),e(mn,Na),e(ve,La),e(H,Qa),w(Ye,H,null),e(H,Wa),w(Ke,H,null),e(H,Xa),w(Ze,H,null),e(F,Ba),e(F,et),w(Wt,et,null),e(et,Ha),e(et,Xt),e(Xt,Va),e(Xt,pn),e(pn,Ua),e(Xt,Ga),e(F,Ja),e(F,tt),w(Bt,tt,null),e(tt,Ya),e(tt,dn),e(dn,Ka),O(t,Gn,$),O(t,ke,$),e(ke,ot),e(ot,cn),w(Ht,cn,null),e(ke,Za),e(ke,un),e(un,ei),O(t,Jn,$),O(t,ne,$),w(Vt,ne,null),e(ne,ti),e(ne,fn),e(fn,oi),e(ne,ni),e(ne,V),w(Ut,V,null),e(V,si),e(V,xe),e(xe,ri),e(xe,gn),e(gn,ai),e(xe,ii),e(xe,hn),e(hn,li),e(xe,mi),e(V,pi),w(nt,V,null),e(V,di),w(st,V,null),e(V,ci),w(rt,V,null),O(t,Yn,$),O(t,we,$),e(we,at),e(at,_n),w(Gt,_n,null),e(we,ui),e(we,$n),e($n,fi),O(t,Kn,$),O(t,S,$),w(Jt,S,null),e(S,gi),e(S,vn),e(vn,hi),e(S,_i),e(S,Yt),e(Yt,$i),e(Yt,kn),e(kn,vi),e(Yt,ki),e(S,xi),e(S,xn),e(xn,wi),e(S,bi),e(S,U),w(Kt,U,null),e(U,Ti),e(U,be),e(be,Mi),e(be,wn),e(wn,Oi),e(be,yi),e(be,bn),e(bn,qi),e(be,Ei),e(U,Ri),w(it,U,null),e(U,ji),w(lt,U,null),e(U,Fi),w(mt,U,null),e(S,zi),e(S,pt),w(Zt,pt,null),e(pt,Ci),e(pt,Tn),e(Tn,Pi),Zn=!0},p(t,[$]){const eo={};$&2&&(eo.$$scope={dirty:$,ctx:t}),Re.$set(eo);const Mn={};$&2&&(Mn.$$scope={dirty:$,ctx:t}),je.$set(Mn);const On={};$&2&&(On.$$scope={dirty:$,ctx:t}),Fe.$set(On);const yn={};$&2&&(yn.$$scope={dirty:$,ctx:t}),Pe.$set(yn);const to={};$&2&&(to.$$scope={dirty:$,ctx:t}),Ae.$set(to);const qn={};$&2&&(qn.$$scope={dirty:$,ctx:t}),Se.$set(qn);const En={};$&2&&(En.$$scope={dirty:$,ctx:t}),Ne.$set(En);const Rn={};$&2&&(Rn.$$scope={dirty:$,ctx:t}),Le.$set(Rn);const J={};$&2&&(J.$$scope={dirty:$,ctx:t}),Qe.$set(J);const oo={};$&2&&(oo.$$scope={dirty:$,ctx:t}),We.$set(oo);const jn={};$&2&&(jn.$$scope={dirty:$,ctx:t}),He.$set(jn);const no={};$&2&&(no.$$scope={dirty:$,ctx:t}),Ve.$set(no);const Fn={};$&2&&(Fn.$$scope={dirty:$,ctx:t}),Ue.$set(Fn);const so={};$&2&&(so.$$scope={dirty:$,ctx:t}),Ye.$set(so);const ro={};$&2&&(ro.$$scope={dirty:$,ctx:t}),Ke.$set(ro);const zn={};$&2&&(zn.$$scope={dirty:$,ctx:t}),Ze.$set(zn);const ao={};$&2&&(ao.$$scope={dirty:$,ctx:t}),nt.$set(ao);const Cn={};$&2&&(Cn.$$scope={dirty:$,ctx:t}),st.$set(Cn);const io={};$&2&&(io.$$scope={dirty:$,ctx:t}),rt.$set(io);const Pn={};$&2&&(Pn.$$scope={dirty:$,ctx:t}),it.$set(Pn);const An={};$&2&&(An.$$scope={dirty:$,ctx:t}),lt.$set(An);const Sn={};$&2&&(Sn.$$scope={dirty:$,ctx:t}),mt.$set(Sn)},i(t){Zn||(b(n.$$.fragment,t),b(dt.$$.fragment,t),b(ct.$$.fragment,t),b(ft.$$.fragment,t),b(gt.$$.fragment,t),b(_t.$$.fragment,t),b($t.$$.fragment,t),b(vt.$$.fragment,t),b(xt.$$.fragment,t),b(Re.$$.fragment,t),b(je.$$.fragment,t),b(Fe.$$.fragment,t),b(wt.$$.fragment,t),b(Tt.$$.fragment,t),b(Mt.$$.fragment,t),b(yt.$$.fragment,t),b(Pe.$$.fragment,t),b(Ae.$$.fragment,t),b(Se.$$.fragment,t),b(qt.$$.fragment,t),b(Et.$$.fragment,t),b(Rt.$$.fragment,t),b(Ft.$$.fragment,t),b(Ne.$$.fragment,t),b(Le.$$.fragment,t),b(Qe.$$.fragment,t),b(We.$$.fragment,t),b(zt.$$.fragment,t),b(Ct.$$.fragment,t),b(Pt.$$.fragment,t),b(St.$$.fragment,t),b(He.$$.fragment,t),b(Ve.$$.fragment,t),b(Ue.$$.fragment,t),b(It.$$.fragment,t),b(Dt.$$.fragment,t),b(Nt.$$.fragment,t),b(Qt.$$.fragment,t),b(Ye.$$.fragment,t),b(Ke.$$.fragment,t),b(Ze.$$.fragment,t),b(Wt.$$.fragment,t),b(Bt.$$.fragment,t),b(Ht.$$.fragment,t),b(Vt.$$.fragment,t),b(Ut.$$.fragment,t),b(nt.$$.fragment,t),b(st.$$.fragment,t),b(rt.$$.fragment,t),b(Gt.$$.fragment,t),b(Jt.$$.fragment,t),b(Kt.$$.fragment,t),b(it.$$.fragment,t),b(lt.$$.fragment,t),b(mt.$$.fragment,t),b(Zt.$$.fragment,t),Zn=!0)},o(t){T(n.$$.fragment,t),T(dt.$$.fragment,t),T(ct.$$.fragment,t),T(ft.$$.fragment,t),T(gt.$$.fragment,t),T(_t.$$.fragment,t),T($t.$$.fragment,t),T(vt.$$.fragment,t),T(xt.$$.fragment,t),T(Re.$$.fragment,t),T(je.$$.fragment,t),T(Fe.$$.fragment,t),T(wt.$$.fragment,t),T(Tt.$$.fragment,t),T(Mt.$$.fragment,t),T(yt.$$.fragment,t),T(Pe.$$.fragment,t),T(Ae.$$.fragment,t),T(Se.$$.fragment,t),T(qt.$$.fragment,t),T(Et.$$.fragment,t),T(Rt.$$.fragment,t),T(Ft.$$.fragment,t),T(Ne.$$.fragment,t),T(Le.$$.fragment,t),T(Qe.$$.fragment,t),T(We.$$.fragment,t),T(zt.$$.fragment,t),T(Ct.$$.fragment,t),T(Pt.$$.fragment,t),T(St.$$.fragment,t),T(He.$$.fragment,t),T(Ve.$$.fragment,t),T(Ue.$$.fragment,t),T(It.$$.fragment,t),T(Dt.$$.fragment,t),T(Nt.$$.fragment,t),T(Qt.$$.fragment,t),T(Ye.$$.fragment,t),T(Ke.$$.fragment,t),T(Ze.$$.fragment,t),T(Wt.$$.fragment,t),T(Bt.$$.fragment,t),T(Ht.$$.fragment,t),T(Vt.$$.fragment,t),T(Ut.$$.fragment,t),T(nt.$$.fragment,t),T(st.$$.fragment,t),T(rt.$$.fragment,t),T(Gt.$$.fragment,t),T(Jt.$$.fragment,t),T(Kt.$$.fragment,t),T(it.$$.fragment,t),T(lt.$$.fragment,t),T(mt.$$.fragment,t),T(Zt.$$.fragment,t),Zn=!1},d(t){o(s),t&&o(_),t&&o(d),M(n),t&&o(v),t&&o(R),M(dt),t&&o(In),t&&o(D),M(ct),M(ft),M(gt),M(_t),t&&o(Dn),t&&o(pe),M($t),t&&o(Nn),t&&o(z),M(vt),M(xt),M(Re),M(je),M(Fe),M(wt),t&&o(Ln),t&&o(ce),M(Tt),t&&o(Qn),t&&o(C),M(Mt),M(yt),M(Pe),M(Ae),M(Se),M(qt),t&&o(Wn),t&&o(fe),M(Et),t&&o(Xn),t&&o(P),M(Rt),M(Ft),M(Ne),M(Le),M(Qe),M(We),M(zt),t&&o(Bn),t&&o(he),M(Ct),t&&o(Hn),t&&o(A),M(Pt),M(St),M(He),M(Ve),M(Ue),M(It),t&&o(Vn),t&&o($e),M(Dt),t&&o(Un),t&&o(F),M(Nt),M(Qt),M(Ye),M(Ke),M(Ze),M(Wt),M(Bt),t&&o(Gn),t&&o(ke),M(Ht),t&&o(Jn),t&&o(ne),M(Vt),M(Ut),M(nt),M(st),M(rt),t&&o(Yn),t&&o(we),M(Gt),t&&o(Kn),t&&o(S),M(Jt),M(Kt),M(it),M(lt),M(mt),M(Zt)}}}const fm={local:"models",sections:[{local:"optimum.onnxruntime.ORTModel",title:"ORTModel"},{local:"optimum.onnxruntime.ORTModelForFeatureExtraction",title:"ORTModelForFeatureExtraction"},{local:"optimum.onnxruntime.ORTModelForQuestionAnswering",title:"ORTModelForQuestionAnswering"},{local:"optimum.onnxruntime.ORTModelForSequenceClassification",title:"ORTModelForSequenceClassification"},{local:"optimum.onnxruntime.ORTModelForTokenClassification",title:"ORTModelForTokenClassification"},{local:"optimum.onnxruntime.ORTModelForCausalLM",title:"ORTModelForCausalLM"},{local:"optimum.onnxruntime.ORTModelForSeq2SeqLM",title:"ORTModelForSeq2SeqLM"},{local:"optimum.onnxruntime.ORTModelForImageClassification",title:"ORTModelForImageClassification"}],title:"Models"};function gm(E){return Xl(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class wm extends Nl{constructor(s){super();Ll(this,s,gm,um,Ql,{})}}export{wm as default,fm as metadata};
