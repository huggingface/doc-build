import{S as pt,i as st,s as dt,e as n,k as p,w as T,t as s,M as ht,c as i,d as o,m as d,a as r,x as R,h,b as m,F as e,g as P,y as w,L as lt,q as N,o as k,B as E,v as ct}from"../../chunks/vendor-19e06bd2.js";import{D as q}from"../../chunks/Docstring-395e5a9c.js";import{I as mt}from"../../chunks/IconCopyLink-3c713d38.js";function ut(Ge){let f,oe,_,x,B,L,_e,G,ge,ne,u,xe,J,ze,ve,D,Oe,$e,ie,g,z,W,U,be,j,ye,re,a,I,Te,K,Re,Pe,v,C,we,X,Ne,Q,ke,Ee,Le,O,A,De,S,Ue,Y,Ie,Ce,Xe,$,H,Ae,Z,Se,He,b,V,Ve,ee,Fe,Me,y,F,qe,te,Be,ae;return L=new mt({}),U=new mt({}),I=new q({props:{name:"class optimum.onnxruntime.ORTOptimizer",anchor:"optimum.onnxruntime.ORTOptimizer",parameters:[{name:"tokenizer",val:": PreTrainedTokenizer"},{name:"model",val:": PreTrainedModel"},{name:"feature",val:": str = 'default'"},{name:"opset",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/onnxruntime/optimization.py#L33"}}),C=new q({props:{name:"export",anchor:"optimum.onnxruntime.ORTOptimizer.export",parameters:[{name:"onnx_model_path",val:": typing.Union[str, os.PathLike]"},{name:"onnx_optimized_model_output_path",val:": typing.Union[str, os.PathLike]"},{name:"optimization_config",val:": OptimizationConfig"},{name:"use_external_data_format",val:": bool = False"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/onnxruntime/optimization.py#L88",parametersDescription:[{anchor:"optimum.onnxruntime.ORTOptimizer.export.onnx_model_path",description:`<strong>onnx_model_path</strong> (<code>Union[str, os.PathLike]</code>) &#x2014;
The path used to save the model exported to an ONNX Intermediate Representation (IR).`,name:"onnx_model_path"},{anchor:"optimum.onnxruntime.ORTOptimizer.export.onnx_optimized_model_output_path",description:`<strong>onnx_optimized_model_output_path</strong> (<code>Union[str, os.PathLike]</code>) &#x2014;
The path used to save the optimized model exported to an ONNX Intermediate Representation (IR).`,name:"onnx_optimized_model_output_path"},{anchor:"optimum.onnxruntime.ORTOptimizer.export.optimization_config",description:`<strong>optimization_config</strong> (<code>OptimizationConfig</code>) &#x2014;
The configuration containing the parameters related to optimization.`,name:"optimization_config"},{anchor:"optimum.onnxruntime.ORTOptimizer.export.use_external_data_format",description:`<strong>use_external_data_format</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether uto se external data format to store model which size is &gt;= 2Gb.`,name:"use_external_data_format"}],returnDescription:`
<p>The path of the resulting optimized model.</p>
`}}),A=new q({props:{name:"from_pretrained",anchor:"optimum.onnxruntime.ORTOptimizer.from_pretrained",parameters:[{name:"model_name_or_path",val:": typing.Union[str, os.PathLike]"},{name:"feature",val:": str"},{name:"opset",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/onnxruntime/optimization.py#L38",parametersDescription:[{anchor:"optimum.onnxruntime.ORTOptimizer.from_pretrained.model_name_or_path",description:`<strong>model_name_or_path</strong> (<code>Union[str, os.PathLike]</code>) &#x2014;
Repository name in the Hugging Face Hub or path to a local directory hosting the model.`,name:"model_name_or_path"},{anchor:"optimum.onnxruntime.ORTOptimizer.from_pretrained.feature",description:`<strong>feature</strong> (<code>str</code>) &#x2014;
Feature to use when exporting the model.`,name:"feature"},{anchor:"optimum.onnxruntime.ORTOptimizer.from_pretrained.opset",description:`<strong>opset</strong> (<code>int</code>, <em>optional</em>) &#x2014;
ONNX opset version to export the model with.`,name:"opset"}],returnDescription:`
<p>An instance of <code>ORTOptimizer</code>.</p>
`}}),H=new q({props:{name:"get_fused_operators",anchor:"optimum.onnxruntime.ORTOptimizer.get_fused_operators",parameters:[{name:"onnx_model_path",val:": typing.Union[str, os.PathLike]"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/onnxruntime/optimization.py#L154",parametersDescription:[{anchor:"optimum.onnxruntime.ORTOptimizer.get_fused_operators.onnx_model_path",description:`<strong>onnx_model_path</strong> (<code>Union[str, os.PathLike]</code>) &#x2014;
Path of the ONNX model.`,name:"onnx_model_path"}],returnDescription:`
<p>The dictionary mapping the name of the fused operators to their number of apparition in the model.</p>
`}}),V=new q({props:{name:"get_nodes_number_difference",anchor:"optimum.onnxruntime.ORTOptimizer.get_nodes_number_difference",parameters:[{name:"onnx_model_path",val:": typing.Union[str, os.PathLike]"},{name:"onnx_optimized_model_path",val:": typing.Union[str, os.PathLike]"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/onnxruntime/optimization.py#L173",parametersDescription:[{anchor:"optimum.onnxruntime.ORTOptimizer.get_nodes_number_difference.onnx_model_path",description:`<strong>onnx_model_path</strong> (<code>Union[str, os.PathLike]</code>) &#x2014;
Path of the ONNX model.`,name:"onnx_model_path"},{anchor:"optimum.onnxruntime.ORTOptimizer.get_nodes_number_difference.onnx_optimized_model_path",description:`<strong>onnx_optimized_model_path</strong> (<code>Union[str, os.PathLike]</code>) &#x2014;
Path of the optimized ONNX model.`,name:"onnx_optimized_model_path"}],returnDescription:`
<p>The difference in the number of nodes between the original and the optimized model.</p>
`}}),F=new q({props:{name:"get_operators_difference",anchor:"optimum.onnxruntime.ORTOptimizer.get_operators_difference",parameters:[{name:"onnx_model_path",val:": typing.Union[str, os.PathLike]"},{name:"onnx_optimized_model_path",val:": typing.Union[str, os.PathLike]"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/onnxruntime/optimization.py#L202",parametersDescription:[{anchor:"optimum.onnxruntime.ORTOptimizer.get_operators_difference.onnx_model_path",description:`<strong>onnx_model_path</strong> (<code>Union[str, os.PathLike]</code>) &#x2014;
Path of the ONNX model.`,name:"onnx_model_path"},{anchor:"optimum.onnxruntime.ORTOptimizer.get_operators_difference.onnx_optimized_model_path",description:`<strong>onnx_optimized_model_path</strong> (<code>Union[str, os.PathLike]</code>) &#x2014;
Path of the optimized ONNX model.`,name:"onnx_optimized_model_path"}],returnDescription:`
<p>The dictionary mapping the operators name to the difference in the number of corresponding nodes between the
original and the optimized model.</p>
`}}),{c(){f=n("meta"),oe=p(),_=n("h1"),x=n("a"),B=n("span"),T(L.$$.fragment),_e=p(),G=n("span"),ge=s("Optimization"),ne=p(),u=n("p"),xe=s("\u{1F917} Optimum provides an "),J=n("code"),ze=s("optimum.onnxruntime"),ve=s(" package that enables you to apply graph optimization on many model hosted on the \u{1F917} hub using the "),D=n("a"),Oe=s("ONNX Runtime"),$e=s(" model optimization tool."),ie=p(),g=n("h2"),z=n("a"),W=n("span"),T(U.$$.fragment),be=p(),j=n("span"),ye=s("ORTOptimizer"),re=p(),a=n("div"),T(I.$$.fragment),Te=p(),K=n("p"),Re=s("Handles the ONNX Runtime optimization process for models shared on huggingface.co/models."),Pe=p(),v=n("div"),T(C.$$.fragment),we=p(),X=n("p"),Ne=s("Optimize a model given the optimization specifications defined in "),Q=n("code"),ke=s("optimization_config"),Ee=s("."),Le=p(),O=n("div"),T(A.$$.fragment),De=p(),S=n("p"),Ue=s("Instantiate a "),Y=n("code"),Ie=s("ORTOptimizer"),Ce=s(" from a pretrained pytorch model and tokenizer."),Xe=p(),$=n("div"),T(H.$$.fragment),Ae=p(),Z=n("p"),Se=s("Compute the dictionary mapping the name of the fused operators to their number of apparition in the model."),He=p(),b=n("div"),T(V.$$.fragment),Ve=p(),ee=n("p"),Fe=s("Compute the difference in the number of nodes between the original and the optimized model."),Me=p(),y=n("div"),T(F.$$.fragment),qe=p(),te=n("p"),Be=s(`Compute the dictionary mapping the operators name to the difference in the number of corresponding nodes between
the original and the optimized model.`),this.h()},l(t){const c=ht('[data-svelte="svelte-1phssyn"]',document.head);f=i(c,"META",{name:!0,content:!0}),c.forEach(o),oe=d(t),_=i(t,"H1",{class:!0});var me=r(_);x=i(me,"A",{id:!0,class:!0,href:!0});var Je=r(x);B=i(Je,"SPAN",{});var We=r(B);R(L.$$.fragment,We),We.forEach(o),Je.forEach(o),_e=d(me),G=i(me,"SPAN",{});var je=r(G);ge=h(je,"Optimization"),je.forEach(o),me.forEach(o),ne=d(t),u=i(t,"P",{});var M=r(u);xe=h(M,"\u{1F917} Optimum provides an "),J=i(M,"CODE",{});var Ke=r(J);ze=h(Ke,"optimum.onnxruntime"),Ke.forEach(o),ve=h(M," package that enables you to apply graph optimization on many model hosted on the \u{1F917} hub using the "),D=i(M,"A",{href:!0,rel:!0});var Qe=r(D);Oe=h(Qe,"ONNX Runtime"),Qe.forEach(o),$e=h(M," model optimization tool."),M.forEach(o),ie=d(t),g=i(t,"H2",{class:!0});var pe=r(g);z=i(pe,"A",{id:!0,class:!0,href:!0});var Ye=r(z);W=i(Ye,"SPAN",{});var Ze=r(W);R(U.$$.fragment,Ze),Ze.forEach(o),Ye.forEach(o),be=d(pe),j=i(pe,"SPAN",{});var et=r(j);ye=h(et,"ORTOptimizer"),et.forEach(o),pe.forEach(o),re=d(t),a=i(t,"DIV",{class:!0});var l=r(a);R(I.$$.fragment,l),Te=d(l),K=i(l,"P",{});var tt=r(K);Re=h(tt,"Handles the ONNX Runtime optimization process for models shared on huggingface.co/models."),tt.forEach(o),Pe=d(l),v=i(l,"DIV",{class:!0});var se=r(v);R(C.$$.fragment,se),we=d(se),X=i(se,"P",{});var de=r(X);Ne=h(de,"Optimize a model given the optimization specifications defined in "),Q=i(de,"CODE",{});var ot=r(Q);ke=h(ot,"optimization_config"),ot.forEach(o),Ee=h(de,"."),de.forEach(o),se.forEach(o),Le=d(l),O=i(l,"DIV",{class:!0});var he=r(O);R(A.$$.fragment,he),De=d(he),S=i(he,"P",{});var le=r(S);Ue=h(le,"Instantiate a "),Y=i(le,"CODE",{});var nt=r(Y);Ie=h(nt,"ORTOptimizer"),nt.forEach(o),Ce=h(le," from a pretrained pytorch model and tokenizer."),le.forEach(o),he.forEach(o),Xe=d(l),$=i(l,"DIV",{class:!0});var ce=r($);R(H.$$.fragment,ce),Ae=d(ce),Z=i(ce,"P",{});var it=r(Z);Se=h(it,"Compute the dictionary mapping the name of the fused operators to their number of apparition in the model."),it.forEach(o),ce.forEach(o),He=d(l),b=i(l,"DIV",{class:!0});var ue=r(b);R(V.$$.fragment,ue),Ve=d(ue),ee=i(ue,"P",{});var rt=r(ee);Fe=h(rt,"Compute the difference in the number of nodes between the original and the optimized model."),rt.forEach(o),ue.forEach(o),Me=d(l),y=i(l,"DIV",{class:!0});var fe=r(y);R(F.$$.fragment,fe),qe=d(fe),te=i(fe,"P",{});var at=r(te);Be=h(at,`Compute the dictionary mapping the operators name to the difference in the number of corresponding nodes between
the original and the optimized model.`),at.forEach(o),fe.forEach(o),l.forEach(o),this.h()},h(){m(f,"name","hf:doc:metadata"),m(f,"content",JSON.stringify(ft)),m(x,"id","optimization"),m(x,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(x,"href","#optimization"),m(_,"class","relative group"),m(D,"href","https://github.com/microsoft/onnxruntime/tree/master/onnxruntime/python/tools/transformers"),m(D,"rel","nofollow"),m(z,"id","optimum.onnxruntime.ORTOptimizer"),m(z,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(z,"href","#optimum.onnxruntime.ORTOptimizer"),m(g,"class","relative group"),m(v,"class","docstring"),m(O,"class","docstring"),m($,"class","docstring"),m(b,"class","docstring"),m(y,"class","docstring"),m(a,"class","docstring")},m(t,c){e(document.head,f),P(t,oe,c),P(t,_,c),e(_,x),e(x,B),w(L,B,null),e(_,_e),e(_,G),e(G,ge),P(t,ne,c),P(t,u,c),e(u,xe),e(u,J),e(J,ze),e(u,ve),e(u,D),e(D,Oe),e(u,$e),P(t,ie,c),P(t,g,c),e(g,z),e(z,W),w(U,W,null),e(g,be),e(g,j),e(j,ye),P(t,re,c),P(t,a,c),w(I,a,null),e(a,Te),e(a,K),e(K,Re),e(a,Pe),e(a,v),w(C,v,null),e(v,we),e(v,X),e(X,Ne),e(X,Q),e(Q,ke),e(X,Ee),e(a,Le),e(a,O),w(A,O,null),e(O,De),e(O,S),e(S,Ue),e(S,Y),e(Y,Ie),e(S,Ce),e(a,Xe),e(a,$),w(H,$,null),e($,Ae),e($,Z),e(Z,Se),e(a,He),e(a,b),w(V,b,null),e(b,Ve),e(b,ee),e(ee,Fe),e(a,Me),e(a,y),w(F,y,null),e(y,qe),e(y,te),e(te,Be),ae=!0},p:lt,i(t){ae||(N(L.$$.fragment,t),N(U.$$.fragment,t),N(I.$$.fragment,t),N(C.$$.fragment,t),N(A.$$.fragment,t),N(H.$$.fragment,t),N(V.$$.fragment,t),N(F.$$.fragment,t),ae=!0)},o(t){k(L.$$.fragment,t),k(U.$$.fragment,t),k(I.$$.fragment,t),k(C.$$.fragment,t),k(A.$$.fragment,t),k(H.$$.fragment,t),k(V.$$.fragment,t),k(F.$$.fragment,t),ae=!1},d(t){o(f),t&&o(oe),t&&o(_),E(L),t&&o(ne),t&&o(u),t&&o(ie),t&&o(g),E(U),t&&o(re),t&&o(a),E(I),E(C),E(A),E(H),E(V),E(F)}}}const ft={local:"optimization",sections:[{local:"optimum.onnxruntime.ORTOptimizer",title:"ORTOptimizer"}],title:"Optimization"};function _t(Ge){return ct(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class vt extends pt{constructor(f){super();st(this,f,_t,ut,dt,{})}}export{vt as default,ft as metadata};
