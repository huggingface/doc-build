import{S as en,i as tn,s as an,e as n,k as o,w as d,t as c,M as nn,c as r,d as a,m as i,a as s,x as u,h as l,b as p,G as t,g,y as h,L as rn,q as f,o as _,B as b,v as sn}from"../chunks/vendor-hf-doc-builder.js";import{D as y}from"../chunks/Docstring-hf-doc-builder.js";import{I as bt}from"../chunks/IconCopyLink-hf-doc-builder.js";function on(Da){let E,He,z,O,ye,Q,vt,xe,$t,We,T,S,De,J,yt,ke,xt,Qe,v,j,Dt,k,K,kt,we,wt,Pt,Pe,Ct,Et,w,X,zt,Ce,Tt,Rt,Ee,Nt,Lt,V,Y,At,ze,qt,It,U,Z,Ot,ee,St,he,Vt,Ut,Mt,M,te,Ft,ae,Bt,fe,Gt,Ht,Je,R,F,Te,ne,Wt,Re,Qt,je,N,re,Jt,Ne,jt,Ke,L,se,Kt,Le,Xt,Xe,A,oe,Yt,Ae,Zt,Ye,q,ie,ea,qe,ta,Ze,I,B,Ie,pe,aa,Oe,na,et,$,ce,ra,P,le,sa,Se,oa,ia,Ve,pa,ca,C,me,la,Ue,ma,da,Me,ua,ga,G,de,ha,Fe,fa,_a,H,ue,ba,Be,va,$a,W,ge,ya,Ge,xa,tt;return Q=new bt({}),J=new bt({}),j=new y({props:{name:"class optimum.runs_base.Run",anchor:"optimum.runs_base.Run",parameters:[{name:"run_config",val:": dict"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/runs_base.py#L48"}}),K=new y({props:{name:"__init__",anchor:"optimum.runs_base.Run.__init__",parameters:[{name:"run_config",val:": dict"}],parametersDescription:[{anchor:"optimum.runs_base.Run.__init__.run_config",description:'<strong>run_config</strong> (dict) &#x2014; Parameters to use for the run. See <a href="/docs/optimum/main/en/benchmark#optimum.utils.runs.RunConfig">RunConfig</a> for the expected keys.',name:"run_config"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/runs_base.py#L49"}}),X=new y({props:{name:"launch",anchor:"optimum.runs_base.Run.launch",parameters:[],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/runs_base.py#L106",returnDescription:`
<p>Finalized run data with metrics stored in the \u201Cevaluation\u201D key.</p>
`,returnType:`
<p><code>dict</code></p>
`}}),Y=new y({props:{name:"load_datasets",anchor:"optimum.runs_base.Run.load_datasets",parameters:[],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/runs_base.py#L140"}}),Z=new y({props:{name:"get_calibration_dataset",anchor:"optimum.runs_base.Run.get_calibration_dataset",parameters:[],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/runs_base.py#L148",returnDescription:`
<p>Calibration dataset.</p>
`,returnType:`
<p><code>datasets.Dataset</code></p>
`}}),te=new y({props:{name:"get_eval_dataset",anchor:"optimum.runs_base.Run.get_eval_dataset",parameters:[],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/runs_base.py#L158",returnDescription:`
<p>Evaluation dataset.</p>
`,returnType:`
<p><code>datasets.Dataset</code></p>
`}}),ne=new bt({}),re=new y({props:{name:"class optimum.utils.runs.RunConfig",anchor:"optimum.utils.runs.RunConfig",parameters:[{name:"metrics",val:": typing.List[str]"},{name:"model_name_or_path",val:": str"},{name:"task",val:": str"},{name:"quantization_approach",val:": QuantizationApproach"},{name:"dataset",val:": DatasetArgs"},{name:"framework",val:": Frameworks"},{name:"framework_args",val:": FrameworkArgs"},{name:"operators_to_quantize",val:": typing.Optional[typing.List[str]] = <factory>"},{name:"node_exclusion",val:": typing.Optional[typing.List[str]] = <factory>"},{name:"per_channel",val:": typing.Optional[bool] = False"},{name:"calibration",val:": typing.Optional[optimum.utils.runs.Calibration] = None"},{name:"task_args",val:": typing.Optional[optimum.utils.runs.TaskArgs] = None"},{name:"aware_training",val:": typing.Optional[bool] = False"},{name:"batch_sizes",val:": typing.Optional[typing.List[int]] = <factory>"},{name:"input_lengths",val:": typing.Optional[typing.List[int]] = <factory>"}],parametersDescription:[{anchor:"optimum.utils.runs.RunConfig.metrics",description:"<strong>metrics</strong> (<code>List[str]</code>) &#x2014; List of metrics to evaluate on.",name:"metrics"},{anchor:"optimum.utils.runs.RunConfig.model_name_or_path",description:"<strong>model_name_or_path</strong> (<code>str</code>) &#x2014; Name of the model hosted on the Hub to use for the run.",name:"model_name_or_path"},{anchor:"optimum.utils.runs.RunConfig.task",description:"<strong>task</strong> (<code>str</code>) &#x2014; Task performed by the model.",name:"task"},{anchor:"optimum.utils.runs.RunConfig.quantization_approach",description:"<strong>quantization_approach</strong> (<code>QuantizationApproach</code>) &#x2014; Whether to use dynamic or static quantization.",name:"quantization_approach"},{anchor:"optimum.utils.runs.RunConfig.dataset",description:"<strong>dataset</strong> (<code>DatasetArgs</code>) &#x2014; Dataset to use. Several keys must be set on top of the dataset name.",name:"dataset"},{anchor:"optimum.utils.runs.RunConfig.framework",description:"<strong>framework</strong> (<code>Frameworks</code>) &#x2014; Name of the framework used (e.g. &#x201C;onnxruntime&#x201D;).",name:"framework"},{anchor:"optimum.utils.runs.RunConfig.framework_args",description:"<strong>framework_args</strong> (<code>FrameworkArgs</code>) &#x2014; Framework-specific arguments.",name:"framework_args"},{anchor:"optimum.utils.runs.RunConfig.operators_to_quantize",description:"<strong>operators_to_quantize</strong> (<code>List[str], NoneType]</code>) &#x2014; Operators to quantize, doing no modifications to others (default: <code>[&quot;Add&quot;, &quot;MatMul&quot;]</code>).",name:"operators_to_quantize"},{anchor:"optimum.utils.runs.RunConfig.node_exclusion",description:"<strong>node_exclusion</strong> (<code>List[str], NoneType]</code>) &#x2014; Specific nodes to exclude from being quantized (default: <code>[]</code>).",name:"node_exclusion"},{anchor:"optimum.utils.runs.RunConfig.per_channel",description:"<strong>per_channel</strong> (<code>Union[bool, NoneType]</code>) &#x2014; Whether to quantize per channel (default: <code>False</code>).",name:"per_channel"},{anchor:"optimum.utils.runs.RunConfig.calibration",description:"<strong>calibration</strong> (<code>Calibration, NoneType]</code>) &#x2014; Calibration parameters, in case static quantization is used.",name:"calibration"},{anchor:"optimum.utils.runs.RunConfig.task_args",description:"<strong>task_args</strong> (<code>TaskArgs, NoneType]</code>) &#x2014; Task-specific arguments (default: <code>None</code>).",name:"task_args"},{anchor:"optimum.utils.runs.RunConfig.aware_training",description:"<strong>aware_training</strong> (<code>Union[bool, NoneType]</code>) &#x2014; Whether the quantization is to be done with Quantization-Aware Training (not supported).",name:"aware_training"},{anchor:"optimum.utils.runs.RunConfig.batch_sizes",description:"<strong>batch_sizes</strong> (<code>List[int], NoneType]</code>) &#x2014; Batch sizes to include in the run to measure time metrics.",name:"batch_sizes"},{anchor:"optimum.utils.runs.RunConfig.input_lengths",description:"<strong>input_lengths</strong> (<code>List[int], NoneType]</code>) &#x2014; Input lengths to include in the run to measure time metrics.",name:"input_lengths"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/utils/runs.py#L271"}}),se=new y({props:{name:"class optimum.utils.runs.Calibration",anchor:"optimum.utils.runs.Calibration",parameters:[{name:"method",val:": CalibrationMethods"},{name:"num_calibration_samples",val:": int"},{name:"calibration_histogram_percentile",val:": typing.Optional[float] = None"},{name:"calibration_moving_average",val:": typing.Optional[bool] = None"},{name:"calibration_moving_average_constant",val:": typing.Optional[float] = None"}],parametersDescription:[{anchor:"optimum.utils.runs.Calibration.method",description:"<strong>method</strong> (<code>CalibrationMethods</code>) &#x2014; Calibration method used, either &#x201C;minmax&#x201D;, &#x201C;entropy&#x201D; or &#x201C;percentile&#x201D;.",name:"method"},{anchor:"optimum.utils.runs.Calibration.num_calibration_samples",description:"<strong>num_calibration_samples</strong> (<code>int</code>) &#x2014; Number of examples to use for the calibration step resulting from static quantization.",name:"num_calibration_samples"},{anchor:"optimum.utils.runs.Calibration.calibration_histogram_percentile",description:"<strong>calibration_histogram_percentile</strong> (<code>Union[float, NoneType]</code>) &#x2014; The percentile used for the percentile calibration method.",name:"calibration_histogram_percentile"},{anchor:"optimum.utils.runs.Calibration.calibration_moving_average",description:"<strong>calibration_moving_average</strong> (<code>Union[bool, NoneType]</code>) &#x2014; Whether to compute the moving average of the minimum and maximum values for the minmax calibration method.",name:"calibration_moving_average"},{anchor:"optimum.utils.runs.Calibration.calibration_moving_average_constant",description:"<strong>calibration_moving_average_constant</strong> (<code>Union[float, NoneType]</code>) &#x2014; Constant smoothing factor to use when computing the moving average of the minimum and maximum values. Effective only when the selected calibration method is minmax and <code>calibration_moving_average</code> is set to True.",name:"calibration_moving_average_constant"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/utils/runs.py#L71"}}),oe=new y({props:{name:"class optimum.utils.runs.DatasetArgs",anchor:"optimum.utils.runs.DatasetArgs",parameters:[{name:"path",val:": str"},{name:"eval_split",val:": str"},{name:"data_keys",val:": typing.Dict[str, typing.Union[NoneType, str]]"},{name:"ref_keys",val:": typing.List[str]"},{name:"name",val:": typing.Optional[str] = None"},{name:"calibration_split",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"optimum.utils.runs.DatasetArgs.path",description:"<strong>path</strong> (<code>str</code>) &#x2014; Path to the dataset, as in <code>datasets.load_dataset(path)</code>.",name:"path"},{anchor:"optimum.utils.runs.DatasetArgs.eval_split",description:"<strong>eval_split</strong> (<code>str</code>) &#x2014; Dataset split used for evaluation (e.g. &#x201C;test&#x201D;).",name:"eval_split"},{anchor:"optimum.utils.runs.DatasetArgs.data_keys",description:"<strong>data_keys</strong> (<code>Union[NoneType, str]]</code>) &#x2014; Dataset columns used as input data. At most two, indicated with &#x201C;primary&#x201D; and &#x201C;secondary&#x201D;.",name:"data_keys"},{anchor:"optimum.utils.runs.DatasetArgs.ref_keys",description:"<strong>ref_keys</strong> (<code>List[str]</code>) &#x2014; Dataset column used for references during evaluation.",name:"ref_keys"},{anchor:"optimum.utils.runs.DatasetArgs.name",description:"<strong>name</strong> (<code>Union[str, NoneType]</code>) &#x2014; Name of the dataset, as in <code>datasets.load_dataset(path, name)</code>.",name:"name"},{anchor:"optimum.utils.runs.DatasetArgs.calibration_split",description:"<strong>calibration_split</strong> (<code>Union[str, NoneType]</code>) &#x2014; Dataset split used for calibration (e.g. &#x201C;train&#x201D;).",name:"calibration_split"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/utils/runs.py#L145"}}),ie=new y({props:{name:"class optimum.utils.runs.TaskArgs",anchor:"optimum.utils.runs.TaskArgs",parameters:[{name:"is_regression",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"optimum.utils.runs.TaskArgs.is_regression",description:"<strong>is_regression</strong> (<code>Union[bool, NoneType]</code>) &#x2014; Text classification specific. Set whether the task is regression (output = one float).",name:"is_regression"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/utils/runs.py#L166"}}),pe=new bt({}),ce=new y({props:{name:"class optimum.utils.preprocessing.base.DatasetProcessing",anchor:"optimum.utils.preprocessing.base.DatasetProcessing",parameters:[{name:"dataset_path",val:": str"},{name:"dataset_name",val:": str"},{name:"preprocessor",val:": typing.Union[transformers.feature_extraction_utils.FeatureExtractionMixin, transformers.tokenization_utils_base.PreTrainedTokenizerBase]"},{name:"eval_split",val:": str"},{name:"static_quantization",val:": bool"},{name:"data_keys",val:": typing.Dict[str, str]"},{name:"ref_keys",val:": typing.List[str]"},{name:"config",val:": PretrainedConfig"},{name:"task_args",val:": typing.Optional[typing.Dict] = None"},{name:"num_calibration_samples",val:": typing.Optional[int] = None"},{name:"calibration_split",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/utils/preprocessing/base.py#L7"}}),le=new y({props:{name:"__init__",anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__",parameters:[{name:"dataset_path",val:": str"},{name:"dataset_name",val:": str"},{name:"preprocessor",val:": typing.Union[transformers.feature_extraction_utils.FeatureExtractionMixin, transformers.tokenization_utils_base.PreTrainedTokenizerBase]"},{name:"eval_split",val:": str"},{name:"static_quantization",val:": bool"},{name:"data_keys",val:": typing.Dict[str, str]"},{name:"ref_keys",val:": typing.List[str]"},{name:"config",val:": PretrainedConfig"},{name:"task_args",val:": typing.Optional[typing.Dict] = None"},{name:"num_calibration_samples",val:": typing.Optional[int] = None"},{name:"calibration_split",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.dataset_path",description:'<strong>dataset_path</strong> (<code>str</code>) &#x2014; Dataset path (<a href="https://huggingface.co/docs/datasets/v2.2.1/en/package_reference/loading_methods#datasets.load_dataset.path" rel="nofollow">https://huggingface.co/docs/datasets/v2.2.1/en/package_reference/loading_methods#datasets.load_dataset.path</a>)',name:"dataset_path"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.dataset_name",description:'<strong>dataset_name</strong> (<code>str</code>) &#x2014; Dataset name (<a href="https://huggingface.co/docs/datasets/v2.2.1/en/package_reference/loading_methods#datasets.load_dataset.name" rel="nofollow">https://huggingface.co/docs/datasets/v2.2.1/en/package_reference/loading_methods#datasets.load_dataset.name</a>)',name:"dataset_name"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.preprocessor",description:"<strong>preprocessor</strong> (<code>Union[FeatureExtractionMixin, PreTrainedTokenizerBase]</code>) &#x2014; Preprocessor used for evaluation.",name:"preprocessor"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.eval_split",description:"<strong>eval_split</strong> (<code>str</code>) &#x2014; Dataset split used for evaluation (e.g. &#x201C;test&#x201D;).",name:"eval_split"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.static_quantization",description:"<strong>static_quantization</strong> (<code>bool</code>) &#x2014; Static quantization is used.",name:"static_quantization"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.data_keys",description:"<strong>data_keys</strong> (<code>Dict[str, str]</code>) &#x2014; Map &#x201C;primary&#x201D; and &#x201C;secondary&#x201D; to data column names.",name:"data_keys"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.ref_keys",description:"<strong>ref_keys</strong> (<code>List[str]</code>) &#x2014; References column names.",name:"ref_keys"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.config",description:"<strong>config</strong> (<code>PretrainedConfig</code>) &#x2014; Model configuration, useful for some tasks.",name:"config"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.task_args(Dict,",description:"<strong>task_args(<code>Dict</code>,</strong> <em>optional</em>) &#x2014; Task-specific arguments.",name:"task_args(Dict,"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.num_calibration_samples",description:"<strong>num_calibration_samples</strong> (<code>int</code>, <em>optional</em>) &#x2014; Number of calibration samples for static quantization. Defaults to None.",name:"num_calibration_samples"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.calibration_split",description:"<strong>calibration_split</strong> (<code>str</code>, <em>optional</em>) &#x2014; Calibration split (e.g. &#x201C;train&#x201D;) for static quantization. Defaults to None.",name:"calibration_split"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/utils/preprocessing/base.py#L8"}}),me=new y({props:{name:"load_datasets",anchor:"optimum.utils.preprocessing.base.DatasetProcessing.load_datasets",parameters:[],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/utils/preprocessing/base.py#L55",returnDescription:`
<p>Dictionary holding the datasets.</p>
`,returnType:`
<p><code>Dict</code></p>
`}}),de=new y({props:{name:"run_inference",anchor:"optimum.utils.preprocessing.base.DatasetProcessing.run_inference",parameters:[{name:"eval_dataset",val:": Dataset"},{name:"pipeline",val:": Pipeline"}],parametersDescription:[{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.run_inference.eval_dataset",description:"<strong>eval_dataset</strong> (<code>Dataset</code>) &#x2014; Raw dataset to run inference on.",name:"eval_dataset"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.run_inference.pipeline",description:"<strong>pipeline</strong> (<code>Pipeline</code>) &#x2014; Pipeline used for inference. Should be initialized beforehand.",name:"pipeline"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/utils/preprocessing/base.py#L65",returnDescription:`
<ul>
<li><strong>labels</strong> are the references for evaluation.</li>
<li><strong>predictions</strong> are the predictions on the dataset using the pipeline.</li>
</ul>
`,returnType:`
<p><code>tuple(List)</code> comprising labels and predictions</p>
`}}),ue=new y({props:{name:"get_metrics",anchor:"optimum.utils.preprocessing.base.DatasetProcessing.get_metrics",parameters:[{name:"predictions",val:""},{name:"references",val:""},{name:"metric",val:""}],parametersDescription:[{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.get_metrics.predictions",description:"<strong>predictions</strong> (<code>List</code>) &#x2014; Predictions.",name:"predictions"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.get_metrics.references",description:"<strong>references</strong> (<code>List</code>) &#x2014; References.",name:"references"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.get_metrics.metric",description:"<strong>metric</strong> (<code>Metric</code>) &#x2014; Pre-loaded metric to run evaluation on.",name:"metric"}],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/utils/preprocessing/base.py#L79",returnDescription:`
<p>Computed metrics.</p>
`,returnType:`
<p><code>Dict</code></p>
`}}),ge=new y({props:{name:"get_pipeline_kwargs",anchor:"optimum.utils.preprocessing.base.DatasetProcessing.get_pipeline_kwargs",parameters:[],source:"https://github.com/huggingface/optimum/blob/main/src/optimum/utils/preprocessing/base.py#L92",returnDescription:`
<p>Task-specific kwargs to initialize the pipeline.</p>
`,returnType:`
<p><code>Dict</code></p>
`}}),{c(){E=n("meta"),He=o(),z=n("h1"),O=n("a"),ye=n("span"),d(Q.$$.fragment),vt=o(),xe=n("span"),$t=c("Benchmarking"),We=o(),T=n("h2"),S=n("a"),De=n("span"),d(J.$$.fragment),yt=o(),ke=n("span"),xt=c("Run"),Qe=o(),v=n("div"),d(j.$$.fragment),Dt=o(),k=n("div"),d(K.$$.fragment),kt=o(),we=n("p"),wt=c("Initialize the Run class holding methods to perform inference and evaluation given a config."),Pt=o(),Pe=n("p"),Ct=c("A run compares a transformers model and an optimized model on latency/throughput, model size, and provided metrics."),Et=o(),w=n("div"),d(X.$$.fragment),zt=o(),Ce=n("p"),Tt=c("Launch inference to compare metrics between the original and optimized model."),Rt=o(),Ee=n("p"),Nt=c("These metrics are latency, throughput, model size, and user provided metrics."),Lt=o(),V=n("div"),d(Y.$$.fragment),At=o(),ze=n("p"),qt=c("Load evaluation dataset, and if needed, calibration dataset for static quantization."),It=o(),U=n("div"),d(Z.$$.fragment),Ot=o(),ee=n("p"),St=c("Get calibration dataset. The dataset needs to be loaded first with "),he=n("a"),Vt=c("load_datasets()"),Ut=c("."),Mt=o(),M=n("div"),d(te.$$.fragment),Ft=o(),ae=n("p"),Bt=c("Get evaluation dataset.  The dataset needs to be loaded first with "),fe=n("a"),Gt=c("load_datasets()"),Ht=c("."),Je=o(),R=n("h2"),F=n("a"),Te=n("span"),d(ne.$$.fragment),Wt=o(),Re=n("span"),Qt=c("RunConfig"),je=o(),N=n("div"),d(re.$$.fragment),Jt=o(),Ne=n("p"),jt=c("Class holding the parameters to launch a run."),Ke=o(),L=n("div"),d(se.$$.fragment),Kt=o(),Le=n("p"),Xt=c("Parameters for post-training calibration with static quantization."),Xe=o(),A=n("div"),d(oe.$$.fragment),Yt=o(),Ae=n("p"),Zt=c("Parameters related to the dataset."),Ye=o(),q=n("div"),d(ie.$$.fragment),ea=o(),qe=n("p"),ta=c("Task-specific parameters."),Ze=o(),I=n("h2"),B=n("a"),Ie=n("span"),d(pe.$$.fragment),aa=o(),Oe=n("span"),na=c("Processing utility methods"),et=o(),$=n("div"),d(ce.$$.fragment),ra=o(),P=n("div"),d(le.$$.fragment),sa=o(),Se=n("p"),oa=c("Initialize the class in charge of loading datasets, running inference and evaluation."),ia=o(),Ve=n("p"),pa=c("This class should be task-dependent, backend independent."),ca=o(),C=n("div"),d(me.$$.fragment),la=o(),Ue=n("p"),ma=c("Load calibration dataset if needed, and evaluation dataset."),da=o(),Me=n("p"),ua=c("The evaluation dataset is meant to be used by a pipeline and is therefore not preprocessed. The calibration dataset is preprocessed."),ga=o(),G=n("div"),d(de.$$.fragment),ha=o(),Fe=n("p"),fa=c("Run inference on the provided dataset using a pipeline, and return all labels, predictions."),_a=o(),H=n("div"),d(ue.$$.fragment),ba=o(),Be=n("p"),va=c("Compute a metric given pre-formatted predictions and references."),$a=o(),W=n("div"),d(ge.$$.fragment),ya=o(),Ge=n("p"),xa=c("Get task-specific kwargs to initialize the pipeline."),this.h()},l(e){const m=nn('[data-svelte="svelte-1phssyn"]',document.head);E=r(m,"META",{name:!0,content:!0}),m.forEach(a),He=i(e),z=r(e,"H1",{class:!0});var at=s(z);O=r(at,"A",{id:!0,class:!0,href:!0});var ka=s(O);ye=r(ka,"SPAN",{});var wa=s(ye);u(Q.$$.fragment,wa),wa.forEach(a),ka.forEach(a),vt=i(at),xe=r(at,"SPAN",{});var Pa=s(xe);$t=l(Pa,"Benchmarking"),Pa.forEach(a),at.forEach(a),We=i(e),T=r(e,"H2",{class:!0});var nt=s(T);S=r(nt,"A",{id:!0,class:!0,href:!0});var Ca=s(S);De=r(Ca,"SPAN",{});var Ea=s(De);u(J.$$.fragment,Ea),Ea.forEach(a),Ca.forEach(a),yt=i(nt),ke=r(nt,"SPAN",{});var za=s(ke);xt=l(za,"Run"),za.forEach(a),nt.forEach(a),Qe=i(e),v=r(e,"DIV",{class:!0});var x=s(v);u(j.$$.fragment,x),Dt=i(x),k=r(x,"DIV",{class:!0});var _e=s(k);u(K.$$.fragment,_e),kt=i(_e),we=r(_e,"P",{});var Ta=s(we);wt=l(Ta,"Initialize the Run class holding methods to perform inference and evaluation given a config."),Ta.forEach(a),Pt=i(_e),Pe=r(_e,"P",{});var Ra=s(Pe);Ct=l(Ra,"A run compares a transformers model and an optimized model on latency/throughput, model size, and provided metrics."),Ra.forEach(a),_e.forEach(a),Et=i(x),w=r(x,"DIV",{class:!0});var be=s(w);u(X.$$.fragment,be),zt=i(be),Ce=r(be,"P",{});var Na=s(Ce);Tt=l(Na,"Launch inference to compare metrics between the original and optimized model."),Na.forEach(a),Rt=i(be),Ee=r(be,"P",{});var La=s(Ee);Nt=l(La,"These metrics are latency, throughput, model size, and user provided metrics."),La.forEach(a),be.forEach(a),Lt=i(x),V=r(x,"DIV",{class:!0});var rt=s(V);u(Y.$$.fragment,rt),At=i(rt),ze=r(rt,"P",{});var Aa=s(ze);qt=l(Aa,"Load evaluation dataset, and if needed, calibration dataset for static quantization."),Aa.forEach(a),rt.forEach(a),It=i(x),U=r(x,"DIV",{class:!0});var st=s(U);u(Z.$$.fragment,st),Ot=i(st),ee=r(st,"P",{});var ot=s(ee);St=l(ot,"Get calibration dataset. The dataset needs to be loaded first with "),he=r(ot,"A",{href:!0});var qa=s(he);Vt=l(qa,"load_datasets()"),qa.forEach(a),Ut=l(ot,"."),ot.forEach(a),st.forEach(a),Mt=i(x),M=r(x,"DIV",{class:!0});var it=s(M);u(te.$$.fragment,it),Ft=i(it),ae=r(it,"P",{});var pt=s(ae);Bt=l(pt,"Get evaluation dataset.  The dataset needs to be loaded first with "),fe=r(pt,"A",{href:!0});var Ia=s(fe);Gt=l(Ia,"load_datasets()"),Ia.forEach(a),Ht=l(pt,"."),pt.forEach(a),it.forEach(a),x.forEach(a),Je=i(e),R=r(e,"H2",{class:!0});var ct=s(R);F=r(ct,"A",{id:!0,class:!0,href:!0});var Oa=s(F);Te=r(Oa,"SPAN",{});var Sa=s(Te);u(ne.$$.fragment,Sa),Sa.forEach(a),Oa.forEach(a),Wt=i(ct),Re=r(ct,"SPAN",{});var Va=s(Re);Qt=l(Va,"RunConfig"),Va.forEach(a),ct.forEach(a),je=i(e),N=r(e,"DIV",{class:!0});var lt=s(N);u(re.$$.fragment,lt),Jt=i(lt),Ne=r(lt,"P",{});var Ua=s(Ne);jt=l(Ua,"Class holding the parameters to launch a run."),Ua.forEach(a),lt.forEach(a),Ke=i(e),L=r(e,"DIV",{class:!0});var mt=s(L);u(se.$$.fragment,mt),Kt=i(mt),Le=r(mt,"P",{});var Ma=s(Le);Xt=l(Ma,"Parameters for post-training calibration with static quantization."),Ma.forEach(a),mt.forEach(a),Xe=i(e),A=r(e,"DIV",{class:!0});var dt=s(A);u(oe.$$.fragment,dt),Yt=i(dt),Ae=r(dt,"P",{});var Fa=s(Ae);Zt=l(Fa,"Parameters related to the dataset."),Fa.forEach(a),dt.forEach(a),Ye=i(e),q=r(e,"DIV",{class:!0});var ut=s(q);u(ie.$$.fragment,ut),ea=i(ut),qe=r(ut,"P",{});var Ba=s(qe);ta=l(Ba,"Task-specific parameters."),Ba.forEach(a),ut.forEach(a),Ze=i(e),I=r(e,"H2",{class:!0});var gt=s(I);B=r(gt,"A",{id:!0,class:!0,href:!0});var Ga=s(B);Ie=r(Ga,"SPAN",{});var Ha=s(Ie);u(pe.$$.fragment,Ha),Ha.forEach(a),Ga.forEach(a),aa=i(gt),Oe=r(gt,"SPAN",{});var Wa=s(Oe);na=l(Wa,"Processing utility methods"),Wa.forEach(a),gt.forEach(a),et=i(e),$=r(e,"DIV",{class:!0});var D=s($);u(ce.$$.fragment,D),ra=i(D),P=r(D,"DIV",{class:!0});var ve=s(P);u(le.$$.fragment,ve),sa=i(ve),Se=r(ve,"P",{});var Qa=s(Se);oa=l(Qa,"Initialize the class in charge of loading datasets, running inference and evaluation."),Qa.forEach(a),ia=i(ve),Ve=r(ve,"P",{});var Ja=s(Ve);pa=l(Ja,"This class should be task-dependent, backend independent."),Ja.forEach(a),ve.forEach(a),ca=i(D),C=r(D,"DIV",{class:!0});var $e=s(C);u(me.$$.fragment,$e),la=i($e),Ue=r($e,"P",{});var ja=s(Ue);ma=l(ja,"Load calibration dataset if needed, and evaluation dataset."),ja.forEach(a),da=i($e),Me=r($e,"P",{});var Ka=s(Me);ua=l(Ka,"The evaluation dataset is meant to be used by a pipeline and is therefore not preprocessed. The calibration dataset is preprocessed."),Ka.forEach(a),$e.forEach(a),ga=i(D),G=r(D,"DIV",{class:!0});var ht=s(G);u(de.$$.fragment,ht),ha=i(ht),Fe=r(ht,"P",{});var Xa=s(Fe);fa=l(Xa,"Run inference on the provided dataset using a pipeline, and return all labels, predictions."),Xa.forEach(a),ht.forEach(a),_a=i(D),H=r(D,"DIV",{class:!0});var ft=s(H);u(ue.$$.fragment,ft),ba=i(ft),Be=r(ft,"P",{});var Ya=s(Be);va=l(Ya,"Compute a metric given pre-formatted predictions and references."),Ya.forEach(a),ft.forEach(a),$a=i(D),W=r(D,"DIV",{class:!0});var _t=s(W);u(ge.$$.fragment,_t),ya=i(_t),Ge=r(_t,"P",{});var Za=s(Ge);xa=l(Za,"Get task-specific kwargs to initialize the pipeline."),Za.forEach(a),_t.forEach(a),D.forEach(a),this.h()},h(){p(E,"name","hf:doc:metadata"),p(E,"content",JSON.stringify(pn)),p(O,"id","benchmarking"),p(O,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(O,"href","#benchmarking"),p(z,"class","relative group"),p(S,"id","optimum.runs_base.Run"),p(S,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(S,"href","#optimum.runs_base.Run"),p(T,"class","relative group"),p(k,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(w,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(V,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(he,"href","/docs/optimum/main/en/benchmark#optimum.runs_base.Run.load_datasets"),p(U,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(fe,"href","/docs/optimum/main/en/benchmark#optimum.runs_base.Run.load_datasets"),p(M,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(v,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(F,"id","optimum.utils.runs.RunConfig"),p(F,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(F,"href","#optimum.utils.runs.RunConfig"),p(R,"class","relative group"),p(N,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(L,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(A,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(B,"id","optimum.utils.preprocessing.base.DatasetProcessing"),p(B,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(B,"href","#optimum.utils.preprocessing.base.DatasetProcessing"),p(I,"class","relative group"),p(P,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(C,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(G,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(H,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(W,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p($,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(e,m){t(document.head,E),g(e,He,m),g(e,z,m),t(z,O),t(O,ye),h(Q,ye,null),t(z,vt),t(z,xe),t(xe,$t),g(e,We,m),g(e,T,m),t(T,S),t(S,De),h(J,De,null),t(T,yt),t(T,ke),t(ke,xt),g(e,Qe,m),g(e,v,m),h(j,v,null),t(v,Dt),t(v,k),h(K,k,null),t(k,kt),t(k,we),t(we,wt),t(k,Pt),t(k,Pe),t(Pe,Ct),t(v,Et),t(v,w),h(X,w,null),t(w,zt),t(w,Ce),t(Ce,Tt),t(w,Rt),t(w,Ee),t(Ee,Nt),t(v,Lt),t(v,V),h(Y,V,null),t(V,At),t(V,ze),t(ze,qt),t(v,It),t(v,U),h(Z,U,null),t(U,Ot),t(U,ee),t(ee,St),t(ee,he),t(he,Vt),t(ee,Ut),t(v,Mt),t(v,M),h(te,M,null),t(M,Ft),t(M,ae),t(ae,Bt),t(ae,fe),t(fe,Gt),t(ae,Ht),g(e,Je,m),g(e,R,m),t(R,F),t(F,Te),h(ne,Te,null),t(R,Wt),t(R,Re),t(Re,Qt),g(e,je,m),g(e,N,m),h(re,N,null),t(N,Jt),t(N,Ne),t(Ne,jt),g(e,Ke,m),g(e,L,m),h(se,L,null),t(L,Kt),t(L,Le),t(Le,Xt),g(e,Xe,m),g(e,A,m),h(oe,A,null),t(A,Yt),t(A,Ae),t(Ae,Zt),g(e,Ye,m),g(e,q,m),h(ie,q,null),t(q,ea),t(q,qe),t(qe,ta),g(e,Ze,m),g(e,I,m),t(I,B),t(B,Ie),h(pe,Ie,null),t(I,aa),t(I,Oe),t(Oe,na),g(e,et,m),g(e,$,m),h(ce,$,null),t($,ra),t($,P),h(le,P,null),t(P,sa),t(P,Se),t(Se,oa),t(P,ia),t(P,Ve),t(Ve,pa),t($,ca),t($,C),h(me,C,null),t(C,la),t(C,Ue),t(Ue,ma),t(C,da),t(C,Me),t(Me,ua),t($,ga),t($,G),h(de,G,null),t(G,ha),t(G,Fe),t(Fe,fa),t($,_a),t($,H),h(ue,H,null),t(H,ba),t(H,Be),t(Be,va),t($,$a),t($,W),h(ge,W,null),t(W,ya),t(W,Ge),t(Ge,xa),tt=!0},p:rn,i(e){tt||(f(Q.$$.fragment,e),f(J.$$.fragment,e),f(j.$$.fragment,e),f(K.$$.fragment,e),f(X.$$.fragment,e),f(Y.$$.fragment,e),f(Z.$$.fragment,e),f(te.$$.fragment,e),f(ne.$$.fragment,e),f(re.$$.fragment,e),f(se.$$.fragment,e),f(oe.$$.fragment,e),f(ie.$$.fragment,e),f(pe.$$.fragment,e),f(ce.$$.fragment,e),f(le.$$.fragment,e),f(me.$$.fragment,e),f(de.$$.fragment,e),f(ue.$$.fragment,e),f(ge.$$.fragment,e),tt=!0)},o(e){_(Q.$$.fragment,e),_(J.$$.fragment,e),_(j.$$.fragment,e),_(K.$$.fragment,e),_(X.$$.fragment,e),_(Y.$$.fragment,e),_(Z.$$.fragment,e),_(te.$$.fragment,e),_(ne.$$.fragment,e),_(re.$$.fragment,e),_(se.$$.fragment,e),_(oe.$$.fragment,e),_(ie.$$.fragment,e),_(pe.$$.fragment,e),_(ce.$$.fragment,e),_(le.$$.fragment,e),_(me.$$.fragment,e),_(de.$$.fragment,e),_(ue.$$.fragment,e),_(ge.$$.fragment,e),tt=!1},d(e){a(E),e&&a(He),e&&a(z),b(Q),e&&a(We),e&&a(T),b(J),e&&a(Qe),e&&a(v),b(j),b(K),b(X),b(Y),b(Z),b(te),e&&a(Je),e&&a(R),b(ne),e&&a(je),e&&a(N),b(re),e&&a(Ke),e&&a(L),b(se),e&&a(Xe),e&&a(A),b(oe),e&&a(Ye),e&&a(q),b(ie),e&&a(Ze),e&&a(I),b(pe),e&&a(et),e&&a($),b(ce),b(le),b(me),b(de),b(ue),b(ge)}}}const pn={local:"benchmarking",sections:[{local:"optimum.runs_base.Run",title:"Run"},{local:"optimum.utils.runs.RunConfig",title:"RunConfig"},{local:"optimum.utils.preprocessing.base.DatasetProcessing",title:"Processing utility methods"}],title:"Benchmarking"};function cn(Da){return sn(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class un extends en{constructor(E){super();tn(this,E,cn,on,an,{})}}export{un as default,pn as metadata};
