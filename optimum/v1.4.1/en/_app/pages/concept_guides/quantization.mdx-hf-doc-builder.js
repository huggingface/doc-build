import{S as L,i as M,s as C,e as l,k as z,w as F,t as E,M as B,c,d as t,m as q,a as m,x as G,h as Q,b as p,G as s,g as f,y as H,L as J,q as O,o as U,B as j,v as D}from"../../chunks/vendor-hf-doc-builder.js";import{I as K}from"../../chunks/IconCopyLink-hf-doc-builder.js";function V(S){let a,g,n,o,d,r,k,b,x,y,u,$,w,h,P,v;return r=new K({}),{c(){a=l("meta"),g=z(),n=l("h1"),o=l("a"),d=l("span"),F(r.$$.fragment),k=z(),b=l("span"),x=E("Quantization"),y=z(),u=l("p"),$=E("Quantization is a technique to reduce the computational and memory cost of running inference by representing the weights and activations with low-precision data types like 8-bit integer (INT8) instead of the usual 32-bit floating point (FP32). Reducing the number of bits means the resulting model requires less memory storage, and operations like matrix multiplication can be performed much faster with integer arithmetic. Remarkably, these performance gains can be realized with little to no loss in accuracy!"),w=z(),h=l("p"),P=E("The basic idea behind quantization is that we can \u201Cdiscretize\u201D the floating-point values in each tensor by mapping their range into a smaller one of fixed-point numbers, and linearly distributing all values in between."),this.h()},l(e){const i=B('[data-svelte="svelte-1phssyn"]',document.head);a=c(i,"META",{name:!0,content:!0}),i.forEach(t),g=q(e),n=c(e,"H1",{class:!0});var _=m(n);o=c(_,"A",{id:!0,class:!0,href:!0});var N=m(o);d=c(N,"SPAN",{});var R=m(d);G(r.$$.fragment,R),R.forEach(t),N.forEach(t),k=q(_),b=c(_,"SPAN",{});var T=m(b);x=Q(T,"Quantization"),T.forEach(t),_.forEach(t),y=q(e),u=c(e,"P",{});var A=m(u);$=Q(A,"Quantization is a technique to reduce the computational and memory cost of running inference by representing the weights and activations with low-precision data types like 8-bit integer (INT8) instead of the usual 32-bit floating point (FP32). Reducing the number of bits means the resulting model requires less memory storage, and operations like matrix multiplication can be performed much faster with integer arithmetic. Remarkably, these performance gains can be realized with little to no loss in accuracy!"),A.forEach(t),w=q(e),h=c(e,"P",{});var I=m(h);P=Q(I,"The basic idea behind quantization is that we can \u201Cdiscretize\u201D the floating-point values in each tensor by mapping their range into a smaller one of fixed-point numbers, and linearly distributing all values in between."),I.forEach(t),this.h()},h(){p(a,"name","hf:doc:metadata"),p(a,"content",JSON.stringify(W)),p(o,"id","quantization"),p(o,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(o,"href","#quantization"),p(n,"class","relative group")},m(e,i){s(document.head,a),f(e,g,i),f(e,n,i),s(n,o),s(o,d),H(r,d,null),s(n,k),s(n,b),s(b,x),f(e,y,i),f(e,u,i),s(u,$),f(e,w,i),f(e,h,i),s(h,P),v=!0},p:J,i(e){v||(O(r.$$.fragment,e),v=!0)},o(e){U(r.$$.fragment,e),v=!1},d(e){t(a),e&&t(g),e&&t(n),j(r),e&&t(y),e&&t(u),e&&t(w),e&&t(h)}}}const W={local:"quantization",title:"Quantization"};function X(S){return D(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class ee extends L{constructor(a){super();M(this,a,X,V,C,{})}}export{ee as default,W as metadata};
